# IBM_PROLOG_BEGIN_TAG 
# This is an automatically generated prolog. 
#  
# bos610 src/bos/usr/bin/trcrpt/trcfmt 1.150 
#  
# Licensed Materials - Property of IBM 
#  
# Restricted Materials of IBM 
#  
# COPYRIGHT International Business Machines Corp. 1988,1993 
# All Rights Reserved 
#  
# US Government Users Restricted Rights - Use, duplication or 
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp. 
#  
# @(#)65        1.150  src/bos/usr/bin/trcrpt/trcfmt, cmdtrace, bos610 2/21/07 17:42:20
# IBM_PROLOG_END_TAG 
# COMPONENT_NAME: CMDTRACE   system trace logging and reporting facility
#
# FUNCTIONS: template file for trcrpt
#
# ORIGINS: 27, 83
#
# (C) COPYRIGHT International Business Machines Corp. 1988, 1993
# All Rights Reserved
# Licensed Materials - Property of IBM
#
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
# 
# LEVEL 1, 5 Years Bull Confidential Information
# 

# I. General Information
#
#    The formats shown below apply to the data placed into the
#    trcrpt format buffer.  These formats in general mirror the binary
#    format of the data in the trace stream.  The exceptions are
#    hooks from a 32-bit application on a 64-bit kernel, and hooks from a
#    64-bit application on a 32-bit kernel.  These exceptions are noted
#    below as appropriate.
#
#    Trace formatting templates should not use the thread id or time
#    stamp from the buffer.  The thread id should be obtained with the
#    $TID macro.  The time stamp is a raw timer value used by trcrpt to
#    calculate the elapsed and delta times.  These values are either
#    4 or 8 bytes depending upon the system the trace was run on, not upon
#    the environment from which the hook was generated.
#    The system environment, 32 or 64 bit, and the hook's
#    environment, 32 or 64 bit, are obtained from the $TRACEENV and $HOOKENV
#    macros discussed below.
#
#    To interpret the time stamp, it is necessary to get the values from
#    hook 0x00a0, subhook 0x25c, used to convert it to nanoseconds.
#    The 3 data words of interest are all 8 bytes in length and are in
#    the generic buffer, see the template for hook 00A.
#    The first data word gives the multiplier, m, and the second word
#    is the divisor, d.  These values should be set to 1 if the
#    third word doesn't contain a 2.  The nanosecond time is then
#    calculated with nt = t * m / d where t is the time from the trace.
#
#    Also, on a 64-bit system, there will be a header on the trace stream.
#    This header serves to identify the stream as coming from a
#    64-bit system.  There is no such header on the data stream on a
#    32-bit system.  This data stream, on both systems, is produced with
#    the "-o -" option of the trace command.
#    This header consists only of a 4-byte magic number, 0xEFDF1114.
#
#    On a 64-bit system, trace hook IDs from 0x0010 to 0xffff can be used.
#    The only restriction lies on hooks below 0x1000. Hooks below 0x1000
#    must have the fourth digit be zero (i.e. of the form 0xhhh0).
#
#    For a 64-bit trace, hook IDs with the fourth digit zero will be
#    displayed as three digit hook IDs. For instance, 0xABC0 will be 
#    displayed as 0xABC. Hook IDs with a non-zero fourth digit will
#    have all four digits displayed. For instance, 0xABC1 will be
#    displayed as 0xABC1.
#
#    32-bit applications and 32-bit kernel routines can only use hook IDs
#    from 0x001 to 0xFFF. They can not use 16 bit hook IDs.
#    
#
# A. Binary format for the 32-bit trace data
#    TRCHKL0        MMMTDDDDiiiiiiii
#    TRCHKL0T       MMMTDDDDiiiiiiiitttttttt
#    TRCHKL1	    MMMTDDDD11111111iiiiiiii
#    TRCHKL1T       MMMTDDDD11111111iiiiiiiitttttttt
#    Note that trchkg covers TRCHKL2-TRCHKL5.
#    trchkg       MMMTDDDD1111111122222222333333334444444455555555iiiiiiii
#    trchkgt      MMMTDDDD1111111122222222333333334444444455555555 i... t...
#    trcgent      MMMTLLLL11111111vvvvvvvvvvvvvvvvvvvvvvvvvvxxxxxx i... t...
#
#         legend:
#      MMM = hook id
#      T   = hooktype
#      D   = hookdata
#      i   = thread id, 4 bytes on a 32 byte system and 8 bytes on a 64-bit
#            system. The thread id starts on a 4 or 8 byte boundary.
#      t   = timestamp, 4 bytes on a 32-bit system or 8 on a
#	     64-bit system.
#      1   = d1  (see trchkid.h for calling syntax for the tracehook routines)
#      2   = d2, etc.
#      v   = trcgen variable length buffer
#      L   = length of variable length data in bytes.
#
#    The DATA_POINTER starts at the third byte in the event, ie.,
#    at the 16 bit hookdata DDDD.
#    The trcgen() is an exception. The DATA_POINTER starts at
#    the fifth byte, ie., at the 'd1' parameter 11111111.
#
#    Note that a generic trace hook with a hookid of 0x00b is
#    produced for 64-bit data traced from a 64-bit app running on
#    a 32-bit kernel.  Since this is produced on a 32-bit system, the
#    thread id and time stamp will be 4 bytes in the data stream.
#
# B.  64-bit trace hook format
#
#    TRCHK64L0	ffffllllhhhhssss iiiiiiiiiiiiiiii (cccccccccccccccc - -p only)
#    TRCHK64L0T	ffffllllhhhhssss iiiiiiiiiiiiiiii tttttttttttttttt
#	(cccccccccccccccc - -p only)
#    TRCHK64L1	ffffllllhhhhssss 1111111111111111 i...
#    ...
#    TRCGEN   	ffffllllhhhhssss dddddddddddddddd "string" i...
#    TRCGENt  	ffffllllhhhhssss dddddddddddddddd "string" i... t...
#
#    Legend
#      f - flags
#        tgbpruuuuuuuuRRR: t - time stamped,  g - generic (trcgen),
#          b - 32-bit data, p - include cpu_id, 
#	   r - registers traced, u - unused.
#	   R - # registers gathered - 1
#      l - length, number of bytes traced.
#        For TRCHKL0 llll = 0,
#        for TRCHKL5T llll = 40, 0x28 (5 8-byte words)
#      h - hook id
#      s - subhook id
#	1 - data word 1, ...
#	d - generic trace data word.
#	i - thread id, 8 bytes on a 64-bit system, 4 on a 32-bit system.
#	    The thread id starts on an 8-byte boundary.
#	t - time stamp, 8 bytes on a 64-bit system, 4 on a 32-bit system.
#	c - cpu-id, only valid for a 64-bit trace, the -p option.
#
#    For non-generic entries, the data pointer starts at the 
#    subhook id, offset 6.  This is compatible with the 32-bit
#    hook format shown above.
#    For generic (trcgen) hooks, the g flag above is on.  The
#    length shows the number of variable bytes traced and does not include
#    the data word.
#    The data pointer starts at the 64-bit data word.
#    Note that the data word is 64 bits here.
#
# C. Trace environments
#    The trcrpt, trace report, utility must be able to tell whether
#    the trace it's formatting came from a 32 or a 64 bit system.
#    This is accomplished by the log file header's magic number.
#    In addition, we need to know whether 32 or 64 bit data was traced.
#    It is possible to run a 32-bit application on a 64-bit kernel,
#    and a 64-bit application on a 32-bit kernel.
#    In the case of a 32-bit app on a 64-bit kernel, the "b" flag
#    shown under item B above is set on.  The trcrpt program will
#    then present the data as if it came from a 32-bit kernel.
#    In the second case, if the reserved hook id 00b is seen, the data 
#    traced by the 32-bit kernel is made to look as if it came
#    from a 64-bit trace.  Thus the templates need not be kernel aware.
#
#    For example, if a 32-bit app uses 
#    TRCHKL5T(0x50000005, 1, 2, 3, 4, 5)
#    and is running on a 64-bit kernel, the data actually traced
#    will look like:
#      ffffllllhhhhssss 1111111111111111 2222222222222222 3333333333333333
#      a000001450000005 0000000100000002 0000000300000004 0000000500000000 i t
#    Here, the flags have the T and B bits set (a000) which says 
#    the hook is timestamped and from a 32-bit app.
#    The length is 0x14 bytes, 5 4-byte registers 00000001 through
#    00000005.
#    The hook id is 0x5000.
#    The subhook id is 0x0005.
#    i and t refer to the 8-byte thread id and time stamp.
#
#    This would be reformatted as follows before being processed
#    by the corresponding template:
#      500e0005 00000001 00000002 00000003 00000004 00000005
#    Note this is how the data would look if traced on a 32-bit kernel.
#    Note also that the data would be followed by an 8-byte thread id and
#    time stamp.
#
#    Similarly, consider the following hook traced by a 64-bit app
#    on a 32-bit kernel:
#      TRCHKL5T(0x50000005, 1, 2, 3, 4, 5)
#    The data traced would be:
#      00b8002c 80000028 50000005 0000000000000001 ... 0000000000000005 i t
#    Note that this is a generic trace entry, T = 8.
#    In the generic entry, we're using the 32-bit data word for the flags
#    and length.
#    The trcrpt utility would reformat this before processing by
#    the template as follows:
#      8000002850000005 0000000000000001 ... 0000000000000005 i8 t8
#
#    The thread id and time stamp in the data stream will be 4 bytes,
#    because the hook came from a 32-bit system.
#
#    If a 32-bit app traces generic data on a 64-bit kernel, the b
#    bit will be set on in the data stream, and the entry will be formatted
#    like it came from a 32-bit environment, i.e. with a 32-bit data word.
#    For the case of a 64-bit app on a 32-bit kernel, generic trace
#    data is handled in the same manner, with the flags placed
#    into the data word.
#    For example, if the app issues
#      TRCGEN(1, 0x50000005, 1, 6, "hello")
#    The 32-bit kernel trace will generate
#      00b00012 40000006 50000005 0000000000000001 "hello"
#   This will be reformatted by trcrpt into
#      4000000650000005 0000000000000001 "hello"
#   with the data pointer starting at the data word.
#
#   Note that the string "hello" could have been 4096 bytes.  Therefore
#   this generic entry must be able to violate the 4096 byte length
#   restriction.
#
# D. Indentation levels
#    The left margin is set per template using the 'L=XXXX' command.
#    The default is L=KERN, the second column.
#    L=APPL moves the left margin to the first  column.
#    L=SVC  moves the left margin to the second column.
#    L=KERN moves the left margin to the third  column.
#    L=INT  moves the left margin to the fourth column.
#    The command if used must go just after the version code.
#
#    Example usage:
#113 1.7 L=INT "stray interrupt" ... \
#
# E. Continuation code and delimiters.
#    A '\' at the end of the line must be used to continue the template
#      on the next line.
#    Individual strings (labels) can be separated by one or more blanks
#      or tabs. However, all whitespace is squeezed down to 1 blank on
#      the report. Use '\t' for skipping to the next tabstop, or use
#      A0.X format (see below) for variable space.
#
#
# II. FORMAT codes
#
# A. Codes that manipulate the DATA_POINTER
# Gm.n
#     "Goto"    Set DATA_POINTER to byte.bit location m.n
#
# Om.n
#     "Omit"    Advance DATA_POINTER by m.n byte.bits
#
# Rm
#     "Reverse" Decrement DATA_POINTER by m bytes. R0 byte aligns.
#
# Wm
#     Position DATA_POINTER at word m.  The word size is either 4 or 8
#     bytes, depending upon whether or not this is a 32 or 64 bit format
#     trace.  This bares no relation to the %W format specifier.
#
# B. Codes that cause data to be output.
# Am.n
#     Left justified ascii.
#     m=length in bytes of the binary data.
#     n=width of the displayed field.
#     The data pointer is rounded up to the next byte boundary.
#     Example
#      DATA_POINTER|
#                  V
#             xxxxxhello world\0xxxxxx
#
#  i.   A8.16 results in:                       |hello wo        |
#       DATA_POINTER--------|
#                           V
#              xxxxxhello world\0xxxxxx
#
#  ii.  A16.16 results in:                      |hello world     |
#       DATA_POINTER----------------|
#                                   V
#              xxxxxhello world\0xxxxxx
#
#  iii. A16 results in:                         |hello world|
#       DATA_POINTER----------------|
#                                   V
#              xxxxxhello world\0xxxxxx
#
#  iv.  A0.16 results in:                       |                |
#       DATA_POINTER|
#                   V
#              xxxxxhello world\0xxxxxx
#
# Sm (m = 1, 2, 4, or 8)
#     Left justified ascii string.
#     The length of the string is in the first m bytes of
#      the data. This length of the string does not include these bytes.
#     The data pointer is advanced by the length value.
#     SW specifies the length to be 4 or 8 bytes, depending upon whether
#     this is a 32 or 64 bit hook.
#     Example
#      DATA_POINTER|
#                  V
#             xxxxxBhello worldxxxxxx     (B = hex 0x0b)
#
#  i.   S1 results in:                          |hello world|
#       DATA_POINTER-----------|
#                              V
#              xxxxBhello worldxxxxxx
#
# $reg%S1
#     A register with the format code of 'Sx' works "backwards" from
#     a register with a different type. The format is Sx, but the length
#     of the string comes from $reg instead of the next n bytes.
#
# Bm.n
#     Binary format.
#     m = length in bytes
#     n = length in bits
#     The length in bits of the data is m * 8 + n. B2.3 and B0.19 are the same.
#     Unlike the other printing FORMAT codes, the DATA_POINTER
#     can be bit aligned and is not rounded up to the next byte boundary.
#
# Xm
#     Hex format.
#     m = length in bytes. m=0 thru 16
#     X0 is the same as X1, except that no trailing space is output after
#     the data.  Therefore X0 can be used with a LOOP to output an
#     unbroken string of data.
#     The DATA_POINTER is advanced by m (1 if m = 0).
#     XW will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook.  The DATA_POINTER is advanced
#     by 4 or 8 bytes.
#
# Dm (m = 2, 4, or 8)
#     Signed decimal format.
#     The length of the data is m bytes.
#     The DATA_POINTER is advanced by m.
#     DW will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook.  The DATA_POINTER is advanced
#     by 4 or 8 bytes.
#
# Um (m = 2, 4, or 8)
#     Unsigned decimal format.
#     The length of the data is m bytes.
#     The DATA_POINTER is advanced by m.
#     UW will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook.  The DATA_POINTER is advanced
#     by 4 or 8 bytes.
#
# om (m = 2, 4, or 8)
#     Octal format.
#     The length of the data is m bytes.
#     The DATA_POINTER is advanced by m.
#     ow will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook.  The DATA_POINTER is advanced
#     by 4 or 8 bytes.
#
# F4
#     Floating point format. (like %0.4E)
#     The length of the data is 4 bytes.
#     The format of the data is that of C type 'float'.
#     The DATA_POINTER is advanced by 4.
#
# F8
#     Floating point format. (like %0.4E)
#     The length of the data is 8 bytes.
#     The format of the data is that of C type 'double'.
#     The DATA_POINTER is advanced by 8.
#
# HB
#     Number of bytes in trcgen() variable length buffer.
#     The DATA_POINTER is not changed.
#
# HT
#   32-bit hooks:
#     The hooktype. (0 - E)
#     trcgen  = 0, trchk  = 1, trchl  = 2, trchkg  = 6
#     trcgent = 8, trchkt = 9, trchlt = A, trchkgt = E
#     HT & 0x07 masks off the timestamp bit
#     This is used for allowing multiple, different trchook() calls with
#       the same template.
#     The DATA_POINTER is not changed.
#   64-bit hooks
#     This is the flags field.
#     0x8000 - hook is time stamped.
#     0x4000 - This is a generic trace.
#
#     Note that if the hook was reformatted as discussed under item
#     I.C above, HT is set to reflect the flags in the new format.
#
# C. Codes that interpret the data in some way before output.
# Tm (m = 4, or 8)
#     Output the next m bytes as a data and time string,
#     in GMT timezone format.  (as in ctime(&seconds))
#     The DATA_POINTER is advanced by m bytes.
#     Only the low-order 32-bits of the time are actually used.
#     TW will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook.  The DATA_POINTER is advanced
#     by 4 or 8 bytes.
#
# ml (l = 8)
#     Output the next l bytes as time in milliseconds from
#     the beginning of the trace.
#     The DATA_POINTER is advanced by 8 bytes.
#     mW will format only 8 bytes of data. The DATA_POINTER is
#     advanced by 8 bytes.
#
# um (m = 4, or 8)
#     Output the next m bytes as time in microseconds.
#     The DATA_POINTER is advanced by m bytes.
#     uW will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook. The DATA_POINTER is advanced
#     by 4 or 8 bytes.
#
# Em (m = 1, 2, 4, or 8)
#     Output the next m bytes as an 'errno' value, replacing
#     the numeric code with the corresponding #define name in
#     /usr/include/sys/errno.h
#     The DATA_POINTER is advanced by 1, 2, 4, or 8.
#     EW will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook.  The DATA_POINTER is advanced
#     by 4 or 8 bytes.
#
# Pm (m = 4, or 8)
#     Use the next m bytes as a process id (pid), and
#     output the pathname of the executable with that process id.
#     Process ids and their pathnames are acquired by the trace command
#     at the start of a trace and by trcrpt via a special EXEC tracehook.
#     The DATA_POINTER is advanced by 4 or 8 bytes.
#     PW will format either 4 or 8 bytes of data depending upon whether
#     this is a 32 or 64 bit hook.
#
# \t
#     Output a tab. \t\t\t outputs 3 tabs. Tabs are expanded to spaces,
#     using a fixed tabstop separation of 8. If L=0 indentation is used,
#     the first tabstop is at 3.
#
# \n
#     Output a newline. \n\n\n outputs 3 newlines.
#     The newline is left-justified according to the INDENTATION LEVEL.
#
# $macro
#     Undefined macros have the value of 0.
#     The DATA_POINTER is not changed.
#     An optional format can be used with macros:
#        $v1%X8    will output the value $v1 in X8 format.
#        $zz%B0.8  will output the value $v1 in 8 bits of binary.
#     Understood formats are: X, D, U, B and W. Others default to X2.
#
#     The W format is used to mask the register.
#     Wm.n masks off all bits except bits m through n, then shifts the
#     result right m bits.  For example, if $ZZ = 0x12345678, then
#     $zz%W24.27 yields 2.  Note the bit numbering starts at the right,
#     with 0 being the least significant bit.
#
# "string"     'string' data type
#     Output the characters inside the double quotes exactly. A string
#     is treated as a descriptor. Use "" as a NULL string.
#
# `string format $macro` If a string is backquoted, it is expanded
#     as a quoted string, except that FORMAT codes and $registers are
#     expanded as registers.
#
# III. SWITCH statement
#     A format code followed by a comma is a SWITCH statement.
#     Each CASE entry of the SWITCH statement consists of
#       1. a 'matchvalue' with a type (usually numeric) corresponding to
#          the format code.
#       2. a simple 'string' or a new 'descriptor' bounded by braces.
#          A descriptor is a sequence of format codes, strings, switches,
#          and loops.
#       3. and a comma delimiter.
#       The switch is terminated by a CASE entry without a comma delimiter.
#     The CASE entry selected is the first entry whose matchvalue
#     is equal to the expansion of the format code.
#     The special matchvalue '\*' is a wildcard and matches anything.
#     The DATA_POINTER is advanced by the format code.
#
#
# IV. LOOP statement
#     The syntax of a 'loop' is
#     LOOP format_code { descriptor }
#     The descriptor is executed N times, where N is the numeric value
#       of the format code.
#     The DATA_POINTER is advanced by the format code plus whatever the
#       descriptor does.
#     Loops are used to output binary buffers of data, so descriptor is
#       usually simply X1 or X0. Note that X0 is like X1 but does not
#       supply a space separator ' ' between each byte.
#
#
# V. macro assignment and expressions
#   'macros' are temporary (for the duration of that event) variables
#   that work like shell variables.
#   They are assigned a value with the syntax:
#   {{ $xxx = EXPR }}
#   where EXPR is a combination of format codes, macros, and constants.
#   Allowed operators are + - / *
#   For example:
#{{ $dog = 7 + 6 }} {{ $cat = $dog * 2 }} $dog $cat
#
#   will output:
#000D 001A
#
#   Macros are useful in loops where the loop count is not always
#   just before the data:
#G1.5 {{ $count = B0.5 }} G11 LOOP $count {X0}
#
#   Up to 255 macros can be defined per template.
#
#
# VI. Special macros:
# $HOOKENV     This is either "32" or "64" depending upon
#	       whether this is a 32 or 64 bit trace hook.
#	       This can be used to interpret the HT value.
# $TRACEENV    This is either "32" or "64" depending upon
#	       whether this is a 32 or 64 bit trace, i.e., whether the
#              trace was generated by a 32 or 64 bit kernel.
#	       Since hooks will be formatted according to the environment
#	       they came from, $HOOKENV should normally be used.
# $RELLINENO   line number for this event. The first line starts at 1.
# $D1 - $D5    dataword 1 through dataword 5. No change to datapointer.
#   The data word is either 4 or 8 bytes.
# $L1 - $L5    Long dataword 1,5(64 bits). No change to datapointer.
# $HD          hookdata (lower 16 bits)
# 	       For a 32-bit generic hook, $HD is the length of the
#	       generic data traced.
#              For 32 or 64 bit generic hooks, use $HL.
# $HL	       Hook data length.  This is the length in bytes of the hook
#	       data.  For generic entries it is the length of the
#	       variable length buffer and doesn't include the data word.
# $WORDSIZE    Contains the word size, 4 or 8 bytes, of the current
#	       entry, (i.e.) $HOOKENV / 8.
# $GENERIC     specifies whether the entry is a generic entry.  The
#	       value is 1 for a generic entry, and 0 if not generic.
#	       $GENERIC is especially useful if the hook can come from
#	       either a 32 or 64 bit environment, since the types (HT)
#	       have different formats.
# $TOTALCPUS   Output the number of CPUs in the system.
# $TRACEDCPUS  Output the number of cpus that were traced.
# $REPORTEDCPUS Output the number of cpus active in this report.
#              This can decrease as CPUs stop tracing when, for example,
#              the single-buffer trace, -f, was used and the buffers for
#              each CPU fill up.
# $LARGEDATATYPES This is set to 1 if the kernel is supporting large data
#              types for 64-bit applications.
# $SVC         Output the name of the current SVC
# $EXECPATH    Output the pathname of the executable for current process.
# $PID         Output the current process id.
# $TID         Output the current thread id.
# $CPUID       Output the current processor id.
# $PRI	       Output the current process priority
# $ERROR       Output an error message to the report and exit from the
#              template after the current descriptor is processed.
#              The error message supplies the logfile, logfile offset of the
#              start of that event, and the traceid.
# $LOGIDX      Current logfile offset into this event.
# $LOGIDX0     Like $LOGIDX, but is the start of the event.
# $LOGFILE     Name of the logfile being processed.
# $TRACEID     Traceid of this event. Can be either 3 or 4 digits.
# $DEFAULT     Use the DEFAULT template 008
# $STOP        End the trace report right away
# $BREAK       End the current trace event
# $SKIP        Like break, but don't print anything out.
# $ENDIANTYPE  Helps to use endian specific format rules.
#              0 - Big endian
#              1 - Little endian
# $PLATFORMTYPE  Rules specific to the platform can be coded against this
#              variable.
#              0 - RISC type of machine
#              1 - IA64 type of machine
# $DATAPOINTER The DATA_POINTER. It can be set and manipulated
#              like other user-macros.
#              {{ $DATAPOINTER = 5 }} is equivalent to G5
#
# Note:  For generic trace hooks, $DATAPOINTER points to the 
#   data word.  This means it is 0x4 for 32-bit hooks, and 0x8 for
#   64-bit hooks.
#   For non-generic hooks, $DATAPOINTER is set to 2 for 32-bit hooks
#   and to 6 for 64 bit trace hooks.  This means it always
#   points to the subhook id.
#
# $BASEPOINTER Usually 0. It is the starting offset into an event. The actual
#              offset is the DATA_POINTER + BASE_POINTER. It is used with
#              template subroutines, where the parts on an event have the
#              same structure, and can be printed by the same template, but
#              may have different starting points into an event.
# $IPADDR      IP address of this machine, 4 bytes.
# $BUFF        Buffer allocation scheme used, 1=kernel heap, 2=separate segment.
# $PURR	       Machine PURR register
# $MCR0, $MCR1, $MCRA Machine MCR registers 0, 1, and A.
# $PMC1, $PMC2 ... $PMC8 Machine PMC registers 1 - 8.
#
# VII. Template subroutines
#    If a macro name consists of 3 or 4 hex digits, it is a "template 
#    subroutine". The template whose traceid equals the macro name is inserted 
#    in place of the macro.
#
#    The data pointer is where it was when the template
#    substitution was encountered. Any change made to the data pointer
#    by the template subroutine remains in affect when the template ends.
#
#    Macros used within the template subroutine correspond to those in the
#    calling template. The first definition of a macro in the called template
#    is the same variable as the first in the called. The names are not
#    related.
#
#    NOTE: Nesting of template subroutines is supported to 10 levels.
#
#    Example:
#    Output the trace label ESDI STRATEGY.
#    The macro '$stat' is set to bytes 2 and 3 of the trace event.
#    Then call template 90F to interpret a buf header. The macro '$return'
#    corresponds to the macro '$rv', since they were declared in the same
#    order. A macro definition with no '=' assignment just declares the name
#    like a place holder. When the template returns, the saved special
#    status word is output and the returned minor device number.
#
#900 1.0 "ESDI STRATEGY" {{ $rv = 0 }} {{ $stat = X2 }} \
#       $90F \n\
#special_esdi_status=$stat for minor device $rv
#
#90F 1.0 "" G4 {{ $return }} \
#       block number X4 \n\
#       byte count   X4 \n\
#       B0.1, 1 B_FLAG0 \
#       B0.1, 1 B_FLAG1 \
#       B0.1, 1 B_FLAG2 \
#       G16 {{ $return = X2 }}
#
#
#    Note: The $DEFAULT reserved macro is the same as $008
#
# VIII. BITFLAGS statement
#     The syntax of a 'bitflags' is
#     BITFLAGS [format_code|register],
#         flag_value string {optional string if false},   or
#         '&' mask field_value string,
#                 ...
#
#     This statement simplifies expanding state flags, since it looks
#       a lot like a series of #defines.
#     The '&' mask is used for interpreting bit fields.
#     The mask is anded to the register and the result is compared to
#       the field_value. If a match, the string is printed.
#     The base is 16 for flag_values and masks.
#     The DATA_POINTER is advanced if a format code is used.
#     Note: the default base for BITFLAGS is 16. If the mask or field value
#     has a leading "o", the number is octal. 0x or 0X makes the number hex.


# A 000 traceid will use this template
# This id is also used to define most of the template functions.
#  filemode(omode)    expand omode the way  ls -l does. The
#                     call to setdelim() inhibits spaces between the chars.
#
004 1.0 L=0 "TRACEID IS ZERO" G0 hookword=XW file=$LOGFILE index=$LOGIDX0 \
{{ \
sinaddr(addr) \
        {{ $addr }} \
        $addr, \
        0xBADFCA11 { $addr }, \
        \* { \
                {{ $z1 = $addr%W24.31 }} \
                {{ $z2 = $addr%W16.23 }} \
                {{ $z3 = $addr%W8.15 }} \
                {{ $z4 = $addr%W0.7 }} \
                setdelim(0) \
                $z1%D1"."$z2%D1"."$z3%D1"."$z4%D1 \
                setdelim(1)  \
        } \
}} \
{{ \
prfd(fd) \
        $fd%D1 \
}} \
{{ \
prpid(pid) \
        $pid, 0 {} {{ $n = $pid }} $n%D1 \
}} \
{{ \
prUserTID(tid) \
	getContextPIDTID($tid, 0, 0) \
}} \
{{ \
prKernelTID(tid) \
	getContextPIDTID($tid, 0, 1) \
}} \
{{ \
prUserPID(pid) \
	getContextPIDTID($pid, 1, 0) \
}} \
{{ \
prKernelPID(pid) \
	getContextPIDTID($pid, 1, 1) \
}} \
{{ \
filemode(omode) \
        setdelim(0) \
        $omode%o4 & 04000, \
        04000 { {{ $suid = "s" }} {{ $suidn = "S" }} }, \
        \*    { {{ $suid = "x" }} {{ $suidn = "-" }} } \
        $omode%o4 & 02000, \
        02000 { {{ $sgid = "s" }} {{ $sgidn = "S" }} }, \
        \*    { {{ $sgid = "x" }} {{ $sgidn = "-" }} } \
        $omode%o4 & 01000, \
        01000 { \
                $omode%o4 & 0170000, \
                00020000 { {{ $svtxt = "T" }} {{ $svtxtn = "T" }} }, \
                \*       { {{ $svtxt = "t" }} {{ $svtxtn = "T" }} } \
        }, \
        \*           { {{ $svtxt = "x" }} {{ $svtxtn = "-" }} } \
        BITFLAGS $omode%o4, \
        & 0170000 00040000 "d", \
        & 0170000 00020000 "c", \
        & 0170000 00060000 "b", \
        & 0170000 00100000 "-", \
        & 0170000 00010000 "p", \
        & 0170000 00120000 "l", \
        & 0170000 00140000 "s", \
        00400  "r" "-" ,\
        00200  "w" "-" ,\
        00100  $suid $suidn ,\
        00040  "r" "-" ,\
        00020  "w" "-" ,\
        00010  $sgid $sgidn ,\
        00004  "r" "-" ,\
        00002  "w" "-" ,\
        00001  $svtxt $svtxtn \
        setdelim(1) \
}} \
{{ \
prsignal(sig) \
        $sig%D1, \
        1   SIGHUP, \
        2   SIGINT, \
        3   SIGQUIT, \
        4   SIGILL, \
        5   SIGTRAP, \
        6   SIGABRT, \
        7   SIGEMT, \
        8   SIGFPE, \
        9   SIGKILL, \
        10  SIGBUS, \
        11  SIGSEGV, \
        12  SIGSYS, \
        13  SIGPIPE, \
        14  SIGALRM, \
        15  SIGTERM, \
        16  SIGURG, \
        17  SIGSTOP, \
        18  SIGTSTP, \
        19  SIGCONT, \
        20  SIGCHLD, \
        21  SIGTTIN, \
        22  SIGTTOU, \
        23  SIGIO, \
        24  SIGXCPU, \
        25  SIGXFSZ, \
        27  SIGMSG, \
        28  SIGWINCH, \
        29  SIGPWR, \
        30  SIGUSR1, \
        31  SIGUSR2, \
        32  SIGPROF, \
        33  SIGDANGER, \
        34  SIGVTALRM, \
        35  SIGMIGRATE, \
        36  SIGPRE, \
        60  SIGGRANT, \
        61  SIGRETRACT, \
        62  SIGSOUND, \
        63  SIGSAK, \
        \*  { $sig%D1 } \
}} \
{{ \
openflagsk(flags) \
        BITFLAGS $flags%o4, \
        & 003 001 "RDONLY", \
        & 003 002 "WRONLY", \
        & 003 003 "RDWR", \
        00400     "CREAT", \
        01000     "TRUNC", \
        02000     "EXCL", \
        04000     "NOCTTY", \
        00004     "NONBLOCK", \
        00010     "APPEND", \
      0100000     "NDELAY" \
}} \
{{ \
openflags(flags) \
        BITFLAGS $flags%o4, \
        & 003 000 "RDONLY", \
        & 003 001 "WRONLY", \
        & 003 002 "RDWR", \
        00400     "CREAT", \
        01000     "TRUNC", \
        02000     "EXCL", \
        04000     "NOCTTY", \
        00004     "NONBLOCK", \
        00010     "APPEND", \
      0100000     "NDELAY" \
}} \
{{ \
dopenflags(flags) \
        BITFLAGS $flags%o4, \
        00001 "READ", \
        00002 "WRITE", \
        00004 "NONBLOCK", \
        00010 "APPEND", \
        00400 "CREAT", \
        01000 "TRUNC", \
        02000 "EXCL", \
        04000 "NOCTTY", \
      0100000 "NDELAY" \
}} \
{{ \
messagetype(mess) \
	$mess, \
	00000000 "M_DATA", \
	00000001 "M_PROTO", \
	00000008 "M_BREAK", \
	00000009 "M_PASSFP", \
	0000000b "M_SIG", \
	0000000c "M_DELAY", \
	0000000d "M_CTL", \
	0000000e "M_IOCTL", \
	00000010 "M_SETOPTS", \
	00000011 "M_RSE", \
	00000081 "M_IOCACK", \
	00000082 "M_IOCNAK", \
	00000083 "M_PCPROTO", \
	00000084 "M_PCSIG", \
	00000085 "M_READ", \
	00000086 "M_FLUSH", \
	00000087 "M_STOP", \
	00000088 "M_START", \
	00000089 "M_HANGUP", \
	0000008a "M_ERROR", \
	0000008b "M_COPYIN", \
	0000008c "M_COPYOUT", \
	0000008d "M_IOCDATA", \
	0000008e "M_PCRSE", \
	0000008f "M_STOPI", \
	00000090 "M_STARTI", \
	00000093 "M_HPDATA", \
	00000094 "M_NOTIFY", \
        \* { $mess%X4 } \
}} \
{{ \
ioctlname(cmd) \
        $cmd, \
        00004801 "HFTGETID", \
        00004802 "HFQUERY", \
        00004803 "HFSKBD", \
        00004805 "HFSMON", \
        00004806 "HFCMON", \
        0000480A "HFRCONF", \
        0000480B "HFESOUND", \
        0000480C "HFDSOUND", \
        0000480F "HFSKEP", \
        00004810 "HFCKEP", \
        00004812 "HFSJKBD", \
        00004814 "HFTQSMGR", \
        00004815 "HFQERROR", \
        00004816 "HFCHGLOC", \
        00004817 "HFESWKBD", \
        00004818 "HFTSECHO", \
        00004819 "HFTSBREAK", \
        0000481A "HFTCSMGR", \
        0000481B "HFTQDEV", \
        0000481C "HFHANDLE", \
        00005800 "TXISATTY", \
        00005801 "TXTTYNAME", \
        00005802 "TXGETLD", \
        00005803 "TXSETLD", \
        00005804 "TXGETCD", \
        00005805 "TXADDCD", \
        00005806 "TXDELCD", \
        00005807 "TXSBAUD", \
        00005808 "TXGBAUD", \
        00005809 "TXSETIHOG", \
        0000580A "TXSETOHOG", \
        00005401 "TCGETS", \
        00005402 "TCSETS", \
        00005403 "TCSETSW", \
        00005404 "TCSETSF", \
        00005405 "TCGETA", \
        00005406 "TCSETA", \
        00005407 "TCSETAW", \
        00005408 "TCSETAF", \
        00005409 "TCSBRK", \
        0000540a "TCSBREAK", \
        0000540b "TCXONC", \
        0000540c "TCFLSH", \
        0000540d "TCGLEN", \
        0000540e "TCSLEN", \
        0000540f "TCSAK", \
        00005410 "TCQSAK", \
        00005411 "TCTRUST", \
        00005412 "TCQTRUST", \
        00005413 "TCSMAP", \
        00005414 "TCGMAP", \
        00005415 "TCKEP", \
        00005416 "TCGSAK", \
        00005417 "TCLOOP", \
        00005418 "TCVPD", \
        00005419 "TCREG", \
        0000541a "TCGSTATUS", \
        0000541b "TCSCONTROL", \
        0000541c "TCSCSMAP", \
        0000541d "TCGCSMAP", \
        001b0000 "LI_GETVT", \
        001b0001 "LI_SETVT", \
        001b0002 "LI_GETXP", \
        001b0003 "LI_SETXP", \
        001b0004 "LI_SLP1", \
        001b0005 "LI_DSLP", \
        001b0006 "LI_SLP0", \
        001b0007 "LI_PRES", \
        001b0008 "LI_DRAM", \
        001b0009 "LI_GETTBC", \
        001b000a "LI_SETTBC", \
        001c8000 "RS_GETA", \
        001c8001 "RS_SETA", \
        40047400 "TIOCGETD", \
        80047401 "TIOCSETD", \
        20007402 "TIOCHPCL", \
        40047403 "TIOCMODG", \
        80047404 "TIOCMODS", \
        40067408 "TIOCGETP", \
        80067409 "TIOCSETP", \
        8006740a "TIOCSETN", \
        2000740d "TIOCEXCL", \
        2000740e "TIOCNXCL", \
        80047410 "TIOCFLUSH", \
        80067411 "TIOCSETC", \
        40067412 "TIOCGETC", \
        8004747f "TIOCLBIS", \
        8004747e "TIOCLBIC", \
        8004747d "TIOCLSET", \
        4004747c "TIOCLGET", \
        2000747b "TIOCSBRK", \
        2000747a "TIOCCBRK", \
        20007479 "TIOCSDTR", \
        20007478 "TIOCCDTR", \
        40047477 "TIOCGPGRP", \
        80047476 "TIOCSPGRP", \
        80067475 "TIOCSLTC", \
        40067474 "TIOCGLTC", \
        40047473 "TIOCOUTQ", \
        80017472 "TIOCSTI", \
        20007471 "TIOCNOTTY", \
        80047470 "TIOCPKT", \
        2000746f "TIOCSTOP", \
        2000746e "TIOCSTART", \
        8004746d "TIOCMSET", \
        8004746c "TIOCMBIS", \
        8004746b "TIOCMBIC", \
        4004746a "TIOCMGET", \
        80047469 "TIOCREMOTE", \
        40087468 "TIOCGWINSZ", \
        80087467 "TIOCSWINSZ", \
        80047466 "TIOCUCNTL", \
        20006601 "FIOCLEX", \
        20006602 "FIONCLEX", \
        4004667f "FIONREAD", \
        8004667e "FIONBIO", \
        8004667d "FIOASYNC", \
        8004667c "FIOSETOWN", \
        4004667b "FIOGETOWN", \
	00006c11 "LPRGETA", \
	00006c12 "LPRSETA", \
	00006c13 "LPRGTOV", \
	00006c14 "LPRSTOV", \
	00006c17 "LPQUERY", \
	00006c1a "LPDIAG", \
	00006c1b "LPRMODG", \
	00006c1c "LPRMODS", \
        80047300 "SIOCSHIWAT", \
        40047301 "SIOCGHIWAT", \
        80047302 "SIOCSLOWAT", \
        40047303 "SIOCGLOWAT", \
        40047307 "SIOCATMARK", \
        80047308 "SIOCSPGRP", \
        40047309 "SIOCGPGRP", \
        8030720a "SIOCADDRT", \
        8030720b "SIOCDELRT", \
        8020690c "SIOCSIFADDR", \
        8020690e "SIOCSIFDSTADDR", \
        c020690f "SIOCGIFDSTADDR", \
        80206910 "SIOCSIFFLAGS", \
        80206913 "SIOCSIFBRDADDR", \
        c020690d "SIOCGIFADDR", \
        c0206912 "SIOCGIFBRDADDR", \
        c0206911 "SIOCGIFFLAGS", \
        c0086914 "SIOCGIFCONF", \
        c0206915 "SIOCGIFNETMASK", \
        80206916 "SIOCSIFNETMASK", \
        c0206917 "SIOCGIFMETRIC", \
        80206918 "SIOCSIFMETRIC", \
        8024691e "SIOCSARP", \
        c024691f "SIOCGARP", \
        80246920 "SIOCDARP", \
        80016921 "SIOCSNETOPT", \
        c0016922 "SIOCGNETOPT", \
        c0016923 "SIOCDNETOPT", \
        8024695d "SIOCSARP_TOKEN", \
        c024695e "SIOCGARP_TOKEN", \
        8024695f "SIOCDARP_TOKEN", \
        80246960 "SIOCSARP_X25", \
        c0246961 "SIOCGARP_X25", \
        80246962 "SIOCDARP_X25", \
        \* { $cmd%X4 } \
}} \
{{ \
bflags(flags) \
        BITFLAGS $flags, \
        0x0001 "B_READ" "B_WRITE", \
        0x0002 "B_DONE", \
        0x0004 "B_ERROR", \
        0x0008 "B_BUSY", \
        0x0020 "B_INFLIGHT", \
        0x0080 "B_AGE", \
        0x0100 "B_ASYNC", \
        0x0200 "B_DELWRI", \
        0x0400 "B_NOHIDE", \
        0x0800 "B_STALE" \
}} \
{{ \
prstate(flags) \
        $flags%D1, \
        0 "NONE", \
        1 "IDLE", \
        2 "RUNABLE", \
        3 "SLEEPING", \
        4 "SWAPPED", \
        5 "STOPPED", \
        6 "DEFUNCT", \
        \*  { $flags%D1 } \
}}
4AB 1.0 "@STTY VTS" \
{{ \
rete(err, line) \
	"return" $err%EW "from line" $line%D4 \
}} \
{{ \
retv(line) \
	"return from line" $line%D4 \
}} \
{{ \
retp(ptr, line) \
	"return vts" $ptr%XW "from line" $line%D4 \
}} \
{{ \
vts_ioctl(num) \
	$num%X4, \
	12345678 "READ_CLCS", \
	12345679 "READ_PARTNER", \
	1234567a "WRITE_PARTNER", \
	\* { ioctlname($num) } \
}} \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "vts" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000e "add ", \
	000f "del ", \
	0010 "create ", \
	0011 "destroy ", \
	0012 "read ", \
	0013 "write ", \
	0014 "ioctl ", \
	0015 "init ", \
	0016 "get_clcs ", \
	0017 "open ", \
	0018 "close ", \
	0019 "make_clc ", \
	001A "read_clcs ", \
	001B "copyin_ioctl ", \
	001C "free_vterm ", \
	001D "register_vterm ", \
	001E "write_partner ", \
	001F "read_partner " \
	$how, \
	0000 { $which, \
	       000e { "uiop" $D4%XW }, \
	       000f { "uiop" $D4%XW }, \
	       0010 { "errp" $D3%XW }, \
	       0012 { "uiop" $D3%XW "chan" $D3%XW "ext" $D5%XW }, \
	       0013 { "uiop" $D3%XW "chan" $D3%XW "ext" $D5%XW }, \
	       0014 { "cmd" vts_ioctl($D3) "arg" $D4%XW "mode" $D5%XW }, \
	       0017 { "rwflag" dopenflags($D3) "chan" $D4%XW "ext" $D5%XW }, \
	       0018 { "chan" $D3%XW "ext" $D4%XW }, \
	       0019 { "id" $D3%XW "addr" $D4%XW "buf" $D5%XW }, \
	       001A { "arg" $D3%XW }, \
	       001B { "arg" $D3%XW }, \
	       001D { "name" $D3%XW }, \
	       001E { "arg" $D3%XW }, \
	       001F { "arg" $D3%XW } \
	     }, \
	0001 { "DATA" $D3%XW $D4%XW $D5%XW },	 \
	0002 { $which, \
	       0010 { retp($D3, $D4) }, \
	       0011 { retv($D4) }, \
	       \*   { rete($D3, $D4) } \
	     }, \
	0003 { $D3, \
		0000 { "break at line" $D4%DW }, \
		0001 { "continue at line" $D4%DW }, \
		0002 { "goto from line" $D4%DW } \
	     }
417 1.0 "@STTY VCON "\
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "vcon" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000e "flush ", \
	000f "ctl ", \
	0010 "termios_set ", \
	0011 "add ", \
	0012 "del ", \
	0013 "write ", \
	0014 "timeout ", \
	0015 "allocmsg ", \
	0016 "revover ", \
	0017 "allocmflush ", \
	0018 "mflush_recover ", \
	0019 "mflush_timeout ", \
	001a "offl ", \
	001b "add_adap ", \
	001c "add_port ", \
	001d "del_adap ", \
	001e "del_port ", \
	001f "cfg_clean ", \
	0020 "hget ", \
	0021 "intr_offl ", \
	0022 "cd_drop " \
	$how ,\
	0000 { $which, \
	       0009 { "ptr" $D2%XW "cmd" ioctlname($D3) }, \
	       000e { "rw:" BITFLAGS $3, 1 "FLUSHR", 2 "FLUSHW" }, \
	       000f { "cmd" ioctlname($D3) }, \
	       0010 { "cflag" $D3%XW "iflag" $D4%XW "start/stop" $D5%X2 }, \
	       0011 { "dev" $D3%XW }, \
	       0012 { "dev" $D3%XW }, \
	       0013 { "buffer" $D3%XW "count" $D4%D4 }, \
	       001b { "devno" $D3%XW "adap_dds" $D4%XW }, \
	       001c { "devno" $D3%XW "adap_dds" $D4%XW }, \
	       001d { "devno" $D3%XW }, \
	       001e { "devno" $D3%XW }, \
	       001f { "devno" $D3%XW "depth" $D4%D4 }, \
	       0020 { "portlock" $D3%D4 "oldlock" $D4%D4 }, \
	       0022 { "status" $D3%D4 "count" $D4%D4 "buf" $D5%X4 } \
	     }, \
	0002 { $which, \
	       0009 { "ret" $D3%D4 "from line" $D4%DW }, \
	       000e { "ret from line" $D4%DW }, \
	       000f { "ret" $D3%D4 "from line" $D4%DW }, \
	       0010 { "ret" $D3%D4 "from line" $D4%DW }, \
	       0013 { "ret" $D3%D4 "from line" $D4%DW }, \
	       0014 { "ret from line" $D4%DW }, \
	       0015 { "ret" $D3%XW "from line" $D4%DW }, \
	       0016 { "ret from line" $D4%DW }, \
	       0017 { "ret" $D3%D4 "from line" $D4%DW }, \
	       0018 { "ret from line" $D4%DW }, \
	       0019 { "ret from line" $D4%DW }, \
	       001a { "ret from line" $D4%DW }, \
	       001b { "ret" $D3%D4 "from line" $D4%DW }, \
	       001c { "ret" $D3%D4 "from line" $D4%DW }, \
	       001d { "ret" $D3%D4 "from line" $D4%DW }, \
	       001e { "ret" $D3%D4 "from line" $D4%DW }, \
	         \* { "ret" $D3%E4 "from line" $D4%DW } }, \
	0003 { $D3, \
		0000 { "break at line" $D4%DW }, \
		0001 { "continue at line" $D4%DW }, \
		0002 { "goto from line" $D4%DW } }
53E 1.0 L=KERN "VSCSI CLIENT " \
        {{ $function  = $HD & 0x0fff }} \
        {{ $specific  = $HD & 0xf000 }} \
	$function, \
        0x0000 {	$specific, \
                0x0000 {"vscsi_init_open" W1 "devno:" XW W2 "devflags:" XW W3 "chan:" XW W4 "ext:" XW}, \
                0xf000 {"vscsi_init_open" W1 "ret_code:" XW W2 "devno:" XW W3 "vscsi->state:" XW} }, \
        0x0001 {	$specific, \
                0x0000 {"vscsi_fail_open" W1 "ret_code:" XW W2 "devno:" XW} }, \
        0x0002 {	$specific, \
                0x0000 {"vscsi_init_ioctl" W1 "devno:" XW W2 "cmd:" XW W3 "arg:" XW}, \
                0xf000 {"vscsi_init_ioctl" W1 "ret_code:" XW W2 "devno:" XW W3 "vscsi->state:" XW} }, \
        0x0003 {	$specific, \
                0x0000 {"vscsi_strategy" W1 "bp:" XW W2 "b_dev:" XW W3 "b_flags:" XW W4 "b_blkno:" XW W5 "b_count:" XW}, \
                0xf000 {"vscsi_strategy" W1 "ret_code:" XW W2 "b_dev:" XW} }, \
        0x0004 {	$specific, \
                0x0000 {"vscsi_start_pending_cmds" W1 "devno:" XW W2 "scp:" XW W3 "b_flags:" XW W4 "b_blkno:" XW W5 "b_count:" XW}, \
                0xf000 {"vscsi_start_pending_cmds" W1 "devno:" XW} }, \
        0x0005 {	$specific, \
                0x0000 {"vscsi_init_close" W1 "devno:" XW W2 "vscsi->state:" XW}, \
                0xf000 {"vscsi_init_close" W1 "ret_code:" XW W2 "devno:" XW W3 "vscsi->state:" XW} }, \
        0x0006 {	$specific, \
		0x0000 {"vscsi_iodone" W1 "vbp" XW W2 "vbp->vscsi->devno" XW W3 "vbp->b_dev" XW "" W4 "vbp->b_error" XW} }, \
        0x0007 {	$specific, \
		0x0000 {"vscsi_watchdog" W1 "devno" XW W2 "state" XW W3 "timer_reason" XW} }
59F 1.0 "@vscsi_initdd" O2 A8.8 "d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8
53B 1.1 "@vioentdd" \
        "VIOENTDD XMT:  " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
53C 1.1 "@vioentdd" \
        "VIOENTDD RCV:  " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
53D 1.1 "@vioentdd" \
        "VIOENTDD GEN:  " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
47C 1.0 L=KERN "USB MSTOR" \
    $HD%X2, \
    0x1010 { "BUFCB pirp=" $D1%XW " status=" $D2%DW }, \
    0x1011 { "BUFCBX pirp=" $D1%XW }, \
    0x1020 { "CFGDEV mdi=" $D1%XW }, \
    0x1021 { "CFGDEVX mdi=" $D1%XW " errnoval=" $D2%DW " l=" $D3%DW }, \
    0x1030 { "CLOSCOM mdi=" $D1%XW }, \
    0x1031 { "CLOSCOMX mdi=" $D1%XW }, \
    0x1040 { "CLOSE devno=" $D1%XW }, \
    0x1041 { "CLOSEX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x1050 { "CMDCB pirp=" $D1%XW " status=" $D2%DW }, \
    0x1051 { "CMDCBX pirp=" $D1%XW }, \
    0x1060 { "CONFIG devno=" $D1%XW " op=" $D2%XW " uiop=" $D3%XW }, \
    0x1061 { "CONFIGX devno=" $D1%XW " errnoval=" $D2%DW " l=" $D3%DW }, \
    0x1070 { "CONNECT mdi=" $D1%XW }, \
    0x1071 { "CONNECTX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1080 { "CTLCB mdi=" $D1%XW " pirp=" $D2%XW " devreq=" $D3%XW }, \
    0x1081 { "CTLCBX mdi=" $D1%XW }, \
    0x1082 { "CTLCBGO mdi=" $D1%XW " pirp=" $D2%XW " devreq=" $D3%XW " status=" $D4%DW }, \
    0x1090 { "DISCONN mdi=" $D1%XW }, \
    0x1091 { "DISCONNX mdi=" $D1%XW }, \
    0x10a0 { "DQPEND b_dev=" $D1%XW " mdi=" $D2%XW " bp=" $D3%XW }, \
    0x10a1 { "DQPENDX mdi=" $D1%XW }, \
    0x10b0 { "INITDEV mdi=" $D1%XW }, \
    0x10b1 { "INITDEVX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x10b2 { "INITDEVXE yyy" }, \
    0x10c0 { "IOCTL devno=" $D1%XW " op=" $D2%XW " arg=" $D3%XW " devflag=" $D4%XW }, \
    0x10c1 { "IOCTLX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x10c2 { "IOCTLW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x10c3 { "CDIOCTL n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x10c4 { "GENIOCTL n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x10c8 { "GENRESET n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x10d0 { "LOGERR mui_devno=" $D1%XW " mdi=" $D2%XW " cmd_error=" $D3%XW " flag=" $D4%XW }, \
    0x10e0 { "MINCNT devno=" $D1%XW " minparms=" $D2%XW }, \
    0x10e1 { "MINCNTX devno=" $D1%XW " errno=" $D2%DW }, \
    0x10f0 { "MODSNS mui_devno=" $D1%XW " mdi=" $D2%XW " type=" $D3%XW }, \
    0x1100 { "MODSEL mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x1101 { "MODSELX mui_devno=" $D1%XW " errno=" $D2%DW }, \
    0x1110 { "MSRESET mdi=" $D1%XW }, \
    0x1111 { "MSRESETX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1120 { "OPEN devno=" $D1%XW " rwflag=" $D2%XW }, \
    0x1121 { "OPENX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x1130 { "OPENCOM mdi=" $D1%XW }, \
    0x1131 { "OPENCOMX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1140 { "PRALL mui_devno=" $D1%XW " mdi=" $D2%XW " type=" $D3%XW }, \
    0x1150 { "PROCBUF mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW " bp=" $D4%XW }, \
    0x1151 { "PROCBUFX mui_devno=" $D1%XW " n=" $D2%XW }, \
    0x1160 { "PROCRST mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x1161 { "PROCRSTX mui_devno=" $D1%XW }, \
    0x1162 { "PROCRSTWU mui_devno=" $D1%XW " mdi=" $D2%XW " n=" $D3%DW }, \
    0x1170 { "PROCSNS mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW " chkcmd=" $D4%XW }, \
    0x1171 { "PROCSNSX mui_devno=" $D1%XW " n=" $D2%XW }, \
    0x1180 { "QPEND b_dev=" $D1%XW " mdi=" $D2%XW " bp=" $D3%XW }, \
    0x1181 { "QPENDX b_dev=" $D1%XW " n=" $D2%XW }, \
    0x1190 { "RAWIO mdi=" $D1%XW " rwflag=" $D2%XW " uiop=" $D3%XW }, \
    0x1191 { "RAWIOX mui_devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x11a0 { "RAWIOMLT mui_devno=" $D1%XW " mui=" $D2%XW " rwflag=" $D3%XW " uiop=" $D4%XW }, \
    0x11a1 { "RAWIOMLTX mui_devno=" $D1%XW " errno=" $D2%DW " l=" $D3%DW }, \
    0x11b0 { "XFBLKS mdi=" $D1%XW " buf=" $D2%XW " blkno=" $D3%DW " nblks=" $D4%DW " xmemp=" $D5%XW }, \
    0x11b1 { "XFBLKSX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x11b2 { "XFBLKSE n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x11c0 { "RDWR devno=" $D1%XW " rwflag=" $D2%XW " uiop=" $D3%XW }, \
    0x11c1 { "RDWRX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x11c2 { "RDWRXU devno=" $D1%XW " l=" $D2%DW }, \
    0x11d0 { "READCAP mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x11d1 { "READCAPX mui_devno=" $D1%XW " errno=" $D2%DW }, \
    0x11e0 { "READTOC mui_devno=" $D1%XW " mdi=" $D2%XW " type=" $D3%XW }, \
    0x11e1 { "READTOCX mui_devno=" $D1%XW " errno=" $D2%XW }, \
    0x11f0 { "REQSNS mdi=" $D1%XW }, \
    0x11f0 { "REQSNSX mdi=" $D1%XW " errno=" $D2%XW }, \
    0x1200 { "REREAD mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x1201 { "REREADX mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x1210 { "RETIRE mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x1211 { "RETIREX mui_devno=" $D1%XW " n=" $D2%XW }, \
    0x1212 { "RETIREWU mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x1220 { "RMVDEV mdi=" $D1%XW }, \
    0x1221 { "RMVDEVX mdi=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x1230 { "RSTONE mdi=" $D1%XW }, \
    0x1231 { "RSTONEX mdi=" $D1%XW " rc=" $D2%DW " n=" $D3%XW }, \
    0x1232 { "RSTONEGO mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1233 { "RSTONEW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1240 { "RSTRCV mdi=" $D1%XW }, \
    0x1241 { "RSTRCVX mdi=" $D1%XW " rc=" $D2%DW " n=" $D3%XW }, \
    0x1242 { "RSTRCVGO mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1250 { "SLEEP mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x1251 { "SLEEPX mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x1260 { "STATCB mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW " pirp=" $D4%XW }, \
    0x1261 { "STATCBX mui_devno=" $D1%XW " cmd_status=" $D2%XW }, \
    0x1262 { "STERROR n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1270 { "STUNIT mui_devno=" $D1%XW " mdi=" $D2%XW " start=" $D3%XW }, \
    0x1280 { "SWDOG mdi=" $D1%XW " pcmd=" $D2%XW " timeout=" $D3%DW }, \
    0x1281 { "SWDOGX mdi=" $D1%XW " n=" $D2%XW }, \
    0x1290 { "TUR mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x12a0 { "USBERR mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW " error=" $D4%DW }, \
    0x12a1 { "USBERRX mui_devno=" $D1%XW " pcmd=" $D2%XW }, \
    0x12a2 { "USBERRW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x12b0 { "WDHNDLR mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x12b1 { "WDHNDLRX mdi=" $D1%XW }, \
    0x12c0 { "BF2CMD devno=" $D1%XW " mdi=" $D2%XW " bp=" $D3%XW }, \
    0x12c1 { "BF2CMDX x=" $D1%XW " y=" $D2%DW }, \
    0x12d0 { "FG2CMD mdi=" $D1%XW " bp=" $D2%XW }, \
    0x12d1 { "FG2CMDX x=" $D1%XW " y=" $D2%DW }, \
    0x12e0 { "STRT mdi=" $D1%XW }, \
    0x12e1 { "STRTX mdi=" $D1%XW " n=" $D2%DW }, \
    0x12e2 { "STRTW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x12f0 { "STRAT bp=" $D1%XW }, \
    0x12f1 { "STRATX" }, \
    0x12f2 { "STRATW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x12f3 { "STRATBP bpt=" $D1%XW " b_dev=" $D2%XW " b_blkno=" $D3%DW " b_bcount=" $D4%DW " b_work=" $D5%DW }, \
    0x12f4 { "STRATMDIMUI mdi=" $D1%XW " mui=" $D2%XW " mdi_maxreq=" $D3%DW " mui_blksize=" $D4%DW " mc_lba=" $D5%DW }, \
    0x1300 { "GETCFG mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x1310 { "RDISCINFO mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x1320 { "CFGUNIT mui_devno=" $D1%XW " mui=" $D2%XW }, \
    0x1321 { "CFGUNITX mui_devno=" $D1%XW " errnoval=" $D2%DW }, \
    0x1330 { "RSH n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1331 { "TDO n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1332 { "AAIO n=" $D1%DW " l=" $D2%DW " x0=" $D3%XW " x1=" $D4%XW }, \
    0x1333 { "AIO n=" $D1%DW " l=" $D2%DW " x0=" $D3%XW " x1=" $D4%XW }, \
    0x1334 { "STOPWDOG mdi=" $D1%XW }, \
    0x1335 { "RMU n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1336 { "CLEARIO n=" $D1%DW " l=" $D2%DW " x0=" $D3%XW " x1=" $D4%XW }, \
    0x1337 { "BLKNO blkno=" $D1%DW " b_work=" $D2%DW " b_blkno=" $D3%DW " mui_mult_blk=" $D4%DW }, \
    0x1338 { "CDMODE n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1339 { "CDRESET n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x133a { "CURMODE n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x133b { "PASSTHRU n=" $D1%DW " l=" $D2%DW " x0=" $D3%XW " x1=" $D4%XW }, \
    0x133c { "PTCMD1 " $D1%XW " " $D2%XW " " $D3%XW " " $D4%XW " " $D5%XW }, \
    0x133d { "PTCMD2 datas=" $D1%DW " datap=" $D2%XW " senses=" $D3%DW " sensep=" $D4%XW " to=" $D5%DW }, \
    0x133e { "IRP p=" $D1%XW " hP=" $D2%XW " pB=" $D3%XW " s=" $D4%DW " s=" $D5%DW }, \
    0x133f { "RIRP pcmd=" $D1%XW }, \
    0x1340 { "DKIOCMDW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1341 { "RAWDATA " $D1%XW " " $D2%XW " " $D3%XW " " $D4%XW " " $D5%XW }, \
    0x1342 { "COAL n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1343 { "RETRY n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1344 { "SYNCCACHE mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x1345 { "DRAINCB n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1346 { "DRAIN n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1347 { "CONNECTW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1348 { "DBW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1349 { "OPENW n=" $D1%DW " l=" $D2%DW " x0=" $D3%XW " x1=" $D4%XW }, \
    0x134a { "CCWE n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x134b { "INQ mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x134c { "INQX mui_devno=" $D1%XW " errno=" $D2%DW }, \
    \* { "unknown" $HD }
650 1.0 L=KERN "USB TAPE" \
    $HD%X2, \
    0x1010 { "BUFCB pirp=" $D1%XW " status=" $D2%DW }, \
    0x1011 { "BUFCBX pirp=" $D1%XW }, \
    0x1020 { "CFGDEV mdi=" $D1%XW }, \
    0x1021 { "CFGDEVX mdi=" $D1%XW " errnoval=" $D2%DW " l=" $D3%DW }, \
    0x1030 { "CLOSCOM mdi=" $D1%XW }, \
    0x1031 { "CLOSCOMX mdi=" $D1%XW }, \
    0x1040 { "CLOSE devno=" $D1%XW }, \
    0x1041 { "CLOSEX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x1050 { "CMDCB pirp=" $D1%XW " status=" $D2%DW }, \
    0x1051 { "CMDCBX pirp=" $D1%XW }, \
    0x1060 { "CONFIG devno=" $D1%XW " op=" $D2%XW " uiop=" $D3%XW }, \
    0x1061 { "CONFIGX devno=" $D1%XW " errnoval=" $D2%DW " l=" $D3%DW }, \
    0x1070 { "CONNECT mdi=" $D1%XW }, \
    0x1071 { "CONNECTX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1080 { "CTLCB mdi=" $D1%XW " pirp=" $D2%XW " devreq=" $D3%XW " status=" $D4%DW }, \
    0x1081 { "CTLCBX mdi=" $D1%XW }, \
    0x1082 { "CTLCBGO mdi=" $D1%XW " pirp=" $D2%XW " devreq=" $D3%XW " status=" $D4%DW }, \
    0x1090 { "DISCONN mdi=" $D1%XW }, \
    0x1091 { "DISCONNX mdi=" $D1%XW }, \
    0x10a0 { "INITDEV mdi=" $D1%XW }, \
    0x10a1 { "INITDEVX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x10a2 { "INITDEVXE yyy" }, \
    0x10b0 { "IOCTL devno=" $D1%XW " op=" $D2%XW " arg=" $D3%XW " devflag=" $D4%XW }, \
    0x10b1 { "IOCTLX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x10b2 { "IOCTLW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x10c0 { "LOGERR mui_devno=" $D1%XW " mdi=" $D2%XW " cmd_error=" $D3%XW " flag=" $D4%XW }, \
    0x10d0 { "MODSNS mui_devno=" $D1%XW " mdi=" $D2%XW " type=" $D3%XW }, \
    0x10e0 { "MODSEL mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x10e1 { "MODSELX mui_devno=" $D1%XW " errno=" $D2%DW }, \
    0x10f0 { "MSRESET mdi=" $D1%XW }, \
    0x10f1 { "MSRESETX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1100 { "OPEN devno=" $D1%XW " rwflag=" $D2%XW }, \
    0x1101 { "OPENX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x1110 { "OPENCOM mdi=" $D1%XW }, \
    0x1111 { "OPENCOMX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1120 { "PROCRST mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x1121 { "PROCRSTX mui_devno=" $D1%XW }, \
    0x1122 { "PROCRSTWU mui_devno=" $D1%XW " mdi=" $D2%XW " n=" $D3%DW }, \
    0x1130 { "PROCSNS mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW " chkcmd=" $D4%XW }, \
    0x1131 { "PROCSNSX mui_devno=" $D1%XW " n=" $D2%XW }, \
    0x1140 { "RAWIO mdi=" $D1%XW " rwflag=" $D2%XW " uiop=" $D3%XW }, \
    0x1141 { "RAWIOX mui_devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x1150 { "XFBLKS mdi=" $D1%XW " buf=" $D2%XW " blkno=" $D3%DW " nblks=" $D4%DW " xmemp=" $D5%XW }, \
    0x1151 { "XFBLKSX mdi=" $D1%XW " rc=" $D2%DW }, \
    0x1152 { "XFBLKSE n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1160 { "RDWR devno=" $D1%XW " rwflag=" $D2%XW " uiop=" $D3%XW }, \
    0x1161 { "RDWRX devno=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x1162 { "RDWRXU devno=" $D1%XW " l=" $D2%DW }, \
    0x1170 { "LOAD mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x1180 { "REQSNS mdi=" $D1%XW }, \
    0x1181 { "REQSNSX mdi=" $D1%XW " errno=" $D2%XW }, \
    0x1190 { "REREAD mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x1191 { "REREADX mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x11a0 { "RETIRE mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x11a1 { "RETIREX mui_devno=" $D1%XW " n=" $D2%XW }, \
    0x11a2 { "RETIREWU mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW }, \
    0x11b0 { "RMVDEV mdi=" $D1%XW }, \
    0x11b1 { "RMVDEVX mdi=" $D1%XW " rc=" $D2%DW " l=" $D3%DW }, \
    0x11c0 { "RSTONE mdi=" $D1%XW }, \
    0x11c1 { "RSTONEX mdi=" $D1%XW " rc=" $D2%DW " n=" $D3%XW }, \
    0x11c2 { "RSTONEGO mdi=" $D1%XW " rc=" $D2%DW }, \
    0x11c3 { "RSTONEW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x11d0 { "RSTRCV mdi=" $D1%XW }, \
    0x11d1 { "RSTRCVX mdi=" $D1%XW " rc=" $D2%DW " n=" $D3%XW }, \
    0x11d2 { "RSTRCVGO mdi=" $D1%XW " rc=" $D2%DW }, \
    0x11e0 { "SLEEP mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x11e1 { "SLEEPX mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x11f0 { "STATCB mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW " pirp=" $D4%XW }, \
    0x11f1 { "STATCBX mui_devno=" $D1%XW " cmd_status=" $D2%XW }, \
    0x11f2 { "STERROR n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1200 { "SWDOG mdi=" $D1%XW " pcmd=" $D2%XW " timeout=" $D3%DW }, \
    0x1201 { "SWDOGX mdi=" $D1%XW " n=" $D2%XW }, \
    0x1210 { "TUR mui_devno=" $D1%XW " mdi=" $D2%XW }, \
    0x1220 { "USBERR mui_devno=" $D1%XW " mdi=" $D2%XW " pcmd=" $D3%XW " error=" $D4%DW }, \
    0x1221 { "USBERRX mui_devno=" $D1%XW " pcmd=" $D2%XW }, \
    0x1222 { "USBERRW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1230 { "WDHNDLR mdi=" $D1%XW " pcmd=" $D2%XW }, \
    0x1231 { "WDHNDLRX mdi=" $D1%XW }, \
    0x1240 { "STRT mdi=" $D1%XW }, \
    0x1241 { "STRTX mdi=" $D1%XW " n=" $D2%DW }, \
    0x1242 { "STRTW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1250 { "CFGUNIT mui_devno=" $D1%XW " mui=" $D2%XW }, \
    0x1251 { "CFGUNITX mui_devno=" $D1%XW " errnoval=" $D2%DW }, \
    0x1260 { "RSH n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1261 { "TDO n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1262 { "AAIO n=" $D1%DW " l=" $D2%DW " x0=" $D3%XW " x1=" $D4%XW }, \
    0x1263 { "AIO n=" $D1%DW " l=" $D2%DW " x0=" $D3%XW " x1=" $D4%XW }, \
    0x1264 { "STOPWDOG mdi=" $D1%XW }, \
    0x1265 { "RMU n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1266 { "CLEARIO n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1267 { "PASSTHRU n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1268 { "IRP p=" $D1%XW " hP=" $D2%XW " pB=" $D3%XW " s=" $D4%DW " s=" $D5%DW }, \
    0x1269 { "RIRP pcmd=" $D1%XW }, \
    0x126a { "STIOCMDW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x126b { "RETRY n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x126c { "DRAINCB n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x126d { "DRAIN n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x126e { "CONNECTW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x126f { "DBW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1270 { "OPENW n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    0x1271 { "CCWE n=" $D1%DW " l=" $D2%DW " x=" $D3%XW }, \
    \* { "unknown" $HD }
651 1.0 "USBTAPE_ERR" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3 }} \
        {{ $cnt = B0.5 }} \
        $loc, \
        0x70 { "usbtape_config:\t\t\t"} , \
        0x71 { "usbtape_open:\t\t\t"} , \
        0x72 { "usbtape_close:\t\t\t"} , \
        0x73 { "usbtape_read:\t\t\t\t"}, \
        0x74 { "usbtape_write:\t\t\t\t"}, \
        0x75 { "usbtape_ioctl:\t\t\t"}, \
        0x76 { "usbtape_open_dev:\t\t"}, \
        0x77 { "usbtape_mstor_reset:\t\t"}, \
        0x78 { "usbtape_open_unit:\t\t"}, \
        0x79 { "abort_active:\t\t\t"}, \
        0x7a { "clear_io:\t\t\t\t"}, \
        0x7b { "usbtape_space:\t\t\t"}, \
        0x7c { "usbtape_write_filemarks:\t"}, \
        0x7d { "usbtape_xmempin:\t\t"}, \
        0x7e { "usbtape_bldcmd:\t\t"}, \
        0x7f { "usbtape_xfer_io:\t\t"}, \
        0x80 { "usbtape_stioctop:\t\t"}, \
        0x81 { "usbtape_stiochgp:\t\t"}, \
        0x82 { "send_sc_passthru:\t\t"}, \
        0x83 { "usbtape_stiocmd:\t\t"}, \
        0x84 { "usbtape_passthru:\t\t"}, \
        0x85 { "get_eps:\t\t\t\t"}, \
        0x86 { "get_descriptors:\t\t"}, \
        0x87 { "bld_inq_cmd:\t\t\t"}, \
        0x88 { "usbtape_connect_luns:\t"}, \
        0x89 { "usbtape_connect:\t\t"}, \
        0x8a { "usbtape_disconnect:\t\t"}, \
        0x8b { "usbtape_ras_register:\t"}, \
        0x8c { "usbtape_sleep:\t\t\t"}, \
        0x8d { "usbtape_request_sense:\t"}, \
        0x8e { "usbtape_readwrite:\t\t"}, \
        0x8f { "usbtape_general:\t\t"}, \
        0x90 { "usbtape_load:\t\t\t"}, \
        0x91 { "usbtape_erase:\t\t\t"}, \
        0x92 { "usbtape_log_error:\t\t"}, \
        0x93 { "usbtape_start_watchdog:\t"}, \
        0x94 { "usbtape_stop_watchdog:\t"}, \
        0x95 { "usbtape_watchdog_hndlr:\t"}, \
        0x96 { "usbtape_release_irps:\t\t"}, \
        0x97 { "retire_cmd:\t\t\t"}, \
        0x98 { "usbtape_abort_all_io:\t\t"}, \
        0x99 { "usbtape_abort_io:\t\t"}, \
        0x9a { "take_dev_offline:\t\t"}, \
        0x9b { "complete_commands_with_error:\t"}, \
        0x9c { "usbtape_cmd_callback:\t\t"}, \
        0x9d { "usbtape_buf_callback:\t\t"}, \
        0x9e { "reset_irps:\t\t\t"}, \
        0x9f { "usbtape_process_ioctl:\t\t"}, \
        0xa0 { "usbtape_process_usb_error:\t"}, \
        0xa1 { "usbtape_process_dev_error:\t"}, \
        0xa2 { "usbtape_process_reset:\t\t"}, \
        0xa3 { "usbtape_process_reqsns:\t\t"}, \
        0xa4 { "usbtape_process_reqsns_error:\t"}, \
        0xa5 { "usbtape_status_callback:\t"}, \
        0xa6 { "usbtape_ctl_callback:\t\t"}, \
        0xa7 { "usbtape_drain_callback:\t\t"}, \
        0xa8 { "usbtape_mstor_reset_recovery:\t"}, \
        0xa9 { "usbtape_mstor_bulk_in_drain:\t"}, \
        0xaa { "usbtape_mstor_reset_one:\t\t"}, \
        0xab { "usbtape_test_unit_ready:\t"}, \
        0xac { "usbtape_reread_status:\t\t"}, \
        0xad { "usbtape_startio:\t\t"}, \
        0xae { "usbtape_restart_handler:\t"}, \
        0xaf { "usbtape_mode_sense:\t\t"}, \
        0xb0 { "usbtape_mode_select:\t\t"}, \
        0xb1 { "usbtape_findpage:\t\t\t"}, \
        0xb2 { "usbtape_reset:\t\t\t\t"}, \
        0xb3 { "usbtape_cdt_func:\t\t\t"}, \
        0xb4 { "usbtape_unitinfo_ras_callback:\t"}, \
        0xb5 { "usbtape_ras_unregister:\t\t"}, \
        0xb6 { "usbtape_ras_error:\t\t"}, \
        \* { "Unidentified Trace from location :" $loc \
        " with data:\t\t\t\t\t"} \
    $typ, \
        0x0 { "Entry" $cnt%X1 XW XW XW XW XW }, \
        0x1 { "Trace" $cnt%X1 XW XW XW XW XW }, \
        0X2 { "Exit " $cnt%X1 XW XW XW XW XW }
735 1.0 "USBMSE:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "putring" }, \
        02  { "rring  " }, \
        03  { "rflush " }, \
        04  { "logerr " }, \
        05  { "kmopen " }, \
        06  { "kmclose" }, \
        07  { "kminit " }, \
        08  { "kmclr  " }, \
        09  { "kmrest " }, \
        0A  { "kmsend " }, \
        0B  { "kmget  " }, \
        20  { "mscfg  " }, \
        21  { "msopen " }, \
        22  { "msclse " }, \
        23  { "msioctl" }, \
        24  { "mscallb" }, \
        25  { "msolvl " }, \
        26  { "msputr " }, \
        27  { "mstimer" }, \
        28  { "msstall" }, \
        29  { "mssetup" }, \
        2A  { "msdisct" }, \
        2B  { "msrect " }, \
        2C  { "mshid  " }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
734 1.0 "USBKBD:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "putring" }, \
        02  { "rring  " }, \
        03  { "rflush " }, \
        04  { "logerr " }, \
        05  { "kmopen " }, \
        06  { "kmclose" }, \
        07  { "kminit " }, \
        08  { "kmclr  " }, \
        09  { "kmrest " }, \
        0A  { "kmsend " }, \
        0B  { "kmget  " }, \
        20  { "kconfig" }, \
        21  { "kmpx   " }, \
        22  { "kopen  " }, \
        23  { "kclose " }, \
        24  { "kioctl " }, \
        25  { "kcallb " }, \
        26  { "keyproc" }, \
        27  { "ksstat " }, \
        28  { "ksak   " }, \
        29  { "kunsak " }, \
        2A  { "kputkey" }, \
        2B  { "kpollap" }, \
        2C  { "kkill  " }, \
        2D  { "kpevent" }, \
        2E  { "kslocal" }, \
        2F  { "kdvleds" }, \
        30  { "kttime " }, \
        31  { "kledone" }, \
        32  { "kOfflvl" }, \
        33  { "kstall " }, \
        34  { "ksetup " }, \
        35  { "kdisct " }, \
        36  { "krect  " }, \
        37  { "kputsq " }, \
        38  { "knxtsnd" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
739 1.0 "USB3DX:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "logerr " }, \
        02  { "usbcfg " }, \
        03  { "usbucfg" }, \
        04  { "usbinit" }, \
        05  { "sbcfg  " }, \
        06  { "sbopn  " }, \
        07  { "sbclose" }, \
        08  { "sbioctl" }, \
        09  { "usbdct " }, \
        0A  { "usbrct " }, \
        0B  { "valpipe" }, \
        0C  { "usbmsg " }, \
        0D  { "usbclrh" }, \
        0E  { "usbfini" }, \
        0F  { "usbcpip" }, \
        10  { "sbHid  " }, \
        11  { "sbread " }, \
        12  { "sbsel  " }, \
        13  { "sbsndrq" }, \
        14  { "usbwait" }, \
        15  { "wdto   " }, \
        16  { "sbcallb" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
61E 1.0 L=KERN "USBA " \
    $HD%D2, \
    442 {"cancel_playback_watchdog_1"}, \
    443 {"cancel_playback_watchdog_2"}, \
    446 {"cancel_record_watchdog_1"}, \
    447 {"cancel_record_watchdog_2"}, \
    323 {"cancel_sleep_timer_0"}, \
    256 {"chan12_AUDIO_BUFFER_0"}, \
    257 {"chan12_AUDIO_BUFFER_1"}, \
    258 {"chan12_AUDIO_BUFFER_2"}, \
    259 {"chan12_AUDIO_BUFFER_3" $D1%XW}, \
    260 {"chan12_AUDIO_BUFFER_4" $D1%XW}, \
    261 {"chan12_AUDIO_BUFFER_5"}, \
    280 {"chan12_AUDIO_CONTROL_0"}, \
    282 {"chan12_AUDIO_CONTROL_1"}, \
    286 {"chan12_AUDIO_CONTROL_2" $D1%XW}, \
    287 {"chan12_AUDIO_CONTROL_3"}, \
    298 {"chan12_AUDIO_CONTROL_4" $D1%XW}, \
    299 {"chan12_AUDIO_CONTROL_5" $D1%XW}, \
    300 {"chan12_AUDIO_CONTROL_6"}, \
    301 {"chan12_AUDIO_CONTROL_7"}, \
    302 {"chan12_AUDIO_CONTROL_8"}, \
    303 {"chan12_AUDIO_CONTROL_9" $D1%XW}, \
    304 {"chan12_AUDIO_CONTROL_10"}, \
    305 {"chan12_AUDIO_CONTROL_11"}, \
    325 {"chan12_AUDIO_CONTROL_12"}, \
    326 {"chan12_AUDIO_CONTROL_13" $D1%XW}, \
    327 {"chan12_AUDIO_CONTROL_14"}, \
    328 {"chan12_AUDIO_CONTROL_15"}, \
    329 {"chan12_AUDIO_CONTROL_16"}, \
    330 {"chan12_AUDIO_CONTROL_17" $D1%XW}, \
    331 {"chan12_AUDIO_CONTROL_18" $D1%XW}, \
    354 {"chan12_AUDIO_CONTROL_19"}, \
    573 {"chan12_AUDIO_CONTROL_20"}, \
    574 {"chan12_AUDIO_CONTROL_21"}, \
    262 {"chan12_AUDIO_CONTROL_sub_CHANGE_0"}, \
    263 {"chan12_AUDIO_CONTROL_sub_CHANGE_1"}, \
    264 {"chan12_AUDIO_CONTROL_sub_CHANGE_2"}, \
    265 {"chan12_AUDIO_CONTROL_sub_CHANGE_3"}, \
    266 {"chan12_AUDIO_CONTROL_sub_CHANGE_4"}, \
    267 {"chan12_AUDIO_CONTROL_sub_CHANGE_5"}, \
    268 {"chan12_AUDIO_CONTROL_sub_CHANGE_6"}, \
    269 {"chan12_AUDIO_CONTROL_sub_CHANGE_7"}, \
    270 {"chan12_AUDIO_CONTROL_sub_CHANGE_8"}, \
    271 {"chan12_AUDIO_CONTROL_sub_CHANGE_9"}, \
    272 {"chan12_AUDIO_CONTROL_sub_CHANGE_10"}, \
    273 {"chan12_AUDIO_CONTROL_sub_CHANGE_11"}, \
    274 {"chan12_AUDIO_CONTROL_sub_CHANGE_12" $D1%XW}, \
    276 {"chan12_AUDIO_CONTROL_sub_CHANGE_14"}, \
    277 {"chan12_AUDIO_CONTROL_sub_CHANGE_15" $D1%XW}, \
    278 {"chan12_AUDIO_CONTROL_sub_CHANGE_16" $D1%XW}, \
    279 {"chan12_AUDIO_CONTROL_sub_CHANGE_17" $D1%XW}, \
    281 {"chan12_AUDIO_CONTROL_sub_CHANGE_19" $D1%XW}, \
    283 {"chan12_AUDIO_CONTROL_sub_CHANGE_21" $D1%XW}, \
    284 {"chan12_AUDIO_CONTROL_sub_CHANGE_22"}, \
    285 {"chan12_AUDIO_CONTROL_sub_CHANGE_23" $D1%XW}, \
    288 {"chan12_AUDIO_CONTROL_sub_CHANGE_26" $D1%XW}, \
    289 {"chan12_AUDIO_CONTROL_sub_CHANGE_27" $D1%XW}, \
    290 {"chan12_AUDIO_CONTROL_sub_CHANGE_28" $D1%XW}, \
    291 {"chan12_AUDIO_CONTROL_sub_CHANGE_29" $D1%XW}, \
    292 {"chan12_AUDIO_CONTROL_sub_CHANGE_30" $D1%XW}, \
    293 {"chan12_AUDIO_CONTROL_sub_CHANGE_31" $D1%XW}, \
    294 {"chan12_AUDIO_CONTROL_sub_CHANGE_32" $D1%XW}, \
    295 {"chan12_AUDIO_CONTROL_sub_CHANGE_33" $D1%XW}, \
    296 {"chan12_AUDIO_CONTROL_sub_CHANGE_34" $D1%XW}, \
    297 {"chan12_AUDIO_CONTROL_sub_CHANGE_35" $D1%XW}, \
    463 {"chan12_AUDIO_INIT_0"}, \
    464 {"chan12_AUDIO_INIT_1"}, \
    465 {"chan12_AUDIO_INIT_2"}, \
    466 {"chan12_AUDIO_INIT_3"}, \
    467 {"chan12_AUDIO_INIT_4" $D1%XW}, \
    468 {"chan12_AUDIO_INIT_5" $D1%XW}, \
    469 {"chan12_AUDIO_INIT_6" $D1%XW}, \
    313 {"chan12_AUDIO_INIT_buffer_0"}, \
    314 {"chan12_AUDIO_INIT_buffer_1"}, \
    315 {"chan12_AUDIO_INIT_buffer_2"}, \
    316 {"chan12_AUDIO_INIT_buffer_3" $D1%XW}, \
    470 {"chan12_AUDIO_INIT_local_0"}, \
    471 {"chan12_AUDIO_INIT_local_1"}, \
    472 {"chan12_AUDIO_INIT_local_2"}, \
    473 {"chan12_AUDIO_INIT_local_3"}, \
    474 {"chan12_AUDIO_INIT_local_4"}, \
    475 {"chan12_AUDIO_INIT_local_5"}, \
    476 {"chan12_AUDIO_INIT_local_6"}, \
    477 {"chan12_AUDIO_INIT_local_7"}, \
    478 {"chan12_AUDIO_INIT_local_8"}, \
    480 {"chan12_AUDIO_INIT_local_10"}, \
    1015 {"chan12_AUDIO_INIT_local_11" $D1%XW}, \
    484 {"chan12_AUDIO_INIT_local_14"}, \
    485 {"chan12_AUDIO_INIT_local_15"}, \
    486 {"chan12_AUDIO_INIT_local_16"}, \
    487 {"chan12_AUDIO_INIT_local_17"}, \
    488 {"chan12_AUDIO_INIT_local_18"}, \
    489 {"chan12_AUDIO_INIT_local_19"}, \
    490 {"chan12_AUDIO_INIT_local_20"}, \
    491 {"chan12_AUDIO_INIT_local_21"}, \
    492 {"chan12_AUDIO_INIT_local_22"}, \
    493 {"chan12_AUDIO_INIT_local_23"}, \
    494 {"chan12_AUDIO_INIT_local_24"}, \
    495 {"chan12_AUDIO_INIT_local_25"}, \
    496 {"chan12_AUDIO_INIT_local_26"}, \
    498 {"chan12_AUDIO_INIT_local_28"}, \
    502 {"chan12_AUDIO_INIT_local_32"}, \
    503 {"chan12_AUDIO_INIT_local_33"}, \
    504 {"chan12_AUDIO_INIT_local_34"}, \
    505 {"chan12_AUDIO_INIT_local_35"}, \
    506 {"chan12_AUDIO_INIT_local_36"}, \
    507 {"chan12_AUDIO_INIT_local_37" $D1%XW}, \
    508 {"chan12_AUDIO_INIT_local_38" $D1%XW}, \
    509 {"chan12_AUDIO_INIT_local_39" $D1%XW}, \
    715 {"chan12_AUDIO_INIT_local_40"}, \
    881 {"chan12_AUDIO_INIT_local_41"}, \
    928 {"chan12_AUDIO_INIT_local_45"}, \
    929 {"chan12_AUDIO_INIT_local_46"}, \
    930 {"chan12_AUDIO_INIT_local_47"}, \
    882 {"chan12_AUDIO_INIT_registers_0"}, \
    883 {"chan12_AUDIO_INIT_registers_1"}, \
    884 {"chan12_AUDIO_INIT_registers_2" $D1%XW}, \
    410 {"chan12_AUDIO_MODIFY_LIMITS_0"}, \
    411 {"chan12_AUDIO_MODIFY_LIMITS_1" $D1%XW}, \
    412 {"chan12_AUDIO_MODIFY_LIMITS_2" $D1%XW}, \
    413 {"chan12_AUDIO_MODIFY_LIMITS_3" $D1%XW}, \
    414 {"chan12_AUDIO_MODIFY_LIMITS_4" $D1%XW}, \
    317 {"chan12_AUDIO_SET_GAIN_0"}, \
    318 {"chan12_AUDIO_SET_GAIN_1"}, \
    319 {"chan12_AUDIO_SET_GAIN_2"}, \
    320 {"chan12_AUDIO_SET_GAIN_3"}, \
    321 {"chan12_AUDIO_SET_GAIN_4" $D1%XW}, \
    693 {"chan12_AUDIO_SET_GAIN_6" $D1%XW}, \
    91 {"chan12_AUDIO_STATUS_0"}, \
    232 {"chan12_AUDIO_STATUS_1"}, \
    233 {"chan12_AUDIO_STATUS_2"}, \
    234 {"chan12_AUDIO_STATUS_3" $D1%XW}, \
    235 {"chan12_AUDIO_STATUS_4" $D1%XW}, \
    236 {"chan12_AUDIO_STATUS_5" $D1%XW}, \
    237 {"chan12_AUDIO_STATUS_6" $D1%XW}, \
    838 {"chan12_AUDIO_WAIT_0"}, \
    839 {"chan12_AUDIO_WAIT_1" $D1%XW}, \
    877 {"chan12_enter_RUNNING_state_0"}, \
    878 {"chan12_enter_RUNNING_state_1" $D1%XW}, \
    879 {"chan12_enter_RUNNING_state_2" $D1%XW}, \
    880 {"chan12_enter_RUNNING_state_3"}, \
    896 {"chan12_enter_RUNNING_state_4"}, \
    858 {"chan12_enter_STOPPED_state_0"}, \
    885 {"chan12_enter_STOPPED_state_1"}, \
    840 {"chan12_leave_RUNNING_state_0"}, \
    841 {"chan12_leave_RUNNING_state_1" $D1%XW}, \
    842 {"chan12_leave_RUNNING_state_2" $D1%XW}, \
    863 {"chan12_leave_STOPPED_state_0"}, \
    886 {"chan12_leave_STOPPED_state_1"}, \
    887 {"chan12_leave_STOPPED_state_2"}, \
    888 {"chan12_leave_STOPPED_state_3"}, \
    889 {"chan12_leave_STOPPED_state_4" $D1%XW}, \
    171 {"chan12_leave_STOPPED_state_5"}, \
    194 {"chan12_leave_STOPPED_state_6" $D1%XW}, \
    196 {"chan12_leave_STOPPED_state_7" $D1%XW}, \
    197 {"chan12_leave_STOPPED_state_8" $D1%XW}, \
    198 {"chan12_leave_STOPPED_state_9" $D1%XW}, \
    306 {"chan12_set_input_0"}, \
    307 {"chan12_set_input_1"}, \
    308 {"chan12_set_input_2"}, \
    309 {"chan12_set_input_3" $D1%XW}, \
    438 {"chan12_set_input_4"}, \
    439 {"chan12_set_input_5"}, \
    609 {"chan12_set_input_6"}, \
    610 {"chan12_set_input_7" $D1%XW}, \
    611 {"chan12_set_input_8"}, \
    612 {"chan12_set_input_9"}, \
    613 {"chan12_set_input_10" $D1%XW}, \
    614 {"chan12_set_input_11"}, \
    615 {"chan12_set_input_12"}, \
    616 {"chan12_set_input_13" $D1%XW}, \
    617 {"chan12_set_input_14"}, \
    618 {"chan12_set_input_15"}, \
    619 {"chan12_set_input_16" $D1%XW}, \
    620 {"chan12_set_input_17"}, \
    621 {"chan12_set_input_18"}, \
    622 {"chan12_set_input_19" $D1%XW}, \
    623 {"chan12_set_input_20"}, \
    624 {"chan12_set_input_21"}, \
    625 {"chan12_set_input_22" $D1%XW}, \
    626 {"chan12_set_input_23"}, \
    627 {"chan12_set_input_24"}, \
    628 {"chan12_set_input_25" $D1%XW}, \
    629 {"chan12_set_input_26"}, \
    630 {"chan12_set_input_27"}, \
    631 {"chan12_set_input_28" $D1%XW}, \
    632 {"chan12_set_input_29"}, \
    633 {"chan12_set_input_30"}, \
    634 {"chan12_set_input_31" $D1%XW}, \
    635 {"chan12_set_input_32"}, \
    636 {"chan12_set_input_33"}, \
    637 {"chan12_set_input_34" $D1%XW}, \
    638 {"chan12_set_input_35"}, \
    639 {"chan12_set_input_36"}, \
    640 {"chan12_set_input_37" $D1%XW}, \
    641 {"chan12_set_input_38"}, \
    682 {"chan12_set_input_39" $D1%XW}, \
    683 {"chan12_set_input_40" $D1%XW}, \
    684 {"chan12_set_input_41" $D1%XW}, \
    685 {"chan12_set_input_42" $D1%XW}, \
    686 {"chan12_set_input_43" $D1%XW}, \
    687 {"chan12_set_input_44" $D1%XW}, \
    688 {"chan12_set_input_45" $D1%XW}, \
    689 {"chan12_set_input_46" $D1%XW}, \
    690 {"chan12_set_input_47" $D1%XW}, \
    691 {"chan12_set_input_48" $D1%XW}, \
    692 {"chan12_set_input_49" $D1%XW}, \
    324 {"configure_entire_driver_0" $D1%XW}, \
    963 {"configure_entire_driver_1" $D1%XW}, \
    543 {"configure_individual_device_0" $D1%XW}, \
    5 {"configure_kdb_0"}, \
    6 {"configure_kdb_1"}, \
    7 {"configure_kdb_2"}, \
    8 {"configure_kdb_3"}, \
    449 {"configure_watchdog_0"}, \
    450 {"configure_watchdog_1"}, \
    451 {"configure_watchdog_2"}, \
    934 {"copyin_audio_channels_list_32_64_0" $D1%XW}, \
    935 {"copyin_audio_channels_list_32_64_1" $D1%XW}, \
    936 {"copyin_audio_channels_list_32_64_2" $D1%XW}, \
    937 {"copyin_audio_channels_list_32_64_3" $D1%XW}, \
    575 {"copyin_audio_control_32_64_0" $D1%XW}, \
    576 {"copyin_audio_control_32_64_1" $D1%XW}, \
    577 {"copyin_audio_control_32_64_2" $D1%XW}, \
    578 {"copyin_audio_control_32_64_3" $D1%XW}, \
    579 {"copyin_audio_control_32_64_4"}, \
    580 {"copyin_audio_control_32_64_5" $D1%XW}, \
    581 {"copyin_audio_control_32_64_6" $D1%XW}, \
    582 {"copyin_audio_control_32_64_7" $D1%XW}, \
    583 {"copyin_audio_control_32_64_8" $D1%XW}, \
    238 {"copyin_audio_status_32_64_0"}, \
    239 {"copyin_audio_status_32_64_1" $D1%XW}, \
    240 {"copyin_audio_status_32_64_2" $D1%XW}, \
    241 {"copyin_audio_status_32_64_3" $D1%XW}, \
    242 {"copyin_audio_status_32_64_4" $D1%XW}, \
    243 {"copyout_audio_status_32_64_0"}, \
    244 {"copyout_audio_status_32_64_1" $D1%XW}, \
    245 {"copyout_audio_status_32_64_2" $D1%XW}, \
    246 {"copyout_audio_status_32_64_3" $D1%XW}, \
    247 {"copyout_audio_status_32_64_4" $D1%XW}, \
    119 {"ddbg_graph_build_0"}, \
    120 {"ddbg_graph_build_1"}, \
    121 {"ddbg_graph_build_2"}, \
    122 {"ddbg_graph_update_logical_input_channels_0"}, \
    123 {"ddbg_graph_update_logical_input_channels_1" $D1%XW $D2%XW}, \
    275 {"ddbg_graph_update_logical_input_channels_2" $D1%XW $D2%XW}, \
    124 {"ddbg_graph_update_logical_output_channels_0"}, \
    125 {"ddbg_graph_update_logical_output_channels_1"}, \
    126 {"ddfc_first_cut_paths_0"}, \
    127 {"ddfc_first_cut_paths_body_0"}, \
    128 {"ddfc_make_path_from_history_0"}, \
    129 {"ddfc_make_path_from_history_1"}, \
    130 {"ddfc_make_path_from_history_body_0"}, \
    131 {"ddfc_sweep_0"}, \
    132 {"ddfc_sweep_1"}, \
    133 {"ddg_graph_interface_group_t_0"}, \
    134 {"ddg_graph_interface_group_t_1"}, \
    135 {"ddg_graph_interface_group_t_2"}, \
    136 {"ddg_graph_interface_group_t_3"}, \
    137 {"ddg_graph_interface_group_t_4"}, \
    138 {"ddg_graph_interface_group_t_5"}, \
    139 {"ddg_graph_interface_group_t_6"}, \
    140 {"ddg_graph_process_0"}, \
    141 {"ddg_graph_process_1"}, \
    142 {"ddg_graph_process_2"}, \
    143 {"ddg_graph_process_3"}, \
    144 {"ddg_graph_process_4"}, \
    145 {"ddg_graph_process_5"}, \
    146 {"ddg_graph_process_6"}, \
    147 {"ddg_graph_process_7"}, \
    148 {"ddg_graph_process_8"}, \
    149 {"ddg_graph_process_9"}, \
    150 {"ddg_graph_process_10"}, \
    151 {"ddg_graph_process_11"}, \
    152 {"ddg_graph_process_12"}, \
    153 {"ddg_graph_process_13"}, \
    434 {"ddg_graph_process_14"}, \
    435 {"ddg_graph_process_15"}, \
    21 {"ddigest_build_group_0"}, \
    92 {"ddigest_build_group_1"}, \
    93 {"ddigest_build_group_2"}, \
    28 {"ddigest_gather_interface_info_0" $D1%XW}, \
    29 {"ddigest_gather_interface_info_1"}, \
    94 {"ddigest_rebuild_group_0"}, \
    95 {"ddigest_rebuild_group_1"}, \
    96 {"ddigest_rebuild_group_2"}, \
    154 {"ddm_duplicate_path_0"}, \
    155 {"ddm_duplicate_path_1"}, \
    156 {"ddm_duplicate_path_2"}, \
    157 {"ddm_duplicate_path_3"}, \
    158 {"ddm_find_and_remove_playback_path_0"}, \
    159 {"ddm_find_and_remove_record_path_0"}, \
    160 {"ddm_match_playback_paths_0"}, \
    161 {"ddm_match_playback_paths_1"}, \
    162 {"ddm_match_record_paths_0"}, \
    163 {"ddm_match_record_paths_1"}, \
    164 {"ddp_graph_prune_0"}, \
    1149 {"ddpd_parse_audio_streaming_0"}, \
    1150 {"ddpd_parse_audio_streaming_1"}, \
    1151 {"ddpd_parse_audio_streaming_endpoint_0"}, \
    1152 {"ddpd_parse_body_0"}, \
    1153 {"ddpd_parse_body_1"}, \
    165 {"ddvg_graph_validate_0" $D1%XW $D2%XW}, \
    97 {"ddvg_validate_audio_control_0"}, \
    98 {"ddvg_validate_audio_control_1"}, \
    99 {"ddvg_validate_audio_control_2"}, \
    100 {"ddvg_validate_audio_control_3"}, \
    101 {"ddvg_validate_audio_control_4"}, \
    102 {"ddvg_validate_audio_control_5"}, \
    103 {"ddvg_validate_audio_streaming_0"}, \
    104 {"ddvg_validate_audio_streaming_1"}, \
    105 {"ddvg_validate_audio_streaming_2"}, \
    106 {"ddvg_validate_audio_streaming_3"}, \
    107 {"ddvg_validate_audio_streaming_4"}, \
    108 {"ddvg_validate_audio_streaming_list_0"}, \
    109 {"ddvg_validate_audio_streaming_list_1" $D1%XW $D2%XW}, \
    110 {"ddvg_validate_audio_streaming_list_list_0"}, \
    111 {"ddvg_validate_audio_streaming_list_list_1"}, \
    112 {"ddvg_validate_interface_group_t_0"}, \
    113 {"ddvg_validate_interface_group_t_1"}, \
    114 {"ddvg_validate_interface_group_t_2"}, \
    115 {"ddvg_validate_interface_group_t_3"}, \
    116 {"ddvg_validate_interface_group_t_4"}, \
    117 {"ddvg_validate_interface_group_t_5"}, \
    118 {"ddvg_validate_interface_group_t_6"}, \
    38 {"ddvi_interface_info_list_t_0"}, \
    861 {"ddvi_interface_info_list_t_1"}, \
    862 {"ddvi_interface_info_list_t_2"}, \
    68 {"ddvi_interface_info_list_t_3"}, \
    39 {"ddvi_interface_info_t_0"}, \
    40 {"ddvi_interface_info_t_1"}, \
    41 {"ddvi_interface_info_t_2"}, \
    42 {"ddvi_interface_info_t_3"}, \
    43 {"ddvi_interface_info_t_4"}, \
    44 {"ddvi_interface_info_t_5"}, \
    45 {"ddvi_interface_info_t_6"}, \
    46 {"ddvi_interface_info_t_7"}, \
    47 {"ddvi_interface_info_t_8"}, \
    48 {"ddvi_interface_info_t_9"}, \
    49 {"ddvi_interface_info_t_10"}, \
    50 {"ddvi_interface_info_t_11"}, \
    51 {"ddvi_interface_info_t_12"}, \
    52 {"ddvi_interface_info_t_13"}, \
    53 {"ddvi_interface_info_t_14"}, \
    54 {"ddvi_interface_info_t_15"}, \
    55 {"ddvi_interface_info_t_16"}, \
    56 {"ddvi_interface_info_t_17"}, \
    57 {"ddvi_interface_info_t_18"}, \
    58 {"ddvi_interface_info_t_19"}, \
    59 {"ddvi_interface_info_t_list_0"}, \
    60 {"ddvi_interface_info_t_list_1"}, \
    61 {"ddvi_interface_info_t_list_2"}, \
    62 {"ddvi_interface_info_t_list_3"}, \
    63 {"ddvi_interface_info_t_list_4"}, \
    64 {"ddvi_interface_info_t_list_5"}, \
    65 {"ddvi_interface_info_t_list_6"}, \
    66 {"ddvi_interface_info_t_list_7"}, \
    67 {"ddvi_interface_info_t_list_8"}, \
    70 {"ddvi_usba_endpoint_t_0"}, \
    71 {"ddvi_usba_endpoint_t_list_0"}, \
    72 {"ddvi_usba_endpoint_t_list_1"}, \
    73 {"ddvi_usba_endpoint_t_list_2"}, \
    74 {"ddvi_usba_unit_t_0"}, \
    75 {"ddvi_usba_unit_t_1"}, \
    76 {"ddvi_usba_unit_t_2"}, \
    77 {"ddvi_usba_unit_t_3"}, \
    78 {"ddvi_usba_unit_t_4"}, \
    79 {"ddvi_usba_unit_t_5"}, \
    80 {"ddvi_usba_unit_t_list_0"}, \
    81 {"ddvi_usba_unit_t_list_1"}, \
    82 {"ddvi_usba_unit_t_list_2"}, \
    83 {"ddvi_usba_unit_t_list_3"}, \
    84 {"ddvi_wChannelConfig_0"}, \
    85 {"ddvi_wChannelConfig_1"}, \
    86 {"ddvi_wChannelConfig_2"}, \
    0 {"el_x_0" $D1%XW $D2%XW $D3%XW}, \
    1 {"el_x_1" $D1%XW $D2%XW $D3%XW}, \
    2 {"el_x_2" $D1%XW $D2%XW $D3%XW}, \
    30 {"free_interface_group_t_0"}, \
    31 {"free_interface_info_list_t_0"}, \
    32 {"free_interface_info_t_0"}, \
    338 {"iomix_AUDIO_CHANNEL_STATUS_0"}, \
    339 {"iomix_AUDIO_CHANNEL_STATUS_1"}, \
    340 {"iomix_AUDIO_CHANNEL_STATUS_2"}, \
    404 {"iomix_AUDIO_CHANNEL_STATUS_3"}, \
    405 {"iomix_AUDIO_CHANNEL_STATUS_4" $D1%XW}, \
    406 {"iomix_AUDIO_CHANNEL_STATUS_5"}, \
    407 {"iomix_AUDIO_CHANNEL_STATUS_6"}, \
    408 {"iomix_AUDIO_CHANNEL_STATUS_7"}, \
    409 {"iomix_AUDIO_CHANNEL_STATUS_8" $D1%XW}, \
    343 {"iomix_AUDIO_GET_CHANNELS_0"}, \
    344 {"iomix_AUDIO_GET_CHANNELS_1" $D1%XW}, \
    348 {"iomix_AUDIO_GET_CHANNELS_2" $D1%XW}, \
    349 {"iomix_AUDIO_GET_CHANNELS_local_0"}, \
    353 {"iomix_AUDIO_GET_CHANNELS_local_1"}, \
    363 {"iomix_AUDIO_GET_CHANNELS_local_3"}, \
    364 {"iomix_AUDIO_GET_CHANNELS_local_4"}, \
    938 {"iomix_AUDIO_SET_CHANNELS_0"}, \
    939 {"iomix_AUDIO_SET_CHANNELS_1"}, \
    940 {"iomix_AUDIO_SET_CHANNELS_2" $D1%XW}, \
    941 {"iomix_AUDIO_SET_CHANNELS_3" $D1%XW}, \
    942 {"iomix_AUDIO_SET_CHANNELS_4"}, \
    943 {"iomix_AUDIO_SET_CHANNELS_5"}, \
    944 {"iomix_AUDIO_SET_CHANNELS_6" $D1%XW}, \
    945 {"iomix_AUDIO_SET_CHANNELS_7" $D1%XW}, \
    946 {"iomix_AUDIO_SET_CHANNELS_8"}, \
    387 {"iomix_AUDIO_SET_CHANNELS_local_0"}, \
    388 {"iomix_AUDIO_SET_CHANNELS_local_1"}, \
    389 {"iomix_AUDIO_SET_CHANNELS_local_2"}, \
    390 {"iomix_AUDIO_SET_CHANNELS_local_3" $D1%XW}, \
    391 {"iomix_AUDIO_SET_CHANNELS_local_4" $D1%XW}, \
    392 {"iomix_AUDIO_SET_CHANNELS_local_5" $D1%XW}, \
    393 {"iomix_AUDIO_SET_CHANNELS_local_6" $D1%XW}, \
    394 {"iomix_AUDIO_SET_CHANNELS_local_7" $D1%XW}, \
    395 {"iomix_AUDIO_SET_CHANNELS_local_8" $D1%XW}, \
    396 {"iomix_AUDIO_SET_CHANNELS_local_9" $D1%XW}, \
    397 {"iomix_AUDIO_SET_CHANNELS_local_10" $D1%XW}, \
    398 {"iomix_AUDIO_SET_CHANNELS_local_11" $D1%XW}, \
    399 {"iomix_AUDIO_SET_CHANNELS_local_12" $D1%XW}, \
    400 {"iomix_AUDIO_SET_CHANNELS_local_13" $D1%XW}, \
    694 {"iomix_AUDIO_SET_CHANNELS_local_14" $D1%XW}, \
    695 {"iomix_AUDIO_SET_CHANNELS_local_15" $D1%XW}, \
    696 {"iomix_AUDIO_SET_CHANNELS_local_16" $D1%XW}, \
    697 {"iomix_AUDIO_SET_CHANNELS_local_17" $D1%XW}, \
    947 {"iomix_AUDIO_SET_CHANNELS_local_18" $D1%XW}, \
    948 {"iomix_AUDIO_SET_CHANNELS_local_19" $D1%XW}, \
    949 {"iomix_AUDIO_SET_CHANNELS_local_20" $D1%XW}, \
    950 {"iomix_AUDIO_SET_CHANNELS_local_21" $D1%XW}, \
    951 {"iomix_AUDIO_SET_CHANNELS_local_22" $D1%XW}, \
    952 {"iomix_AUDIO_SET_CHANNELS_local_23" $D1%XW}, \
    953 {"iomix_AUDIO_SET_CHANNELS_local_24" $D1%XW}, \
    954 {"iomix_AUDIO_SET_CHANNELS_local_25" $D1%XW}, \
    955 {"iomix_AUDIO_SET_CHANNELS_local_26" $D1%XW}, \
    956 {"iomix_AUDIO_SET_CHANNELS_local_27" $D1%XW}, \
    957 {"iomix_AUDIO_SET_CHANNELS_local_28" $D1%XW}, \
    375 {"mstvol_AUDIO_MASTER_VOLUME_0"}, \
    376 {"mstvol_AUDIO_MASTER_VOLUME_1"}, \
    377 {"mstvol_AUDIO_MASTER_VOLUME_2"}, \
    378 {"mstvol_AUDIO_MASTER_VOLUME_3" $D1%XW}, \
    379 {"mstvol_AUDIO_MASTER_VOLUME_4"}, \
    380 {"mstvol_AUDIO_MASTER_VOLUME_5" $D1%XW}, \
    381 {"mstvol_AUDIO_MASTER_VOLUME_6" $D1%XW}, \
    418 {"process_CFG_TERM_0" $D1%XW}, \
    419 {"process_CFG_TERM_1"}, \
    420 {"process_CFG_TERM_2" $D1%XW}, \
    421 {"process_CFG_TERM_3"}, \
    422 {"process_CFG_TERM_4" $D1%XW}, \
    423 {"process_CFG_TERM_5" $D1%XW}, \
    964 {"sleep_timer_sleep_0"}, \
    965 {"sleep_timer_sleep_1"}, \
    966 {"sleep_timer_sleep_2"}, \
    967 {"sleep_timer_sleep_3"}, \
    968 {"sleep_timer_sleep_4"}, \
    969 {"sleep_timer_sleep_5"}, \
    453 {"start_playback_watchdog_1"}, \
    455 {"start_record_watchdog_1"}, \
    970 {"ua_MULAWtoPCM16L_filter_block_0"}, \
    971 {"ua_MULAWtoPCM16L_filter_block_1"}, \
    972 {"ua_MULAWtoPCM16L_filter_block_2"}, \
    973 {"ua_MULAWtoPCM16L_filter_block_3"}, \
    974 {"ua_MULAWtoPCM16_filter_block_0"}, \
    975 {"ua_MULAWtoPCM16_filter_block_1"}, \
    976 {"ua_MULAWtoPCM16_filter_block_2"}, \
    977 {"ua_MULAWtoPCM16_filter_block_3"}, \
    912 {"ua_PCM8toPCM16L_filter_block_0"}, \
    913 {"ua_PCM8toPCM16L_filter_block_1"}, \
    914 {"ua_PCM8toPCM16L_filter_block_2"}, \
    915 {"ua_PCM8toPCM16L_filter_block_3"}, \
    201 {"ua_PCM8toPCM16_filter_block_0"}, \
    203 {"ua_PCM8toPCM16_filter_block_1"}, \
    204 {"ua_PCM8toPCM16_filter_block_2"}, \
    208 {"ua_PCM8toPCM16_filter_block_3"}, \
    916 {"ua_PCM16LtoPCM8_filter_block_0"}, \
    917 {"ua_PCM16LtoPCM8_filter_block_1"}, \
    918 {"ua_PCM16LtoPCM8_filter_block_2"}, \
    919 {"ua_PCM16LtoPCM8_filter_block_3"}, \
    920 {"ua_PCM16LtoPCMU8_filter_block_0"}, \
    921 {"ua_PCM16LtoPCMU8_filter_block_1"}, \
    922 {"ua_PCM16LtoPCMU8_filter_block_2"}, \
    923 {"ua_PCM16LtoPCMU8_filter_block_3"}, \
    211 {"ua_PCM16toPCM8_filter_block_0"}, \
    219 {"ua_PCM16toPCM8_filter_block_1"}, \
    220 {"ua_PCM16toPCM8_filter_block_2"}, \
    815 {"ua_PCM16toPCM8_filter_block_3"}, \
    819 {"ua_PCM16toPCMU8_filter_block_0"}, \
    821 {"ua_PCM16toPCMU8_filter_block_1"}, \
    906 {"ua_PCM16toPCMU8_filter_block_2"}, \
    907 {"ua_PCM16toPCMU8_filter_block_3"}, \
    924 {"ua_PCMU8toPCM16L_filter_block_0"}, \
    925 {"ua_PCMU8toPCM16L_filter_block_1"}, \
    926 {"ua_PCMU8toPCM16L_filter_block_2"}, \
    927 {"ua_PCMU8toPCM16L_filter_block_3"}, \
    908 {"ua_PCMU8toPCM16_filter_block_0"}, \
    909 {"ua_PCMU8toPCM16_filter_block_1"}, \
    910 {"ua_PCMU8toPCM16_filter_block_2"}, \
    911 {"ua_PCMU8toPCM16_filter_block_3"}, \
    168 {"ua_abort_all_pending_0"}, \
    169 {"ua_abort_all_pending_1"}, \
    170 {"ua_abort_all_pending_2"}, \
    172 {"ua_abort_all_pending_4"}, \
    173 {"ua_abort_all_pending_5"}, \
    510 {"ua_abuf_allocate_buffer_0"}, \
    511 {"ua_abuf_allocate_buffer_1" $D1%XW}, \
    512 {"ua_abuf_free_buffer_0"}, \
    513 {"ua_abuf_reset_buffer_0"}, \
    33 {"ua_add_interface_to_group_1" $D1%XW}, \
    34 {"ua_add_interface_to_group_2"}, \
    87 {"ua_add_interface_to_group_3"}, \
    88 {"ua_add_interface_to_group_4" $D1%XW}, \
    89 {"ua_add_interface_to_group_5" $D1%XW}, \
    174 {"ua_allocate_and_map_0"}, \
    175 {"ua_allocate_and_map_1"}, \
    176 {"ua_allocate_and_map_2"}, \
    177 {"ua_allocate_and_map_3"}, \
    178 {"ua_allocate_and_map_4"}, \
    322 {"ua_allocate_and_map_5"}, \
    716 {"ua_allocate_and_map_7"}, \
    717 {"ua_allocate_and_map_8"}, \
    718 {"ua_allocate_and_map_9"}, \
    719 {"ua_allocate_and_map_10"}, \
    342 {"ua_allocate_channel_0" $D1%XW}, \
    345 {"ua_allocate_channel_3"}, \
    346 {"ua_allocate_channel_4"}, \
    248 {"ua_chan12_ioctl_0" $D1%XW}, \
    249 {"ua_chan12_ioctl_1"}, \
    250 {"ua_chan12_ioctl_2"}, \
    251 {"ua_chan12_ioctl_3" $D1%XW}, \
    864 {"ua_close_0" $D1%XW $D2%XW}, \
    865 {"ua_close_1" $D1%XW}, \
    866 {"ua_close_2" $D1%XW}, \
    867 {"ua_close_3" $D1%XW}, \
    362 {"ua_close_devicelocked_0"}, \
    365 {"ua_close_devicelocked_3"}, \
    366 {"ua_close_devicelocked_4"}, \
    367 {"ua_close_devicelocked_5"}, \
    368 {"ua_close_devicelocked_6"}, \
    369 {"ua_close_devicelocked_7"}, \
    370 {"ua_close_devicelocked_8" $D1%XW}, \
    371 {"ua_close_devicelocked_9"}, \
    372 {"ua_close_devicelocked_10"}, \
    373 {"ua_close_devicelocked_11"}, \
    374 {"ua_close_devicelocked_12"}, \
    13 {"ua_close_interface_0"}, \
    15 {"ua_close_interface_2"}, \
    23 {"ua_close_loop_0"}, \
    24 {"ua_close_loop_1"}, \
    25 {"ua_close_loop_2"}, \
    90 {"ua_collect_interfaces_0"}, \
    166 {"ua_collect_interfaces_1"}, \
    179 {"ua_connect_pipes_0"}, \
    180 {"ua_deallocate_and_unmap_0"}, \
    181 {"ua_deallocate_and_unmap_1"}, \
    183 {"ua_deallocate_and_unmap_3"}, \
    720 {"ua_deallocate_and_unmap_4"}, \
    347 {"ua_deallocate_channel_0" $D1%XW}, \
    350 {"ua_deallocate_channel_3"}, \
    351 {"ua_deallocate_channel_4" $D1%XW}, \
    14 {"ua_debug_diag_ioctl2_0"}, \
    26 {"ua_debug_diag_ioctl_0"}, \
    27 {"ua_debug_ioctl_0"}, \
    978 {"ua_debug_ioctl_1"}, \
    979 {"ua_debug_ioctl_2" $D1%XW}, \
    980 {"ua_debug_ioctl_3"}, \
    981 {"ua_debug_ioctl_4" $D1%XW}, \
    982 {"ua_debug_ioctl_5" $D1%XW}, \
    18 {"ua_detected_disconnect_locked_0"}, \
    335 {"ua_device_first_open_0"}, \
    336 {"ua_device_first_open_1" $D1%XW}, \
    424 {"ua_device_first_open_2"}, \
    425 {"ua_device_first_open_3" $D1%XW}, \
    426 {"ua_device_last_close_0"}, \
    427 {"ua_device_last_close_1"}, \
    428 {"ua_device_last_close_2" $D1%XW}, \
    429 {"ua_device_last_close_3" $D1%XW}, \
    19 {"ua_disconnect_0" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    184 {"ua_disconnect_1"}, \
    185 {"ua_disconnect_pipes_0"}, \
    186 {"ua_down_0"}, \
    187 {"ua_down_1"}, \
    188 {"ua_down_2"}, \
    535 {"ua_down_3" $D1%XW}, \
    229 {"ua_extension_to_known_state_0"}, \
    569 {"ua_extension_to_known_state_1"}, \
    570 {"ua_extension_to_known_state_2"}, \
    571 {"ua_extension_to_known_state_3" $D1%XW}, \
    572 {"ua_extension_to_known_state_4"}, \
    452 {"ua_feature_get_volume_0"}, \
    454 {"ua_feature_get_volume_1"}, \
    721 {"ua_feature_get_volume_2"}, \
    722 {"ua_feature_get_volume_3" $D1%XW}, \
    735 {"ua_feature_get_volume_4" $D1%XW}, \
    526 {"ua_feature_set_mute_0"}, \
    527 {"ua_feature_set_mute_1"}, \
    547 {"ua_feature_set_mute_2"}, \
    548 {"ua_feature_set_mute_3" $D1%XW}, \
    556 {"ua_feature_set_mute_4" $D1%XW}, \
    775 {"ua_feature_set_volume_nominal_0" $D1%XW $D2%XW $D3%XW}, \
    783 {"ua_feature_set_volume_nominal_1"}, \
    788 {"ua_feature_set_volume_nominal_2"}, \
    791 {"ua_feature_set_volume_nominal_3" $D1%XW}, \
    793 {"ua_feature_set_volume_nominal_4" $D1%XW}, \
    798 {"ua_feature_set_volume_nominal_5" $D1%XW}, \
    799 {"ua_feature_set_volume_nominal_6" $D1%XW}, \
    810 {"ua_feature_set_volume_nominal_8"}, \
    822 {"ua_feature_set_volume_nominal_9"}, \
    551 {"ua_feature_set_volume_nominal_14" $D1%XW}, \
    604 {"ua_feature_set_volume_nominal_15" $D1%XW}, \
    832 {"ua_feature_set_volume_raw_0" $D1%XW $D2%XW $D3%XW}, \
    834 {"ua_feature_set_volume_raw_1"}, \
    835 {"ua_feature_set_volume_raw_2"}, \
    837 {"ua_feature_set_volume_raw_3" $D1%XW}, \
    843 {"ua_feature_set_volume_raw_4" $D1%XW}, \
    230 {"ua_feature_to_known_state_0"}, \
    552 {"ua_feature_to_known_state_1"}, \
    553 {"ua_feature_to_known_state_2"}, \
    555 {"ua_feature_to_known_state_4"}, \
    557 {"ua_feature_to_known_state_6" $D1%XW}, \
    558 {"ua_feature_to_known_state_7" $D1%XW}, \
    559 {"ua_feature_to_known_state_8" $D1%XW}, \
    560 {"ua_feature_to_known_state_9" $D1%XW}, \
    561 {"ua_feature_to_known_state_10" $D1%XW}, \
    562 {"ua_feature_to_known_state_11" $D1%XW}, \
    563 {"ua_feature_to_known_state_12" $D1%XW}, \
    564 {"ua_feature_to_known_state_13" $D1%XW}, \
    661 {"ua_feature_to_known_state_14" $D1%XW}, \
    662 {"ua_feature_to_known_state_15" $D1%XW}, \
    167 {"ua_find_and_join_group_1"}, \
    231 {"ua_group_by_itself_0"}, \
    189 {"ua_handle_control_0"}, \
    190 {"ua_handle_control_1" $D1%XW $D2%XW}, \
    191 {"ua_handle_control_2"}, \
    192 {"ua_handle_control_3"}, \
    193 {"ua_handle_control_4"}, \
    195 {"ua_handle_control_6"}, \
    811 {"ua_handle_data_1" $D1%XW $D2%XW}, \
    812 {"ua_handle_data_2"}, \
    813 {"ua_handle_data_3"}, \
    814 {"ua_handle_data_4"}, \
    1077 {"ua_handle_data_5" $D1%XW $D2%XW $D3%XW}, \
    816 {"ua_handle_data_6"}, \
    1078 {"ua_handle_data_7" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1093 {"ua_handle_data_8" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1107 {"ua_handle_data_9" $D1%XW $D2%XW $D3%XW}, \
    1146 {"ua_handle_data_10" $D1%XW $D2%XW $D3%XW}, \
    1147 {"ua_handle_data_11" $D1%XW $D2%XW $D3%XW}, \
    1148 {"ua_handle_data_12" $D1%XW $D2%XW $D3%XW}, \
    199 {"ua_initialize_offlevel_0"}, \
    518 {"ua_input_to_known_state_0"}, \
    202 {"ua_io_complete_callback_2" $D1%XW}, \
    205 {"ua_io_complete_callback_5" $D1%XW $D2%XW $D3%XW}, \
    252 {"ua_ioctl_0" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    253 {"ua_ioctl_1" $D1%XW}, \
    254 {"ua_ioctl_2" $D1%XW}, \
    255 {"ua_ioctl_3" $D1%XW}, \
    958 {"ua_iomix_ioctl_0"}, \
    959 {"ua_iomix_ioctl_1" $D1%XW}, \
    332 {"ua_lookup_device_channel_and_validate_0" $D1%XW}, \
    333 {"ua_lookup_device_channel_and_validate_1" $D1%XW}, \
    334 {"ua_lookup_device_channel_and_validate_2"}, \
    337 {"ua_lookup_device_channel_and_validate_5"}, \
    584 {"ua_master_volume_changed_0"}, \
    585 {"ua_master_volume_changed_1" $D1%XW}, \
    481 {"ua_match_ADPCM_0"}, \
    482 {"ua_match_ALAW_0"}, \
    483 {"ua_match_MULAW_0"}, \
    497 {"ua_match_PCMS8_0"}, \
    499 {"ua_match_PCMS16L_0"}, \
    500 {"ua_match_PCMS16M_0"}, \
    501 {"ua_match_PCMS16M_1"}, \
    817 {"ua_match_PCMU8_0"}, \
    818 {"ua_match_PCMU16L_0"}, \
    1005 {"ua_match_PCMU16M_0"}, \
    1006 {"ua_match_PCM_0"}, \
    1038 {"ua_match_interface_apply_0"}, \
    1039 {"ua_match_interface_apply_1"}, \
    1040 {"ua_match_interface_apply_2"}, \
    1041 {"ua_match_interface_body_0"}, \
    1042 {"ua_match_interface_body_1"}, \
    1043 {"ua_match_interface_body_2"}, \
    1044 {"ua_match_interface_body_3"}, \
    1045 {"ua_match_interface_body_4"}, \
    1046 {"ua_match_interface_body_5"}, \
    1047 {"ua_match_interface_from_init_0"}, \
    1048 {"ua_match_interface_from_init_1"}, \
    1049 {"ua_match_interface_from_init_2"}, \
    1050 {"ua_match_interface_from_init_3"}, \
    1051 {"ua_match_interface_from_init_4"}, \
    1052 {"ua_match_interface_from_init_5" $D1%XW}, \
    1053 {"ua_match_interface_from_init_6"}, \
    1054 {"ua_match_interface_from_init_7" $D1%XW}, \
    1055 {"ua_match_interface_from_init_8"}, \
    1056 {"ua_match_interface_from_reconnect_0"}, \
    1057 {"ua_match_interface_from_reconnect_1"}, \
    1058 {"ua_match_interface_from_reconnect_2"}, \
    1059 {"ua_match_interface_from_reconnect_3"}, \
    1060 {"ua_match_interface_from_reconnect_4" $D1%XW}, \
    1061 {"ua_match_interface_from_reconnect_5"}, \
    1062 {"ua_match_interface_from_reconnect_6"}, \
    1063 {"ua_match_interface_from_reconnect_7" $D1%XW}, \
    1064 {"ua_match_interface_from_reconnect_8"}, \
    872 {"ua_match_srate_0"}, \
    873 {"ua_match_srate_1" $D1%XW $D2%XW}, \
    874 {"ua_match_srate_2"}, \
    875 {"ua_match_srate_3"}, \
    876 {"ua_match_try_native_pad_replicate_0"}, \
    933 {"ua_match_try_single_filter_0"}, \
    607 {"ua_mixer_get_raw_0"}, \
    642 {"ua_mixer_get_raw_1"}, \
    643 {"ua_mixer_get_raw_2"}, \
    644 {"ua_mixer_get_raw_3"}, \
    645 {"ua_mixer_get_raw_4"}, \
    663 {"ua_mixer_get_raw_5" $D1%XW}, \
    845 {"ua_mixer_set_nominal_0"}, \
    1092 {"ua_mixer_set_nominal_1"}, \
    1101 {"ua_mixer_set_nominal_2"}, \
    1102 {"ua_mixer_set_nominal_3"}, \
    1154 {"ua_mixer_set_nominal_4"}, \
    664 {"ua_mixer_set_nominal_5" $D1%XW}, \
    742 {"ua_mixer_set_nominal_6" $D1%XW}, \
    743 {"ua_mixer_set_nominal_7" $D1%XW}, \
    759 {"ua_mixer_set_nominal_8" $D1%XW}, \
    765 {"ua_mixer_set_nominal_9" $D1%XW}, \
    769 {"ua_mixer_set_nominal_11"}, \
    1161 {"ua_mixer_set_nominal_12"}, \
    1155 {"ua_mixer_set_raw_0"}, \
    1156 {"ua_mixer_set_raw_1"}, \
    1157 {"ua_mixer_set_raw_2"}, \
    1158 {"ua_mixer_set_raw_3"}, \
    1159 {"ua_mixer_set_raw_4"}, \
    1160 {"ua_mixer_set_raw_5" $D1%XW}, \
    519 {"ua_mixer_to_known_state_0"}, \
    544 {"ua_mixer_to_known_state_1"}, \
    545 {"ua_mixer_to_known_state_2"}, \
    546 {"ua_mixer_to_known_state_3" $D1%XW}, \
    983 {"ua_mpx_0" $D1%XW $D2%XW $D3%XW}, \
    984 {"ua_mpx_1" $D1%XW}, \
    985 {"ua_mpx_2"}, \
    986 {"ua_mpx_3"}, \
    987 {"ua_mpx_4"}, \
    988 {"ua_mpx_5"}, \
    989 {"ua_mpx_6"}, \
    990 {"ua_mpx_7"}, \
    991 {"ua_mpx_8"}, \
    992 {"ua_mpx_9"}, \
    993 {"ua_mpx_10" $D1%XW}, \
    415 {"ua_mstvol_ioctl_0"}, \
    416 {"ua_mstvol_ioctl_1"}, \
    417 {"ua_mstvol_ioctl_2" $D1%XW}, \
    207 {"ua_offlevel_body_1"}, \
    820 {"ua_offlevel_body_4"}, \
    868 {"ua_open_0" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    869 {"ua_open_1" $D1%XW}, \
    870 {"ua_open_2" $D1%XW}, \
    871 {"ua_open_3" $D1%XW}, \
    352 {"ua_open_devicelocked_0"}, \
    355 {"ua_open_devicelocked_3" $D1%XW}, \
    356 {"ua_open_devicelocked_4" $D1%XW}, \
    357 {"ua_open_devicelocked_5" $D1%XW}, \
    358 {"ua_open_devicelocked_6"}, \
    359 {"ua_open_devicelocked_7"}, \
    360 {"ua_open_devicelocked_8"}, \
    361 {"ua_open_devicelocked_9" $D1%XW}, \
    16 {"ua_open_interface_0"}, \
    17 {"ua_open_interface_1"}, \
    22 {"ua_open_interface_2" $D1%XW $D2%XW}, \
    520 {"ua_output_to_known_state_0"}, \
    521 {"ua_output_to_known_state_1"}, \
    522 {"ua_output_to_known_state_2"}, \
    523 {"ua_output_to_known_state_3" $D1%XW}, \
    524 {"ua_output_to_known_state_4" $D1%XW}, \
    1144 {"ua_output_to_known_state_5"}, \
    1145 {"ua_output_to_known_state_6"}, \
    1106 {"ua_pad_audio_data_0"}, \
    646 {"ua_path_off_0"}, \
    647 {"ua_path_off_1" $D1%XW}, \
    648 {"ua_path_off_2" $D1%XW}, \
    649 {"ua_path_off_3" $D1%XW}, \
    650 {"ua_path_off_4" $D1%XW}, \
    651 {"ua_path_off_5" $D1%XW}, \
    652 {"ua_path_off_6" $D1%XW}, \
    653 {"ua_path_off_7" $D1%XW}, \
    654 {"ua_path_off_8" $D1%XW}, \
    665 {"ua_path_off_9" $D1%XW}, \
    666 {"ua_path_off_10" $D1%XW}, \
    670 {"ua_path_on_0"}, \
    671 {"ua_path_on_1"}, \
    672 {"ua_path_on_2" $D1%XW}, \
    673 {"ua_path_on_3" $D1%XW}, \
    674 {"ua_path_on_4" $D1%XW}, \
    675 {"ua_path_on_5" $D1%XW}, \
    676 {"ua_path_on_6" $D1%XW}, \
    677 {"ua_path_on_7" $D1%XW}, \
    678 {"ua_path_on_8" $D1%XW}, \
    679 {"ua_path_on_9" $D1%XW}, \
    680 {"ua_path_on_10" $D1%XW}, \
    681 {"ua_path_on_11" $D1%XW}, \
    456 {"ua_playback_watchdog_expired_0"}, \
    457 {"ua_playback_watchdog_expired_1"}, \
    525 {"ua_processing_to_known_state_0"}, \
    565 {"ua_processing_to_known_state_1"}, \
    566 {"ua_processing_to_known_state_2"}, \
    567 {"ua_processing_to_known_state_3" $D1%XW}, \
    568 {"ua_processing_to_known_state_4"}, \
    723 {"ua_read_0" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    724 {"ua_read_1" $D1%XW}, \
    725 {"ua_read_2" $D1%XW}, \
    726 {"ua_read_3" $D1%XW}, \
    727 {"ua_read_by_translate_0"}, \
    728 {"ua_read_by_translate_1"}, \
    729 {"ua_read_by_translate_2" $D1%XW $D2%XW}, \
    730 {"ua_read_by_translate_3" $D1%XW}, \
    731 {"ua_read_by_translate_4" $D1%XW}, \
    732 {"ua_read_by_uiop_0" $D1%XW}, \
    733 {"ua_read_chan12_0"}, \
    734 {"ua_read_chan12_1"}, \
    182 {"ua_read_chan12_2"}, \
    736 {"ua_read_chan12_3"}, \
    737 {"ua_read_chan12_4"}, \
    738 {"ua_read_chan12_5"}, \
    739 {"ua_read_chan12_6"}, \
    740 {"ua_read_chan12_7" $D1%XW}, \
    741 {"ua_read_chan12_8" $D1%XW}, \
    772 {"ua_read_chan12_10"}, \
    1079 {"ua_read_chan12_11"}, \
    1080 {"ua_read_chan12_12"}, \
    744 {"ua_read_loop_1"}, \
    745 {"ua_read_loop_2" $D1%XW}, \
    746 {"ua_read_loop_3" $D1%XW}, \
    1081 {"ua_read_loop_4"}, \
    1082 {"ua_read_loop_5"}, \
    1083 {"ua_read_loop_6"}, \
    698 {"ua_rebuild_input_volume_0"}, \
    401 {"ua_rebuild_input_volume_1"}, \
    402 {"ua_rebuild_input_volume_2"}, \
    403 {"ua_rebuild_input_volume_3" $D1%XW}, \
    310 {"ua_rebuild_output_volume_0"}, \
    311 {"ua_rebuild_output_volume_1"}, \
    312 {"ua_rebuild_output_volume_2"}, \
    1004 {"ua_reconfigure_alternate_settings_0"}, \
    1007 {"ua_reconfigure_alternate_settings_1"}, \
    1008 {"ua_reconfigure_alternate_settings_2"}, \
    1009 {"ua_reconfigure_alternate_settings_3"}, \
    1010 {"ua_reconfigure_alternate_settings_4"}, \
    1011 {"ua_reconfigure_alternate_settings_5"}, \
    1012 {"ua_reconfigure_alternate_settings_6"}, \
    1013 {"ua_reconfigure_track_0"}, \
    1014 {"ua_reconfigure_track_1"}, \
    1024 {"ua_reconfigure_track_2"}, \
    1025 {"ua_reconfigure_track_3"}, \
    1026 {"ua_reconfigure_track_4"}, \
    1027 {"ua_reconfigure_track_5"}, \
    1028 {"ua_reconfigure_track_6"}, \
    1029 {"ua_reconfigure_track_7"}, \
    1030 {"ua_reconfigure_track_8"}, \
    1031 {"ua_reconfigure_track_9"}, \
    1032 {"ua_reconfigure_track_10"}, \
    1033 {"ua_reconfigure_track_11"}, \
    1065 {"ua_reconfigure_track_12" $D1%XW}, \
    69 {"ua_reconfigure_track_13"}, \
    479 {"ua_reconfigure_track_14"}, \
    1016 {"ua_reconfigure_track_15" $D1%XW}, \
    1017 {"ua_reconfigure_track_16" $D1%XW}, \
    1018 {"ua_reconfigure_track_17"}, \
    1019 {"ua_reconfigure_track_18"}, \
    1020 {"ua_reconfigure_track_19"}, \
    1021 {"ua_reconfigure_track_20"}, \
    1022 {"ua_reconfigure_track_21"}, \
    1023 {"ua_reconfigure_track_22"}, \
    1066 {"ua_reconfigure_track_23" $D1%XW}, \
    1067 {"ua_reconfigure_track_24" $D1%XW}, \
    1068 {"ua_reconfigure_track_25"}, \
    1069 {"ua_reconfigure_track_26"}, \
    1070 {"ua_reconfigure_track_27"}, \
    1071 {"ua_reconfigure_track_28" $D1%XW}, \
    1073 {"ua_reconfigure_track_29"}, \
    1074 {"ua_reconfigure_track_30"}, \
    1075 {"ua_reconfigure_track_31" $D1%XW}, \
    1076 {"ua_reconfigure_track_32" $D1%XW}, \
    20 {"ua_reconnect_0" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    217 {"ua_reconnect_1"}, \
    1034 {"ua_reconnect_2"}, \
    1035 {"ua_reconnect_3"}, \
    1072 {"ua_reconnect_4" $D1%XW}, \
    458 {"ua_record_watchdog_expired_0"}, \
    459 {"ua_record_watchdog_expired_1"}, \
    994 {"ua_rega_ioctl_0"}, \
    995 {"ua_rega_ioctl_1" $D1%XW}, \
    218 {"ua_reset_device_0"}, \
    1108 {"ua_sample_trace_0"}, \
    1109 {"ua_sample_trace_1"}, \
    1110 {"ua_sample_trace_2" $D1%XW}, \
    1111 {"ua_sample_trace_3" $D1%XW $D2%XW}, \
    1112 {"ua_sample_trace_4" $D1%XW $D2%XW $D3%XW}, \
    1113 {"ua_sample_trace_5" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1114 {"ua_sample_trace_6" $D1%XW $D2%XW $D3%XW $D4%XW $D5%XW}, \
    1115 {"ua_sample_trace_7" $D1%XW}, \
    1116 {"ua_sample_trace_8" $D1%XW $D2%XW}, \
    1117 {"ua_sample_trace_9" $D1%XW $D2%XW $D3%XW}, \
    1118 {"ua_sample_trace_10" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1119 {"ua_sample_trace_11" $D1%XW $D2%XW $D3%XW $D4%XW $D5%XW}, \
    1120 {"ua_sample_trace_12"}, \
    1121 {"ua_sample_trace_13" $D1%XW}, \
    1122 {"ua_sample_trace_14" $D1%XW $D2%XW}, \
    1123 {"ua_sample_trace_15" $D1%XW $D2%XW $D3%XW}, \
    1124 {"ua_sample_trace_16" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1125 {"ua_sample_trace_17" $D1%XW $D2%XW $D3%XW $D4%XW $D5%XW}, \
    1126 {"ua_sample_trace_18"}, \
    1127 {"ua_sample_trace_19" $D1%XW}, \
    1128 {"ua_sample_trace_20" $D1%XW $D2%XW}, \
    1129 {"ua_sample_trace_21" $D1%XW $D2%XW $D3%XW}, \
    1130 {"ua_sample_trace_22" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1131 {"ua_sample_trace_23" $D1%XW $D2%XW $D3%XW $D4%XW $D5%XW}, \
    1132 {"ua_sample_trace_24"}, \
    1133 {"ua_sample_trace_25" $D1%XW}, \
    1134 {"ua_sample_trace_26" $D1%XW $D2%XW}, \
    1135 {"ua_sample_trace_27" $D1%XW $D2%XW $D3%XW}, \
    1136 {"ua_sample_trace_28" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1137 {"ua_sample_trace_29" $D1%XW $D2%XW $D3%XW $D4%XW $D5%XW}, \
    1138 {"ua_sample_trace_30"}, \
    1139 {"ua_sample_trace_31" $D1%XW}, \
    1140 {"ua_sample_trace_32" $D1%XW $D2%XW}, \
    1141 {"ua_sample_trace_33" $D1%XW $D2%XW $D3%XW}, \
    1142 {"ua_sample_trace_34" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    1143 {"ua_sample_trace_35" $D1%XW $D2%XW $D3%XW $D4%XW $D5%XW}, \
    996 {"ua_select_0" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    997 {"ua_select_1" $D1%XW}, \
    998 {"ua_select_2" $D1%XW}, \
    999 {"ua_select_3" $D1%XW}, \
    382 {"ua_select_chan12_0"}, \
    383 {"ua_select_chan12_1"}, \
    384 {"ua_select_chan12_2"}, \
    385 {"ua_select_chan12_3"}, \
    386 {"ua_select_chan12_4" $D1%XW}, \
    655 {"ua_selector_set_input_0"}, \
    656 {"ua_selector_set_input_1"}, \
    657 {"ua_selector_set_input_2"}, \
    658 {"ua_selector_set_input_3" $D1%XW}, \
    667 {"ua_selector_set_input_4"}, \
    659 {"ua_selector_to_known_state_5"}, \
    890 {"ua_set_endpoint_sample_rate_0"}, \
    891 {"ua_set_endpoint_sample_rate_1"}, \
    892 {"ua_set_endpoint_sample_rate_2"}, \
    893 {"ua_set_endpoint_sample_rate_3" $D1%XW}, \
    894 {"ua_set_endpoint_sample_rate_4" $D1%XW}, \
    586 {"ua_set_hardware_playback_volume_and_mute_0"}, \
    587 {"ua_set_hardware_playback_volume_and_mute_1"}, \
    588 {"ua_set_hardware_playback_volume_and_mute_2"}, \
    589 {"ua_set_hardware_playback_volume_and_mute_3"}, \
    590 {"ua_set_hardware_playback_volume_and_mute_4"}, \
    591 {"ua_set_hardware_playback_volume_and_mute_5"}, \
    592 {"ua_set_hardware_playback_volume_and_mute_6"}, \
    593 {"ua_set_hardware_playback_volume_and_mute_7" $D1%XW}, \
    594 {"ua_set_hardware_playback_volume_and_mute_8" $D1%XW}, \
    595 {"ua_set_hardware_playback_volume_and_mute_9" $D1%XW}, \
    596 {"ua_set_hardware_playback_volume_and_mute_10" $D1%XW}, \
    597 {"ua_set_hardware_playback_volume_and_mute_11" $D1%XW}, \
    598 {"ua_set_hardware_playback_volume_and_mute_12" $D1%XW}, \
    599 {"ua_set_hardware_playback_volume_and_mute_13" $D1%XW}, \
    600 {"ua_set_hardware_playback_volume_and_mute_14" $D1%XW}, \
    601 {"ua_set_hardware_playback_volume_and_mute_15" $D1%XW}, \
    699 {"ua_set_hardware_record_volume_and_mute_0"}, \
    700 {"ua_set_hardware_record_volume_and_mute_1"}, \
    701 {"ua_set_hardware_record_volume_and_mute_2"}, \
    702 {"ua_set_hardware_record_volume_and_mute_3"}, \
    703 {"ua_set_hardware_record_volume_and_mute_4"}, \
    704 {"ua_set_hardware_record_volume_and_mute_5"}, \
    705 {"ua_set_hardware_record_volume_and_mute_6"}, \
    706 {"ua_set_hardware_record_volume_and_mute_7" $D1%XW}, \
    707 {"ua_set_hardware_record_volume_and_mute_8" $D1%XW}, \
    708 {"ua_set_hardware_record_volume_and_mute_9" $D1%XW}, \
    709 {"ua_set_hardware_record_volume_and_mute_10" $D1%XW}, \
    710 {"ua_set_hardware_record_volume_and_mute_11" $D1%XW}, \
    711 {"ua_set_hardware_record_volume_and_mute_12" $D1%XW}, \
    712 {"ua_set_hardware_record_volume_and_mute_13" $D1%XW}, \
    713 {"ua_set_hardware_record_volume_and_mute_14" $D1%XW}, \
    714 {"ua_set_hardware_record_volume_and_mute_15" $D1%XW}, \
    602 {"ua_set_unit_mute_0"}, \
    603 {"ua_set_unit_mute_1"}, \
    554 {"ua_set_unit_mute_3" $D1%XW}, \
    605 {"ua_set_unit_volume_0"}, \
    606 {"ua_set_unit_volume_1" $D1%XW}, \
    608 {"ua_set_unit_volume_3"}, \
    660 {"ua_set_unit_volume_4" $D1%XW}, \
    1000 {"ua_sleep_timer_expired_0"}, \
    859 {"ua_switch_to_idle_alternate_setting_0"}, \
    860 {"ua_switch_to_idle_alternate_setting_1"}, \
    895 {"ua_switch_to_idle_alternate_setting_4"}, \
    931 {"ua_switch_to_mode_alternate_setting_0"}, \
    932 {"ua_switch_to_mode_alternate_setting_1"}, \
    221 {"ua_uninitialize_offlevel_0"}, \
    528 {"ua_unit_to_known_state_1" $D1%XW}, \
    536 {"ua_unit_to_known_state_2"}, \
    537 {"ua_unit_to_known_state_3"}, \
    529 {"ua_units_to_known_states_0"}, \
    530 {"ua_units_to_known_states_1"}, \
    531 {"ua_units_to_known_states_2"}, \
    532 {"ua_units_to_known_states_3"}, \
    533 {"ua_units_to_known_states_4" $D1%XW}, \
    534 {"ua_units_to_known_states_5"}, \
    538 {"ua_units_to_known_states_6"}, \
    668 {"ua_units_to_known_states_7" $D1%XW}, \
    669 {"ua_units_to_known_states_8" $D1%XW}, \
    222 {"ua_up_0"}, \
    223 {"ua_up_1" $D1%XW}, \
    224 {"ua_up_2" $D1%XW}, \
    539 {"ua_up_3" $D1%XW}, \
    747 {"ua_write_0" $D1%XW $D2%XW $D3%XW $D4%XW}, \
    748 {"ua_write_1" $D1%XW}, \
    749 {"ua_write_2" $D1%XW}, \
    750 {"ua_write_3" $D1%XW}, \
    751 {"ua_write_by_translate_0"}, \
    752 {"ua_write_by_translate_1"}, \
    753 {"ua_write_by_translate_2"}, \
    754 {"ua_write_by_translate_3" $D1%XW}, \
    755 {"ua_write_by_translate_4" $D1%XW}, \
    756 {"ua_write_by_uiop_0" $D1%XW}, \
    757 {"ua_write_chan12_0"}, \
    758 {"ua_write_chan12_1"}, \
    200 {"ua_write_chan12_2"}, \
    760 {"ua_write_chan12_3"}, \
    761 {"ua_write_chan12_4"}, \
    762 {"ua_write_chan12_5"}, \
    763 {"ua_write_chan12_6" $D1%XW}, \
    764 {"ua_write_chan12_7" $D1%XW}, \
    1084 {"ua_write_chan12_8"}, \
    1085 {"ua_write_chan12_9"}, \
    1086 {"ua_write_chan12_10"}, \
    767 {"ua_write_loop_2" $D1%XW}, \
    768 {"ua_write_loop_3" $D1%XW}, \
    1087 {"ua_write_loop_4"}, \
    1088 {"ua_write_loop_5"}, \
    1089 {"ua_write_loop_6"}, \
    823 {"ua_xfer_complete_playback_1"}, \
    824 {"ua_xfer_complete_playback_2"}, \
    825 {"ua_xfer_complete_playback_3" $D1%XW}, \
    779 {"ua_xfer_complete_playback_5"}, \
    904 {"ua_xfer_complete_playback_7"}, \
    828 {"ua_xfer_complete_record_1"}, \
    829 {"ua_xfer_complete_record_2"}, \
    830 {"ua_xfer_complete_record_3"}, \
    831 {"ua_xfer_complete_record_4" $D1%XW}, \
    780 {"ua_xfer_complete_record_5"}, \
    844 {"ua_xfer_complete_record_6"}, \
    905 {"ua_xfer_complete_record_8"}, \
    1094 {"ua_xfer_complete_record_9"}, \
    1095 {"ua_xfer_complete_record_pad_0"}, \
    1096 {"ua_xfer_complete_record_pad_1"}, \
    1097 {"ua_xfer_complete_record_pad_2"}, \
    1098 {"ua_xfer_complete_record_pad_3"}, \
    1099 {"ua_xfer_complete_record_pad_4"}, \
    1100 {"ua_xfer_complete_record_pad_5"}, \
    1105 {"ua_xfer_complete_record_pad_6"}, \
    770 {"ua_xfer_drain_write_buffers_1" $D1%XW}, \
    771 {"ua_xfer_fill_read_buffers_0"}, \
    773 {"ua_xfer_fill_read_buffers_2"}, \
    774 {"ua_xfer_fill_read_buffers_3" $D1%XW}, \
    846 {"ua_xfer_flush_playback_0"}, \
    847 {"ua_xfer_flush_playback_1"}, \
    848 {"ua_xfer_flush_playback_2" $D1%XW}, \
    849 {"ua_xfer_flush_playback_3"}, \
    901 {"ua_xfer_flush_playback_4"}, \
    850 {"ua_xfer_halt_playback_0"}, \
    851 {"ua_xfer_halt_playback_1"}, \
    852 {"ua_xfer_halt_playback_2"}, \
    853 {"ua_xfer_halt_playback_3" $D1%XW}, \
    854 {"ua_xfer_halt_record_0"}, \
    855 {"ua_xfer_halt_record_1"}, \
    856 {"ua_xfer_halt_record_2"}, \
    857 {"ua_xfer_halt_record_3" $D1%XW}, \
    206 {"ua_xfer_initiate_next_read_transfer_0"}, \
    776 {"ua_xfer_initiate_next_read_transfer_1"}, \
    777 {"ua_xfer_initiate_next_read_transfer_2"}, \
    778 {"ua_xfer_initiate_next_read_transfer_3"}, \
    781 {"ua_xfer_initiate_next_read_transfer_6" $D1%XW}, \
    782 {"ua_xfer_initiate_next_read_transfer_7"}, \
    209 {"ua_xfer_initiate_next_write_transfer_0"}, \
    784 {"ua_xfer_initiate_next_write_transfer_1"}, \
    785 {"ua_xfer_initiate_next_write_transfer_2"}, \
    786 {"ua_xfer_initiate_next_write_transfer_3" $D1%XW}, \
    787 {"ua_xfer_initiate_next_write_transfer_4"}, \
    805 {"ua_xfer_initiate_next_write_transfer_5"}, \
    833 {"ua_xfer_initiate_read_transfers_1" $D1%XW}, \
    836 {"ua_xfer_initiate_write_transfers_1" $D1%XW}, \
    789 {"ua_xfer_wait_for_data_record_1"}, \
    790 {"ua_xfer_wait_for_data_record_2" $D1%XW}, \
    806 {"ua_xfer_wait_for_data_record_3"}, \
    902 {"ua_xfer_wait_for_data_record_4"}, \
    792 {"ua_xfer_wait_for_space_playback_1" $D1%XW}, \
    807 {"ua_xfer_wait_for_space_playback_2"}, \
    903 {"ua_xfer_wait_for_space_playback_3"}, \
    794 {"ua_xfer_wait_playback_1"}, \
    795 {"ua_xfer_wait_playback_2"}, \
    796 {"ua_xfer_wait_playback_3" $D1%XW}, \
    797 {"ua_xfer_wait_playback_4" $D1%XW}, \
    808 {"ua_xfer_wait_playback_6"}, \
    897 {"ua_xfer_wait_playback_7"}, \
    898 {"ua_xfer_wait_playback_8"}, \
    1036 {"ua_xfer_wait_playback_9"}, \
    1090 {"ua_xfer_wait_playback_10"}, \
    800 {"ua_xfer_wait_record_1"}, \
    801 {"ua_xfer_wait_record_2"}, \
    803 {"ua_xfer_wait_record_4"}, \
    804 {"ua_xfer_wait_record_5"}, \
    809 {"ua_xfer_wait_record_6"}, \
    899 {"ua_xfer_wait_record_7"}, \
    900 {"ua_xfer_wait_record_8"}, \
    1037 {"ua_xfer_wait_record_9"}, \
    1091 {"ua_xfer_wait_record_10"}, \
    225 {"uar_request_and_wait_0"}, \
    226 {"uar_request_and_wait_1"}, \
    227 {"uar_request_and_wait_2" $D1%XW}, \
    228 {"uar_request_and_wait_3"}, \
    1103 {"uar_request_and_wait_4" $D1%XW}, \
    1104 {"uar_request_and_wait_5" $D1%XW}, \
    516 {"uar_request_and_wait_6"}, \
    517 {"uar_request_and_wait_7"}, \
    540 {"uar_request_and_wait_with_retry_0"}, \
    541 {"uar_request_and_wait_with_retry_1" $D1%XW $D2%XW}, \
    542 {"uar_request_and_wait_with_retry_2" $D1%XW}, \
    1001 {"unconfigure_entire_driver_0" $D1%XW}, \
    1002 {"unconfigure_entire_driver_1"}, \
    1003 {"unconfigure_entire_driver_2" $D1%XW}, \
    430 {"unconfigure_individual_device_0" $D1%XW}, \
    431 {"unconfigure_individual_device_1" $D1%XW}, \
    432 {"unconfigure_individual_device_2"}, \
    433 {"unconfigure_individual_device_3"}, \
    436 {"unconfigure_individual_device_4"}, \
    437 {"unconfigure_individual_device_5" $D1%XW}, \
    9 {"unconfigure_kdb_0"}, \
    10 {"unconfigure_kdb_1"}, \
    11 {"unconfigure_kdb_2"}, \
    12 {"unconfigure_kdb_3"}, \
    460 {"unconfigure_watchdog_0"}, \
    461 {"unconfigure_watchdog_1"}, \
    462 {"unconfigure_watchdog_2"}, \
    3 {"usba_config_0" $D1%XW $D2%XW}, \
    4 {"usba_config_1"}, \
    341 {"wipe_device_structure_0" $D1%XW}, \
    440 {"wipe_registers_0"}, \
    960 {"wipe_registers_1" $D1%XW}, \
    961 {"wipe_registers_2"}, \
    962 {"wipe_registers_3"}, \
    514 {"wipe_track_structure_0"}, \
    515 {"wipe_track_structure_1" $D1%XW}, \
    35 {"zxmalloc_0" $D1%XW}, \
    36 {"zxmfree_0" $D1%XW}, \
    37 {"zxmfree_1"}, \
    \* {"unknown trace hook" $HD}

3A8 1.0 "SCSESDD" \
        $HDU, \
        0x1F { iodone: devtoname($D1) bp=$D2 buftofilename($D2) \
                endtimer(0x221,$D2) }, \
        0x17 { $D2, 0 { $SKIP } \
                bstart: devtoname($D1) bp=$D2 buftofilename($D2) \
                        pblock=$D4 bcount=$D5 bflags($D3) \
        }, \
        \*   { $DD1 }
47E 1.0 "SC2SDISKDD_ERR" \
	{{ $loc = X1 }} \
	{{ $typ = B0.3}} \
	{{ $cnt = B0.5}} \
	$loc, \
	0x70 { "scdisk_strategy:\t\t\t"} , \
	0x71 { "INSERT_Q:\t\t\t\t"} , \
	0x72 { "DEQUEUE :\t\t\t\t"} , \
	0x73 { "scdisk_start:\t\t\t"} , \
	0x74 { "scdisk_coalesce:\t\t\t"} , \
	0x75 { "RELOCATE:\t\t\t\t"} , \
	0x76 { "scdisk_iodone:\t\t\t"} , \
	0x77 { "scdisk_process_good:\t\t"} , \
	0x78 { "scdisk_process_error:\t\t"} , \
	0x79 { "SDIODONE:\t\t\t\t"} , \
	0x7a { "RWIODONE:\t\t\t\t"} , \
	0x7b { "BUFRETRY:\t\t\t\t"} , \
	0x7c { "scdisk_process_buf_error:\t\t"} , \
	0x7d { "scdisk_fail_disk:\t\t\t"} , \
	0x7e { "scdisk_process_scsi_error:\t\t"} , \
	0x7f { "scdisk_process_adapter_error:\t"} , \
	0x80 { "scdisk_process_buf:\t\t\t"} , \
	0x81 { "scdisk_process_reset:\t\t"} , \
	0x82 { "scdisk_q_cmd:\t\t\t"} , \
	0x83 { "scdisk_d_q_cmd:\t\t\t"} , \
	0x84 { "scdisk_cmd_alloc:\t\t\t"} , \
	0x85 { "scdisk_cmd_free:\t\t\t"} , \
	0x86 { "CMDFAIL :\t\t\t\t"} , \
	0x87 { "scdisk_prevent_allow:\t\t"} , \
	0x88 { "scdisk_start_unit:\t\t"} , \
	0x89 { "scdisk_test_unit_ready:\t\t"} , \
	0x8a { "scdisk_request_sense:\t\t"} , \
	0x8b { "scdisk_reserve:\t\t\t"} , \
	0x8c { "scdisk_release:\t\t\t"} , \
	0x8d { "scdisk_mode_sense:\t\t\t"} , \
	0x8e { "scdisk_mode_select:\t\t"} , \
	0x8f { "scdisk_read_cap:\t\t\t"} , \
	0x90 { "scdisk_read_cap16:\t\t"} , \
	0x91 { "scdisk_get_read_toc:\t\t"} , \
	0x92 { "scdisk_read_disc_info:\t\t"} , \
	0x93 { "scdisk_get_medium_type:\t\t"} , \
	0x94 { "scdisk_get_medium_info:\t\t"} , \
	0x95 { "INQUIRY :\t\t\t\t"} , \
	0x96 { "SCSISENS:\t\t\t\t"} , \
	0x97 { "scdisk_log_error:\t\t\t"} , \
	0x98 { "scdisk_watchdog:\t\t\t"} , \
	0x99 { "scdisk_write_verify:\t\t"} , \
	0x9a { "scdisk_process_special_error:\t"} , \
	0x9b { "scdisk_process_reqsns_error:\t"} , \
	0x9c { "scdisk_build_cmd:\t\t\t"} , \
	0x9d { "scdisk_issue_multicmd:\t\t"} , \
	0x9e { "scdisk_process_diagnostic_error:\t"} , \
	0x9f { "scdisk_process_ioctl_err:\t\t"} , \
	0xa0 { "scdisk_process_reset_error:\t\t"} , \
	0xa1 { "scdisk_start_watchdog:\t\t"} , \
	0xa2 { "ISSUE   :\t\t\t\t"} , \
	0xa3 { "DUMP    :\t\t\t\t"} , \
	0xa4 { "scdisk_dump_reqsns:\t\t"} , \
	0xa5 { "scdisk_dump_start_unit:\t\t"} , \
	0xa6 { "scdisk_process_dmp_sns:\t\t"} , \
	0xa7 { "scdisk_process_dmp_error:\t\t"} , \
	0xa8 { "scdisk_dump_write:\t\t"} , \
	0xa9 { "DMPISSUE:\t\t\t\t"} , \
	0xaa { "scdisk_pm_handler:\t\t"} , \
	0xab { "scdisk_pm_watchdog:\t\t"} , \
	0xac { "scdisk_sync_spinup:\t\t"} , \
	0xad { "scdisk_spinup_watch:\t\t"} , \
	0xae { "scdisk_pr_in:\t\t\t"} , \
	0xaf { "scdisk_pr_register_ignore:\t\t"} , \
	0xb0 { "scdisk_pr_reserve_release:\t\t"} , \
	0xb1 { "scdisk_pr_clear:\t\t\t"} , \
	0xb2 { "scdisk_pr_preempt:\t\t"} , \
	0xb3 { "scdisk_retry_cmd:\t\t\t"} , \
	0xb4 { "scdisk_lun_reset:\t\t\t"} , \
	0xb5 { "scdisk_target_reset:\t\t"} , \
	0xb6 { "scdisk_select_path:\t\t\t"} , \
	0xb7 { "scdisk_recover_adap_q:\t\t"} , \
	0xb8 { "scdisk_open:\t\t\t"} , \
	0xb9 { "scdisk_close:\t\t\t"} , \
	0xba { "scdisk_rdwr:\t\t\t"} , \
	0xbb { "scdisk_mincnt:\t\t\t"} , \
	0xbc { "scdisk_raw:\t\t\t"} , \
	0xbd { "scdisk_raw_buffer:\t\t"} , \
	0xbe { "scdisk_io_buffer:\t\t\t"} , \
	0xbf { "scdisk_raw_io:\t\t\t"} , \
	0xc0 { "scdisk_build_raw_cmd:\t\t"} , \
	0xc1 { "scdisk_ioctl:\t\t\t"} , \
	0xc2 { "scdisk_dk_rwbuffer:\t\t"} , \
	0xc3 { "scdisk_open_adapter:\t\t"} , \
	0xc4 { "scdisk_close_adapter:\t\t"} \
	$typ, \
	0x0 { "Entry" $cnt%X1 XW XW XW XW XW } , \
	0x1 { "Trace" $cnt%X1 XW XW XW XW XW } , \
	0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }
660   1.0 "nmentdd XMIT" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3}} \
        {{ $cnt = B0.5}} \
        $loc, \
         0x1  { "nment_close:                    "} , \
         0x2  { "nment_config:                   "} , \
         0x3  { "nment_init_acs:                 "} , \
         0x4  { "nment_init_adapter:             "} , \
         0x5  { "nment_disable_adapter:          "} , \
         0x6  { "nment_init_eeh:                 "} , \
         0x7  { "nment_free_eeh:                 "} , \
         0x8  { "nment_ctl:                      "} , \
         0x9  { "nment_enable_multicast:         "} , \
         0xa  { "nment_disable_multicast:        "} , \
         0xb  { "nment_enable_promiscuous:       "} , \
         0xc  { "nment_disable_promiscuous:      "} , \
         0xd  { "debug_trace:                    "} , \
         0xe  { "clear_stats:                    "} , \
         0xf  { "get_stats:                      "} , \
         0x10 { "get_all_stats:                  "} , \
         0x11 { "compute_crc32:                  "} , \
         0x12 { "set_multicast_hash_regs:        "} , \
         0x13 { "nment_enable_address:           "} , \
         0x14 { "nment_disable_address:          "} , \
         0x15 { "mib_query:                      "} , \
         0x16 { "mib_get:                        "} , \
         0x17 { "mib_addr:                       "} , \
         0x18 { "set_link_status:                "} , \
         0x19 { "unmute_adapter:                 "} , \
         0x1a { "mute_adapter:                   "} , \
         0x1b { "change_mac_address:             "} , \
         0x1c { "nment_ntt_extractregs:          "} , \
         0x1d { "nment_takeregsnap:              "} , \
         0x1e { "nment_initsnapbuff:             "} , \
         0x1f { "nment_freesnapbuff:             "} , \
         0x20 { "nment_dump:                     "} , \
         0x21 { "nment_dump_output:              "} , \
         0x22 { "nment_ras_register:             "} , \
         0x23 { "nment_ras_unregister:           "} , \
         0x24 { "nment_ras_callback:             "} , \
         0x25 { "nment_slih:                     "} , \
         0x26 { "check_link_status:              "} , \
         0x27 { "nment_enter_limbo:              "} , \
         0x28 { "nment_bugout:                   "} , \
         0x29 { "nment_link_to:                  "} , \
         0x2a { "nment_autosense:                "} , \
         0x2b { "nment_async_status:             "} , \
         0x2c { "free_cdt:                       "} , \
         0x2d { "nment_free_services:            "} , \
         0x2e { "init_cdt:                       "} , \
         0x2f { "nment_init_services:            "} , \
         0x30 { "nment_reset_adapter:            "} , \
         0x31 { "nment_cdt_add:                  "} , \
         0x32 { "nment_cdt_del:                  "} , \
         0x33 { "nment_cdt_func:                 "} , \
         0x34 { "nment_open:                     "} , \
         0x35 { "nment_start_adapter:            "} , \
         0x36 { "dvl_mac_check:                  "} , \
         0x37 { "nment_free_stats_blk:           "} , \
         0x38 { "nment_init_stats_blk:           "} , \
         0x39 { "nment_free_status_blk:          "} , \
         0x3a { "nment_init_status_blk:          "} , \
         0x3b { "nment_ctx_w:                    "} , \
         0x3c { "nment_ctx_r:                    "} , \
         0x3d { "nment_free_ctx:                 "} , \
         0x3e { "nment_alloc_ctx:                "} , \
         0x3f { "nment_init_tx_ctx:              "} , \
         0x40 { "nment_init_rx_ctx:              "} , \
         0x41 { "nment_init_ctx:                 "} , \
         0x42 { "nment_pulse_to:                 "} , \
         0x43 { "nment_load_cpu_fw:              "} , \
         0x44 { "nment_init_cp_cpu:              "} , \
         0x45 { "nment_init_com_cpu:             "} , \
         0x46 { "nment_init_tpat_cpu:            "} , \
         0x47 { "nment_init_txp_cpu:             "} , \
         0x48 { "nment_init_rxp_cpu:             "} , \
         0x49 { "nment_load_rv2p_fw:             "} , \
         0x4a { "nment_init_cpus:                "} , \
         0x4b { "nment_reset_phy:                "} , \
         0x4c { "nment_init_remote_phy:          "} , \
         0x4d { "nment_get_phy_type:             "} , \
         0x4e { "nment_set_mac_link:             "} , \
         0x4f { "nment_init_serdes_phy:          "} , \
         0x50 { "nment_init_copper_phy:          "} , \
         0x51 { "nment_init_phy:                 "} , \
         0x52 { "nment_set_rx_filters:           "} , \
         0x53 { "soft_reset_adapter:             "} , \
         0x54 { "set_mac_address:                "} , \
         0x55 { "temp_func_call:                 "} , \
         0x56 { "nment_logerr:                   "} , \
         0x57 { "nment_pio_retry:                "} , \
         0x58 { "nment_trace:                    "} , \
         0x59 { "nment_failover:                 "} , \
         0x5a { "eeh_read_slot:                  "} , \
         0x5b { "nment_get_shmem_base:           "} , \
         0x5c { "nment_fw_sync:                  "} , \
         0x5d { "nment_eeh_callback:             "} , \
         0x5e { "eeh_finish_reset:               "} , \
         0x5f { "acquire_nvram_lock:             "} , \
         0x60 { "enable_nvram_access:            "} , \
         0x61 { "disable_nvram_access:           "} , \
         0x62 { "release_nvram_lock:             "} , \
         0x63 { "nvram_read_dword:               "} , \
         0x64 { "nment_nvram_read:               "} , \
         0x65 { "nment_get_vpd:                  "} , \
         0x66 { "nment_read_phy:                 "} , \
         0x67 { "nment_write_phy:                "} , \
         0x68 { "nment_get_link_status:          "} , \
         0x69 { "set_port_speed:                 "} , \
         0x6a { "nment_free_rx:                  "} , \
         0x6b { "nment_init_rx:                  "} , \
         0x6c { "nment_rx_handler:               "} , \
         0x6d { "undo_rx:                        "} , \
         0x6e { "refresh_rxque:                  "} , \
         0x6f { "nment_free_tx:                  "} , \
         0x70 { "nment_init_tx:                  "} , \
         0x71 { "nment_output:                   "} , \
         0x72 { "nment_tx_to:                    "} , \
         0x73 { "send_packet:                    "} , \
         0x74 { "tx_complete:                    "} , \
         0x75 { "undo_tx:                        "} , \
         0x76 { "nment_dump_ctx:                 "} , \
         0x77 { "nment_set_mac_address:          "} , \
         0x78 { "nment_nment_init_cdt:           "} , \
         0x79 { "nment_init_cdt:                 "} , \
         0x7a { "nment_free_cdt:                 "} , \
         0x7b { "disable_nvram_write:            "} , \
         0x7c { "enable_nvram_write:             "} , \
         0x7d { "nvram_erase_page:               "} , \
         0x7e { "nment_nvram_write:              "} , \
         0x7f { "nment_get_cfgspace:             "} , \
         0x80 { "nment_check_link_status:        "} , \
         0x81 { "maclink_setup:                  "} , \
         0x82 { "nvram_write_dword:              "} , \
         0x83 { "restore_multicast_filters:      "} , \
         0x84 { "nment_rx_recover:               "}   \
    $typ, \
    0x0 { "Entry " $cnt%X1 XW XW XW XW XW } , \
    0x1 { "Trace " $cnt%X1 XW XW XW XW XW } , \
    0x2 { "Exit  " $cnt%X1 XW XW XW XW XW } , \
    0x3 { "ERR   " $cnt%X1 XW XW XW XW XW }
661   1.0 "nmentdd RECV" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3}} \
        {{ $cnt = B0.5}} \
        $loc, \
          0x1 { "nment_clos:                     "} , \
          0x2 { "nment_confi:                    "} , \
          0x3 { "nment_init_ac:                  "} , \
          0x4 { "nment_init_adapte:              "} , \
          0x5 { "nment_disable_adapte:           "} , \
          0x6 { "nment_init_ee:                  "} , \
          0x7 { "nment_free_ee:                  "} , \
          0x8 { "nment_ct:                       "} , \
          0x9 { "nment_enable_multicas:          "} , \
          0xa { "nment_disable_multicas:         "} , \
          0xb { "nment_enable_promiscuou:        "} , \
          0xc { "nment_disable_promiscuou:       "} , \
          0xd { "debug_trac:                     "} , \
          0xe { "clear_stat:                     "} , \
          0xf { "get_stat:                       "} , \
         0x10 { "get_all_stats:                  "} , \
         0x11 { "compute_crc32:                  "} , \
         0x12 { "set_multicast_hash_regs:        "} , \
         0x13 { "nment_enable_address:           "} , \
         0x14 { "nment_disable_address:          "} , \
         0x15 { "mib_query:                      "} , \
         0x16 { "mib_get:                        "} , \
         0x17 { "mib_addr:                       "} , \
         0x18 { "set_link_status:                "} , \
         0x19 { "unmute_adapter:                 "} , \
         0x1a { "mute_adapter:                   "} , \
         0x1b { "change_mac_address:             "} , \
         0x1c { "nment_ntt_extractregs:          "} , \
         0x1d { "nment_takeregsnap:              "} , \
         0x1e { "nment_initsnapbuff:             "} , \
         0x1f { "nment_freesnapbuff:             "} , \
         0x20 { "nment_dump:                     "} , \
         0x21 { "nment_dump_output:              "} , \
         0x22 { "nment_ras_register:             "} , \
         0x23 { "nment_ras_unregister:           "} , \
         0x24 { "nment_ras_callback:             "} , \
         0x25 { "nment_slih:                     "} , \
         0x26 { "check_link_status:              "} , \
         0x27 { "nment_enter_limbo:              "} , \
         0x28 { "nment_bugout:                   "} , \
         0x29 { "nment_link_to:                  "} , \
         0x2a { "nment_autosense:                "} , \
         0x2b { "nment_async_status:             "} , \
         0x2c { "free_cdt:                       "} , \
         0x2d { "nment_free_services:            "} , \
         0x2e { "init_cdt:                       "} , \
         0x2f { "nment_init_services:            "} , \
         0x30 { "nment_reset_adapter:            "} , \
         0x31 { "nment_cdt_add:                  "} , \
         0x32 { "nment_cdt_del:                  "} , \
         0x33 { "nment_cdt_func:                 "} , \
         0x34 { "nment_open:                     "} , \
         0x35 { "nment_start_adapter:            "} , \
         0x36 { "dvl_mac_check:                  "} , \
         0x37 { "nment_free_stats_blk:           "} , \
         0x38 { "nment_init_stats_blk:           "} , \
         0x39 { "nment_free_status_blk:          "} , \
         0x3a { "nment_init_status_blk:          "} , \
         0x3b { "nment_ctx_w:                    "} , \
         0x3c { "nment_ctx_r:                    "} , \
         0x3d { "nment_free_ctx:                 "} , \
         0x3e { "nment_alloc_ctx:                "} , \
         0x3f { "nment_init_tx_ctx:              "} , \
         0x40 { "nment_init_rx_ctx:              "} , \
         0x41 { "nment_init_ctx:                 "} , \
         0x42 { "nment_pulse_to:                 "} , \
         0x43 { "nment_load_cpu_fw:              "} , \
         0x44 { "nment_init_cp_cpu:              "} , \
         0x45 { "nment_init_com_cpu:             "} , \
         0x46 { "nment_init_tpat_cpu:            "} , \
         0x47 { "nment_init_txp_cpu:             "} , \
         0x48 { "nment_init_rxp_cpu:             "} , \
         0x49 { "nment_load_rv2p_fw:             "} , \
         0x4a { "nment_init_cpus:                "} , \
         0x4b { "nment_reset_phy:                "} , \
         0x4c { "nment_init_remote_phy:          "} , \
         0x4d { "nment_get_phy_type:             "} , \
         0x4e { "nment_set_mac_link:             "} , \
         0x4f { "nment_init_serdes_phy:          "} , \
         0x50 { "nment_init_copper_phy:          "} , \
         0x51 { "nment_init_phy:                 "} , \
         0x52 { "nment_set_rx_filters:           "} , \
         0x53 { "soft_reset_adapter:             "} , \
         0x54 { "set_mac_address:                "} , \
         0x55 { "temp_func_call:                 "} , \
         0x56 { "nment_logerr:                   "} , \
         0x57 { "nment_pio_retry:                "} , \
         0x58 { "nment_trace:                    "} , \
         0x59 { "nment_failover:                 "} , \
         0x5a { "eeh_read_slot:                  "} , \
         0x5b { "nment_get_shmem_base:           "} , \
         0x5c { "nment_fw_sync:                  "} , \
         0x5d { "nment_eeh_callback:             "} , \
         0x5e { "eeh_finish_reset:               "} , \
         0x5f { "acquire_nvram_lock:             "} , \
         0x60 { "enable_nvram_access:            "} , \
         0x61 { "disable_nvram_access:           "} , \
         0x62 { "release_nvram_lock:             "} , \
         0x63 { "nvram_read_dword:               "} , \
         0x64 { "nment_nvram_read:               "} , \
         0x65 { "nment_get_vpd:                  "} , \
         0x66 { "nment_read_phy:                 "} , \
         0x67 { "nment_write_phy:                "} , \
         0x68 { "nment_get_link_status:          "} , \
         0x69 { "set_port_speed:                 "} , \
         0x6a { "nment_free_rx:                  "} , \
         0x6b { "nment_init_rx:                  "} , \
         0x6c { "nment_rx_handler:               "} , \
         0x6d { "undo_rx:                        "} , \
         0x6e { "refresh_rxque:                  "} , \
         0x6f { "nment_free_tx:                  "} , \
         0x70 { "nment_init_tx:                  "} , \
         0x71 { "nment_output:                   "} , \
         0x72 { "nment_tx_to:                    "} , \
         0x73 { "send_packet:                    "} , \
         0x74 { "tx_complete:                    "} , \
         0x75 { "undo_tx:                        "} , \
         0x76 { "nment_dump_ctx:                 "} , \
         0x77 { "nment_set_mac_address:          "} , \
         0x78 { "nment_nment_init_cdt:           "} , \
         0x79 { "nment_init_cdt:                 "} , \
         0x7a { "nment_free_cdt:                 "} , \
         0x7b { "disable_nvram_write:            "} , \
         0x7c { "enable_nvram_write:             "} , \
         0x7d { "nvram_erase_page:               "} , \
         0x7e { "nment_nvram_write:              "} , \
         0x7f { "nment_get_cfgspace:             "} , \
         0x80 { "nment_check_link_status:        "} , \
         0x81 { "maclink_setup:                  "} , \
         0x82 { "nvram_write_dword:              "} , \
         0x83 { "restore_multicast_filters:      "} , \
         0x84 { "nment_rx_recover:               "}   \
    $typ, \
    0x0 { "Entry " $cnt%X1 XW XW XW XW XW } , \
    0x1 { "Trace " $cnt%X1 XW XW XW XW XW } , \
    0x2 { "Exit  " $cnt%X1 XW XW XW XW XW } , \
    0x3 { "ERR   " $cnt%X1 XW XW XW XW XW }
662   1.0 "nmentdd OTHER" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3}} \
        {{ $cnt = B0.5}} \
        $loc, \
         0x1  { "nment_close:                    "} , \
         0x2  { "nment_config:                   "} , \
         0x3  { "nment_init_acs:                 "} , \
         0x4  { "nment_init_adapter:             "} , \
         0x5  { "nment_disable_adapter:          "} , \
         0x6  { "nment_init_eeh:                 "} , \
         0x7  { "nment_free_eeh:                 "} , \
         0x8  { "nment_ctl:                      "} , \
         0x9  { "nment_enable_multicast:         "} , \
         0xa  { "nment_disable_multicast:        "} , \
         0xb  { "nment_enable_promiscuous:       "} , \
         0xc  { "nment_disable_promiscuous:      "} , \
         0xd  { "debug_trace:                    "} , \
         0xe  { "clear_stats:                    "} , \
         0xf  { "get_stats:                      "} , \
         0x10 { "get_all_stats:                  "} , \
         0x11 { "compute_crc32:                  "} , \
         0x12 { "set_multicast_hash_regs:        "} , \
         0x13 { "nment_enable_address:           "} , \
         0x14 { "nment_disable_address:          "} , \
         0x15 { "mib_query:                      "} , \
         0x16 { "mib_get:                        "} , \
         0x17 { "mib_addr:                       "} , \
         0x18 { "set_link_status:                "} , \
         0x19 { "unmute_adapter:                 "} , \
         0x1a { "mute_adapter:                   "} , \
         0x1b { "change_mac_address:             "} , \
         0x1c { "nment_ntt_extractregs:          "} , \
         0x1d { "nment_takeregsnap:              "} , \
         0x1e { "nment_initsnapbuff:             "} , \
         0x1f { "nment_freesnapbuff:             "} , \
         0x20 { "nment_dump:                     "} , \
         0x21 { "nment_dump_output:              "} , \
         0x22 { "nment_ras_register:             "} , \
         0x23 { "nment_ras_unregister:           "} , \
         0x24 { "nment_ras_callback:             "} , \
         0x25 { "nment_slih:                     "} , \
         0x26 { "check_link_status:              "} , \
         0x27 { "nment_enter_limbo:              "} , \
         0x28 { "nment_bugout:                   "} , \
         0x29 { "nment_link_to:                  "} , \
         0x2a { "nment_autosense:                "} , \
         0x2b { "nment_async_status:             "} , \
         0x2c { "free_cdt:                       "} , \
         0x2d { "nment_free_services:            "} , \
         0x2e { "init_cdt:                       "} , \
         0x2f { "nment_init_services:            "} , \
         0x30 { "nment_reset_adapter:            "} , \
         0x31 { "nment_cdt_add:                  "} , \
         0x32 { "nment_cdt_del:                  "} , \
         0x33 { "nment_cdt_func:                 "} , \
         0x34 { "nment_open:                     "} , \
         0x35 { "nment_start_adapter:            "} , \
         0x36 { "dvl_mac_check:                  "} , \
         0x37 { "nment_free_stats_blk:           "} , \
         0x38 { "nment_init_stats_blk:           "} , \
         0x39 { "nment_free_status_blk:          "} , \
         0x3a { "nment_init_status_blk:          "} , \
         0x3b { "nment_ctx_w:                    "} , \
         0x3c { "nment_ctx_r:                    "} , \
         0x3d { "nment_free_ctx:                 "} , \
         0x3e { "nment_alloc_ctx:                "} , \
         0x3f { "nment_init_tx_ctx:              "} , \
         0x40 { "nment_init_rx_ctx:              "} , \
         0x41 { "nment_init_ctx:                 "} , \
         0x42 { "nment_pulse_to:                 "} , \
         0x43 { "nment_load_cpu_fw:              "} , \
         0x44 { "nment_init_cp_cpu:              "} , \
         0x45 { "nment_init_com_cpu:             "} , \
         0x46 { "nment_init_tpat_cpu:            "} , \
         0x47 { "nment_init_txp_cpu:             "} , \
         0x48 { "nment_init_rxp_cpu:             "} , \
         0x49 { "nment_load_rv2p_fw:             "} , \
         0x4a { "nment_init_cpus:                "} , \
         0x4b { "nment_reset_phy:                "} , \
         0x4c { "nment_init_remote_phy:          "} , \
         0x4d { "nment_get_phy_type:             "} , \
         0x4e { "nment_set_mac_link:             "} , \
         0x4f { "nment_init_serdes_phy:          "} , \
         0x50 { "nment_init_copper_phy:          "} , \
         0x51 { "nment_init_phy:                 "} , \
         0x52 { "nment_set_rx_filters:           "} , \
         0x53 { "soft_reset_adapter:             "} , \
         0x54 { "set_mac_address:                "} , \
         0x55 { "temp_func_call:                 "} , \
         0x56 { "nment_logerr:                   "} , \
         0x57 { "nment_pio_retry:                "} , \
         0x58 { "nment_trace:                    "} , \
         0x59 { "nment_failover:                 "} , \
         0x5a { "eeh_read_slot:                  "} , \
         0x5b { "nment_get_shmem_base:           "} , \
         0x5c { "nment_fw_sync:                  "} , \
         0x5d { "nment_eeh_callback:             "} , \
         0x5e { "eeh_finish_reset:               "} , \
         0x5f { "acquire_nvram_lock:             "} , \
         0x60 { "enable_nvram_access:            "} , \
         0x61 { "disable_nvram_access:           "} , \
         0x62 { "release_nvram_lock:             "} , \
         0x63 { "nvram_read_dword:               "} , \
         0x64 { "nment_nvram_read:               "} , \
         0x65 { "nment_get_vpd:                  "} , \
         0x66 { "nment_read_phy:                 "} , \
         0x67 { "nment_write_phy:                "} , \
         0x68 { "nment_get_link_status:          "} , \
         0x69 { "set_port_speed:                 "} , \
         0x6a { "nment_free_rx:                  "} , \
         0x6b { "nment_init_rx:                  "} , \
         0x6c { "nment_rx_handler:               "} , \
         0x6d { "undo_rx:                        "} , \
         0x6e { "refresh_rxque:                  "} , \
         0x6f { "nment_free_tx:                  "} , \
         0x70 { "nment_init_tx:                  "} , \
         0x71 { "nment_output:                   "} , \
         0x72 { "nment_tx_to:                    "} , \
         0x73 { "send_packet:                    "} , \
         0x74 { "tx_complete:                    "} , \
         0x75 { "undo_tx:                        "} , \
         0x76 { "nment_dump_ctx:                 "} , \
         0x77 { "nment_set_mac_address:          "} , \
         0x78 { "nment_nment_init_cdt:           "} , \
         0x79 { "nment_init_cdt:                 "} , \
         0x7a { "nment_free_cdt:                 "} , \
         0x7b { "disable_nvram_write:            "} , \
         0x7c { "enable_nvram_write:             "} , \
         0x7d { "nvram_erase_page:               "} , \
         0x7e { "nment_nvram_write:              "} , \
         0x7f { "nment_get_cfgspace:             "} , \
         0x80 { "nment_check_link_status:        "} , \
         0x81 { "maclink_setup:                  "} , \
         0x82 { "nvram_write_dword:              "} , \
         0x83 { "restore_multicast_filters:      "} , \
         0x84 { "nment_rx_recover:               "}   \
    $typ, \
    0x0 { "Entry " $cnt%X1 XW XW XW XW XW } , \
    0x1 { "Trace " $cnt%X1 XW XW XW XW XW } , \
    0x2 { "Exit  " $cnt%X1 XW XW XW XW XW } , \
    0x3 { "ERR   " $cnt%X1 XW XW XW XW XW }
5F7 1.0 "@mxibdd64" \
        "MXIB DD SPEC: " O2 A8.8 "d1=" X8 " d2=" X8 " d3=" X8  " d4=" X8
5F8 1.0 "@mxibdd64" \
        "MXIB DD GEN: " O2 A8.8 "d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8
5F9 1.0 "@mxibdd64" \
        "MXIB DD ERR: " O2 A8.8 "d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8
5FA 1.0 "@mxibdd64" \
        "MXIB DD DBG: " O2 A8.8 "d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8
5FB 1.0 "@IbMxLib" \
        "MXIB SP: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
65D 1.0 "@elxentdd" \
	"PCI ELXENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
65E 1.0 "@elxentdd" \
	"PCI ELXENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
65F 1.0 "@elxentdd" \
	"PCI ELXENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
5ED 1.0 "@kxentdd" \
	"PCI KXENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
5EE 1.0 "@kxentdd" \
	"PCI KXENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
5EF 1.0 "@kxentdd" \
	"PCI KXENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
63D 1.0 "@msnentdd" \
	"PCI MSNENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
63E 1.0 "@msnentdd" \
	"PCI MSNENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
63F 1.0 "@msnentdd" \
	"PCI MSNENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
64E 1.0 "@y4cryptdd" \
        "Y4CRYPTDD:  " \
        $GENERIC, \
          0 { O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }, \
          1 { A4.8 W2 {{ $loopcnt = $HL / 16 }} {{ $bytecnt = 0 }} " " LOOP $loopcnt { X16 "\n\t\t\t" {{ $bytecnt = $bytecnt + 16 }} } {{ $loopcnt = $HL - $bytecnt }} LOOP $loopcnt {X0} }
5B2 1.0 "@bentdd" \
        "PCI BENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57515545 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
5B3 1.0 "@bentdd" \
        "PCI BENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
5B4 1.0 "@bentdd" \
        "PCI BENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3B9 1.0 "FCDD" \
	$DD1
3C4 1.0 "FCPS" \
	$DD1
497 1.0 "FCPS_ERR" \
	{{ $loc = X1 }} \
	{{ $typ = B0.3}} \
	{{ $cnt = B0.5}} \
	$loc, \
	0x01 { "efsc_async_dead_link:             "} , \
	0x02 { "efsc_async_link_down:             "} , \
	0x03 { "efsc_async_link_up:               "} , \
	0x04 { "efsc_async_plogi:                 "} , \
	0x05 { "efsc_async_logo:                  "} , \
	0x06 { "efsc_async_prli:                  "} , \
	0x07 { "efsc_async_prlo:                  "} , \
	0x08 { "efsc_async_lip:                   "} , \
	0x09 { "efsc_async_halt_adap:             "} , \
	0x0a { "efsc_async_resume_adap:           "} , \
	0x0b { "efsc_async_reset_adap:            "} , \
	0x0c { "efsc_async_farp_request:          "} , \
	0x0d { "efsc_async_migrated:              "} , \
	0x0e { "efsc_async_hard_fail:             "} , \
	0x0f { "efsc_tm_set_fcp_nmsrv:            "} , \
	0x10 { "efsc_tm_check_general:            "} , \
	0x11 { "efsc_tm_check_no_lun:             "} , \
	0x12 { "efsc_tm_check_invalid_op:         "} , \
	0x13 { "efsc_tm_check_invalid_cdb:        "} , \
	0x14 { "efsc_tm_check_invalid_cmdiu:      "} , \
	0x15 { "efsc_tm_check_itf:                "} , \
	0x16 { "efsc_tm_build_spc_req_sns_resp:   "} , \
	0x17 { "efsc_tm_build_sppc_send_diag_resp:"} , \
	0x18 { "efsc_wdog_starve_to:              "} , \
	0x19 { "efsc_wdog_cdar_to:                "} , \
	0x1a { "efsc_wdog_cmd_to:                 "} , \
	0x1b { "efsc_wdog_abort_claca_to:         "} , \
	0x1c { "efsc_wdog_target_rst_to:          "} , \
	0x1d { "efsc_wdog_cancel_to:              "} , \
	0x1e { "efsc_wdog_updt_vport_to:          "} , \
	0x1f { "efsc_wdog_plogi_mvlg_to:          "} , \
	0x20 { "efsc_wdog_prli_to:                "} , \
	0x21 { "efsc_wdog_gen_req_dly_to:         "} , \
	0x22 { "efsc_wdog_gen_req_to:             "} , \
	0x23 { "efsc_wdog_prli_dly_to:            "} , \
	0x24 { "efsc_prlog_check_error:           "} , \
	0x25 { "efsc_prlog_failure:               "} , \
	0x26 { "efsc_prlog_success:               "} , \
	0x27 { "efsc_copy_strt_tgt_to_caller:     "} , \
	0x28 { "efsc_tm_build_spc_tur_resp:       "} , \
	0x29 { "efsc_tm_build_spc_write_buf_resp: "} , \
	0x2a { "efsc_tm_build_sppc_send_resp:     "} , \
	0x2b { "efsc_tm_build_nolun_resp:         "} , \
	0x2c { "efsc_issue_rft_id:                "} , \
	0x2d { "efsc_process_rft_id:              "} , \
	0x2e { "efsc_send_rft_id:                 "} , \
	0x2f { "efsc_tm_issue_move_login:         "} , \
	0x30 { "efsc_tm_process_move_login:       "} , \
	0x31 { "efsc_move_login_success:          "} , \
	0x32 { "efsc_move_login_failure:          "} , \
	0x33 { "efsc_tm_mvlg_update_tmlogin:      "} , \
	0x34 { "efsc_gid_pn_targets:              "} , \
	0x35 { "efsc_npiv_has_stale_target:       "} , \
	0x36 { "efsc_tm_watchdog:                 "} , \
	0x37 { "efsc_tm_wdog_move_log_to:         "} , \
	0x38 { "efsc_tm_wdog_log_in_out_to:       "} , \
	0x39 { "efsc_tm_wdog_gen_req_to:          "} , \
	0x3a { "efsc_tm_process_gid_pn:           "} , \
	0x3b { "efsc_process_gid_pn_rsp:          "} , \
	0x3c { "efsc_tm_delete_lru_login:         "} , \
	0x3d { "efsc_tm_issue_gid_pn:             "} , \
	0x3e { "efsc_cmd_check_wwpn_change:       "} , \
	0x3f { "efsc_tm_invalidate_stale_logins:  "} , \
	0x40 { "efsc_tm_process_continue:         "} , \
	0x6f { "efsc_open:                        "} , \
	0x70 { "efsc_get_lun_tag:                 "} , \
	0x71 { "efsc_alloc_spc_els_buf:           "} , \
	0x72 { "efsc_alloc_spc_rsp_buf:           "} , \
	0x73 { "efsc_alloc_spc_bde_buf:           "} , \
	0x74 { "efsc_select:                      "} , \
	0x75 { "efsc_process_reset_ring:          "} , \
	0x76 { "efsc_fail_cmd:                    "} , \
	0x77 { "SDIODONE:                         "} , \
	0x78 { "efsc_strategy|clearaca:           "} , \
	0x79 { "efsc_strategy|abort_task_set:     "} , \
	0x7a { "efsc_strategy|strategy:           "} , \
	0x7b { "efsc_start_pending_cmds:          "} , \
	0x7c { "efsc_process_cmd_error:           "} , \
	0x7d { "efsc_process_fcp_status:          "} , \
	0x7e { "efsc_process_scsi_elem|scsierror: "} , \
	0x7f { "efsc_process_task_mgm_cmds:       "} , \
	0x80 { "efsc_process_adapter_error:       "} , \
	0x81 { "efsc_issue_reset_ring:            "} , \
	0x82 { "efsc_dyntrk_failed:               "} , \
	0x83 { "efsc_async_rscn:                  "} , \
	0x84 { "efsc_dump_start:                  "} , \
	0x85 { "efsc_issue_cancel_cmd|sendcancel: "} , \
	0x86 { "efsc_issue_cancel_cmd|cancel_req: "} , \
	0x87 { "efsc_issue_target_cancel:         "} , \
	0x88 { "efsc_bld_target_cancel:           "} , \
	0x89 { "IOCTLERR:                         "} , \
	0x8a { "RESETERR:                         "} , \
	0x8b { "efsc_issue_target_reset:          "} , \
	0x8c { "efsc_issue_lun_reset:             "} , \
	0x8d { "efsc_init_dev:                    "} , \
	0x8e { "efsc_process_move_login:          "} , \
	0x8f { "efsc_stale_target:                "} , \
	0x90 { "efsc_issue_move_login:            "} , \
	0x91 { "efsc_invalidate_stale_logins:     "} , \
	0x92 { "efsc_process_gen_req:             "} , \
	0x93 { "efsc_process_gid_pn:              "} , \
	0x94 { "efsc_issue_gid_pn:                "} , \
	0x95 { "efsc_process_task_mgm_to:         "} , \
	0x96 { "efsc_watchdog:                    "} , \
	0x97 { "efsc_mvlg_update:                 "} , \
	0x98 { "efsc_issue_relogin:               "} , \
	0x99 { "efsc_start:                       "} , \
	0x9a { "efsc_recv:                        "} , \
	0x9b { "efsc_cmd_recv:                    "} , \
	0x9c { "efsc_process_scsi_elem:           "} , \
	0x9d { "efsc_process_cancel_elem:         "} , \
	0x9e { "efsc_process_pdisc:               "} , \
	0x9f { "efsc_process_relogin:             "} , \
	0xa0 { "efsc_process_prlog_elem:          "} , \
	0xa1 { "RESETCMP:                         "} , \
	0xa2 { "Q_CMD:                            "} , \
	0xa3 { "D_Q_CMD:                          "} , \
	0xa4 { "CMDALLOC:                         "} , \
	0xa5 { "HASH_TAR:                         "} , \
	0xa6 { "efsc_send_target_reset:           "} , \
	0xa7 { "FREE_CMD:                         "} , \
	0xa8 { "efsc_flush_pending_cmds:          "} , \
	0xa9 { "efsc_cdt_func:                    "} , \
	0xaa { "SCSISENS:                         "} , \
	0xab { "efsc_log_err:                     "} , \
	0xac { "ASYNTIMR:                         "} , \
	0xad { "efsc_async_stat:                  "} , \
	0xae { "BUILDCMD:                         "} , \
	0xaf { "BUILDCAN:                         "} , \
	0xb0 { "efsc_halt_dev:                    "} , \
	0xb1 { "efsc_send_lun_reset:              "} , \
	0xb2 { "ISSUE:                            "} , \
	0xb3 { "efsc_clear_dev:                   "} , \
	0xb4 { "PRXMT_SQ:                         "} , \
	0xb5 { "efsc_plogi:                       "} , \
	0xb6 { "efsc_send_prlog:                  "} , \
	0xb7 { "efsc_issue_prlog:                 "} , \
	0xb8 { "efsc_issue_pdisc:                 "} , \
	0xb9 { "efsc_issue_send_seq:              "} , \
	0xba { "efsc_issue_send_els:              "} , \
	0xbb { "efsc_issue_gen_req:               "} , \
	0xbc { "efsc_ioctl_setup:                 "} , \
	0xbd { "efsc_ioctl_check_dyntrk:          "} , \
	0xbe { "efsc_ras_callback:                "} , \
	0xbf { "efsc_init_dev_finish:             "} , \
	0xc0 { "efsc_ras_callback_dev:            "} , \
	0xc1 { "efsc_ras_callback_target:         "} , \
	0xc2 { "efsc_clear_initiator:             "} , \
	0xc3 { "efsc_process_update_vport:        "} , \
	0xc4 { "efsc_issue_update_vport:          "} , \
	0xc5 { "efsc_npiv_scsi:                   "} , \
	0xc6 { "efsc_npiv_start_pending_cmds:     "} , \
	0xc7 { "efsc_npiv_issue_prli_cmd:         "} , \
	0xc8 { "efsc_npiv_issue_cancel_cmd:       "} , \
	0xc9 { "efsc_npiv_issue_scsi_cmd:         "} , \
	0xca { "efsc_process_npiv_scsi_elem:      "} , \
	0xcb { "efsc_npiv_admin:                  "} , \
	0xcc { "efsc_issue_npiv_admin:            "} , \
	0xcd { "efsc_process_npiv_admin:          "} , \
	0xce { "efsc_npiv_async_stat:             "} , \
	0xcf { "efsc_npiv_send_async_stat:        "} , \
	0xd0 { "efsc_npiv_output:                 "} , \
	0xd1 { "efsc_npiv_admin_entry_fcn:        "} , \
	0xd2 { "efsc_npiv_offl_npiv_issue:        "} , \
	0xd3 { "efsc_npiv_cmd_done:               "} , \
	0xd4 { "efsc_offl_npiv_done:              "} , \
	0xd5 { "efsc_init_initiator:              "} , \
	0xd6 { "efsc_tm_add_login:                "} , \
	0xd7 { "efsc_tm_delete_login:             "} , \
	0xd8 { "efsc_tm_find_login_nport_id:      "} , \
	0xd9 { "efsc_tm_find_login_rpi:           "} , \
	0xda { "efsc_tm_find_login_wwpn:          "} , \
	0xdb { "efsc_tm_abort_cmds:               "} , \
	0xdc { "efsc_tm_stop_io_disable:          "} , \
	0xdd { "efsc_tm_start_io_disable:         "} , \
	0xde { "efsc_tm_issue_log_in_out:         "} , \
	0xdf { "efsc_tm_process_log_in_out:       "} , \
	0xe0 { "efsc_async_grp_dmn_scn:           "} , \
	0xe1 { "efsc_tm_clear:                    "} , \
	0xe2 { "efsc_tm_undo_start:               "} , \
	0xe3 { "efsc_tm_offl:                     "} , \
	0xe4 { "efsc_tm_offl_cmd:                 "} , \
	0xe5 { "efsc_tm_offl_ulp:                 "} , \
	0xe6 { "efsc_tm_offl_rsp:                 "} , \
	0xe7 { "efsc_tm_process_rcv_sequence:     "} , \
	0xe8 { "efsc_tm_process_rcv_sequence|ERR: "} , \
	0xe9 { "efsc_tm_issue_tfcp:               "} , \
	0xea { "efsc_tm_process_tfcp:             "} , \
	0xeb { "efsc_tm_process_tfcp|ERROR:       "} , \
	0xec { "efsc_tm_proc_data_iocb|ERROR:     "} , \
	0xed { "efsc_tm_free_buf:                 "} , \
	0xee { "efsc_tm_get_efscbuf:              "} , \
	0xef { "efsc_tm_build_spc_inq_resp:       "} , \
	0xf0 { "efsc_tm_build_rspiu:              "} , \
	0xf1 { "efsc_tm_process_ret_hbqe:         "} , \
	0xf2 { "efsc_tm_build_spc_rpt_luns_resp:  "} , \
	0xf3 { "efsc_tm_cmdiu_sanity:             "} , \
	0xf4 { "efsc_tm_offl_cmd_task_mgm:        "} , \
	0xf5 { "efsc_tm_offl_cmd_normal:          "} , \
	0xf6 { "efsc_tm_process_xri_aborted:      "} , \
	0xf7 { "efsc_tm_issue_flush_qbufs:        "} , \
	0xf8 { "efsc_tm_login_abort_cmds:         "} , \
	0xf9 { "efsc_tm_offl_aborted_cmd:         "} , \
	0xfa { "efsc_tm_build_close_xri:          "} , \
	0xfb { "efsc_tm_fail_cmd:                 "} , \
	0xfc { "efsc_tm_has_act_cmds:             "} , \
	0xfd { "efsc_tm_has_cmds:                 "} , \
	0xfe { "efsc_tm_start:                    "} , \
	0xff { "efsc_send_sequence:               "}   \
	$typ, \
	0x0 { "Entry" $cnt%X1 XW XW XW XW XW } , \
	0x1 { "Trace" $cnt%X1 XW XW XW XW XW } , \
	0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }
498 1.0 "FCDD_ERR" \
	{{ $loc = X1 }} \
	{{ $typ = B0.3}} \
	{{ $cnt = B0.5}} \
	$loc, \
	0x01 { "efc_process_config_port_mb:       "} , \
	0x02 { "efc_process_config_ring_mb:       "} , \
	0x03 { "efc_process_read_config_mb:       "} , \
	0x04 { "efc_process_config_link_mb:       "} , \
	0x05 { "efc_process_init_link_mb:         "} , \
	0x06 { "efc_process_read_la64_mb:         "} , \
	0x07 { "efc_process_clear_la_mb:          "} , \
	0x08 { "efc_process_read_sparm64_mb:      "} , \
	0x09 { "efc_process_reg_login64_mb:       "} , \
	0x0a { "efc_process_reg_vpi_mb:           "} , \
	0x0b { "efc_process_unreg_login_mb:       "} , \
	0x0c { "efc_process_down_link_mb:         "} , \
	0x0d { "efc_process_reg_vpi_mb:           "} , \
	0x0e { "efc_process_reset_link_mb:        "} , \
	0x0f { "efc_process_reset_ring_mb:        "} , \
	0x10 { "efc_process_dump_mailbox_mb:      "} , \
	0x11 { "efc_process_config_farp_mb:       "} , \
	0x12 { "efc_finish_async_plogi:           "} , \
	0x13 { "efc_find_hostbuf:                 "} , \
	0x14 { "efc_find_login_rpi:               "} , \
	0x15 { "efc_invalidate_stale_logins:      "} , \
	0x70 { "efc_process_adap_ring:            "} , \
	0x71 { "efc_process_proto_ring:           "} , \
	0x72 { "efc_process_latt:                 "} , \
	0x73 { "efc_process_erratt:               "} , \
	0x74 { "efc_proc_adap_iocb_err:           "} , \
	0x75 { "efc_process_async_iocb:           "} , \
	0x76 { "efc_proc_async_iocb_err:          "} , \
	0x77 { "efc_xmit_rsp:                     "} , \
	0x78 { "efc_farp_reply:                   "} , \
	0x79 { "efc_process_plogi:                "} , \
	0x7a { "efc_flush_adap_ring:              "} , \
	0x7b { "efc_flush_ring:                   "} , \
	0x7c { "efc_cmd_fcn|move_entry:           "} , \
	0x7d { "efc_reset_ring:                   "} , \
	0x7e { "efc_issue_proto_ring:             "} , \
	0x7f { "efc_cdt_func:                     "} , \
	0x80 { "efc_watchdog:                     "} , \
	0x81 { "efc_eeh_callback:                 "} , \
	0x82 { "efc_hard_error:                   "} , \
	0x83 { "efc_ctl_nport_login:              "} , \
	0x84 { "efc_ctl_login_reg:                "} , \
	0x86 { "efc_ctl_dma_setup:                "} , \
	0x8b { "efc_output:                       "} , \
	0x8d { "efc_ras_callback:                 "} , \
	0x8e { "efc_lnk_stat:                     "} , \
	0x90 { "efc_async_status:                 "} , \
	0x93 { "efc_build_els:                    "} , \
	0x94 { "efc_fabric_login:                 "} , \
	0x95 { "efc_state_change_reg:             "} , \
	0x96 { "efc_queue_buffers_for_ring:       "} , \
	0x97 { "efc_queue_proto_bufs:             "} , \
	0x98 { "efc_process_mbatt:                "} , \
	0x99 { "efc_process_adap_iocb:            "} , \
	0x9b { "efc_mapdma_iocb:                  "} , \
	0x9c { "efc_unmapdma_iocb:                "} , \
	0x9d { "efc_alloc_sglist:                 "} , \
	0x9e { "efc_clear_sglist:                 "} , \
	0x9f { "efc_process_read_rconfig_mb:      "} , \
	0xa4 { "efc_start_delay:                  "} , \
	0xa5 { "efc_delay_timer:                  "} , \
	0xa6 { "efc_start_wait_plogi:             "} , \
	0xa7 { "efc_wait_plogi:                   "} , \
	0xa8 { "efc_process_flogi:                "} , \
	0xa9 { "efc_abort_disc:                   "} , \
	0xaa { "efc_config_port:                  "} , \
	0xab { "efc_config_rings:                 "} , \
	0xac { "efc_get_link_status:              "} , \
	0xad { "efc_get_link_status_disable:      "} , \
	0xae { "efc_read_rconfig:                 "} , \
	0xaf { "efc_config_farp:                  "} , \
	0xb0 { "efc_start:                        "} , \
	0xb1 { "efc_read_link_stat:               "} , \
	0xb2 { "efc_build_cmd:                    "} , \
	0xb3 { "efc_build_iocb:                   "} , \
	0xb4 { "efc_config_link:                  "} , \
	0xb5 { "efc_clear_latt:                   "} , \
	0xb6 { "efc_get_fcparms:                  "} , \
	0xb7 { "efc_register_login:               "} , \
	0xb8 { "efc_unregister_login:             "} , \
	0xb9 { "efc_read_config:                  "} , \
	0xba { "efc_dump_adap_mb:                 "} , \
	0xbb { "efc_kill_board_mb:                "} , \
	0xbc { "efc_get_fcparms:                  "} , \
	0xbd { "efc_start_link_delay:             "} , \
	0xbe { "efc_link_delay_timer:             "} , \
	0xbf { "efc_cleanup:                      "} , \
	0xc0 { "efc_early_cleanup:                "} , \
	0xc1 { "efc_free_login_tble:              "} , \
	0xc2 { "efc_add_login_tble:               "} , \
	0xc3 { "efc_del_login_tble:               "} , \
	0xc4 { "efc_find_login_nport_id:          "} , \
	0xc5 { "efc_find_login_ww_name:           "} , \
	0xc6 { "efc_passthru_mb:                  "} , \
	0xc7 { "efc_issue_adap_ring:              "} , \
	0xc8 { "efc_offlevel_isr:                 "} , \
	0xc9 { "efc_polling_timer:                "} , \
	0xcb { "efc_issue_qbufs:                  "} , \
	0xcc { "efc_intr:                         "} , \
	0xcd { "efc_cmd_fcn:                      "} , \
	0xce { "efc_check_slot:                   "} , \
	0xcf { "efc_build_mb:                     "} , \
	0xd0 { "efc_restart_adapter:              "} , \
	0xd1 { "efc_kill_brd_delay_timer:         "} , \
	0xd2 { "efc_els_recovery:                 "} , \
	0xd3 { "efc_issue_kill_brd:               "} , \
	0xd4 { "efc_unreg_log_and_down_link:      "} , \
	0xd5 { "efc_config_read_hbq:              "} , \
	0xd6 { "efc_process_config_hbq_mb:        "} , \
	0xd7 { "efc_process_read_hbq_mb:          "} , \
	0xd8 { "efc_pause_hbq:                    "} , \
	0xd9 { "efc_process_pause_hbq_mb:         "} , \
	0xda { "efc_resume_hbq:                   "} , \
	0xdb { "efc_process_resume_hbq_mb:        "} , \
	0xdc { "efc_issue_hbq_bufs:               "} , \
	0xdd { "efc_issue_hbq_bufs_proto:         "} , \
	0xde { "efc_finish_restart_adapter:       "} , \
	0xdf { "efc_register_vpi:                 "} , \
	0xe0 { "efc_unregister_vpi:               "} , \
	0xe1 { "efc_find_vport_nport_id:          "} , \
	0xe2 { "efc_ctl_npiv_setup:               "} , \
	0xe3 { "efc_add_vport:                    "} , \
	0xe4 { "efc_del_vport:                    "} , \
	0xe5 { "efc_ctl_els:                      "} , \
	0xe6 { "efc_find_vport_vpi:               "} , \
	0xe7 { "efc_process_async_rcv_els64:      "} , \
	0xe8 { "efc_process_async_plogi:          "} , \
	0xe9 { "efc_process_async_flogi:          "} , \
	0xea { "efc_process_async_fan:            "} , \
	0xeb { "efc_process_async_logo:           "} , \
	0xec { "efc_process_async_adisc:          "} , \
	0xed { "efc_process_async_pdisc:          "} , \
	0xee { "efc_process_async_rnid:           "} , \
	0xef { "efc_process_async_rpsc:           "} , \
	0xf0 { "efc_process_async_rls:            "} , \
	0xf1 { "efc_process_async_farp_req:       "} , \
	0xf2 { "efc_process_async_farp_reply:     "} , \
	0xf3 { "efc_process_async_prli:           "} , \
	0xf4 { "efc_process_async_prlo:           "} , \
	0xf5 { "efc_process_async_rnft:           "} , \
	0xf6 { "efc_process_async_rpl:            "} , \
	0xf7 { "efc_process_async_rps:            "} , \
	0xf8 { "efc_process_async_rscn:           "} , \
	0xf9 { "efc_process_async_xri_aborted:    "} , \
	0xfa { "efc_process_async_ret_hbqe64:     "} , \
	0xfb { "efc_process_async_continue:       "} , \
	0xfc { "efc_async_status_to_entity:       "} , \
	0xfd { "efc_open:                         "} , \
	0xfe { "efc_close:                        "}   \
	$typ, \
	0x0 { "Entry" $cnt%X1 XW XW XW XW XW } , \
	0x1 { "Trace" $cnt%X1 XW XW XW XW XW } , \
	0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }

5A5 1.0 "FCIP" \
	$DD1
736 1.0 "USBOHCD22106474: " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "config " }, \
        02  { "ioctl  " }, \
        03  { "intr   " }, \
        04  { "cfgInfo" }, \
        05  { "addDev " }, \
        06  { "delDev " }, \
        07  { "rstPort" }, \
        08  { "setAddr" }, \
        09  { "selCfg " }, \
        0A  { "cleanup" }, \
        0B  { "cfgrhub" }, \
        0C  { "rstrprt" }, \
        0D  { "addHub " }, \
        0E  { "delHub " }, \
        0F  { "findDev" }, \
        10  { "canIO  " }, \
        11  { "cliReg " }, \
        12  { "cliDreg" }, \
        13  { "obtain " }, \
        14  { "release" }, \
        15  { "intAloc" }, \
        16  { "desAloc" }, \
        17  { "alocPol" }, \
        18  { "freePol" }, \
        19  { "alocEl " }, \
        1A  { "freeEl " }, \
        1B  { "bus2vir" }, \
        1C  { "vir2bus" }, \
        1D  { "findEl " }, \
        1E  { "destAll" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
4AC 1.0 "QLFCADD" \
        $DD1
4AD 1.0 "QLFCPDD" \
        $DD1
63A 1.0 "FCPS_ERR" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3}} \
        {{ $cnt = B0.5}} \
        $loc, \
	0x61 { "qlfsc_invalidate_stale_logins:           "} , \
	0x62 { "qlfsc_gid_pn_targets:                    "} , \
        0x63 { "qlfsc_wdog_starve_to:                    "} , \
        0x64 { "qlfsc_wdog_cdar_to:                      "} , \
        0x65 { "qlfsc_wdog_dev_to:                       "} , \
        0x66 { "qlfsc_wdog_abort_claca_to:               "} , \
        0x67 { "qlfsc_wdog_cancel_to:                    "} , \
        0x68 { "qlfsc_wdog_marker_to:                    "} , \
        0x69 { "qlfsc_wdog_plogi_mvlg_to:                "} , \
        0x6a { "qlfsc_wdog_pdisc_to:                     "} , \
        0x6b { "qlfsc_wdog_target_rst_to:                "} , \
        0x6c { "qlfsc_wdog_ct_iu_dly_to:                 "} , \
        0x6d { "qlfsc_wdog_ct_pthru_to:                  "} , \
        0x6e { "qlfsc_wdog_els_pthru_to:                 "} , \
        0x6f { "qlfsc_wdog_abort_iocb_to:                "} , \
	0x70 { "qlfsc_ioctl_check_dyntrk:                "} , \
	0x71 { "qlfsc_ioctl_setup:                       "} , \
	0x72 { "qlfsc_initiate_dyntrk:                   "} , \
	0x73 { "qlfsc_stale_target:                      "} , \
	0x74 { "qlfsc_init_dev_finish:                   "} , \
	0x75 { "qlfsc_send_els_pthru:                    "} , \
	0x76 { "qlfsc_build_ct_pthru:                    "} , \
	0x77 { "SDIODONE:                                "} , \
	0x78 { "qlfsc_plogi:                             "} , \
	0x79 { "qlfsc_send_login:                        "} , \
	0x7a { "qlfsc_clear_dev:                         "} , \
	0x7b { "qlfsc_send_target_reset:                 "} , \
	0x7c { "qlfsc_fail_scsi:                         "} , \
	0x7d { "qlfsc_fail_cmd:                          "} , \
	0x7e { "qlfsc_flush_pending_cmds:                "} , \
	0x7f { "qlfsc_dev_restart_iodone:                "} , \
	0x80 { "qlfsc_strategy:                          "} , \
	0x81 { "qlfsc_start:                             "} , \
	0x82 { "qlfsc_start_pending_cmds:                "} , \
	0x83 { "qlfsc_cmd_recv:                          "} , \
	0x84 { "qlfsc_npiv_build_admin_update_npiv:      "} , \
	0x85 { "qlfsc_process_scsi_elem:                 "} , \
	0x86 { "qlfsc_process_tskmgm_iocb:               "} , \
	0x87 { "qlfsc_process_tskmgm_iocb_error:         "} , \
	0x88 { "qlfsc_process_marker_elem:               "} , \
	0x89 { "qlfsc_recv:                              "} , \
	0x8a { "SCSIERROR:                               "} , \
	0x8b { "qlfsc_process_els_pthru_elem:            "} , \
	0x8c { "qlfsc_process_cancel_elem:               "} , \
	0x8d { "qlfsc_process_pdisc:                     "} , \
	0x8e { "qlfsc_process_relogin:                   "} , \
	0x8f { "qlfsc_process_ct_pthru:                  "} , \
	0x90 { "qlfsc_process_gid_pn:                    "} , \
	0x91 { "qlfsc_process_move_login:                "} , \
	0x92 { "qlfsc_process_task_mgm_cmds:             "} , \
	0x93 { "qlfsc_process_task_mgm_to:               "} , \
	0x94 { "qlfsc_process_cmd_error:                 "} , \
	0x95 { "qlfsc_process_fcp_status:                "} , \
	0x96 { "qlfsc_process_iocb_error:                "} , \
	0x97 { "qlfsc_cleanup_dev_cancel:                "} , \
	0x98 { "qlfsc_cleanup_target_cancel:             "} , \
	0x99 { "qlfsc_issue_adap_reset:                  "} , \
	0x9a { "qlfsc_issue_els_pthru:                   "} , \
	0x9b { "qlfsc_issue_ct_pthru:                    "} , \
	0x9c { "qlfsc_issue_gid_pn:                      "} , \
	0x9d { "qlfsc_issue_target_marker:               "} , \
	0x9e { "qlfsc_issue_lun_marker:                  "} , \
	0x9f { "qlfsc_dyntrk_failed:                     "} , \
	0xa0 { "qlfsc_issue_relogin:                     "} , \
	0xa1 { "qlfsc_log_err:                           "} , \
	0xa2 { "qlfsc_watchdog:                          "} , \
	0xa3 { "qlfsc_async_stat:                        "} , \
	0xa4 { "qlfsc_cdt_func:                          "} , \
	0xa5 { "qlfsc_move_devs:                         "} , \
	0xa6 { "qlfsc_issue_lun_cancel:                  "} , \
	0xa7 { "qlfsc_issue_target_cancel:               "} , \
	0xa8 { "qlfsc_issue_pdisc:                       "} , \
	0xa9 { "qlfsc_issue_target_reset:                "} , \
	0xaa { "qlfsc_issue_lun_reset:                   "} , \
	0xab { "qlfsc_issue_clear_aca:                   "} , \
	0xac { "qlfsc_issue_abt_tsk_set:                 "} , \
	0xad { "qlfsc_issue_move_login:                  "} , \
	0xae { "qlfsc_ioctl:                             "} , \
	0xaf { "qlfsc_alloc_spc_cmd_buf:                 "} , \
	0xb0 { "qlfsc_alloc_spc_els_buf:                 "} , \
	0xb1 { "qlfsc_alloc_spc_rsp_buf:                 "} , \
	0xb2 { "qlfsc_init_dev:                          "} , \
	0xb3 { "qlfsc_open:                              "} , \
	0xb4 { "qlfsc_dump:                              "} , \
	0xb5 { "qlfsc_dump_start:                        "} , \
	0xb6 { "qlfsc_dump_write:                        "} , \
	0xb7 { "qlfsc_select:                            "} , \
	0xb8 { "qlfsc_issue_abort_iocb:                  "} , \
	0xb9 { "qlfsc_npiv_scsi:                         "} , \
	0xba { "qlfsc_npiv_scsi_cancel:                  "} , \
	0xbb { "qlfsc_npiv_start_pending_cmds:           "} , \
	0xbc { "qlfsc_npiv_scsi_issue_cmd:               "} , \
	0xbd { "qlfsc_npiv_build_scsi_tm:                "} , \
	0xbe { "qlfsc_npiv_build_scsi_cmd:               "} , \
	0xbf { "qlfsc_npiv_admin:                        "} , \
	0xc0 { "qlfsc_npiv_admin_build_and_issue:        "} , \
	0xc1 { "qlfsc_npiv_admin_issue_cmd:              "} , \
	0xc2 { "qlfsc_init_initiator:                    "} , \
	0xc3 { "qlfsc_clear_initiator:                   "} , \
	0xc4 { "qlfsc_npiv_logout_target:                "} , \
	0xc5 { "qlfsc_clear_target:                      "} , \
	0xc6 { "qlfsc_npiv_cmd_recv:                     "} , \
	0xc7 { "qlfsc_npiv_recv:                         "} , \
	0xc8 { "qlfsc_build_fcp_rsp_from_iocb:           "} , \
	0xc9 { "qlfsc_npiv_async_stat:                   "} , \
	0xca { "qlfsc_npiv_send_async_stat:              "} , \
	0xcb { "qlfsc_npiv_map_status_admin:             "} , \
	0xcc { "qlfsc_npiv_map_status_prli:              "} , \
	0xcd { "qlfsc_npiv_map_status_scsi:              "} , \
	0xce { "qlfsc_npiv_build_scsi_crc2:              "} , \
	0xcf { "qlfsc_npiv_build_admin_ctiu:             "} , \
	0xd0 { "qlfsc_npiv_build_admin_els:              "} , \
	0xd1 { "qlfsc_issue_update_vport:                "} , \
	0xd2 { "qlfsc_process_update_vport:              "} , \
	0xd3 { "qlfsc_npiv_output:                       "} , \
	0xd4 { "qlfsc_npiv_admin_entry_fcn:              "} , \
	0xd5 { "qlfsc_offl_npiv_issue:                   "} , \
	0xd6 { "qlfsc_npiv_cmd_done:                     "} , \
	0xd7 { "qlfsc_offl_npiv_done:                    "} , \
	0xd8 { "qlfsc_npiv_build_scsi_marker:            "} , \
	0xd9 { "qlfsc_get_adap_stat:                     "} , \
	0xda { "qlfsc_ras_register_dev:                  "} , \
	0xdb { "qlfsc_ras_register_target:               "} , \
	0xdc { "qlfsc_npiv_build_scsi_iocancel:          "} , \
	0xdd { "qlfsc_npiv_build_cmd_elem_cancel:        "} , \
	0xde { "qlfsc_npiv_build_scsi_type6:             "} , \
	0xdf { "qlfsc_async_timeout:                     "} , \
	0xe0 { "qlfsc_link_down_initiators:              "} , \
	0xe1 { "qlfsc_npiv_build_scsi_prli:              "} , \
	0xe2 { "qlfsc_npiv_build_qlfsc_cmd_cancel:       "} , \
	0xe3 { "qlfsc_npiv_build_admin_move_login:       "} , \
	0xe4 { "qlfsc_npiv_build_admin_relogin:          "} , \
	0xe5 { "qlfsc_npiv_process_scsi_marker:          "} , \
	0xe6 { "qlfsc_npiv_process_scsi_iocancel:        "} , \
	0xe7 { "qlfsc_npiv_process_scsi_tm:              "} , \
	0xe8 { "qlfsc_npiv_process_scsi_prli:            "} , \
	0xe9 { "qlfsc_npiv_process_admin_relogin:        "} , \
	0xea { "qlfsc_npiv_process_admin_els:            "} , \
	0xeb { "qlfsc_npiv_process_admin_ctiu:           "} , \
	0xec { "qlfsc_npiv_process_admin_move_login:     "} , \
	0xed { "qlfsc_npiv_process_admin_update_npiv:    "} , \
	0xee { "qlfsc_npiv_process_admin_cancel:         "} , \
        0xef { "qlfsc_async_hard_fail:                   "} , \
        0xf0 { "qlfsc_async_dead_link:                   "} , \
        0xf1 { "qlfsc_async_link_down:                   "} , \
        0xf2 { "qlfsc_async_link_up:                     "} , \
        0xf3 { "qlfsc_async_plogi:                       "} , \
        0xf4 { "qlfsc_async_logo:                        "} , \
        0xf5 { "qlfsc_async_prli:                        "} , \
        0xf6 { "qlfsc_async_prlo:                        "} , \
        0xf7 { "qlfsc_async_lip:                         "} , \
        0xf8 { "qlfsc_async_rscn:                        "} , \
        0xf9 { "qlfsc_async_grp_dmn_scn:                 "} , \
        0xfa { "qlfsc_async_halt_reset_adap:             "} , \
        0xfb { "qlfsc_async_resume_adap:                 "} , \
        0xfc { "qlfsc_async_reset_adap_fail:             "} , \
        0xfd { "qlfsc_async_farp_request:                "} , \
        0xfe { "qlfsc_async_migrated:                    "}   \
    $typ, \
    0x0 { "Entry " $cnt%X1 XW XW XW XW XW } , \
    0x1 { "Trace " $cnt%X1 XW XW XW XW XW } , \
    0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }
63B 1.0 "FCDD_ERR" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3}} \
        {{ $cnt = B0.5}} \
        $loc, \
	0x28 { "qlfc_intr_reset_failure:                 "} , \
	0x29 { "qlfc_proto_reset_failure:                "} , \
	0x2a { "qlfc_proto_reset_success:                "} , \
        0x2b { "qlfc_proc_ae_event:                      "} , \
        0x2c { "qlfc_proc_ae_dd_notify:                  "} , \
        0x2d { "qlfc_proc_ae_lip_occurred:               "} , \
        0x2e { "qlfc_proc_ae_change_notification:        "} , \
        0x2f { "qlfc_proc_ae_req_resp_error:             "} , \
        0x30 { "qlfc_proc_ae_port_db_changed:            "} , \
        0x31 { "qlfc_proc_flash_access_mb:               "} , \
        0x32 { "qlfc_proc_dump_ram_mb:                   "} , \
        0x33 { "qlfc_proc_idc_ack_msg_mb:                "} , \
        0x34 { "qlfc_proc_get_dcbx_params_mb:            "} , \
        0x35 { "qlfc_proc_get_set_params_mb:             "} , \
        0x36 { "qlfc_proc_get_link_status_mb:            "} , \
        0x37 { "qlfc_proc_get_rps_rls_mb:                "} , \
        0x38 { "qlfc_proc_initiate_lip_mb:               "} , \
        0x39 { "qlfc_proc_idc_send_msg_mb:               "} , \
        0x3a { "qlfc_proc_adap_abort_io_iocb_err:        "} , \
        0x3b { "qlfc_proc_adap_modify_vp_cfg_iocb_err:   "} , \
        0x3c { "qlfc_proc_adap_rpt_id_acq_iocb_err:      "} , \
        0x3d { "qlfc_proc_adap_vp_ctl_iocb_err:          "} , \
        0x3e { "qlfc_proc_adap_mb_iocb_err:              "} , \
        0x3f { "qlfc_proc_adap_marker_iocb_err:          "} , \
        0x40 { "qlfc_proc_send_change_request_mb:        "} , \
        0x41 { "qlfc_proc_get_fcf_list_mb:               "} , \
        0x42 { "qlfc_proc_get_fcal_posmap_mb:            "} , \
        0x43 { "qlfc_proc_serdes_xmt_param_mb:           "} , \
        0x44 { "qlfc_proc_set_fw_options_mb:             "} , \
        0x45 { "qlfc_proc_verify_chksum_mb:              "} , \
        0x46 { "qlfc_proc_load_ram_mb:                   "} , \
        0x47 { "qlfc_proc_write_mpi_reg_mb:              "} , \
        0x48 { "qlfc_proc_restart_mpi_fw_mb:             "} , \
        0x49 { "qlfc_proc_get_data_rate_mb:              "} , \
        0x4a { "qlfc_proc_adap_nport_login_iocb:         "} , \
        0x4b { "qlfc_proc_adap_nport_logout_iocb:        "} , \
        0x4c { "qlfc_proc_adap_update_vport_iocb:        "} , \
        0x4d { "qlfc_proc_adap_log_in_out_iocb_err:      "} , \
        0x4e { "qlfc_proc_adap_ct_pthru_iocb_err:        "} , \
        0x4f { "qlfc_proc_adap_els_pthru_iocb_err:       "} , \
        0x50 { "qlfc_proc_get_port_list_mb:              "} , \
        0x51 { "qlfc_proc_get_id_mb:                     "} , \
        0x52 { "qlfc_proc_get_fw_state_mb:               "} , \
        0x53 { "qlfc_proc_init_firmware_mb:              "} , \
        0x54 { "qlfc_proc_about_firmware_mb:             "} , \
        0x55 { "qlfc_proc_execute_fw_mb:                 "} , \
	0x56 { "qlfc_find_cmd_handle:                    "} , \
	0x57 { "qlfc_find_pending_cmd_handle:            "} , \
	0x58 { "qlfc_find_active_cmd_handle:             "} , \
	0x59 { "qlfc_adapter_post:                       "} , \
	0x5a { "qlfc_init:                               "} , \
	0x5b { "qlfc_reset_mpi_disable:                  "} , \
	0x5c { "qlfc_write_mpi_reg_mb:                   "} , \
	0x5d { "qlfc_proc_offl_comp_q:                   "} , \
	0x5e { "qlfc_offlevel_q_isr:                     "} , \
	0x5f { "qlfc_abort_pending_cmd:                  "} , \
	0x60 { "qlfc_flush_pending_cmds_vport:           "} , \
	0x61 { "qlfc_flush_pending_cmds_nport_handle:    "} , \
	0x62 { "qlfc_flush_pending_ctlelem_nport_handle: "} , \
	0x63 { "qlfc_flush_pending_ctlelem_lun_id:       "} , \
	0x64 { "qlfc_get_fw_state_disable:               "} , \
	0x65 { "qlfc_mvlg_check_logo_new:                "} , \
	0x66 { "qlfc_mvlg_check_logo_old:                "} , \
	0x67 { "qlfc_mvlg_login_new:                     "} , \
	0x68 { "qlfc_get_fw_state_mb:                    "} , \
	0x69 { "qlfc_logout_all:                         "} , \
	0x6a { "qlfc_proc_adap_mb_iocb:                  "} , \
	0x6b { "qlfc_proc_login_collision:               "} , \
	0x6c { "qlfc_ctl_nport_logout:                   "} , \
	0x6d { "qlfc_ctl_npiv_clear:                     "} , \
	0x6e { "qlfc_build_els_pthru_iocb:               "} , \
	0x6f { "qlfc_create_login_response:              "} , \
	0x70 { "qlfc_build_abort_iocb:                   "} , \
	0x71 { "qlfc_about_firmware_mb:                  "} , \
	0x72 { "qlfc_add_login_tble:                     "} , \
	0x73 { "qlfc_async_status:                       "} , \
	0x74 { "qlfc_add_status:                         "} , \
	0x75 { "qlfc_build_cmd:                          "} , \
	0x76 { "qlfc_build_iocb:                         "} , \
	0x77 { "qlfc_build_mb:                           "} , \
	0x78 { "qlfc_verify_chksum_mb:                   "} , \
	0x79 { "qlfc_close:                              "} , \
	0x7a { "qlfc_cmd_fcn:                            "} , \
	0x7b { "qlfc_ctl:                                "} , \
	0x7c { "qlfc_ctl_nport_login:                    "} , \
	0x7d { "qlfc_hard_error:                         "} , \
	0x7e { "qlfc_ctl_dma_setup:                      "} , \
	0x7f { "qlfc_cdt_func:                           "} , \
	0x80 { "qlfc_watchdog:                           "} , \
	0x81 { "qlfc_build_ctiu_pthru_iocb:              "} , \
	0x82 { "qlfc_del_status:                         "} , \
	0x83 { "qlfc_cleanup:                            "} , \
	0x84 { "qlfc_del_login_tble:                     "} , \
	0x85 { "qlfc_check_slot:                         "} , \
	0x86 { "qlfc_diag_loop_back_mb:                  "} , \
	0x87 { "qlfc_diag_echo_test_mb:                  "} , \
	0x88 { "qlfc_dump_ram_mb:                        "} , \
	0x89 { "qlfc_download_fw_image:                  "} , \
	0x8a { "qlfc_early_cleanup:                      "} , \
	0x8b { "qlfc_execute_fw_mb:                      "} , \
	0x8c { "qlfc_erase_flash:                        "} , \
	0x8d { "qlfc_write_flash_image:                  "} , \
	0x8e { "qlfc_read_flash_image:                   "} , \
	0x8f { "qlfc_free_login_tble:                    "} , \
	0x90 { "qlfc_eeh_callback:                       "} , \
	0x91 { "qlfc_finish_adapter_post:                "} , \
	0x90 { "qlfc_eeh_callback:                       "} , \
	0x91 { "qlfc_finish_adapter_post:                "} , \
	0x92 { "qlfc_find_login_nport_id:                "} , \
	0x93 { "qlfc_find_login_ww_name:                 "} , \
	0x94 { "qlfc_flush_adap:                         "} , \
	0x95 { "qlfc_flush_adap_queue:                   "} , \
	0x96 { "qlfc_flush_queue:                        "} , \
	0x97 { "qlfc_find_login_nport_handle:            "} , \
	0x98 { "qlfc_get_lnk_stat_mb:                    "} , \
	0x99 { "qlfc_get_next_avail_nport_handle:        "} , \
	0x9a { "qlfc_build_get_pdb_mbiocb:               "} , \
	0x9b { "qlfc_start_gfws_delay:                   "} , \
	0x9c { "qlfc_gfws_delay_timer:                   "} , \
	0x9d { "qlfc_get_name_list_mb:                   "} , \
	0x9e { "qlfc_data_rate_mb:                       "} , \
	0x9f { "qlfc_get_id_mb:                          "} , \
	0xa0 { "qlfc_get_id_disable:                     "} , \
	0xa1 { "qlfc_issue_adap_pend:                    "} , \
	0xa2 { "qlfc_issue_proto_queue:                  "} , \
	0xa3 { "qlfc_issue_mb:                           "} , \
	0xa4 { "qlfc_issue_adap_pri:                     "} , \
	0xa5 { "qlfc_intr:                               "} , \
	0xa6 { "qlfc_proc_adap_iocb_err:                 "} , \
	0xa7 { "qlfc_initialize_fw_mb:                   "} , \
	0xa8 { "qlfc_initiate_lip_mb:                    "} , \
	0xa9 { "qlfc_get_rps_rls_mb:                     "} , \
	0xaa { "qlfc_mapdma_iocb:                        "} , \
	0xab { "qlfc_move_login:                         "} , \
	0xac { "qlfc_load_ram_mb:                        "} , \
	0xad { "qlfc_build_marker_iocb:                  "} , \
	0xae { "qlfc_add_filter:                         "} , \
	0xaf { "qlfc_del_filter:                         "} , \
	0xb0 { "qlfc_offlevel_isr:                       "} , \
	0xb1 { "qlfc_open:                               "} , \
	0xb2 { "qlfc_output:                             "} , \
	0xb3 { "qlfc_polling_timer:                      "} , \
	0xb4 { "qlfc_proc_flush_q:                       "} , \
	0xb5 { "qlfc_proc_proto_queue:                   "} , \
	0xb6 { "qlfc_proc_adap_queue:                    "} , \
	0xb7 { "qlfc_proc_link_down:                     "} , \
	0xb8 { "qlfc_proc_syserr:                        "} , \
	0xb9 { "qlfc_proc_mailbox:                       "} , \
	0xba { "qlfc_proc_adap_iocb:                     "} , \
	0xbb { "qlfc_proc_iocbs:                         "} , \
	0xbc { "qlfc_restart_adapter:                    "} , \
	0xbd { "qlfc_passthru_mb:                        "} , \
	0xbe { "qlfc_start_delay:                        "} , \
	0xbf { "qlfc_delay_timer:                        "} , \
	0xc0 { "qlfc_adp_reset_delay_timer:              "} , \
	0xc1 { "qlfc_read_nvram:                         "} , \
	0xc2 { "qlfc_get_flash_id:                       "} , \
	0xc3 { "qlfc_setup_and_load_riscram:             "} , \
	0xc4 { "qlfc_set_fw_options_mb:                  "} , \
	0xc5 { "qlfc_scn_request_mb:                     "} , \
	0xc6 { "qlfc_alloc_sglist:                       "} , \
	0xc7 { "qlfc_clear_sglist:                       "} , \
	0xc8 { "qlfc_start:                              "} , \
	0xc7 { "qlfc_clear_sglist:                       "} , \
	0xc8 { "qlfc_start:                              "} , \
	0xc9 { "qlfc_lnk_stat:                           "} , \
	0xca { "qlfc_unmapdma_iocb:                      "} , \
	0xcb { "qlfc_build_lilo_iocb:                    "} , \
	0xcc { "qlfc_get_alpa_map_mb:                    "} , \
	0xcd { "qlfc_link_dead_timer:                    "} , \
	0xce { "qlfc_proc_ae_linkup:                     "} , \
	0xcf { "qlfc_serdes_param_mb:                    "} , \
	0xd0 { "qlfc_init_adapter:                       "} , \
	0xd1 { "qlfc_write_flash_config:                 "} , \
	0xd2 { "qlfc_load_riscram:                       "} , \
	0xd3 { "qlfc_extract_risc_code:                  "} , \
	0xd4 { "qlfc_compare_risc_code:                  "} , \
	0xd5 { "qlfc_dump:                               "} , \
	0xd6 { "qlfc_dump_write:                         "} , \
	0xd7 { "qlfc_dmp_issue_queue:                    "} , \
	0xd8 { "qlfc_dump_intr:                          "} , \
	0xd9 { "qlfc_dump_time_out:                      "} , \
	0xda { "qlfc_dump_process_mb_cmplt:              "} , \
	0xdb { "qlfc_dump_process_async_event:           "} , \
	0xdc { "qlfc_dump_process_link_down:             "} , \
	0xdd { "qlfc_getset_param:                       "} , \
	0xde { "qlfc_getset_param_dis:                   "} , \
	0xdf { "qlfc_get_fcf_list_mb:                    "} , \
	0xe0 { "qlfc_get_dcbx_param_mb:                  "} , \
	0xe1 { "qlfc_restart_mpi_fw_mb:                  "} , \
	0xe2 { "qlfc_send_idc_mb:                        "} , \
	0xe3 { "qlfc_idc_ack_mb:                         "} , \
	0xe4 { "qlfc_ns_relogin:                         "} , \
	0xe5 { "qlfc_get_flt_addr:                       "} , \
	0xe6 { "qlfc_check_devid_image:                  "} , \
	0xe7 { "qlfc_check_for_rmw_region:               "} , \
	0xe8 { "qlfc_check_for_rmw:                      "} , \
	0xe9 { "qlfc_validate_ucode_image:               "} , \
	0xea { "qlfc_setup_fw_buffers:                   "} , \
	0xeb { "qlfc_read_mod_write_region:              "} , \
	0xec { "qlfc_read_mod_write_flash:               "} , \
	0xed { "qlfc_upd_image_version:                  "} , \
	0xee { "qlfc_search_flt_region:                  "} , \
	0xef { "qlfc_find_vpd_field:                     "} , \
	0xf0 { "qlfc_compare_upd_vpd:                    "} , \
	0xf1 { "qlfc_extract_flash_info:                 "} , \
	0xf2 { "qlfc_flash_access_ctrl_mb:               "} , \
	0xf3 { "qlfc_flash_access_control:               "} , \
	0xf4 { "qlfc_proc_exec_fw:                       "} , \
	0xf5 { "qlfc_upd_vpd_checksum:                   "} , \
	0xf6 { "qlfc_build_modify_vp_cfg_iocb:           "} , \
	0xf7 { "qlfc_build_vp_control_iocb:              "} , \
	0xf8 { "qlfc_add_vport:                          "} , \
	0xf9 { "qlfc_del_vport:                          "} , \
	0xfa { "qlfc_find_vport_nport_id:                "} , \
	0xfb { "qlfc_find_vport_vp_index:                "} , \
	0xfc { "qlfc_find_vport_ww_name:                 "} , \
	0xfd { "qlfc_ctl_npiv_setup:                     "} , \
	0xfe { "qlfc_find_update_vport_cmd:              "} , \
	0xff { "qlfc_proc_rpt_id_acq_iocb:               "}   \
    $typ, \
    0x0 { "Entry " $cnt%X1 XW XW XW XW XW } , \
    0x1 { "Trace " $cnt%X1 XW XW XW XW XW } , \
    0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }

5A8 1.0 "QFCADD" \
        $DD1
5A9 1.0 "QFCPDD" \
        $DD1
40A 1.0 "@STTY JAS" \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "jas" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000E "flush ", \
	000F "ctl ", \
	0010 "termios_set ", \
	0011 "termios_get ", \
	0012 "termiox_set ", \
	0013 "termiox_get ", \
	0014 "break_set ", \
	0015 "break_clear ", \
	0016 "add_adap ", \
	0017 "del_adap ", \
	0018 "allocmsg ", \
	0019 "recover ", \
	001A "timeout ", \
	001B "allocmflush ", \
	001C "mflush_recover ", \
	001D "mflush_timeout ", \
	001E "add_port ", \
	001F "del_port ", \
	0020 "pci_qry_vpd ", \
	0021 "cleanup ", \
	0022 "pci_read ", \
	0023 "pci_write ", \
	0024 "setpci ", \
	0025 "getchars ", \
	0026 "setup_break_clear ", \
	0027 "getmodem ", \
	0028 "check_temt ", \
        0029 "end_of_drain ", \
        002A "freemsg ", \
        002B "allocb ", \
        002C "reset_bd ", \
        002D "reset_port ", \
        002E "kill_apps ", \
        002F "bd2mem_spec ", \
        0030 "err_adpfail ", \
        0031 "failadap ", \
        0032 "eeh_check ", \
        0033 "eeh_callback ", \
        0034 "eeprom_out ", \
        0035 "jas_qry_vpd " \
	$how, \
	0000 { $which, \
		0009 { "ptr" $D2%XW "cmd" ioctlname($D3) }, \
		000E { "rw" BITFLAGS $D3, 1 "read", 2 "write" }, \
		000F { "cmd" ioctlname($D3) }, \
		0010 { "cflag" $D3%XW "iflag" $D4%XW "start/stop" $D5%X2 }, \
		0011 { }, \
		0012 { "hflag" $D3%XW }, \
		0013 { }, \
		0014 { duration $D3%DW }, \
		0015 { }, \
		0016 { "dev" $D3%XW }, \
		0017 { "dev" $D3%XW }, \
		0018 { }, \
		0019 { }, \
		001A { }, \
		001B { }, \
		001C { }, \
		001D { }, \
		001E { "dev" $D3%XW "dds" $D3%XW }, \
		001F { "dev" $D3%XW }, \
		0020 { "dev" $D3%XW "uiop" $D4%XW }, \
		0021 { "dev" $D3%XW "depth" $D3%D4 }, \
		0022 { }, \
		0023 { }, \
		0024 { }, \
		0025 { "port" $D3%XW "rsp" $D4%XW "count" $D5%DW }, \
		0026 { }, \
		0027 { "port" $D3%XW "rsp" $D4%XW }, \
		0028 { }, \
                0029 { }, \
                002A { }, \
                002B { }, \
                002C { }, \
                002D { }, \
                002E { }, \
                002F { "bd" $D3%XW "flag" $D4%DW }, \
                0030 { }, \
                0031 { }, \
                0032 { "bd" $D4%XW }, \
                0033 { "cmd" $D4%XW "dds_ptr" $D5%XW "flag" $D6%DW }, \
		0034 { "vaddr" $D3%XW "byte" $D4%X1 }, \
		0035 { "dev" $D3%XW "uiop" $D4%XW } \
	     }, \
	0001 { "DATA" $D3%XW $D4%XW $D5%XW }, \
        0002 { $which, \
		0018 { "ret" $D3 "from line" $D4%DW }, \
                002F { "ret" $D3%XW "from line" $D4%DW }, \
		\* { "ret" $D3%DW "from line" $D4%DW } \
	     }, \
	0003 { $D3, \
		0000 { "break at line" $D4%DW }, \
		0001 { "continue at line" $D4%DW }, \
		0002 { "goto from line" $D4%DW } \
	     }
3A9 1.0 "@dpmpdd" \
        "PCI HDLC DD XMT: " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3AA 1.0 "@dpmpdd" \
        "PCI HDLC DD RCV: " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3AB 1.0 "@dpmpdd" \
        "PCI HDLC DD GEN: " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
4FA 1.0 L=KERN "USB_EHCI " \
    $HD%D2, \
    681 {"EHCI_stray_getFrame_0"}, \
    682 {"EHCI_stray_pipeAbort_0"}, \
    683 {"EHCI_stray_pipeAddIOB_0"}, \
    684 {"EHCI_stray_pipeClear_0"}, \
    685 {"EHCI_stray_pipeConnect_0"}, \
    686 {"EHCI_stray_pipeDisconnect_0"}, \
    687 {"EHCI_stray_pipeHalt_0"}, \
    688 {"EHCI_stray_pipeIO_0"}, \
    689 {"EHCI_stray_pipeResetToggle_0"}, \
    690 {"EHCI_stray_pipeStatus_0"}, \
    691 {"EHCI_stray_shutdownComplete_0"}, \
    692 {"EHCI_stray_unregisterHC_0"}, \
    445 {"abort_all_iobs_0" $D1%XW}, \
    446 {"abort_all_iobs_1" $D1%XW}, \
    447 {"abort_all_iobs_2" $D1%XW}, \
    241 {"cancel_port_reset_timer_0"}, \
    242 {"cancel_port_reset_timer_1"}, \
    243 {"cancel_port_reset_timer_2"}, \
    244 {"cancel_port_reset_timer_3"}, \
    245 {"cancel_port_reset_timer_ie_0"}, \
    246 {"cancel_port_reset_timer_ie_1"}, \
    247 {"cancel_port_reset_timer_ie_2"}, \
    248 {"cancel_port_reset_timer_ie_3"}, \
    723 {"cancel_sleep_timer_0"}, \
    724 {"cancel_sleep_timer_1"}, \
    15 {"cancel_watchdog_0"}, \
    16 {"cancel_watchdog_1"}, \
    725 {"cancel_watchdog_2"}, \
    17 {"cancel_watchdog_interrupt_0"}, \
    18 {"cancel_watchdog_interrupt_1"}, \
    726 {"cancel_watchdog_interrupt_2"}, \
    19 {"cold_start_with_wait_0"}, \
    25 {"cold_start_with_wait_1"}, \
    26 {"cold_start_with_wait_2"}, \
    655 {"configure_eeh_0"}, \
    656 {"configure_eeh_1"}, \
    702 {"configure_interrupts_A_0"}, \
    703 {"configure_interrupts_A_1"}, \
    704 {"configure_interrupts_B_0"}, \
    705 {"configure_interrupts_B_1"}, \
    602 {"configure_pci_config_registers_0"}, \
    603 {"configure_pci_config_registers_1"}, \
    249 {"configure_port_reset_timer_0"}, \
    727 {"configure_sleep_timer_0"}, \
    728 {"configure_watchdog_0"}, \
    607 {"debug_busMap_0"}, \
    608 {"debug_postIOB_0" $D1%XW $D2%XW}, \
    609 {"debug_postIOB_1" $D1%XW}, \
    610 {"debug_reqHCrestart_0"}, \
    611 {"debug_reqHCshutdown_0"}, \
    612 {"debug_reqHCunregister_0"}, \
    613 {"debug_unBusMap_0"}, \
    250 {"device_init_0"}, \
    251 {"device_init_1"}, \
    252 {"device_init_2"}, \
    253 {"device_init_3"}, \
    254 {"device_init_4"}, \
    255 {"device_init_5"}, \
    256 {"device_init_6"}, \
    257 {"device_init_7"}, \
    258 {"device_init_8"}, \
    259 {"device_init_9"}, \
    260 {"device_init_10"}, \
    261 {"device_init_11"}, \
    262 {"device_init_12"}, \
    263 {"device_init_13"}, \
    104 {"device_init_14"}, \
    265 {"device_init_15"}, \
    0 {"device_init_16" $D1%XW $D2%XW}, \
    1 {"device_init_17" $D1%XW $D2%XW}, \
    2 {"device_term_0"}, \
    3 {"device_term_1" $D1%XW}, \
    4 {"device_term_2"}, \
    5 {"device_term_3"}, \
    6 {"device_term_4"}, \
    7 {"device_term_5"}, \
    507 {"device_term_6"}, \
    508 {"device_term_7"}, \
    509 {"device_term_8" $D1%XW}, \
    510 {"device_term_9"}, \
    511 {"device_term_10"}, \
    512 {"device_term_11"}, \
    513 {"device_term_12"}, \
    514 {"device_term_13"}, \
    515 {"device_term_14"}, \
    516 {"device_term_15" $D1%XW $D2%XW}, \
    517 {"device_term_16" $D1%XW $D2%XW}, \
    518 {"device_term_17"}, \
    594 {"ehcd_QHh_free_0"}, \
    595 {"ehcd_QHh_free_1"}, \
    596 {"ehcd_QHh_free_2"}, \
    597 {"ehcd_QHh_new_0"}, \
    598 {"ehcd_QHh_new_1"}, \
    175 {"ehcd_delete_a_pipe_0" $D1%XW}, \
    714 {"ehcd_delete_a_pipe_1"}, \
    599 {"ehcd_iTD_free_0"}, \
    167 {"ehcd_pipeConnect_body_0"}, \
    168 {"ehcd_pipeConnect_body_1"}, \
    169 {"ehcd_pipeConnect_body_2"}, \
    170 {"ehcd_pipeConnect_body_3"}, \
    171 {"ehcd_pipeConnect_body_4" $D1%XW}, \
    172 {"ehcd_pipeConnect_body_5" $D1%XW}, \
    173 {"ehcd_pipeConnect_body_6"}, \
    174 {"ehcd_pipeConnect_body_7" $D1%XW}, \
    497 {"ehcd_pipeConnect_body_8"}, \
    176 {"ehcd_pipeConnect_body_9" $D1%XW}, \
    498 {"ehcd_pipeConnect_body_10"}, \
    420 {"ehcd_pipeConnect_body_11"}, \
    435 {"ehcd_pipe_abort_0" $D1%XW}, \
    436 {"ehcd_pipe_abort_1"}, \
    565 {"ehcd_pipe_abort_2"}, \
    566 {"ehcd_pipe_abort_3"}, \
    567 {"ehcd_pipe_abort_4"}, \
    589 {"ehcd_pipe_abort_5"}, \
    715 {"ehcd_pipe_abort_6"}, \
    716 {"ehcd_pipe_abort_7"}, \
    717 {"ehcd_pipe_abort_8"}, \
    718 {"ehcd_pipe_abort_9"}, \
    719 {"ehcd_pipe_abort_10"}, \
    720 {"ehcd_pipe_abort_11"}, \
    469 {"ehcd_pipe_initialize_0"}, \
    470 {"ehcd_pipe_initialize_1"}, \
    471 {"ehcd_pipe_initialize_2"}, \
    472 {"ehcd_pipe_initialize_3"}, \
    473 {"ehcd_pipe_initialize_4"}, \
    474 {"ehcd_pipe_initialize_5"}, \
    475 {"ehcd_pipe_initialize_6"}, \
    476 {"ehcd_pipe_initialize_7"}, \
    477 {"ehcd_pipe_initialize_8"}, \
    478 {"ehcd_pipe_initialize_9"}, \
    479 {"ehcd_pipe_initialize_10"}, \
    480 {"ehcd_pipe_initialize_11"}, \
    481 {"ehcd_pipe_initialize_12"}, \
    482 {"ehcd_pipe_initialize_13"}, \
    483 {"ehcd_pipe_initialize_14"}, \
    105 {"ehcd_pipe_initialize_15"}, \
    106 {"ehcd_pipe_initialize_16"}, \
    486 {"ehcd_pipe_initialize_17" $D1%XW}, \
    107 {"ehcd_pipe_initialize_18"}, \
    457 {"ehcd_pipe_initialize_19" $D1%XW}, \
    108 {"ehcd_pipe_initialize_20"}, \
    487 {"ehcd_pipe_uninitialize_0"}, \
    109 {"ehcd_pipe_uninitialize_1"}, \
    110 {"ehcd_pipe_uninitialize_2"}, \
    111 {"ehcd_pipe_uninitialize_3"}, \
    112 {"ehcd_pipe_uninitialize_4"}, \
    563 {"ehcd_process_done_0"}, \
    564 {"ehcd_process_done_1"}, \
    236 {"ehcd_process_done_2"}, \
    600 {"ehcd_qTD_free_0"}, \
    601 {"ehcd_siTD_free_0"}, \
    463 {"ehcd_unlink_periodic_0"}, \
    464 {"ehcd_unlink_periodic_1"}, \
    465 {"ehcd_unlink_periodic_2"}, \
    499 {"ehci_core_config_0"}, \
    500 {"ehci_core_config_1"}, \
    501 {"ehci_core_config_2"}, \
    502 {"ehci_core_config_3"}, \
    503 {"ehci_core_config_4"}, \
    504 {"ehci_core_config_5"}, \
    505 {"ehci_core_config_6"}, \
    506 {"ehci_core_config_7" $D1%XW}, \
    519 {"ehci_core_init_0"}, \
    520 {"ehci_core_term_0"}, \
    521 {"ehci_ds_init_0"}, \
    522 {"ehci_ds_term_0"}, \
    523 {"ehci_ds_term_1"}, \
    27 {"enter_operational_state_0"}, \
    28 {"enter_operational_state_1"}, \
    29 {"enter_operational_state_2"}, \
    30 {"enter_operational_state_3"}, \
    14 {"error_log_0" $D1%XW}, \
    20 {"error_log_dp_0"}, \
    21 {"error_log_dp_u32x3_0"}, \
    22 {"error_log_dt_0"}, \
    23 {"error_log_sp_0"}, \
    24 {"error_log_st_0"}, \
    410 {"error_log_st_u32x2_0"}, \
    8 {"estimate_bw_and_TT_0"}, \
    9 {"estimate_bw_and_TT_1" $D1%XW}, \
    11 {"estimate_bw_and_TT_2" $D1%XW}, \
    12 {"estimate_bw_and_TT_node_0"}, \
    13 {"estimate_bw_and_TT_node_and_parents_0"}, \
    427 {"estimate_bw_and_TT_node_and_parents_1" $D1%XW}, \
    428 {"estimate_bw_and_TT_node_and_parents_2" $D1%XW}, \
    552 {"estimate_bw_and_TT_node_and_parents_3" $D1%XW}, \
    32 {"fake_control_sequence_in_0"}, \
    33 {"fake_control_sequence_in_1"}, \
    34 {"fake_control_sequence_in_2"}, \
    35 {"fake_control_sequence_in_3"}, \
    36 {"fake_control_sequence_in_4" $D1%XW}, \
    87 {"fake_control_sequence_in_5" $D1%XW}, \
    88 {"fake_control_sequence_in_6" $D1%XW}, \
    91 {"fake_control_sequence_in_7" $D1%XW}, \
    93 {"fake_control_sequence_in_8" $D1%XW}, \
    95 {"fake_control_sequence_in_9" $D1%XW}, \
    97 {"fake_control_sequence_in_10" $D1%XW}, \
    621 {"fake_control_sequence_in_11" $D1%XW}, \
    622 {"fake_control_sequence_in_12" $D1%XW}, \
    623 {"fake_control_sequence_in_13"}, \
    624 {"fake_control_sequence_in_14"}, \
    625 {"fake_control_sequence_in_15"}, \
    626 {"fake_control_sequence_in_16"}, \
    339 {"fake_control_sequence_setup_only_0"}, \
    340 {"fake_control_sequence_setup_only_1"}, \
    341 {"fake_control_sequence_setup_only_2"}, \
    342 {"fake_control_sequence_setup_only_3"}, \
    343 {"fake_control_sequence_setup_only_4"}, \
    344 {"fake_control_sequence_setup_only_5"}, \
    345 {"fake_control_sequence_setup_only_6"}, \
    346 {"fake_control_sequence_setup_only_7"}, \
    347 {"fake_control_sequence_setup_only_8"}, \
    348 {"fake_control_sequence_setup_only_9"}, \
    349 {"fake_control_sequence_setup_only_10"}, \
    350 {"fake_control_sequence_setup_only_11"}, \
    351 {"fake_control_sequence_setup_only_12"}, \
    352 {"fake_control_sequence_setup_only_13"}, \
    353 {"fake_control_sequence_setup_only_14"}, \
    354 {"fake_control_sequence_setup_only_15"}, \
    355 {"fake_control_sequence_setup_only_16"}, \
    356 {"fake_control_sequence_setup_only_17"}, \
    357 {"fake_control_sequence_setup_only_18"}, \
    358 {"fake_control_sequence_setup_only_19"}, \
    359 {"fake_control_sequence_setup_only_20"}, \
    360 {"fake_control_sequence_setup_only_21"}, \
    361 {"fake_control_sequence_setup_only_22"}, \
    362 {"fake_control_sequence_setup_only_23"}, \
    627 {"fake_interrupt_in_0"}, \
    628 {"fake_interrupt_in_1"}, \
    629 {"fake_interrupt_in_2"}, \
    630 {"fake_interrupt_in_3"}, \
    631 {"fake_interrupt_in_4" $D1%XW}, \
    632 {"fake_interrupt_in_5" $D1%XW}, \
    633 {"fake_interrupt_in_6" $D1%XW}, \
    634 {"fake_interrupt_in_7" $D1%XW}, \
    635 {"fake_interrupt_in_8" $D1%XW}, \
    636 {"fake_interrupt_in_9" $D1%XW}, \
    637 {"fake_interrupt_in_10" $D1%XW}, \
    638 {"fake_interrupt_in_11"}, \
    639 {"fake_interrupt_in_12"}, \
    640 {"fake_interrupt_in_13"}, \
    553 {"find_start_high_interrupt_0"}, \
    554 {"find_start_high_interrupt_1" $D1%XW}, \
    555 {"find_start_high_interrupt_2" $D1%XW}, \
    573 {"find_start_multimicro_0"}, \
    574 {"find_start_multimicro_1"}, \
    575 {"find_start_multimicro_2" $D1%XW}, \
    556 {"find_start_split_interrupt_0"}, \
    557 {"find_start_split_interrupt_1" $D1%XW}, \
    558 {"find_start_split_interrupt_2" $D1%XW}, \
    576 {"find_start_split_isochronous_0"}, \
    577 {"find_start_split_isochronous_1" $D1%XW}, \
    31 {"get_op_parms_0"}, \
    37 {"hcd_blind_stop_0"}, \
    10 {"hcd_close_validated_0"}, \
    429 {"hcd_close_validated_1"}, \
    430 {"hcd_close_validated_2"}, \
    641 {"hcd_debug_ioctl_0"}, \
    642 {"hcd_debug_ioctl_1" $D1%XW}, \
    643 {"hcd_debug_ioctl_2" $D1%XW}, \
    644 {"hcd_debug_ioctl_3" $D1%XW}, \
    645 {"hcd_debug_ioctl_4" $D1%XW}, \
    646 {"hcd_debug_ioctl_5" $D1%XW}, \
    647 {"hcd_debug_ioctl_6" $D1%XW}, \
    392 {"hcd_debug_keyword_0"}, \
    393 {"hcd_debug_keyword_1"}, \
    394 {"hcd_debug_keyword_2"}, \
    395 {"hcd_debug_keyword_3"}, \
    396 {"hcd_debug_keyword_4"}, \
    397 {"hcd_debug_keyword_5"}, \
    398 {"hcd_debug_keyword_6"}, \
    399 {"hcd_debug_keyword_7"}, \
    400 {"hcd_debug_keyword_8"}, \
    401 {"hcd_debug_keyword_9"}, \
    402 {"hcd_debug_keyword_10"}, \
    403 {"hcd_debug_keyword_11"}, \
    404 {"hcd_debug_keyword_12"}, \
    405 {"hcd_debug_keyword_13"}, \
    406 {"hcd_debug_keyword_14"}, \
    407 {"hcd_debug_keyword_15"}, \
    408 {"hcd_debug_keyword_16"}, \
    409 {"hcd_debug_keyword_17"}, \
    614 {"hcd_debug_register_0"}, \
    615 {"hcd_debug_register_1"}, \
    616 {"hcd_debug_register_2"}, \
    617 {"hcd_debug_register_3"}, \
    618 {"hcd_debug_register_4"}, \
    648 {"hcd_debug_reset_0"}, \
    379 {"hcd_debug_transfer_0"}, \
    380 {"hcd_debug_transfer_1"}, \
    381 {"hcd_debug_transfer_2"}, \
    382 {"hcd_debug_transfer_3"}, \
    383 {"hcd_debug_transfer_4"}, \
    384 {"hcd_debug_transfer_5"}, \
    385 {"hcd_debug_transfer_6"}, \
    386 {"hcd_debug_transfer_7"}, \
    387 {"hcd_debug_transfer_8"}, \
    388 {"hcd_debug_transfer_9"}, \
    389 {"hcd_debug_transfer_10"}, \
    390 {"hcd_debug_transfer_11"}, \
    391 {"hcd_debug_transfer_12"}, \
    649 {"hcd_debug_unregister_0"}, \
    650 {"hcd_debug_unregister_1"}, \
    651 {"hcd_debug_unregister_2"}, \
    652 {"hcd_debug_unregister_3"}, \
    653 {"hcd_debug_unregister_4"}, \
    99 {"hcd_eeh_adapter_dead_0"}, \
    100 {"hcd_eeh_adapter_dead_1"}, \
    663 {"hcd_eeh_check_slot_0"}, \
    664 {"hcd_eeh_check_slot_1"}, \
    141 {"hcd_eeh_shutdown_complete_0"}, \
    145 {"hcd_eeh_stop_operations_0"}, \
    146 {"hcd_eeh_stop_timer_0"}, \
    147 {"hcd_eeh_stop_timer_1"}, \
    666 {"hcd_eeh_stop_timer_2"}, \
    148 {"hcd_eeh_stop_timer_ie_0"}, \
    149 {"hcd_eeh_stop_timer_ie_1"}, \
    667 {"hcd_eeh_stop_timer_ie_2"}, \
    310 {"hcd_free_iobh_list_0"}, \
    311 {"hcd_free_iobh_list_1"}, \
    312 {"hcd_free_iobh_list_2"}, \
    721 {"hcd_free_iobh_list_3"}, \
    722 {"hcd_free_iobh_list_4"}, \
    524 {"hcd_lookup_device_0"}, \
    654 {"hcd_no_op_shutdown_complete_0"}, \
    431 {"hcd_open_validated_0"}, \
    432 {"hcd_open_validated_1" $D1%XW}, \
    433 {"hcd_open_validated_2"}, \
    434 {"hcd_open_validated_3"}, \
    177 {"hcd_register_0"}, \
    178 {"hcd_register_1"}, \
    179 {"hcd_register_2"}, \
    180 {"hcd_register_3" $D1%XW}, \
    181 {"hcd_register_4"}, \
    182 {"hcd_register_5"}, \
    113 {"hcd_register_6"}, \
    183 {"hcd_register_body_0"}, \
    184 {"hcd_register_body_1"}, \
    185 {"hcd_register_body_2"}, \
    186 {"hcd_register_body_3"}, \
    187 {"hcd_register_body_4" $D1%XW}, \
    287 {"hcd_rh_port_GET_STATUS_0" $D1%XW}, \
    288 {"hcd_rh_port_GET_STATUS_1"}, \
    301 {"hcd_rh_port_GET_STATUS_2" $D1%XW}, \
    302 {"hcd_rh_port_GET_STATUS_3"}, \
    276 {"hcd_rh_process_status_change_0"}, \
    277 {"hcd_rh_process_status_change_1"}, \
    278 {"hcd_rh_process_status_change_2"}, \
    279 {"hcd_rh_process_status_change_3"}, \
    280 {"hcd_rh_process_status_change_4"}, \
    281 {"hcd_rh_process_status_change_5"}, \
    282 {"hcd_rh_process_status_change_6"}, \
    39 {"hcd_rh_set_PORT_RESET_0" $D1%XW $D2%XW}, \
    40 {"hcd_rh_set_PORT_RESET_1" $D1%XW $D2%XW $D3%XW}, \
    289 {"hcd_rh_set_PORT_RESET_2"}, \
    290 {"hcd_rh_set_PORT_RESET_3"}, \
    188 {"hcd_root_hub_control_DEVICE_0"}, \
    189 {"hcd_root_hub_control_DEVICE_1"}, \
    190 {"hcd_root_hub_control_DEVICE_2"}, \
    191 {"hcd_root_hub_control_DEVICE_STAND_0"}, \
    192 {"hcd_root_hub_control_DEVICE_STAND_1" $D1%XW}, \
    193 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_0"}, \
    194 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_1"}, \
    195 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_2"}, \
    196 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_3"}, \
    197 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_4"}, \
    198 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_5"}, \
    199 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_6"}, \
    200 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_7"}, \
    201 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_8"}, \
    202 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_9"}, \
    203 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_10"}, \
    204 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_11"}, \
    205 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_12"}, \
    206 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_13"}, \
    207 {"hcd_root_hub_control_DEVICE_STAND_GET_DESCRIPTOR_14" $D1%XW}, \
    208 {"hcd_root_hub_control_endpoint_0"}, \
    209 {"hcd_root_hub_control_endpoint_1"}, \
    210 {"hcd_root_hub_control_endpoint_2"}, \
    211 {"hcd_root_hub_control_endpoint_3"}, \
    212 {"hcd_root_hub_control_setup_0"}, \
    213 {"hcd_root_hub_control_setup_1"}, \
    214 {"hcd_root_hub_control_setup_2" $D1%XW}, \
    215 {"hcd_root_hub_request_0"}, \
    216 {"hcd_root_hub_request_1"}, \
    217 {"hcd_root_hub_request_2"}, \
    218 {"hcd_root_hub_request_3"}, \
    219 {"hcd_root_hub_request_4"}, \
    220 {"hcd_root_hub_request_5"}, \
    41 {"hcd_sr_cleanup_0"}, \
    42 {"hcd_sr_cleanup_1"}, \
    43 {"hcd_sr_cleanup_2"}, \
    44 {"hcd_sr_cleanup_3"}, \
    45 {"hcd_sr_cleanup_4"}, \
    46 {"hcd_sr_cleanup_5"}, \
    47 {"hcd_sr_cleanup_6"}, \
    48 {"hcd_sr_cleanup_7"}, \
    49 {"hcd_sr_cleanup_8" $D1%XW}, \
    50 {"hcd_sr_cleanup_9"}, \
    150 {"hcd_sr_cleanup_10"}, \
    53 {"hcd_sr_shutdown_complete_0"}, \
    58 {"hcd_sr_software_reset_from_interrupt_0"}, \
    59 {"hcd_sr_software_reset_from_interrupt_1"}, \
    60 {"hcd_sr_software_reset_from_interrupt_2"}, \
    62 {"hcd_sr_software_reset_from_interrupt_4"}, \
    63 {"hcd_sr_software_reset_from_interrupt_5"}, \
    64 {"hcd_sr_software_reset_from_interrupt_6"}, \
    65 {"hcd_sr_software_reset_from_interrupt_7"}, \
    66 {"hcd_sr_software_reset_from_interrupt_8"}, \
    67 {"hcd_sr_software_reset_from_interrupt_9"}, \
    70 {"hcd_sr_start_software_reset_0"}, \
    71 {"hcd_sr_start_software_reset_1"}, \
    72 {"hcd_sr_start_software_reset_2"}, \
    73 {"hcd_sr_stop_operations_0"}, \
    74 {"hcd_sr_stop_timer_0"}, \
    75 {"hcd_sr_stop_timer_1"}, \
    76 {"hcd_sr_stop_timer_2"}, \
    77 {"hcd_sr_stop_timer_interrupt_0"}, \
    78 {"hcd_sr_stop_timer_interrupt_1"}, \
    79 {"hcd_sr_stop_timer_interrupt_2"}, \
    221 {"hcd_warm_initialize_0"}, \
    222 {"hcd_warm_initialize_1" $D1%XW}, \
    223 {"hcd_warm_preop_0"}, \
    224 {"hcd_warm_preop_1" $D1%XW}, \
    225 {"hcd_warm_preop_2" $D1%XW}, \
    730 {"hcd_warm_uninitialize_0"}, \
    710 {"infrastructure_allocate_0"}, \
    711 {"infrastructure_allocate_1"}, \
    450 {"insert_periodic_0"}, \
    80 {"leave_operational_state_0"}, \
    451 {"make_reverse_links_0"}, \
    314 {"perform_doorbell_sequence_0"}, \
    315 {"perform_doorbell_sequence_1"}, \
    316 {"perform_doorbell_sequence_2"}, \
    317 {"perform_doorbell_sequence_3"}, \
    318 {"perform_doorbell_sequence_4"}, \
    319 {"perform_doorbell_sequence_5"}, \
    320 {"perform_doorbell_sequence_6"}, \
    322 {"perform_doorbell_sequence_8" $D1%XW}, \
    324 {"perform_doorbell_sequence_10"}, \
    325 {"perform_doorbell_sequence_11"}, \
    326 {"perform_doorbell_sequence_12"}, \
    327 {"perform_doorbell_sequence_13"}, \
    328 {"perform_doorbell_sequence_14"}, \
    329 {"perform_doorbell_sequence_15"}, \
    330 {"perform_doorbell_sequence_16"}, \
    365 {"periodic_allocate_0"}, \
    366 {"periodic_allocate_1"}, \
    367 {"periodic_allocate_2"}, \
    579 {"periodic_allocate_3"}, \
    580 {"periodic_allocate_4"}, \
    368 {"periodic_deallocate_0"}, \
    369 {"periodic_deallocate_1"}, \
    370 {"periodic_deallocate_2"}, \
    581 {"periodic_deallocate_3"}, \
    582 {"periodic_deallocate_4"}, \
    712 {"periodic_down_0"}, \
    226 {"periodic_up_0"}, \
    227 {"periodic_up_1"}, \
    228 {"periodic_up_2"}, \
    229 {"periodic_up_3"}, \
    230 {"periodic_up_4"}, \
    231 {"periodic_up_5"}, \
    232 {"periodic_up_6"}, \
    233 {"periodic_up_7"}, \
    234 {"periodic_up_8"}, \
    713 {"periodic_up_9"}, \
    303 {"pipe_IO_single_request_high_asynchronous_0"}, \
    305 {"pipe_IO_single_request_high_asynchronous_1"}, \
    331 {"pipe_IO_single_request_high_asynchronous_2" $D1%XW}, \
    332 {"pipe_IO_single_request_high_asynchronous_3" $D1%XW}, \
    333 {"pipe_IO_single_request_high_interrupt_0"}, \
    334 {"pipe_IO_single_request_high_interrupt_1"}, \
    335 {"pipe_IO_single_request_high_interrupt_2" $D1%XW}, \
    306 {"pipe_IO_single_request_high_isochronous_0"}, \
    578 {"pipe_IO_single_request_split_isochronous_0"}, \
    309 {"pipe_extract_transaction_high_isochronous_0"}, \
    583 {"pipe_extract_transaction_split_isochronous_0"}, \
    336 {"pipe_initialize_emulated_0"}, \
    337 {"pipe_initialize_emulated_2"}, \
    338 {"pipe_initialize_high_asynchronous_0"}, \
    371 {"pipe_initialize_high_asynchronous_1"}, \
    372 {"pipe_initialize_high_asynchronous_2" $D1%XW}, \
    373 {"pipe_initialize_high_interrupt_0"}, \
    458 {"pipe_initialize_high_interrupt_1" $D1%XW}, \
    460 {"pipe_initialize_high_interrupt_2" $D1%XW}, \
    461 {"pipe_initialize_high_isochronous_0"}, \
    462 {"pipe_initialize_high_isochronous_1" $D1%XW}, \
    307 {"pipe_initialize_high_isochronous_2" $D1%XW}, \
    456 {"pipe_initialize_split_asynchronous_0"}, \
    466 {"pipe_initialize_split_asynchronous_1"}, \
    467 {"pipe_initialize_split_asynchronous_2" $D1%XW}, \
    468 {"pipe_initialize_split_interrupt_0"}, \
    484 {"pipe_initialize_split_interrupt_1" $D1%XW}, \
    485 {"pipe_initialize_split_interrupt_2" $D1%XW}, \
    452 {"pipe_initialize_split_isochronous_0"}, \
    453 {"pipe_initialize_split_isochronous_1" $D1%XW}, \
    454 {"pipe_initialize_split_isochronous_2" $D1%XW}, \
    455 {"pipe_initialize_split_isochronous_3" $D1%XW}, \
    423 {"pipe_uninitialize_high_asynchronous_0"}, \
    424 {"pipe_uninitialize_high_asynchronous_1"}, \
    425 {"pipe_uninitialize_high_asynchronous_2"}, \
    426 {"pipe_uninitialize_high_interrupt_0"}, \
    448 {"pipe_uninitialize_high_interrupt_1"}, \
    449 {"pipe_uninitialize_high_interrupt_2"}, \
    313 {"pipe_update_iob_status_high_isochronous_0"}, \
    416 {"pipe_update_iob_status_high_isochronous_1" $D1%XW}, \
    421 {"pipe_update_iob_status_high_isochronous_2" $D1%XW}, \
    572 {"pipe_update_iob_status_high_isochronous_3" $D1%XW}, \
    525 {"process_CFG_INIT_0"}, \
    526 {"process_CFG_INIT_1"}, \
    527 {"process_CFG_INIT_2" $D1%XW}, \
    528 {"process_CFG_INIT_3" $D1%XW}, \
    529 {"process_CFG_INIT_4"}, \
    530 {"process_CFG_INIT_5" $D1%XW}, \
    531 {"process_CFG_INIT_6" $D1%XW}, \
    532 {"process_CFG_INIT_7"}, \
    533 {"process_CFG_INIT_8" $D1%XW}, \
    534 {"process_CFG_INIT_9"}, \
    535 {"process_CFG_INIT_10" $D1%XW}, \
    536 {"process_CFG_INIT_11" $D1%XW}, \
    537 {"process_CFG_TERM_0"}, \
    538 {"process_CFG_TERM_1"}, \
    539 {"process_CFG_TERM_2" $D1%XW}, \
    540 {"process_CFG_TERM_3"}, \
    541 {"process_CFG_TERM_4" $D1%XW}, \
    542 {"process_CFG_TERM_5"}, \
    543 {"process_CFG_TERM_6" $D1%XW}, \
    544 {"process_CFG_TERM_7" $D1%XW}, \
    304 {"process_pipeIO_all_or_nothing_0"}, \
    437 {"process_pipeIO_all_or_nothing_1"}, \
    438 {"process_pipeIO_all_or_nothing_2"}, \
    439 {"process_pipeIO_all_or_nothing_3"}, \
    440 {"process_pipeIO_all_or_nothing_4" $D1%XW}, \
    441 {"process_pipeIO_all_or_nothing_5" $D1%XW}, \
    442 {"process_pipeIO_all_or_nothing_6" $D1%XW}, \
    443 {"process_pipeIO_all_or_nothing_7" $D1%XW $D2%XW}, \
    444 {"process_pipeIO_all_or_nothing_8"}, \
    237 {"process_pipeIO_done_0" $D1%XW $D2%XW}, \
    238 {"process_pipeIO_done_1"}, \
    459 {"process_pipeIO_single_request_0" $D1%XW $D2%XW $D3%XW}, \
    604 {"reconfigure_pci_config_registers_0"}, \
    605 {"reconfigure_pci_config_registers_1" $D1%XW $D2%XW $D3%XW}, \
    606 {"reconfigure_pci_config_registers_2"}, \
    267 {"remove_device_0"}, \
    268 {"remove_device_1"}, \
    699 {"request_shutdown_0"}, \
    700 {"request_shutdown_1"}, \
    701 {"request_unregister_0"}, \
    559 {"select_microframe_bw_0"}, \
    560 {"select_microframe_bw_1" $D1%XW}, \
    561 {"select_microframe_bw_and_TT_0"}, \
    562 {"select_microframe_bw_and_TT_1" $D1%XW}, \
    55 {"skwrapped_EHCI_pipeAbort_1"}, \
    56 {"skwrapped_EHCI_pipeAbort_2" $D1%XW}, \
    140 {"skwrapped_EHCI_pipeAddIOB_1" $D1%XW}, \
    143 {"skwrapped_EHCI_pipeClear_1"}, \
    144 {"skwrapped_EHCI_pipeClear_2" $D1%XW}, \
    154 {"skwrapped_EHCI_pipeConnect_0" $D1%XW}, \
    155 {"skwrapped_EHCI_pipeConnect_1" $D1%XW $D2%XW}, \
    158 {"skwrapped_EHCI_pipeHalt_1" $D1%XW}, \
    266 {"skwrapped_EHCI_pipeIO_0"}, \
    273 {"skwrapped_EHCI_pipeIO_1"}, \
    283 {"skwrapped_EHCI_pipeIO_2"}, \
    284 {"skwrapped_EHCI_pipeIO_3"}, \
    285 {"skwrapped_EHCI_pipeIO_4"}, \
    286 {"skwrapped_EHCI_pipeIO_5"}, \
    668 {"skwrapped_EHCI_pipeResetToggle_1" $D1%XW}, \
    757 {"skwrapped_EHCI_shutdownComplete_1"}, \
    759 {"skwrapped_EHCI_unregisterHC_1"}, \
    760 {"skwrapped_EHCI_unregisterHC_2"}, \
    761 {"skwrapped_EHCI_unregisterHC_3"}, \
    762 {"skwrapped_EHCI_unregisterHC_4" $D1%XW}, \
    61 {"skwrapped_ehcd_close_0"}, \
    264 {"skwrapped_ehcd_close_1" $D1%XW}, \
    736 {"skwrapped_ehcd_close_2" $D1%XW}, \
    737 {"skwrapped_ehcd_ioctl_0"}, \
    738 {"skwrapped_ehcd_ioctl_1"}, \
    739 {"skwrapped_ehcd_ioctl_2"}, \
    740 {"skwrapped_ehcd_ioctl_3" $D1%XW}, \
    741 {"skwrapped_ehcd_ioctl_4" $D1%XW}, \
    742 {"skwrapped_ehcd_ioctl_5" $D1%XW}, \
    114 {"skwrapped_ehcd_ioctl_6"}, \
    159 {"skwrapped_ehcd_offlevel_done_0"}, \
    743 {"skwrapped_ehcd_open_0"}, \
    744 {"skwrapped_ehcd_open_1"}, \
    745 {"skwrapped_ehcd_open_2" $D1%XW}, \
    746 {"skwrapped_ehcd_open_3" $D1%XW}, \
    38 {"skwrapped_hcd_eeh_callback_0" $D1%XW}, \
    235 {"skwrapped_hcd_eeh_callback_1"}, \
    239 {"skwrapped_hcd_eeh_callback_2"}, \
    240 {"skwrapped_hcd_eeh_callback_3"}, \
    274 {"skwrapped_hcd_eeh_callback_4"}, \
    275 {"skwrapped_hcd_eeh_callback_5"}, \
    291 {"skwrapped_hcd_eeh_callback_6"}, \
    292 {"skwrapped_hcd_eeh_callback_7"}, \
    293 {"skwrapped_hcd_eeh_callback_8"}, \
    294 {"skwrapped_hcd_eeh_callback_9"}, \
    295 {"skwrapped_hcd_eeh_callback_10"}, \
    296 {"skwrapped_hcd_eeh_callback_11"}, \
    297 {"skwrapped_hcd_eeh_callback_12"}, \
    298 {"skwrapped_hcd_eeh_callback_13"}, \
    299 {"skwrapped_hcd_eeh_callback_14"}, \
    300 {"skwrapped_hcd_eeh_callback_15"}, \
    308 {"skwrapped_hcd_eeh_callback_16"}, \
    363 {"skwrapped_hcd_eeh_callback_17"}, \
    364 {"skwrapped_hcd_eeh_callback_18"}, \
    678 {"skwrapped_hcd_eeh_callback_19"}, \
    679 {"skwrapped_hcd_eeh_callback_20"}, \
    680 {"skwrapped_hcd_eeh_callback_21"}, \
    693 {"skwrapped_hcd_eeh_callback_22"}, \
    694 {"skwrapped_hcd_eeh_callback_23"}, \
    697 {"skwrapped_hcd_eeh_callback_26"}, \
    706 {"skwrapped_hcd_eeh_callback_27" $D1%XW}, \
    707 {"skwrapped_hcd_eeh_callback_28"}, \
    763 {"skwrapped_hcd_eeh_callback_29"}, \
    764 {"skwrapped_hcd_eeh_callback_30" $D1%XW}, \
    765 {"skwrapped_hcd_eeh_callback_31" $D1%XW}, \
    766 {"skwrapped_hcd_eeh_callback_32" $D1%XW}, \
    767 {"skwrapped_hcd_eeh_callback_33"}, \
    768 {"skwrapped_hcd_eeh_callback_34"}, \
    769 {"skwrapped_hcd_eeh_callback_35"}, \
    770 {"skwrapped_hcd_eeh_callback_36" $D1%XW}, \
    771 {"skwrapped_hcd_eeh_callback_37"}, \
    772 {"skwrapped_hcd_eeh_callback_38"}, \
    54 {"skwrapped_hcd_eeh_callback_39"}, \
    57 {"skwrapped_hcd_eeh_callback_40"}, \
    101 {"skwrapped_hcd_eeh_callback_41"}, \
    102 {"skwrapped_hcd_eeh_callback_42"}, \
    103 {"skwrapped_hcd_eeh_callback_43"}, \
    545 {"skwrapped_hcd_eeh_notify_ready_for_reset_0"}, \
    546 {"skwrapped_hcd_eeh_notify_ready_for_reset_1" $D1%XW}, \
    547 {"skwrapped_hcd_eeh_shutdown_complete_timed_out_0"}, \
    548 {"skwrapped_hcd_eeh_shutdown_complete_timed_out_1"}, \
    549 {"skwrapped_hcd_eeh_shutdown_complete_timed_out_2"}, \
    160 {"skwrapped_hcd_interrupt_handler_0"}, \
    161 {"skwrapped_hcd_interrupt_handler_1"}, \
    162 {"skwrapped_hcd_interrupt_handler_2"}, \
    163 {"skwrapped_hcd_interrupt_handler_3"}, \
    164 {"skwrapped_hcd_interrupt_handler_4"}, \
    165 {"skwrapped_hcd_interrupt_handler_5"}, \
    166 {"skwrapped_hcd_interrupt_handler_6"}, \
    321 {"skwrapped_hcd_interrupt_handler_7"}, \
    323 {"skwrapped_hcd_interrupt_handler_8"}, \
    413 {"skwrapped_hcd_interrupt_handler_9"}, \
    414 {"skwrapped_hcd_interrupt_handler_10"}, \
    415 {"skwrapped_hcd_interrupt_handler_11" $D1%XW}, \
    670 {"skwrapped_hcd_interrupt_handler_12"}, \
    671 {"skwrapped_hcd_offlevel_recover_from_host_system_error_0"}, \
    672 {"skwrapped_hcd_offlevel_second_done_0"}, \
    673 {"skwrapped_hcd_offlevel_second_done_1"}, \
    674 {"skwrapped_hcd_offlevel_second_done_2"}, \
    675 {"skwrapped_hcd_offlevel_sr_cleanup_0"}, \
    676 {"skwrapped_hcd_offlevel_status_change_0"}, \
    677 {"skwrapped_hcd_offlevel_status_change_1"}, \
    550 {"skwrapped_hcd_port_reset_timer_expired_0"}, \
    551 {"skwrapped_hcd_port_reset_timer_expired_1" $D1%XW}, \
    657 {"skwrapped_hcd_port_reset_timer_expired_2" $D1%XW}, \
    658 {"skwrapped_hcd_port_reset_timer_expired_3"}, \
    659 {"skwrapped_hcd_port_reset_timer_expired_4"}, \
    660 {"skwrapped_hcd_port_reset_timer_expired_5" $D1%XW}, \
    661 {"skwrapped_hcd_sleep_timer_expired_0"}, \
    662 {"skwrapped_hcd_sr_ready_for_cleanup_0"}, \
    747 {"skwrapped_hcd_sr_ready_for_cleanup_1"}, \
    51 {"skwrapped_hcd_sr_shutdown_complete_timed_out_0"}, \
    52 {"skwrapped_hcd_sr_shutdown_complete_timed_out_1"}, \
    68 {"skwrapped_hcd_sr_shutdown_complete_timed_out_2"}, \
    69 {"skwrapped_hcd_sr_shutdown_complete_timed_out_3"}, \
    748 {"skwrapped_hcd_sr_start_reset_0"}, \
    749 {"skwrapped_hcd_sr_start_reset_1"}, \
    750 {"skwrapped_pipe_watchdog_handler_0"}, \
    751 {"skwrapped_pipe_watchdog_handler_1" $D1%XW}, \
    752 {"skwrapped_watchdog_expired_0" $D1%XW}, \
    753 {"skwrapped_watchdog_expired_1"}, \
    754 {"skwrapped_watchdog_expired_2"}, \
    755 {"skwrapped_watchdog_expired_3"}, \
    756 {"skwrapped_watchdog_expired_4"}, \
    731 {"sleep_timer_sleep_0"}, \
    732 {"sleep_timer_sleep_1"}, \
    269 {"start_port_reset_timer_0"}, \
    270 {"start_port_reset_timer_1"}, \
    733 {"start_sleep_timer_0"}, \
    151 {"unconfigure_eeh_0"}, \
    152 {"unconfigure_eeh_1"}, \
    153 {"unconfigure_eeh_2"}, \
    708 {"unconfigure_interrupts_0"}, \
    709 {"unconfigure_interrupts_1"}, \
    271 {"unconfigure_port_reset_timer_0"}, \
    272 {"unconfigure_port_reset_timer_1"}, \
    734 {"unconfigure_sleep_timer_0"}, \
    81 {"unconfigure_sr_0"}, \
    735 {"unconfigure_watchdog_0"}, \
    619 {"wait_for_not_pending_0"}, \
    620 {"wait_for_not_pending_1"}, \
    82 {"wake_from_whatever_state_with_wait_0"}, \
    83 {"wake_from_whatever_state_with_wait_1"}, \
    84 {"wake_from_whatever_state_with_wait_2"}, \
    85 {"wake_from_whatever_state_with_wait_3"}, \
    86 {"wake_from_whatever_state_with_wait_4"}, \
    89 {"wake_from_whatever_state_with_wait_7"}, \
    90 {"wake_from_whatever_state_with_wait_8"}, \
    92 {"wake_from_whatever_state_with_wait_10"}, \
    94 {"wake_from_whatever_state_with_wait_12"}, \
    96 {"wake_from_whatever_state_with_wait_14"}, \
    98 {"wake_register_settings_0"}, \
    417 {"zxmalloc_0" $D1%XW}, \
    418 {"zxmfree_0" $D1%XW}, \
    419 {"zxmfree_1"}, \
    \* {"unknown trace hook" $HD}
4FB 1.0 L=KERN "EHCI_T " \
    $HD%D2, \
    1 {"<< " " " \
{{ \
    EHCI_common(notused0) \
        {{ $mm = $D2%W0.7 }} {{ $aa = $D2%W8.15 }} {{ $ee = $D2%W16.23 }} \
        {{ $tt = $D2%W24.25 }} {{ $ss = $D2%W26.29 }} {{ $ef = $D5%W0.15 }} \
        devtoname($D1)"a"$aa%X1"e"$ee%X1 \
        $tt, \
        0 { "C" " " " " }, \
        1 { "Is" $ef%X2 }, \
        2 { "B" " " " " }, \
        3 { "In" }, \
        \* { "invalid_type" $tt%X1 } \
        $ss, \
        1 { "L" " " " " }, \
        2 { "F" " " " " }, \
        4 { "H" " " " " }, \
        9 { "sL" }, \
        a { "sF" }, \
        \* { "invalid_speed" $ss%X1 } \
}} \
{{ \
    EHCI_corlen(notused1) \
        {{ $ce = $D3%W0.15 }} {{ $pid = $D3%W16.17 }} {{ $s = $D3%W18.18 }} \
        $ce%X2 \
        $pid, \
        0 { "<-  S" }, \
        1 { " " " -> I" }, \
        2 { "<-  O" }, \
        \* { "invalid_pid" $pid%X1 } \
        {{ $llll = $D4%W0.15 }} \
        $s, \
        0 { $llll%X2" " " " }, \
        1 { $llll%X2"s" }, \
        \* { "invalid_shortok" $s%X1 $llll%X2 } \
}} \
{{ \
    EHCI_usbs(usbs) \
        $usbs%D2, \
        1 { "STALL" }, \
        2 { "HALTED" }, \
        3 { "ACTIVE" }, \
        4 { "DISCONNECT" }, \
        5 { "ABORTING" }, \
        6 { "ABORTED" }, \
        7 { "PENDING" }, \
        8 { "BANDWIDTH" }, \
        9 { "SPEED" }, \
        10 { "POWER" }, \
        11 { "DATA" }, \
        12 { "ERROR" }, \
        13 { "BADHANDLE" }, \
        14 { "TIMEOUT" }, \
        15 { "X_CRC" }, \
        16 { "X_BitStuffing" }, \
        17 { "X_DataToggleMismatch" }, \
        18 { "X_DeviceNotResponding" }, \
        19 { "X_PIDCheckFailure" }, \
        20 { "X_UnexpectedPID" }, \
        21 { "X_DataOverrun" }, \
        22 { "X_DataUnderrun" }, \
        23 { "X_BufferOverrun" }, \
        24 { "X_BufferUnderrun" }, \
        25 { "X_NotAccessed" }, \
        26 { "X_Unimplemented" }, \
        \* { "unknown_status" $usbs } \
}} \
{{ \
    EHCI_inbound(notused2) \
        EHCI_common($D1) \
        EHCI_corlen($D1) \
        {{ $ssss = $D4%W16.31 }} {{ $sign = $D4%W31.31 }} \
        $ssss%X2 \
        $sign, \
        0 { \
            $ssss, \
            0 { "SUCCESS" }, \
            \* { "errno="$ssss%D2 } \
          }, \
        1 { \
            {{ $usbs = 0x10000 - $ssss }} \
            EHCI_usbs($usbs) \
          }, \
        \* { "invalid_sign" $sign%X1 } \
}} \
        EHCI_common($D1) \
        EHCI_corlen($D1) \
        {{ $ssss = $D4%W16.31 }} \
        $ssss%X2 \
        $ssss%X2, \
        fff9 { "" }, \
        \* { "invalid_status" } \
        }, \
    2 { " " ">> " EHCI_inbound($D1) "" }, \
    3 { " " ">> " EHCI_inbound($D1) "done2" }, \
    4 { " " ">> " EHCI_inbound($D1) "obsolete 1" }, \
    5 { " " ">> " EHCI_inbound($D1) "abort p" }, \
    6 { " " ">> " EHCI_inbound($D1) "abort d2" }, \
    7 { " " ">> " EHCI_inbound($D1) "abort h" }, \
    8 { " " ">> " EHCI_inbound($D1) "abort sc" }, \
    9 { " " ">> " EHCI_inbound($D1) "obsolete 2" }, \
    10 { "++ " " " EHCI_common($D1) "pipeConnect" }, \
    11 { "-- " " " EHCI_common($D1) "pipeDisconnect" }, \
    12 { "== " " " EHCI_common($D1) "pipeStatus" \
        $D3, \
        0 { "ACTIVE" }, \
        1 { "HALTED" }, \
        \* { "invalid_status" } \
       }, \
    13 { "== " " " EHCI_common($D1) "pipeAbort" }, \
    14 { "== " " " EHCI_common($D1) "pipeHalt" }, \
    15 { "== " " " EHCI_common($D1) "pipeClear" }, \
    16 { "== " " " EHCI_common($D1) "pipeResetToggle" }, \
    17 { "== " " " EHCI_common($D1) "pipeAddIOB" }, \
    18 { "== " " " devtoname($D1) "shutdownComplete" }, \
    19 { "== " " " devtoname($D1) "unregisterHC" }, \
    20 { "== " " " devtoname($D1) "reqHCrestart" }, \
    21 { "== " " " devtoname($D1) "reqHCunregister" }, \
    22 { "== " " " devtoname($D1) "reqHCshutdown" }, \
    23 { "== " " " devtoname($D1) "getFrame" }, \
    \* {"unknown trace hook" $HD}
73C 1.0 L=APPL "Cortinadd"                   \
                                              \
                {{ $a =  $HD & 0xff00 }}      \
                {{ $routine =  $a / 256 }}    \
                {{ $func  = $HD & 0xff }}     \
                                              \
                $routine,                     \
                  \*  { "funcID" $routine%X2} \
                                              \
                $func,                        \
                  0  { " [entr]" },           \
                  ff { " [exit]" },           \
                  \* { "    ["$func%X2"]"  }  \
                                              \
                $HL,                          \
                  14 {O2 "     d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
                  28 {O2 "     d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
2E6 1.0 "@phxentdd" \
        "PCI ENT DD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
2E7 1.0 "@phxentdd" \
        "PCI ENT DD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
2E8 1.0 "@phxentdd" \
        "PCI ENT DD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
470 1.0 "@scentdd" \
	"PCI SCENT DD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
471 1.0 "@scentdd" \
	"PCI SCENT DD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
472 1.0 "@scentdd" \
	"PCI SCENT DD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
4A1 1.0 "@kngentdd" \
	"PCI KNGENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
4A2 1.0 "@kngentdd" \
	"PCI KNGENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
4A3 1.0 "@kngentdd" \
	"PCI KNGENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
522 1.0 "@ICA:	IBM Crypto Accelerator Error Traces" \
          $H%D1, \
        1   { "ICA_CONFIG_ENOMEM	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        2   { "ICA_ERR_CREAT_CARD	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        3   { "ICA_CONFIG_UIOWR		" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        4   { "ICA_CONFIG_DST_ERR	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        5   { "ICA_RSA_BUF_ENOMEM	" D1=$D1 D2=$D2 D3=$D3 size=$D4 location=$D5},\
        6   { "ICA_PCI_EIO		" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        7   { "ICA_RSA_INIT_REGS	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        8   { "ICA_RSA_D_INIT_FAIL	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        9   { "ICA_RSA_D_MAP_FAIL	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        A   { "ICA_IOCTL_BAD_ARGS	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        B   { "ICA_COPYIN_FAILURE	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        C   { "ICA_COPYOUT_FAILURE	" rcode=$D1 D2=$D2 D3=$D3 D4=$D4 location=$D5},\
        D   { "ICA_INTR_INIT_FAILURE	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        E   { "ICA_IOCTL_FAILURE	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        F   { "ICA_MEMORY_XMALLOC_FAIL	" ENOMEM=$D1 D2=$D2 D3=$D3 D4=$D4 location=$D5},\
        10   { "ICA_DES_QUE_MAX		" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        11   { "ICA_DES_D_INIT_FAIL	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        12   { "ICA_DES_D_MAP_FAIL 	" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        13   { "ICA_READ_RANDOM_FAIL 	" rcode=$D1 D2=$D2 D3=$D3 D4=$D4 location=$D5},\
        14   { "ICA_RSA_CRT_BAD_INPUT 	" trcpath=$D1 inputDataLen=$D2 pInputData=$D3 max_size=$D4 max_data_size=$D5},\
        15   { "ICA_RSA_BAD_KEYTYPE	" keytype=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5},\
        16   { "ICA_RSA_BAD_INPUT_LEN	" crt_data_len=$D1 crt_B_len=$D2 crt_N_len=$D3 D4=$D4 D5=$D5},\
        17   { "ICA_BAD_DES_ARGS	" mode=$D1 dataLength=$D2 pInputData=$D3 OutputDataLength=$D4 pOutput=$D5},\
        18   { "ICA_BAD_DES_MODE	" D1=$D1 mode=$D2 D3=$D3 D4=$D4 D5=$D5},\
        22   { "ICA_VEM                 " mode=$D1 rsa_op_id=$D2 result=$D3 pir=$D4 vf_element=$D5},\
        23   { "ICA_NO_THRD_TO_WAKE     " mode=$D1 rsa_op_id=$D2 result=$D3 pir=$D4 vf_element=$D5},\
        24   { "ICA_INTR_PIR_ERR        " mode=$D1 pir=$D2 pir_paq_bit=$D3 pir_beo_bit=$D4 icacm_rsavf_lwp=$D5},\
        25   { "ICA_CFG_WATCH_DOG_INIT  " mode=$D1 count=$D2 w_dog=$D3 D4=$D4 D5=$D5},\
        26   { "ICA_BAD_PIR  " mode=$D1 icard=$D2 pir=$D3 D4=$D4 D5=$D5},\
	27   { "ICA_EEH_ERROR" card=$D1%S1 icard=$D2 Dd3=$D3 D4=$D4 D5=$D5 },\
	28   { "ICA_EEH_FALSE_ALARM" card=$D1%S1 icard=$D2 Dd3=$D3 D4=$D4 D5=$D5 },\
       \* { `mode=$HD` D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
523	1.0 "@ICA:	IBM Crypto Accelerator Verbose Traces" \
          $H%D1, \
        1   { "ICA_RSA_WO_CRT_IOCTL            " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        2   { "ICA_RSA_WITH_CRT_IOCTL          " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        3   { "ICA_RSA_MOD_MULTIPLY_IOCTL      " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        4   { "ICA_RSA_WO_CRT_IOCTL_OK         " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        5   { "ICA_RSA_WITH_CRT_IOCTL_OK       " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        6   { "ICA_RSA_MOD_MULTIPLY_IOCTL_OK   " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        7   { "ICA_RSA_WO_CRT_BAD_LEN          " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        8   { "ICA_RSA_NOT_USED                " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        9   { "ICA_RSA_FAIL_CMD                " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        A   { "ICA_IOCTL_SUCCESS               " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        B   { "ICA_INTR_PIER		       " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        C   { "ICA_REG_OUT_BM01		       " BMAR0=$D1%X4 BMCR0=$D2%X4 BMAR1=$D3%X4 BMCR1=$D4%X4 D5=$D5%X4},\
        D   { "ICA_REG_OUT_BM23		       " BMAR2=$D1%X4 BMCR2=$D2%X4 BMAR3=$D3%X4 BMCR3=$D4%X4 D5=$D5%X4},\
        E   { "ICA_REG_OUT_SET3		       " RFP=$D1%X4 DFP=$D2%X4 BMCSR=$D3%X4 PIR=$D4%X4 PIER=$D5%X4},\
        F   { "ICA_REG_OUT_SET4                " RIBAR=$D1%X4 ROBAR=$D2%X4 VF_BAR=$D3%X4 RCR=$D4%X4 RSCR=$D5%X4},\
        10  { "ICA_REG_OUT_SET5                " RSR=$D1%X4 DCR=$D2%X4 OSCR=$D3%X4 MIR=$D4%X4 MIER=$D5%X4},\
        11  { "ICA_PCI_SPC_RD                  " data=$D1%X4 pic_offset=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        12  { "ICA_PCI_SPC_WR                  " data=$D1%X4 pci_offset=$D2%X4 D3=$D3 D4=$D4 D5=$D5},\
        13  { "ICA_RSA_CRT_BAD_LEN             " length=$D1%X4 D2=$D2%X4 D3=$D3 D4=$D4 unique_copyin_finder=$D5},\
        14  { "ICA_IOCTL_VPD                   " vpd_dev=$D1%X4 vpd_flag=$D2%X4 vpd_size=$D3 vpd_data=$D4 D5=$D5},\
        15  { "ICA_RSA_ISSUE_CMD               " nrml=$D1%X4 cmd=$D2%X4 pid=$D3 dev=$D4 rip_index=$D5},\
        16  { "ICA_RSA_CMD_RETURN              " nrml=$D1%X4 cmd=$D2%X4 pid=$D3 dev=$D4 rip_index=$D5},\
        17  { "ICA_RSA_WAIT_RSRC               " nrml=$D1%X4 D2=$D2%X4 pid=$D3 D4=$D4 D5=$D5},\
        18  { "ICA_RSA_GOT_RSRC                " nrml=$D1%X4 D2=$D2%X4 pid=$D3 D4=$D4 D5=$D5},\
        19  { "ICA_OPEN_OK                     " nrml=$D1%X4 D2=$D2%X4 D3=$D3 D4=$D4 D5=$D5},\
        20  { "ICA_CLOSE_OK                    " nrml=$D1%X4 D2=$D2%X4 D3=$D3 D4=$D4 D5=$D5},\
       \* { `mode=$HD` D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4 }
524	1.0 "@ICA:	IBM Crypto Accelerator Verbose Traces" \
          $H%D1, \
        1   { "ICA_INTR_PIR            " D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4},\
        2   { "ICA_INTR_RSA            " normal=$D1%X4 rsa_lwp=$D2%X4 result=$D3 %X4 pir=$D4%X4 vf_element=$D5%X4},\
       \* { `mode=$HD` D1=$D1%X4 D2=$D2%X4 D3=$D3%X4 D4=$D4%X4 D5=$D5%X4 }
4F7 1.0 "@xcryptdd" \
        "XCRYPTDD:  " \
        $GENERIC, \
          0 { O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }, \
          1 { A4.8 W2 {{ $loopcnt = $HL / 16 }} {{ $bytecnt = 0 }} " " LOOP $loopcnt { X16 "\n\t\t\t" {{ $bytecnt = $bytecnt + 16 }} } {{ $loopcnt = $HL - $bytecnt }} LOOP $loopcnt {X0} }
479 1.0 "QLISCDD" \
	$DD1
47A 1.0 "QLISCSIDD" \
	$DD1
598 1.0 "@ventdd" \
	"PCI VENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
599 1.0 "@ventdd" \
	"PCI VENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
59A 1.0 "@ventdd" \
	"PCI VENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
22C 1.1 "@tsdd" \
        "MPQP COMIO EMUL: " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
2F6 1.2 L=KERN "SAL960" {{ $loc = X1 }} $loc, \
        a1  { "SendSCB entry :" "card   :" O1.0 XW "low priority  :" XW } , \
        a2  { "SendSCB exit  :" "card   :" O1.0 XW "return code   :" XW } , \
        a3  { "Stream CtrlOn :" "Card   :" O1.0 XW "Slot Identity :" XW } , \
        a4  { "Stream CtrlOff:" "Card   :" O1.0 XW "Slot Identity :" XW } , \
        a5  { "SCB Flow_On   :" "Card   :" O1.0 XW "Num of SCBs   :" XW } , \
        a6  { "SCB Flow_Off  :" "Card   :" O1.0 XW "Num Waiting   :" XW } , \
        a7  { "FreeBuff Entry:" "Card   :" O1.0 XW "Address       :" XW } , \
        a8  { "FreeBuff Exit :" "Card   :" O1.0 XW "1 if no lock  :" XW } , \
        a9  { "AlocBuff Entry:" "Card   :" O1.0 XW "Length        :" XW } , \
        aa  { "AlocBuff Exit :" "Card   :" O1.0 XW "1 if no lock  :" XW } , \
        ab  { "S96Send  Entry:" "Card   :" O1.0 XW "Stream Handle :" XW } , \
        ac  { "S96Send  Exit :" "Card   :" O1.0 XW "NoMem = x80.0c:" XW } , \
        ad  { "S96Recv  Entry:" "Card   :" O1.0 XW "Buf Address   :" XW } , \
        ae  { "S96Recv  Exit :" "Card   :" O1.0 XW "System mblk   :" XW } , \
        af  { "MapCard  Entry:" "Card   :" O1.0 XW "Card Address  :" XW } , \
        b0  { "MapCard  Exit :" "Card   :" O1.0 XW "Mapped Addr   :" XW } , \
        b1  { "UmpCard  Entry:" "Card   :" O1.0 XW "Base Address  :" XW } , \
        b2  { "UmpCard  Exit :" "Card   :" O1.0 XW "Base Address  :" XW } , \
        b3  { "User SendData :" "Card   :" O1.0 XW "Message Numb  :" XW } , \
        b4  { "User RecvData :" "Card   :" O1.0 XW "Message Numb  :" XW } , \
        b5  { "Rec Lock Entry:" "thread :" O1.0 DW "level :: count:" XW "lock addr :" XW } , \
        b6  { "Rec Lock Entry:" "thread :" O1.0 DW "level :: count:" XW "lock addr :" XW } , \
        b7  { "Recv Buff Req :" "card   :" O1.0 XW "Buff call id  :" XW } , \
        b8  { "Enq  Buff Req :" "card   :" O1.0 XW "Buff call id  :" XW } , \
        b9  { "Mark card Bad :" "card   :" O1.0 XW "Reason Code   :" XW } , \
        ba  { "Recv Buff Evn :" "card   :" O1.0 XW "Buff call id  :" XW } , \
        bb  { "SCB from OSS  :" "card   :" O1.0 XW "SCB Type      :" XW } , \
        bc  { "SCB Unit Stat :" "card   :" O1.0 XW "StatType      :" XW } , \
        bd  { "Enq  Buff Evn :" "card   :" O1.0 XW "Buff call id  :" XW } , \
        be  { "Chkcard Entry :" "cardnum:" O1.0 XW "reserved      :" XW } , \
        bf  { "ChkcardRsvd!=0:" "cardnum:" O1.0 XW "reserved      :" XW } , \
        c0  { "ChkcrdStWrd!=0:" "cardnum:" O1.0 XW "salinf.st_word:" XW } , \
        c1  { "s96open Entry :" "cardnum:" O1.0 XW "oss.ctllen    :" XW } , \
        c2  { "s96ioctlEntry :" "card   :" O1.0 XW "sd,streamdscrp:" XW "iocmd     :" XW } , \
        c3  { "s96ioctlEntry1:" "arg    :" O1.0 XW "reserved      :" XW } , \
        c4  { "96ioctlInvCmd!:" "card   :" O1.0 XW "sd,streamdscrp:" XW "iocmd     :" XW } , \
        c5  { "chkstrd Entry :" "card   :" O1.0 XW "reserved      :" XW "strd      :" XW } , \
        c6  { "chkcbmh Entry :" "card   :" O1.0 XW "reserved      :" XW "strd      :" XW } , \
        c7  { "chkcbmh Reset!:" "card   :" O1.0 XW "reserved      :" XW "strd      :" XW } , \
        c8  { "chkcbmhMajMin!:" "card   :" O1.0 XW "reserved      :" XW "strd      :" XW } , \
        c9  { "ckcbmhGtRctAd!:" "card   :" O1.0 XW "caddr         :" XW "strd      :" XW } , \
        ca  { "chkcbmh_mread!:" "card   :" O1.0 XW "chandle       :" XW "strd      :" XW } , \
        cb  { "s96reg Entry  :" "tcn    :" O1.0 XW "msize         :" XW "flblen    :" XW } , \
        cc  { "s96reg Entry1 :" "memo   :" O1.0 XW "reserved      :" XW } , \
        cd  { "s96dereg Entry:" "handle :" O1.0 XW "reserved      :" XW } , \
        ce  { "s96free Entry :" "handle :" O1.0 XW "ptr           :" XW } , \
        cf  { "S96Send salsnd:" "card   :" O1.0 XW "sal_send retcd:" XW } , \
        d0  { "chkcbmsHdlTbl :" "Mnr(strd:" O1.0 XW "cbmstbl[Mnr(strd:" XW "strd   :" XW } , \
        d1  { "sal_freem1    :" "Card   :" O1.0 XW "buff          :" XW } , \
        d2  { "sal_freeb1    :" "Card   :" O1.0 XW "RES_DESCR ulen:" XW } , \
        d3  { "ProcessCBM,REG:" "Card   :" O1.0 XW "RES_DESCR strd:" XW } , \
        d4  { "PrcssCBM,DEREG:" "Card   :" O1.0 XW "rsp->RetCode  :" XW }
2c7 1.0 "chatmdd" \
        "ID:" w1 A4.8 "d1=" XW " d2=" XW " d3=" XW " d4=" XW  \
        R0 \
        $D1, \
        0x53696E42 { \n "CHATMDD xmit interrupt  " $D2 }
2c8 1.0 "chatmdd" \
        "ID:" W1 A4.8 "d1=" XW " d2=" XW " d3=" XW " d4=" XW  \
        R0 \
        $D1, \
        0x53696E42 { \n "CHATMDD receive interrupt  " $D2 }
2c9 1.0 "chatmdd" \
        "ID:" W1 A4.8 "d1=" XW " d2=" XW " d3=" XW " d4=" XW  \
        R0 \
        $D1, \
        0x53696E42 { \n "CHATMDD other interrupt  " $D2 }
2ca 1.0 "bbatmdd" \
        "ID:" O2 A4.8 "d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4  \
        R0 \
        $D1, \
        0x53696E42 { \n "BATMDD error interrupt  " $D2 }
5C9 1.0 "SISRAID_ERR" \
	{{ $loc = X1 }} \
	{{ $unused = X1 }} \
	$loc, \
	0x70 { "Bus CFG INIT:\t\t\t" XW XW XW } , \
	0x71 { "AF Bus CFG_INIT:\t\t\t" XW XW XW } , \
	0x72 { "Adap CFG_INIT:\t\t\t" XW XW XW } , \
	0x73 { "CFG_TERM:\t\t\t\t" XW XW XW } , \
	0x74 { "Enter CFG_QVPD:\t\t\t" XW XW XW } , \
	0x75 { "Enter CFG_QSID:\t\t\t" XW XW XW } , \
	0x76 { "Enter CFG_SSID:\t\t\t" XW XW XW } , \
	0x77 { "Enter Open:\t\t\t" XW XW XW } , \
	0x78 { "Exit Open:\t\t\t\t" XW XW XW } , \
	0x79 { "Enter Close:\t\t\t" XW XW XW } , \
	0x7a { "Exit Close:\t\t\t" XW XW XW } , \
	0x7b { "Undo Open:\t\t\t\t" XW XW XW } , \
	0x7c { "Enter Strategy:\t\t\t" XW XW XW } , \
	0x7d { "Exit Strategy 1:\t\t\t" XW XW XW } , \
	0x7e { "Exit Strategy 2:\t\t\t" XW XW XW } , \
	0x7f { "Exit Strategy 3:\t\t\t" XW XW XW } , \
	0x80 { "Process Q_RESUME:\t\t\t" XW XW XW } , \
	0x81 { "DMA_R_NO_RES:\t\t\t" XW XW XW } , \
	0x82 { "Process LUN_RESET:\t\t" XW XW XW } , \
	0x83 { "Process TARGET_RESET:\t\t" XW XW XW } , \
	0x84 { "Process Q_CLR:\t\t\t" XW XW XW } , \
	0x85 { "Process RESUME QF:\t\t" XW XW XW } , \
	0x86 { "Process RESUME SR:\t\t" XW XW XW } , \
	0x87 { "Start   :\t\t\t\t" XW XW XW } , \
	0x88 { "Enter AF Strategy:\t\t" XW XW XW } , \
	0x89 { "Exit AF Strat 1:\t\t\t" XW XW XW } , \
	0x8a { "Exit AF Strat 2:\t\t\t" XW XW XW } , \
	0x8b { "Exit AF Strat 3:\t\t\t" XW XW XW } , \
	0x8c { "Exit AF Strat 4:\t\t\t" XW XW XW } , \
	0x8d { "Start AF:\t\t\t\t" XW XW XW } , \
	0x8e { "AF buf complete:\t\t\t" XW XW XW } , \
	0x8f { "SCSI buf complete:\t\t" XW XW XW } , \
	0x90 { "IOA Non-0 IOASC:\t\t\t" XW XW XW } , \
	0x91 { "Err intr UC Buff:\t\t" XW XW XW } , \
	0x92 { "Err intr no UC Buff:\t\t" XW XW XW } , \
	0x93 { "Error Interrupt:\t\t\t" XW XW XW } , \
	0x94 { "Dev Non-0 IOASC:\t\t\t" XW XW XW } , \
	0x95 { "AF Non-0 IOASC:\t\t\t" XW XW XW } , \
	0x96 { "Send command:\t\t\t" XW XW XW } , \
	0x97 { "Blocking command end:\t\t" XW XW XW } , \
	0x98 { "max_buf_speed:\t\t\t" XW XW XW } , \
	0x99 { "Wdog timer intr:\t\t\t" XW XW XW } , \
	0x9a { "HHRQ Wdog:\t\t\t\t" XW XW XW } , \
	0x9b { "SCSI buf timeout:\t\t\t" XW XW XW } , \
	0x9c { "AF buf timeout:\t\t\t" XW XW XW } , \
	0x9d { "EPOW Resume:\t\t\t" XW XW XW } , \
	0x9e { "EPOW Bus Reset:\t\t\t" XW XW XW } , \
	0x9f { "Enter IOCTL:\t\t\t" XW XW XW } , \
	0xa0 { "Exit IOCTL:\t\t\t" XW XW XW } , \
	0xa1 { "PT sis ioctl:\t\t\t" XW XW XW } , \
	0xa2 { "Phys Dev Attr:\t\t\t" XW XW XW } , \
	0xa3 { "TM start:\t\t\t\t" XW XW XW } , \
	0xa4 { "TM stop:\t\t\t\t" XW XW XW } , \
	0xa5 { "Undo StartTgt:\t\t\t" XW XW XW } , \
	0xa6 { "DUMPINIT:\t\t\t\t" XW XW XW } , \
	0xa7 { "DUMPTERM:\t\t\t\t" XW XW XW } , \
	0xa8 { "Reset IOA error:\t\t\t" XW XW XW } , \
	0xa9 { "Reset IOA job:\t\t\t" XW XW XW } , \
	0xaa { "Cfg HCAM Exist:\t\t\t" XW XW XW } , \
	0xab { "Cfg HCAM New:\t\t\t" XW XW XW } , \
	0xac { "Cfg HCAM Del:\t\t\t" XW XW XW } , \
	0xad { "Error HCAM:\t\t\t" XW XW XW } , \
	0xae { "Bad VPD Signature:\t\t" XW XW XW } , \
	0xaf { "Downlevel Gemstone:\t\t" XW XW XW } , \
	0xb0 { "EEH Event:\t\t\t\t" XW XW XW } , \
	0xb1 { "AF ST error:\t\t\t" XW XW XW } , \
	0xb2 { "AF ST done:\t\t\t" XW XW XW } , \
	0xb3 { "AF Startup:\t\t\t" XW XW XW } , \
	0xb4 { "Set DASD TO:\t\t\t" XW XW XW } , \
	0xb5 { "HV Blocked:\t\t\t" XW XW XW } , \
	0xb6 { "AF ST ERROR p01:\t\t\t" XW XW XW } , \
	0xb7 { "AF ST ERROR p0A:\t\t\t" XW XW XW } , \
	0xb8 { "AF ST ERROR p20:\t\t\t" XW XW XW } , \
	0xb9 { "Brain Dead:\t\t\t" XW XW XW } , \
	0xba { "Smart Dump:\t\t\t" XW XW XW } , \
	0xbb { "Smart Dump End:\t\t\t" XW XW XW }
730 1.0 "SONDD:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "config " }, \
        02  { "rd_VPD " }, \
        03  { "init   " }, \
        04  { "rd_pci " }, \
        05  { "wr_pci " }, \
        06  { "term   " }, \
        07  { "open   " }, \
        08  { "close  " }, \
        09  { "make_gp" }, \
        0A  { "unmakgp" }, \
        0B  { "ddf    " }, \
        0C  { "ddf_ext" }, \
        0D  { "get_VPD" }, \
        0E  { "setksr " }, \
        0F  { "intadpt" }, \
        10  { "wfifo  " }, \
        11  { "syncdpm" }, \
        12  { "add_pd " }, \
        13  { "rm_pd  " }, \
        14  { "findpd " }, \
        15  { "initpci" }, \
        16  { "mon_id " }, \
        17  { "mon_dfl" }, \
        18  { "mon_str" }, \
        19  { "vttinit" }, \
        1A  { "vttact " }, \
        1B  { "setchar" }, \
        1C  { "qchar  " }, \
        1D  { "setdtg " }, \
        1E  { "vttdact" }, \
        1F  { "vttterm" }, \
        20  { "fndubuf" }, \
        21  { "vttcfl " }, \
        22  { "vttclr " }, \
        23  { "vttcpl " }, \
        24  { "vttdefc" }, \
        25  { "vttmovc" }, \
        26  { "vttscr " }, \
        27  { "vtttext" }, \
        28  { "updtcur" }, \
        29  { "crcx   " }, \
        2A  { "drcx   " }, \
        2B  { "cwing  " }, \
        2C  { "dwing  " }, \
        2D  { "uwing  " }, \
        2E  { "fixwid " }, \
        2F  { "stlwid " }, \
        30  { "synctag" }, \
        31  { "putevnt" }, \
        32  { "intr   " }, \
        33  { "swapBuf" }, \
        34  { "doSwap " }, \
        35  { "wgSwap " }, \
        36  { "waitdma" }, \
        37  { "sswitch" }, \
        38  { "eswitch" }, \
        39  { "fifospc" }, \
        3A  { "drwwid " }, \
        3B  { "bndwin " }, \
        3C  { "toggleB" }, \
        3D  { "wr_fifo" }, \
        3E  { "vttdpm " }, \
        3F  { "logerr " }, \
        40  { "abxreg " }, \
        41  { "abxqry " }, \
        42  { "abxureg" }, \
        43  { "abxkreg" }, \
        44  { "abxkqry" }, \
        45  { "xgivwid" }, \
        46  { "xgetwid" }, \
        47  { "devinit" }, \
        48  { "swapdwa" }, \
        49  { "getevt " }, \
        4A  { "postevt" }, \
        4B  { "getwid " }, \
        4C  { "xrtwid " }, \
        4D  { "syncras" }, \
        4E  { "rdEDIO " }, \
        4F  { "ddc    " }, \
        50  { "I2Cwrt " }, \
        51  { "I2Crd  " }, \
        52  { "fevtlst" }, \
        53  { "qryddc " }, \
        54  { "swapX  " }, \
        55  { "creatUq" }, \
        56  { "bindUq " }, \
        57  { "ubindUq" }, \
        58  { "destUq " }, \
        59  { "regUq  " }, \
        5A  { "Uqinfo " }, \
        5B  { "destpol" }, \
        5C  { "rmUqifo" }, \
        5D  { "getUqe " }, \
        5E  { "freeUqe" }, \
        5F  { "cthread" }, \
        60  { "dthread" }, \
        61  { "wrt_reg" }, \
        62  { "rd_reg " }, \
        63  { "rstadpt" }, \
        64  { "waitevt" }, \
        65  { "waitbsy" }, \
        66  { "clnuq  " }, \
        67  { "clnuqbn" }, \
        68  { "modcurr" }, \
        69  { "drwcur " }, \
        6A  { "regBuf " }, \
        6B  { "uregBuf" }, \
        6C  { "regShw " }, \
        6D  { "uregShw" }, \
        6E  { "dahwctx" }, \
        6F  { "ahwctx " }, \
        70  { "intdrcx" }, \
        71  { "offregn" }, \
        72  { "wrutil " }, \
        73  { "drwregn" }, \
        74  { "resctx " }, \
        75  { "savctx " }, \
        76  { "setWAT " }, \
        77  { "rmWnWid" }, \
        78  { "eWidWrt" }, \
        79  { "creatCC" }, \
        7A  { "delCC  " }, \
        7B  { "updteCC" }, \
        7C  { "enbleCC" }, \
        7D  { "disblCC" }, \
        7E  { "pm_hdlr" }, \
        7F  { "pmrecfg" }, \
        80  { "pmshtdn" }, \
        81  { "gpradp " }, \
        82  { "gplradp" }, \
        83  { "gscrtch" }, \
        84  { "fscrtch" }, \
        85  { "sendbuf" }, \
        86  { "dma    " }, \
        87  { "dmaSV  " }, \
        88  { "dmaMap " }, \
        8A  { "dmacplt" }, \
        8B  { "initTxt" }, \
        8C  { "lnkdrty" }, \
        8D  { "uregTxt" }, \
        8E  { "regTxt " }, \
        8F  { "initMap" }, \
        90  { "waitTxt" }, \
        91  { "strdata" }, \
        92  { "getdata" }, \
        93  { "regsseg" }, \
        94  { "uregssg" }, \
        95  { "qrysseq" }, \
        96  { "loadgmm" }, \
        97  { "bindcom" }, \
        98  { "ubndcom" }, \
        99  { "mapbuff" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
473 1.0 "@goentdd" \
	"PCI GOENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
474 1.0 "@goentdd" \
	"PCI GOENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
475 1.0 "@goentdd" \
	"PCI GOENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3e8 1.0 "bbatmdd" \
        "ID:" O2 A4.8 "d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4  \
        R0 \
        $D1, \
        0x53696E42 { \n "BATMDD xmit interrupt  " $D2 }
3e9 1.0 "bbatmdd" \
        "ID:" O2 A4.8 "d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4  \
        R0 \
        $D1, \
        0x53696E42 { \n "BATMDD receive interrupt  " $D2 }
3ea 1.0 "bbatmdd" \
        "ID:" O2 A4.8 "d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4  \
        R0 \
        $D1, \
        0x53696E42 { \n "BATMDD other interrupt  " $D2 }
2DA 1.0 "@cstokdd" \
        "Tokenring (14103e00) transmit: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
2DB 1.0 "@cstokdd" \
        "Tokenring (14103e00) receive: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " size=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
2DC 1.0 "@cstokdd" \
        "Tokenring (14103e00) generic: " W1 A4.8 W2 "d1=" XW "d2=" XW " d3=" XW
737 1.0 L=APPL "Lanaidd"                     \
                                              \
        	{{ $a =  $HD & 0xff00 }}      \
        	{{ $routine =  $a / 256 }}    \
        	{{ $func  = $HD & 0xff }}     \
                                              \
        	$routine,                     \
        	  \*  { "funcID" $routine%X2} \
                                              \
        	$func,                        \
        	  0  { " [entr]" },           \
        	  ff { " [exit]" },           \
        	  \* { "    ["$func%X2"]"  }  \
                                              \
        	$HL,                          \
                  14 {O2 "     d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
                  28 {O2 "     d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
733 1.0 "MOJDD:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "config " }, \
        02  { "rd_VPD " }, \
        03  { "init   " }, \
        04  { "rd_pci " }, \
        05  { "wr_pci " }, \
        06  { "term   " }, \
        07  { "open   " }, \
        08  { "close  " }, \
        09  { "make_gp" }, \
        0A  { "unmakgp" }, \
        0B  { "ddf    " }, \
        0C  { "ddf_ext" }, \
        0D  { "get_VPD" }, \
        0E  { "setksr " }, \
        0F  { "intadpt" }, \
        10  { "wfifo  " }, \
        11  { "syncdpm" }, \
        12  { "add_pd " }, \
        13  { "rm_pd  " }, \
        14  { "findpd " }, \
        15  { "initpci" }, \
        16  { "mon_id " }, \
        17  { "mon_dfl" }, \
        18  { "mon_str" }, \
        19  { "vttinit" }, \
        1A  { "vttact " }, \
        1B  { "setchar" }, \
        1C  { "qchar  " }, \
        1D  { "setdtg " }, \
        1E  { "vttdact" }, \
        1F  { "vttterm" }, \
        20  { "fndubuf" }, \
        21  { "vttcfl " }, \
        22  { "vttclr " }, \
        23  { "vttcpl " }, \
        24  { "vttdefc" }, \
        25  { "vttmovc" }, \
        26  { "vttscr " }, \
        27  { "vtttext" }, \
        28  { "updtcur" }, \
        29  { "crcx   " }, \
        2A  { "drcx   " }, \
        2B  { "cwing  " }, \
        2C  { "dwing  " }, \
        2D  { "uwing  " }, \
        2E  { "fixwid " }, \
        2F  { "stlwid " }, \
        30  { "synctag" }, \
        31  { "putevnt" }, \
        32  { "intr   " }, \
        33  { "swapBuf" }, \
        34  { "doSwap " }, \
        35  { "wgSwap " }, \
        36  { "waitdma" }, \
        37  { "sswitch" }, \
        38  { "eswitch" }, \
        39  { "fifospc" }, \
        3A  { "drwwid " }, \
        3B  { "bndwin " }, \
        3C  { "toggleB" }, \
        3D  { "wr_fifo" }, \
        3E  { "vttdpm " }, \
        3F  { "logerr " }, \
        40  { "abxreg " }, \
        41  { "abxqry " }, \
        42  { "abxureg" }, \
        43  { "abxkreg" }, \
        44  { "abxkqry" }, \
        45  { "xgivwid" }, \
        46  { "xgetwid" }, \
        47  { "devinit" }, \
        48  { "swapdwa" }, \
        49  { "getevt " }, \
        4A  { "postevt" }, \
        4B  { "getwid " }, \
        4C  { "xrtwid " }, \
        4D  { "syncras" }, \
        4E  { "rdEDIO " }, \
        4F  { "ddc    " }, \
        50  { "I2Cwrt " }, \
        51  { "I2Crd  " }, \
        52  { "fevtlst" }, \
        53  { "qryddc " }, \
        54  { "swapX  " }, \
        55  { "creatUq" }, \
        56  { "bindUq " }, \
        57  { "ubindUq" }, \
        58  { "destUq " }, \
        59  { "regUq  " }, \
        5A  { "Uqinfo " }, \
        5B  { "destpol" }, \
        5C  { "rmUqifo" }, \
        5D  { "getUqe " }, \
        5E  { "freeUqe" }, \
        5F  { "cthread" }, \
        60  { "dthread" }, \
        61  { "wrt_reg" }, \
        62  { "rd_reg " }, \
        63  { "rstadpt" }, \
        64  { "waitevt" }, \
        65  { "waitbsy" }, \
        66  { "clnuq  " }, \
        67  { "clnuqbn" }, \
        68  { "modcurr" }, \
        69  { "drwcur " }, \
        6A  { "regBuf " }, \
        6B  { "uregBuf" }, \
        6C  { "regShw " }, \
        6D  { "uregShw" }, \
        6E  { "dahwctx" }, \
        6F  { "ahwctx " }, \
        70  { "intdrcx" }, \
        71  { "offregn" }, \
        72  { "wrutil " }, \
        73  { "drwregn" }, \
        74  { "resctx " }, \
        75  { "savctx " }, \
        76  { "setWAT " }, \
        77  { "rmWnWid" }, \
        78  { "eWidWrt" }, \
        79  { "creatCC" }, \
        7A  { "delCC  " }, \
        7B  { "updteCC" }, \
        7C  { "enbleCC" }, \
        7D  { "disblCC" }, \
        7E  { "pm_hdlr" }, \
        7F  { "pmrecfg" }, \
        80  { "pmshtdn" }, \
        81  { "gpradp " }, \
        82  { "gplradp" }, \
        83  { "gscrtch" }, \
        84  { "fscrtch" }, \
        85  { "sendbuf" }, \
        86  { "dma    " }, \
        87  { "dmaSV  " }, \
        88  { "dmaMap " }, \
        8A  { "dmacplt" }, \
        8B  { "initTxt" }, \
        8C  { "lnkdrty" }, \
        8D  { "uregTxt" }, \
        8E  { "regTxt " }, \
        8F  { "initMap" }, \
        90  { "waitTxt" }, \
        91  { "strdata" }, \
        92  { "getdata" }, \
        93  { "regsseg" }, \
        94  { "uregssg" }, \
        95  { "qrysseq" }, \
        96  { "loadgmm" }, \
        97  { "bindcom" }, \
        98  { "ubndcom" }, \
        99  { "mapbuff" }, \
        9B  { "eehCabk" }, \
        9C  { "eehEnab" }, \
        9D  { "eehDisb" }, \
        9E  { "eehEchk" }, \
        9F  { "eehCfgi" }, \
        a0  { "eehRcfg" }, \
        a1  { "eehThdl" }, \
        a2  { "eehShdl" }, \
        a3  { "eehWach" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
4C5 1.0 "@mentdd" \
        "PCI MENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57515545 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW}
4C6 1.0 "@mentdd" \
        "PCI MENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW}
4C7 1.0 "@mentdd" \
        "PCI MENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
2EA 1.0 "@gxentdd" \
        "PCI GXENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57515545 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
2EB 1.0 "@gxentdd" \
        "PCI GXENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
2EC 1.0 "@gxentdd" \
        "PCI GXENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
73A 1.0 "ATIDD:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01 { "config " }, \
        02 { "init   " }, \
        03 { "rd_pci " }, \
        04 { "wr_pci " }, \
        05 { "term   " }, \
        06 { "open   " }, \
        07 { "close  " }, \
        08 { "setksr " }, \
        09 { "intadpt" }, \
        0A { "syncdpm" }, \
        0B { "add_pd " }, \
        0C { "rm_pd  " }, \
        0D { "findpd " }, \
        0E { "initpci" }, \
        0F { "mon_id " }, \
        10 { "mon_dfl" }, \
        11 { "vttinit" }, \
        12 { "vttact " }, \
        13 { "setdtg " }, \
        14 { "vttdact" }, \
        15 { "vttterm" }, \
        16 { "vttcfl " }, \
        17 { "vttclr " }, \
        18 { "vttcpl " }, \
        19 { "vttdefc" }, \
        1A { "vttmovc" }, \
        1B { "vttscr " }, \
        1C { "vtttext" }, \
        1D { "updtcur" }, \
        1E { "vttdpm " }, \
        1F { "logerr " }, \
        20 { "wrt_reg" }, \
        21 { "rd_reg " }, \
        22 { "dcursor" }, \
        23 { "pm_hdl " }, \
        24 { "cleanup" }, \
        25 { "unregpm" }, \
        26 { "dchar  " }, \
        27 { "cleanvt" }, \
        28 { "fline  " }, \
        29 { "pline  " }, \
        2A { "pllinit" }, \
        2B { "initmem" }, \
        2C { "DDF    " }, \
        2D { "DDF_ext" }, \
        2E { "setdevc" }, \
        2F { "qrydevc" }, \
        30 { "makegp " }, \
        31 { "unmkgp " }, \
        32 { "rdEDID " }, \
        33 { "DDC    " }, \
        34 { "I2Cwrt " }, \
        35 { "I2Cread" }, \
        36 { "dftres " }, \
        37 { "RASreg " }, \
        38 { "RASureg" }, \
        39 { "RAScbak" }, \
        3A { "EEHenbl" }, \
        3B { "EEHdsbl" }, \
        3C { "EEHthdr" }, \
        3D { "EEHsthd" }, \
        3E { "EEHcbak" }, \
        3F { "EEHevnt" }, \
        40 { "EEHrcfg" }, \
        41 { "EEHicfg" }, \
        42 { "EEHmode" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }

5CC 1.0 "CSCSIDD" \
        $DD1
5CD 1.0 "MPTADAPDD" \
        $DD1
64A 1.0 L=KERN "loopback " \
	{{ $loc = X2 }} \
	$loc, \
	0x0100 {"open_enter:"}, \
	0x0101 {"open_bound:" }, \
	0x0199 {"open_error:"}, \
	0x01FF {"open_exit:"}, \
	0x0200 {"close_enter:"}, \
	0x0201 {"close_unblocked:"}, \
	0x0299 {"close_error:"}, \
	0x02FF {"close_exit:"}, \
	0x0300 {"read_enter:"}, \
	0x0399 {"read_error:"}, \
	0x03FF {"read_exit:"}, \
	0x0400 {"write_enter:"}, \
	0x0499 {"write_error:"}, \
	0x04FF {"write_exit:"}, \
	0x0500 {"ioctl_enter:"}, \
	0x0501 {"ioctl_bound:"}, \
	0x0502 {"ioctl_unblocked:"}, \
	0x0599 {"ioctl_error:"}, \
	0x05FF {"ioctl_exit:"}, \
	0x0699 {"strat_error:"}, \
	0x0700 {"kproc_enter:"}, \
	0x07FF {"kproc_exit:"}, \
	\* {"unknown subhook " $loc%X2} \
	$HL, \
	0x8  {"devno="XW}, \
	0x10 {"krc="XW "devno="XW}, \
	0x18 {"krc="XW "devno="XW "D1="XW}, \
	0x20 {"krc="XW "devno="XW "D1="XW "D2="XW}, \
	0x28 {"krc="XW "devno="XW "D1="XW "D2="XW "D3="XW}
46F 1.0 "ISCSISW" \
	{{ $loc = X1 }} R1 \
	$DD1 \
	$loc, \
	70 { "topoftrc: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	71 { "strategy: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	72 { "start: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	73 { "startcmd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	74 { "interrupt: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	75 { "cmdrecv: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	76 { "error: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	77 { "iscsi_error: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	78 { "sdiodone: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	79 { "scsierror: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	7a { "procscsi: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	7b { "procancel: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	7c { "proclog: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	7d { "adaperror: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	7e { "processreset: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	7f { "processtsk: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	80 { "proc_tsk_to: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	81 { "qcmd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	82 { "dqcmd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	83 { "cmdalloc: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	84 { "clearaca: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	85 { "cancel_req: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	86 { "hash_targ: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	87 { "target_i_rst: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	88 { "target_rst: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	89 { "abort_task_set: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	8a { "cmdfree: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	8b { "cmdfail: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	8c { "cmdflush: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	8d { "scsifail: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	8e { "cdt_func: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	8f { "scsisense: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	90 { "logerr: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	91 { "cmdtimer: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	92 { "asynctimer: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	93 { "asyncstat: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	94 { "buildcmd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	95 { "buildcan: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	96 { "buildtcan: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	97 { "sendcancel: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	97 { "sendcancel: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	98 { "sendtcancel: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	99 { "ioctlerr: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	9a { "reseterr: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	9b { "haltdev: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	9c { "lunrst: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	9d { "lun_i_rst: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	9e { "issue: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	9f { "initd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a0 { "cleard: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a1 { "xmt_seq: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a2 { "ilog: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a3 { "relog: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a4 { "reset_ring: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a5 { "send_seq: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a6 { "recv_scn: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a7 { "iscsi_to_ip: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a8 { "ip_to_scsi: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	a9 { "target_trb: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	aa { "nopin_rsp: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	ab { "hrtt: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	ac { "hdread: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	ad { "hscsi_rsp_dat: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	ae { "hscsi_rsp: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	af { "htskmgm_rsp: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b0 { "hlogo_rsp: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b1 { "hlogin_rsp: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b2 { "rcv_hndler: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b3 { "fnd_ttagcmd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b4 { "rcv_trb: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b5 { "ext_free: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b6 { "close_s: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b7 { "h_drd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b8 { "h_reject: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	b9 { "h_rejectd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	ba { "h_async: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	bb { "h_asyncd: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5 }, \
	bc { "cancel_trb: d1="$D1 "d2="$D2 "d3="$D3 "d4="$D4 "d5="$D5}, \
	bd { "iscsi_to_ip enter: d1="$D1 }, \
	be { "iscsi_to_ip exit: d1="$D1 }, \
	bf { "ip_to_scsi enter: d1="$D1 }, \
	c0 { "ip_to_scsi exit: d1="$D1 }
409 1.0 "@STTY SF" \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "sf" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000E "termios_set ", \
	000F "flush ", \
	0010 "ctl ", \
	0011 "termios_get ", \
	0012 "termiox_set ", \
	0013 "termiox_get ", \
	0014 "break_set ", \
	0015 "break_clear ", \
	0016 "register ", \
	0017 "unregister ", \
	0018 "allocmsg ", \
	0019 "recover ", \
	001a "timeout ", \
	001b "err ", \
	0020 "sf_config_gorp ", \
	0021 "sf_open_port ", \
	0022 "sf_unpin_if_pinned ", \
	0023 "sf_close_port ", \
	0024 "sf_ioctl ", \
	0025 "sf_ctl ", \
	0026 "sf_poll_mode ", \
	0027 "sf_poll_int ", \
	0028 "sfc_open ", \
	0029 "sfc_close ", \
	002a "sf_check_temt ", \
	002b "sf_end_of_drain " \
	$how, \
	0000 { $which, \
		000E { "tios" $D3%X4 "force" $D4%D4 }, \
		000F { "rw" $D3%D4 "recycle" $D4%D4 "ARG3" $D5%X4 }, \
		0010 { "mp" $D3%X4 }, \
		0011 { "tios" $D3%X4 }, \
		0012 { "tiox" $D3%X4 "force" $D4%D4 }, \
		0013 { "tiox" $D3%X4 }, \
		0014 { "duration" $D3%D4 "mp" $D4%X4 }, \
		0016 { "devi" $D3%X4 }, \
		0017 { "devi" $D3%X4 }, \
		0018 { "getlock" $D3%D4 }, \
		001b { "name" $D3%X4 "code" $D4%D4 "err" $D5%E4 }, \
		0020 { "dev" $D3%X4 "cmd" $D4%D4 "uiop" $D5%X4 }, \
		0022 { "sc" $D3%X4 "lock" $D4%X4 "*lock" $D5%X4 }, \
		0024 { "cmd" ioctlname($D3) }, \
		0025 { "q" $D3%X4 "mp" $D4%X4 }, \
		0026 { "start" $D3%D4 "nsecs" $D4%D4 "*oldpri" $D5%D4 }, \
		0027 { "trp" $D3%X4 }, \
		0029 { "lock" $D3%X4 "*lock" $D4%X4 } }, \
	0001 { "DATA" $D3%D4 $D4%D4 $D5%D4 }, \
        0002 { $which, \
		0018 { "ret" $D3 "from line" $D4%D4 }, \
		\* { "ret" $D3%E4 "from line" $D4%D4 } }, \
	0003 { $D3, \
		0000 { "break at line" $D4%D4 }, \
		0001 { "continue at line" $D4%D4 }, \
		0002 { "goto from line" $D4%D4 } }
3B5 2.144 L=KERN "@ecpadd" "ecp i/o:   " \
                    {{ all_capable(acap) BITFLAGS $acap, \
                        0x00 "None ", \
                        0x01 "CapSPP ", \
                        0x02 "CapNibble ", \
                        0x04 "CapByte ", \
                        0x08 "CapEPP ", \
                        0x10 "CapECP " \
                    }} \
                    {{ astatus(status) BITFLAGS $status, \
                        0x80000000  "TimedOut", \
                        0x10000000  "XfrComplete", \
                        0x08000000  "PM", \
                        0x01000000  "PMSleep", \
                        0x00800000  "SlihInited", \
                        0x00100000  "SpiLocked", \
                        0x00080000  "Error", \
                        0x00010000  "NoPeripheral", \
                        0x00008000  "Busy", \
                        0x00004000  "Ack", \
                        0x00001000  "Fault" \
                    }} \
                    {{ bool(val) $val, \
                        0 { "FALSE" }, \
                        \* { "TRUE" } \
                    }} \
                    {{ btype(t) $t, \
                        0 { "none" }, \
                        1 { "poa" }, \
                        2 { "diag" }, \
                        3 { "devstr" }, \
                        4 { "ps" }, \
                        5 { "pcl" }, \
                        6 { "coded" }, \
                        7 { "dot1" }, \
                        8 { "dot3" }, \
                        9 { "dot4" }, \
                        \* { $t%XW } \
                    }} \
                    {{ capable(cap) $cap, \
                        0x0000 { "CapNone" }, \
                        0x0001 { "CapSPP" }, \
                        0x0002 { "CapNibble" }, \
                        0x0004 { "CapByte" }, \
                        0x0008 { "CapEPP" }, \
                        0x0010 { "CapECP" }, \
                        \* { $cap%X2 } \
                    }} \
                    {{ cfg_cmd(cmd) $cmd, \
                        1 { "CFG_INIT" }, \
                        2 { "CFG_TERM" }, \
                        3 { "CFG_QVPD" }, \
                        4 { "CFG_UCODE" }, \
                        \* { $rw%X1 } \
                    }} \
                    {{ d_err(err) $err, \
                        0xfffffffe { "EDMA_NOACC" }, \
                        0xfffffffd { "EDMA_NORES" }, \
                        0xfffffffc { "EDMA_DIOFULL" }, \
                        0xfffffffb { "EDMA_TC_NOTREACHED" }, \
                        0xfffffffa { "EDMA_BAD_MODE" }, \
                        0xffffffff { "EDMA_FAIL" }, \
                        \* { $err%DW } \
                    }} \
                    {{ d_state(dstate) $dstate, \
                        0 { "DMA_CLEARED" }, \
                        1 { "DMA_ALLOCATED" }, \
                        2 { "DMA_SLAVE_MAPPED" }, \
                        3 { "DMA_STARTED" }, \
                        4 { "DMA_RUNNING" }, \
                        5 { "DMA_STOPPED" }, \
                        6 { "DMA_COMPLETE" }, \
                        7 { "DMA_REMAINDER" }, \
                        \* { $dstate%DW } \
                    }} \
                    {{ hsresult(res) $res, \
                        0  { "Success" }, \
                        -1 { "Rejected" }, \
                        -2 { "TimedOut" }, \
                        -3 { "Not1284" }, \
                        -4 { "Intr" }, \
                        -5 { "Violation" }, \
                        -6 { "OFF" }, \
                        \* { $res%XW } \
                    }} \
                    {{ hwmode(m) $m, \
                        0 { "SPP" }, \
                        1 { "BYTE" }, \
                        2 { "PPFIFO" }, \
                        3 { "ECP" }, \
                        4 { "EPP" }, \
                        6 { "TFIFO" }, \
                        \* { $res%XW } \
                    }} \
                    {{ iftype(it) $it, \
                        0  { "Standard" }, \
                        1 { "Converged" }, \
                        2 { "IEEE1284" }, \
                        \* { $type%XW } \
                    }} \
                    {{ ioctl(ctl) $ctl, \
                        0  { "None" }, \
                        0x0000ff01 { "IOCINFO" }, \
                        0x00006c00 { "LPR" }, \
                        0x00006c01 { "LPRGET" }, \
                        0x00006c02 { "LPRSET" }, \
                        0x00006c11 { "LPRGETA" }, \
                        0x00006c12 { "LPRSETA" }, \
                        0x00006c13 { "LPRGTOV" }, \
                        0x00006c14 { "LPRSTOV" }, \
                        0x00006c17 { "LPQUERY" }, \
                        0x00006c1a { "LPDIAG" }, \
                        0x00006c1b { "LPRMODG" }, \
                        0x00006c1c { "LPRMODS" }, \
                        0x00006c28 { "ECP" }, \
                        0x00006c29 { "ECPDEVSTR" }, \
                        0x00006c2a { "ECPTERMINATE" }, \
                        0x00006c2b { "ECPMODECAP" }, \
                        0x00006c2c { "ECPMODE" }, \
                        0x00006c2d { "ECPWFLUSH" }, \
                        0x00006c2e { "ECPWATOMIC" }, \
                        0x00006c2f { "ECPS1284_D1" }, \
                        0x00006c30 { "ECPSLU" }, \
                        0x00006c31 { "ECPCTLEND" }, \
                        \* { $ctl%XW } \
                    }} \
                    {{ lpdiag(cmd) $cmd, \
                        0x00000001 { "LP_R_STAT" }, \
                        0x00000002 { "LP_R_CNTL" }, \
                        0x00000003 { "LP_W_CNTL" }, \
                        0x00000004 { "LP_R_DATA" }, \
                        0x00000005 { "LP_W_DATA" }, \
                        0x00000006 { "LP_WATCHINT" }, \
                        0x00000007 { "LP_DIDINTOCC" }, \
                        0x00000010 { "ECP_R_TFIFO" }, \
                        0x00000011 { "ECP_W_TFIFO" }, \
                        0x00000012 { "ECP_R_ECR" }, \
                        0x00000013 { "ECP_W_ECR" }, \
                        0x00000014 { "ECP_WR_DMA" }, \
                        \* { $cmd%XW } \
                    }} \
                    {{ lpmod(modes) BITFLAGS $modes, \
                        0x00000001 "PLOT ", \
                        0x00000002 "NOFF ", \
                        0x00000004 "NONL ", \
                        0x00000008 "NOCL ", \
                        0x00000010 "NOTB ", \
                        0x00000020 "NOBS ", \
                        0x00000040 "NOCR ", \
                        0x00000080 "CAPS ", \
                        0x00000100 "WRAP ", \
                        0x00000200 "FONTINIT ", \
                        0x00000400 "RPTERR ", \
                        0x00000800 "IGNOREPE ", \
                        0x01000000 "DOALLWRITES " \
                    }} \
                    {{ lpstatus(lpstat) BITFLAGS $lpstat%X4, \
                        0x01   "LPST_POUT", \
                        0x02   "LPST_TOUT", \
                        0x04   "LPST_ERROR", \
                        0x08   "LPST_BUSY", \
                        0x020  "LPST_NOSLCT", \
                        0x040  "LPST_SOFT", \
                        0x080  "LPST_OFF" \
                    }} \
                    {{ mode_nego(mode) $mode, \
                        0 { "None" }, \
                        1 { "Single" }, \
                        2 { "All" }, \
                        3 { "GetDevid" }, \
                        \* { $mode%XW } \
                    }} \
                    {{ openflags(flags) BITFLAGS $flags%X4, \
                        0x00000001  "_FREAD", \
                        0x00000002  "_FWRITE", \
                        0x00000004  "_FNONBLOCK", \
                        0x00000008  "_FAPPEND", \
                        0x00000010  "_FSYNC", \
                        0x00000020  "_FEXEC", \
                        0x00000040  "_FBIT6", \
                        0x00000080  "_FBIT7", \
                        0x00000100  "_FCREAT", \
                        0x00000200  "_FTRUNC", \
                        0x00000400  "_FEXCL", \
                        0x00000800  "_FNOCTTY", \
                        0x00001000  "_FRSHARE", \
                        0x00002000  "_FDEFER", \
                        0x00004000  "_FDELAY", \
                        0x00008000  "_FNDELAY", \
                        0x00010000  "_FNSHARE", \
                        0x00020000  "_FASYNC", \
                        0x00040000  "_FMOUNT", \
                        0x00080000  "_FSYNCALL", \
                        0x00100000  "_FNOCACHE", \
                        0x00200000  "_FREADSYNC", \
                        0x00400000  "_FDATASYNC", \
                        0x00800000  "_FDEFERIND", \
                        0x01000000  "_FDATAFLUSH", \
                        0x02000000  "_FCLREAD", \
                        0x04000000  "_FLARGEFILE", \
                        0x08000000  "_FDIRECT", \
                        0x10000000  "_FDOCLONE", \
                        0x20000000  "_FBIT29", \
                        0x40000000  "_FKERNEL", \
                        0x80000000  "_FMSYNC" \
                    }} \
                    {{ pflags(flags) $flags, \
                        \* { $flags%XW } \
                    }} \
                    {{ uio_rw(rw) $rw, \
                        0 { "READ" }, \
                        1 { "WRITE" }, \
                        2 { "READ_NO_MOVE" }, \
                        3 { "WRITE_NO_MOVE" }, \
                        \* { $rw%X1 } \
                    }} \
                    {{ wakeup(est) $est, \
                        0x00000000 { "SLEEP_NONE" }, \
                        0x00000001 { "THR_AWAKENED" }, \
                        0x00000004 { "THR_INTR" }, \
                        0x00000002 { "THR_TIMEOUT" }, \
                        0x00002284 { "DMA_TC" }, \
                        0x00002285 { "HOST_RECOVERY" }, \
                        0x00002286 { "D1_REPLY" }, \
                        0x00002287 { "D1_OUTPUT" }, \
                        0x00002288 { "INPUT_FIFO" }, \
                        0x00002289 { "INPUT_DATAR" }, \
                        0x0000228a { "INPUT_NIBBLE" }, \
                        0x0000228b { "FIFO_EMPTY" }, \
                        0x0000228c { "FIFO_BUSY" }, \
                        0x0000228d { "NFAULT" }, \
                        0x0000228e { "NACK" }, \
                        0x0000228f { "FIFO_RESTART" }, \
                        0x00002290 { "REV_REQ" }, \
                        0x00002291 { "INTR_LOCKING" }, \
                        0x00002292 { "PM_SLEPT" }, \
                        0x00002293 { "PIO_DONE" }, \
                        0x00002294 { "PIF_MISSING" }, \
                        0x00002295 { "STATUS_CHECK" }, \
                        0x00002296 { "DIAG" }, \
                        0x00003000 { "NEGO_EVENT" }, \
                        0x00003002 { "EVENT2" }, \
                        0x00003005 { "EVENT5" }, \
                        0x00003006 { "EVENT6" }, \
                        0x00003033 { "EVENT51" }, \
                        0x00003034 { "EVENT52" }, \
                        0x00003035 { "EVENT53" }, \
                        0x00003037 { "EVENT55" }, \
                        0x0000304b { "EVENT75" }, \
                        0x0000304c { "SETUP" }, \
                        0x0000304d { "TERMINATED" }, \
                        0x0000304e { "SLEEP_ECP" }, \
                        0x0000304f { "SLEEP_LAST" }, \
                        \* { $est%XW } \
                    }} \
			 $HD, \
                         0x0100 { O2 `(XW) cfg cmd ` cfg_cmd(DW) }, \
                         0x0101 { O2 `(XW) cfgx errno=EW\n -----`\n }, \
                         0x0111 { O2 `(XW) cfg unkx errno=EW\n -----`\n  }, \
                         0x0121 { O2 `(XW) cfg tux  errno=EW\n -----`\n }, \
                         0x0131 { O2 `(XW) cfg cux  errno=EW\n -----`\n }, \
                         0x0141 { O2 `(XW) cfg sanityx errno=EW\n -----`\n }, \
                         0x0143 { O2 `(XW) cfg iohandle errno=EW\n -----`\n }, \
                         0x0151 { O2 `(XW) cfg algnx errno=EW\n -----`\n }, \
                         0x0161 { O2 `(XW) cfg uiox errno=EW\n -----`\n }, \
                         0x0170 { O2 `(XW) cfg adap` }, \
                         0x0180 { O2 `(XW) cfg pif` }, \
                         0x0190 { O2 `(XW) fvt cmd value=DW` }, \
                         0x01a0 { O2 `(XW) adap ddi reg1=X2 reg2=X2 i_level=D1 i_priority=D1 d_level=D1 d_plat=D1` }, \
                         0x01b0 { O2 `(XW) pnp A4` O3 ` val=X1` }, \
                         0x01d0 { O2 `(XW) astatus( ` astatus(XW) `)`  }, \
                         0x01f0 { O2 `(XW) timestamp DW DW` }, \
                         0x0200 { O2 `(XW) close-entry` }, \
                         0x0201 { O2 `(XW) close-entryx errno=EW out=DW in=DW` }, \
                         0x0210 { O2 `(XW) close-entryx totals out=DW in=DW\n ==============================`\n }, \
                         0x0300 { O2 `(XW) ioctl-entry ` ioctl(XW) `arg=XW devflags( ` openflags(XW) `)` }, \
                         0x0301 { O2 `(XW) ioctl-entryx errno=EW` }, \
                         0x0310 { O2 `(XW) lprmodes( ` lpmod(XW) `)` }, \
                         0x0320 { O2 `(XW) astatus( ` astatus(XW) `) lpquery.status( ` lpstatus(XW) `) .tadapt=XW .reccnt=DW` }, \
			 0x0330 { O2 `(XW) lpdiag-entry cmd=` lpdiag(XW) ` value=XW ecr=X1 dsr=X1 dcr=X1` O1 }, \
			 0x0340 { O2 `(XW) lpdiag-entryx cmd=` lpdiag(XW) ` value=XW` }, \
                         0x0400 { O2 `(XW) open-entry ` }, \
                         0x0410 { O2 `(XW) open-entry detail openflags( ` openflags(XW)`) pflags( ` pflags(XW) `) astatus( ` astatus(XW) `)` }, \
                         0x0401 { O2 `(XW) open-entryx errno=EW pflags( ` pflags(XW) `)`  }, \
                         0x0500 { O2 `(XW) read-entry resid=DW` }, \
                         0x0501 { O2 `(XW) read-entryx errno=EW resid=DW` }, \
                         0x0600 { O2 `(XW) select-entry events=DW revents=DW` }, \
                         0x0601 { O2 `(XW) select-entryx errno=EW revents=DW` }, \
                         0x0700 { O2 `(XW) write-entry resid=DW iovcnt=DW offset=DW` }, \
                         0x0701 { O2 `(XW) write-entryx errno=EW resid=DW iovcnt=DW offset=DW` }, \
                         0x0710 { O2 `(XW) short write` }, \
               		 0x0761 { O2 `(XW) write-entryx retry errno=EW` }, \
                         0x0800 { O2 `(XW) dtor adap` }, \
                         0x0810 { O2 `(XW) dtor pif` }, \
                         0x0900 { O2 `(XW) pif lock` }, \
                         0x0a00 { O2 `(XW) pif unlock` }, \
                         0x0b01 { O2 `(XW) periph errno=EW` }, \
			 0x0d00 { O2 `(XW) data-not-traced-in-driver DW` }, \
                         0x0c00 { O2 `(XW) wdog start restart=DW` }, \
                         0x0c10 { O2 `(XW) wdog stop restart=DW` }, \
			 0x1a00 { O2 `(XW) termination valid` }, \
                         0x1100 { O2 `(XW) set interface nego_type=` mode_nego(XW) `if_type=` iftype(XW) `busy_delay=DW` }, \
                         0x1101 { O2 `(XW) set interfacex istate=` istate(XW) `hsresult=` hsresult(D2) `wanted=` capable(X2) \
                                     `capable(` all_capable(X2) `) mode=` capable(X2) }, \
			 0x1b00 { O2 `(XW) cvgd init ecr=X1 dsr=X1 dcr=X1` O1 }, \
			 0x1b10 { O2 `(XW) control0 XW` }, \
			 0x1b20 { O2 `(XW) control2 XW` }, \
			 0x1b30 { O2 `(XW) cvgd` O3 ` dcr=X1` }, \
                         0x31b0 { O2 `(XW) write` O3 `datar=X1` }, \
                         0x31c0 { O2 `(XW) read` O3 `dfifo=X1` }, \
                         0x31d0 { O2 `(XW) write` O3 `dfifo=X1` }, \
                         0x5210 { O2 `(XW) dma_state dold=` d_state(XW) ` dnew=` d_state(XW) }, \
                         0x5310 { O2 `(XW) d_flags=XW ch_flags=XW` }, \
                         0x5320 { O2 `(XW) d_alloc handle=XW` }, \
                         0x5321 { O2 `(XW) d_allocx handle=XW` }, \
                         0x5410 { O2 `(XW) d_map clear` }, \
			 0x5810 { O2 `(XW) sleep wakeup ` wakeup(XW) }, \
                         0x5e20 { O2 `(XW) clust init clust_addr=XW` }, \
                         0x6300 { O2 `(XW) d_enable` }, \
                         0x6400 { O2 `(XW) d_unmap_slave` }, \
                         0x6401 { O2 `(XW) d_umap_slavex derr=` d_err(XW) }, \
                         0x6600 { O2 `(XW) dma_start ` bool(DW) }, \
                         0x6900 { O2 `(XW) d_trb` }, \
                         0x6a00 { O2 `(XW) d_map slave derr=` d_err(XW) ` d_flags=XW ch_flags=XW bytes_done=DW` }, \
                         0x6b00 { O2 `(XW) d_dio total_iovecs=D1 used_iovecs==D1 resid_iov==D1 ` O1  `bytes_done==DW dvec=XW` }, \
                         0x6b10 { O2 `(XW) d_dvec dveci=DW iov_base=XW iov_len=DW xmp=XW` }, \
                         0x6b20 { O2 `(XW) uses dma ` bool(DW) }, \
                         0x6b30 { O2 `(XW) dma_minxfer ` bool(DW) }, \
                         0x6b40 { O2 `(XW) fastbytes=DW` }, \
			 0x7000 { O2 `(XW) pm check mode=XW`  }, \
			 0x7010 { O2 `(XW) pm device active ` bool(DW) }, \
			 0x7020 { O2 `(XW) pm register` }, \
			 0x7030 { O2 `(XW) pm unregister` }, \
			 0x7100 { O2 `(XW) pm handler mode=XW ctrl=XW` }, \
			 0x7101 { O2 `(XW) pm handlerx errno=EW` }, \
                         0x8300 { O2 `(XW) pm handler idle` }, \
			 0x8401 { O2 `(XW) pm handler idlex errno=EW` }, \
			 0x9001 { O2 `(XW) pm handler device enablex errno=EW` }, \
			 0xa000 { O2 `(XW) pm handler device enable` }, \
                         0xd000 { O2 `(XW) diag_d` }, \
                         0xd001 { O2 `(XW) diag_dx errno=EW out=DW` }, \
                         0xd010 { O2 `(XW) diag_d resid=DW` }, \
                         0xd101 { O2 `(XW) diag_d outputx result=XW` }, \
                         0xd110 { O2 `(XW) diag_d success` }, \
                         0xd200 { O2 `(XW) diag_d input` }, \
                         0xd201 { O2 `(XW) diag_d inputx dma_err=XW bytes_mapped=DW` }, \
                         0xd240 { O2 `(XW) diag_d sleep` }, \
                         0xd250 { O2 `(XW) diag_d out bytes=DW` }, \
                         0xd260 { O2 `(XW) diag_d dump` {{ $cnt = 16 }} `LOOP $cnt (X1}` }, \
                         \* { ` hkdata=X2 d1=$D1 d2=$D2 d3=$D3 d4=$DW d5=$D5` }
3B6 2.144 L=KERN "@ecpadd" "ecp prtcl: " \
                    {{ all_capable(acap) BITFLAGS $acap, \
                        0x00 "None ", \
                        0x01 "CapSPP ", \
                        0x02 "CapNibble ", \
                        0x04 "CapByte ", \
                        0x08 "CapEPP ", \
                        0x10 "CapECP " \
                    }} \
                    {{ bool(val) $val, \
                        0 { "FALSE" }, \
                        \* { "TRUE" } \
                    }} \
                    {{ capable(cap) $cap, \
                        0x0000 { "CapNone" }, \
                        0x0001 { "CapSPP" }, \
                        0x0002 { "CapNibble" }, \
                        0x0004 { "CapByte" }, \
                        0x0008 { "CapEPP" }, \
                        0x0010 { "CapECP" }, \
                        \* { $cap%X2 } \
                    }} \
                    {{ fifo_state(s) $s, \
                        0x00000000 { "FifoUnknown" }, \
                        0x00000001 { "FifoIdle" }, \
                        0x00000002 { "FifoEmpty" }, \
                        0x00000003 { "FifoBusy" }, \
                        0x00000004 { "FifoBusyService" }, \
                        0x00000005 { "FifoComplete" }, \
                        0x00000006 { "FifoDMAUnknown" }, \
                        0x00000007 { "FifoDMAIdle" }, \
                        0x00000008 { "FifoDMAEmpty" }, \
                        0x00000009 { "FifoDMABusy" }, \
                        0x0000000a { "FifoDMABusyService" }, \
                        0x0000000b { "FifoDMAComplete" }, \
                        \* { $s%DW } \
                    }} \
                    {{ hsresult(res) $res, \
                        0  { "Success" }, \
                        -1 { "Rejected" }, \
                        -2 { "TimedOut" }, \
                        -3 { "Not1284" }, \
                        -4 { "Intr" }, \
                        -5 { "Violation" }, \
                        -6 { "OFF" }, \
                        \* { $res%XW } \
                    }} \
                    {{ hwmode(m) $m, \
                        0 { "SPP" }, \
                        1 { "BYTE" }, \
                        2 { "PPFIFO" }, \
                        3 { "ECP" }, \
                        4 { "EPP" }, \
                        6 { "TFIFO" }, \
                        \* { $res%XW } \
                    }} \
                    {{ if_state(s) $s, \
                             0 { "StatusUnknown" }, \
                             1 { "StatusMissing" }, \
                             2 { "StatusIdle" }, \
                             3 { "StatusOffline" }, \
                             4 { "StatusBusy" }, \
                             5 { "StatusFault" }, \
                             6 { "Status1284" }, \
                        \* { $s%DW } \
                    }} \
                    {{ iftype(it) $it, \
                        0  { "Standard" }, \
                        1 { "Converged" }, \
                        2 { "IEEE1284" }, \
                        \* { $type%XW } \
                    }} \
                    {{ istate(state) $state, \
                        0x00000000 { "IntrNone" }, \
                        0x00000001 { "IntrNegotiation" }, \
                        0x00000002 { "IntrToReverse" }, \
                        0x00000003 { "IntrSetup" }, \
                        0x00000004 { "IntrTerminate" }, \
                        0x00000005 { "IntrLocking" }, \
                        0x00000006 { "IntrGetDevid" }, \
                        0x00000007 { "IntrOutputStart" }, \
                        0x00000008 { "IntrOutputHostRecovery" }, \
                        0x00000009 { "IntrOutputPIODatar" }, \
                        0x0000000a { "IntrOutputDMA" }, \
                        0x0000000b { "IntrInputStart" }, \
                        0x0000000c { "IntrInputDMA" }, \
                        0x0000000d { "IntrInputFifo" }, \
                        0x0000000e { "IntrInputDatar" }, \
                        0x0000000f { "IntrInputNibble" }, \
                        0x00000010 { "IntrReplyD1" }, \
                        0x00000011 { "IntrOutputD1" }, \
                        0x00000012 { "IntrDiag" }, \
                        0x00000013 { "IntrOutputCvgd" }, \
                        0x00000014 { "IntrStateMax" }, \
                        \* { $state%XW } \
                    }} \
                    {{ mode_nego(mode) $mode, \
                        0 { "None" }, \
                        1 { "Single" }, \
                        2 { "All" }, \
                        3 { "GetDevid" }, \
                        \* { $mode%XW } \
                    }} \
                    {{ pflags(flags) $flags, \
                        \* { $flags%XW } \
                    }} \
                    {{ phase(ph) $ph, \
                        0x00000000 { "None" }, \
                        0x00000001 { "Negotiate" }, \
                        0x00000002 { "GenericSetup" }, \
                        0x00000003 { "Setup" }, \
                        0x00000004 { "Terminate" }, \
                        0x00000005 { "GenericTerminate" }, \
                        0x00000006 { "FwdIdle" }, \
                        0x00000007 { "Forward" }, \
                        0x00000008 { "FwdToRev" }, \
                        0x00000009 { "RevIdle" }, \
                        0x0000000a { "Reverse" }, \
                        0x0000000b { "RevToFwd" }, \
                        \* { $ph%XW } \
                    }} \
                    {{ service(arm) $arm, \
                        0 { "Arm" }, \
                        1 { "DisArm" }, \
                        \* { $arm%X1 } \
                    }} \
                    {{ xfault(w) $w, \
                        0 { "FaultOnly" }, \
                        1 { "AckOnly" }, \
                        \* { $w%DW } \
                    }} \
			 $HD, \
                         0x1a01 { O2 `(XW) term valid ` bool(DW)  }, \
                         0x1110 { O2 `(XW) negotiate1 target_mode=`capable(X1) `nego_byte=X1 first=X1 second=X1` }, \
                         0x1111 { O2 `(XW) negotiate1x result=` hsresult(D2) `last_event=D2 O2 target_mode=` capable(X2) }, \
                         0x1130 { O2 `(XW) toforward  mode=` capable(X2) `ph=`phase(X2) }, \
                         0x1131 { O2 `(XW) toforwardx error=EW`  }, \
                         0x1140 { O2 `(XW) toreverse mode=` capable(X2) `ph=` phase(X2) }, \
                         0x1150 { O2 `(XW) interface init ` iftype(XW) `ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x1151 { O2 `(XW) interface initx ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x1160 { O2 `(XW) negotiate2 target_mode=` capable(X1) `nego_byte=X1 first=X1 second=X1` }, \
                         0x1170 { O2 `(XW) toforwardidle ` capable(X2) ` ` phase(X2) }, \
			 0x11b0 { O2 `(XW) wait ready DW` }, \
			 0x11c0 { O2 `(XW) wait readyx `  if_state(DW) }, \
                         0x1700 { O2 `(XW) setup ` capable (XW) }, \
                         0x1710 { O2 `(XW) terminate` }, \
                         0x1711 { O2 `(XW) terminatex result=` hsresult(D2) `mode=` capable(X2) ` ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x1720 { O2 `(XW) forceterm` }, \
                         0x1730 { O2 `(XW) reset printer iftype=` iftype(XW)}, \
                         0x1800 { O2 `(XW) event=D2 result=` hsresult(D2) `pflags( `pflags(XW)`) ph=`phase(X2)  `cnt=D2` }, \
                         0x1900 { O2  `(XW) afifo cmd=X1` O3 }, \
                         0x2800 { O2 `(XW) pio state ` pio_state(XW) }, \
                         0x2810 { O2 `(XW) pio state ` pio_state(XW) ` DW` }, \
                         0x2820 { O2 `(XW) pio state ` pio_state(XW) `DW ecr=X1 dsr=X1 dcr=X1 octet X1` }, \
			 0x2910 { O2 `(XW) mode switch ` hwmode(B0.3) O0.5 O3 }, \
                         0x3130 { O2 `(XW) data avail `bool($D2) }, \
                         0x3140 { O2 `(XW) read` O3 `dsr=X1` }, \
                         0x3150 { O2 `(XW) write` O3 `dcr=X1` }, \
                         0x3170 { O2 `(XW) read` O3 `dcr=X1` }, \
                         0x3180 { O2 `(XW) read` O3 `ecr=X1` }, \
                         0x3190 { O2 `(XW) write` O3 `ecr=X1` }, \
                         0x31a0 { O2 `(XW) read` O3 `datar=X1` }, \
			 0x3e00 { O2 `(XW) status unknown DW`  }, \
			 0x3e10 { O2 `(XW) extctrl unknown DW`  }, \
                         0x4610 { O2 `(XW) exclusive ` xfault(DW) O4 }, \
                         0x4e80 { O2 `(XW) ` service(DW) ` service ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x5630 { O2 `(XW) fifo state ` fifo_state(XW) `ecr=X1` O3 }, \
                         0x5800 { O2 `(XW) secs=DW nsecs=DW` }, \
                         0x5a10 { O2 `(XW) no protocol` }, \
                         0x5c00 { O2 `(XW) host recovery` }, \
                         0x5c01 { O2 `(XW) host recoveryx ` hsresult(DW) }, \
                         0x5e30 { O2 `(XW) pif new mode ` capable(XW) }, \
                         0x5f10 { O2 `(XW) if state ` if_state(DW) O1 `dsr=X1` O2 }, \
                         0x6200 { O2 `(XW) hs notify` }, \
			 0x6b50 { O2 `(XW) fwd wedged ` bool(DW) }, \
                         \* { ` hkdata= X2 d1=$D1 d2=$D2 d3=$D3 d4=$DW d5=$D5` }
3C0 2.144 L=INT "@ecpadd" "ecp slih:  " \
                    {{ astatus(status) BITFLAGS $status, \
                        0x80000000  "TimedOut", \
                        0x10000000  "XfrComplete", \
                        0x08000000  "PM", \
                        0x01000000  "PMSleep", \
                        0x00800000  "SlihInited", \
                        0x00100000  "SpiLocked", \
                        0x00080000  "Error", \
                        0x00010000  "NoPeripheral", \
                        0x00008000  "Busy", \
                        0x00004000  "Ack", \
                        0x00001000  "Fault" \
                    }} \
                    {{ bool(val) $val, \
                        0 { "FALSE" }, \
                        \* { "TRUE" } \
                    }} \
                    {{ istate(state) $state, \
                        0x00000000 { "IntrNone" }, \
                        0x00000001 { "IntrNegotiation" }, \
                        0x00000002 { "IntrToReverse" }, \
                        0x00000003 { "IntrSetup" }, \
                        0x00000004 { "IntrTerminate" }, \
                        0x00000005 { "IntrLocking" }, \
                        0x00000006 { "IntrGetDevid" }, \
                        0x00000007 { "IntrOutputStart" }, \
                        0x00000008 { "IntrOutputHostRecovery" }, \
                        0x00000009 { "IntrOutputPIODatar" }, \
                        0x0000000a { "IntrOutputDMA" }, \
                        0x0000000b { "IntrInputStart" }, \
                        0x0000000c { "IntrInputDMA" }, \
                        0x0000000d { "IntrInputFifo" }, \
                        0x0000000e { "IntrInputDatar" }, \
                        0x0000000f { "IntrInputNibble" }, \
                        0x00000010 { "IntrReplyD1" }, \
                        0x00000011 { "IntrOutputD1" }, \
                        0x00000012 { "IntrDiag" }, \
                        0x00000013 { "IntrOutputCvgd" }, \
                        0x00000014 { "IntrStateMax" }, \
                        \* { $state%XW } \
                    }} \
                    {{ phase(ph) $ph, \
                        0x00000000 { "None" }, \
                        0x00000001 { "Negotiate" }, \
                        0x00000002 { "GenericSetup" }, \
                        0x00000003 { "Setup" }, \
                        0x00000004 { "Terminate" }, \
                        0x00000005 { "GenericTerminate" }, \
                        0x00000006 { "FwdIdle" }, \
                        0x00000007 { "Forward" }, \
                        0x00000008 { "FwdToRev" }, \
                        0x00000009 { "RevIdle" }, \
                        0x0000000a { "Reverse" }, \
                        0x0000000b { "RevToFwd" }, \
                        \* { $ph%XW } \
                    }} \
                    {{ wakeup(est) $est, \
                        0x00000000 { "SLEEP_NONE" }, \
                        0x00000001 { "THR_AWAKENED" }, \
                        0x00000004 { "THR_INTR" }, \
                        0x00000002 { "THR_TIMEOUT" }, \
                        0x00002284 { "DMA_TC" }, \
                        0x00002285 { "HOST_RECOVERY" }, \
                        0x00002286 { "D1_REPLY" }, \
                        0x00002287 { "D1_OUTPUT" }, \
                        0x00002288 { "INPUT_FIFO" }, \
                        0x00002289 { "INPUT_DATAR" }, \
                        0x0000228a { "INPUT_NIBBLE" }, \
                        0x0000228b { "FIFO_EMPTY" }, \
                        0x0000228c { "FIFO_BUSY" }, \
                        0x0000228d { "NFAULT" }, \
                        0x0000228e { "NACK" }, \
                        0x0000228f { "FIFO_RESTART" }, \
                        0x00002290 { "REV_REQ" }, \
                        0x00002291 { "INTR_LOCKING" }, \
                        0x00002292 { "PM_SLEPT" }, \
                        0x00002293 { "PIO_DONE" }, \
                        0x00002294 { "PIF_MISSING" }, \
                        0x00002295 { "STATUS_CHECK" }, \
                        0x00002296 { "DIAG" }, \
                        0x00003000 { "NEGO_EVENT" }, \
                        0x00003002 { "EVENT2" }, \
                        0x00003005 { "EVENT5" }, \
                        0x00003006 { "EVENT6" }, \
                        0x00003033 { "EVENT51" }, \
                        0x00003034 { "EVENT52" }, \
                        0x00003035 { "EVENT53" }, \
                        0x00003037 { "EVENT55" }, \
                        0x0000304b { "EVENT75" }, \
                        0x0000304c { "SETUP" }, \
                        0x0000304d { "TERMINATED" }, \
                        0x0000304e { "SLEEP_ECP" }, \
                        0x0000304f { "SLEEP_LAST" }, \
                        \* { $est%XW } \
                    }} \
			 $HD, \
                         0x01e0 { O2 `(XW) istate_depth=DW` }, \
                         0x4000 { O2 `(XW) entry intr_state=`istate(XW) `ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x4001 { O2 `(XW) ` wakeup(XW) ` exit astatus( ` astatus(XW)`) event=DW` }, \
                         0x4010 { O2 `(XW) none` }, \
                         0x4020 { O2 `(XW) pif=DW` }, \
                         0x4101 { O2 `(XW) pif ERR event=DW` }, \
                         0x4201 { O2 `(XW) unk ERR errno=EW state=DW` }, \
                         0x4600 { O2 `(XW) allow interrupts ` bool(DW)  }, \
                         0x4620 { O2 `(XW) dma fifo empty ` bool(DW) }, \
                         0x4630 { O2 `(XW) dma slow empty ` bool(DW) }, \
                         0x4960 { O2 `(XW) fifo in` }, \
                         0x4970 { O2 `(XW) datar in` }, \
                         0x4980 { O2 `(XW) nibble in` }, \
                         0x49d0 { O2 `(XW) d1 reply` }, \
                         0x4c00 { O2 `(XW) internal inext=XW ihandler=XW ibus_type=X2 iflags=X2 ilevel=XW` }, \
                         0x4c10 { O2 `(XW) internal2 ipriority=XW ibid=XW icount=XW` }, \
                         0x4c20 { O2 `(XW) init astatus( `astatus(XW)`) event=DW` }, \
                         0x4c30 { O2 `(XW) clear astatus( `astatus(XW)`) event=DW` }, \
                         0x4d00 { O2 `(XW) diag istate=` istate(XW) }, \
                         0x4e00 { O2 `(XW) push istate=` istate(XW) }, \
                         0x4e10 { O2 `(XW) pop new_istate ` istate(XW) }, \
                         0x4e20 { O2 `(XW) init` }, \
                         0x4e40 { O2 `(XW) repl nstate=` istate(XW) }, \
                         0x4e50 { O2 `(XW) bogon ` istate(XW) ` X2 X2 XW` }, \
                         0x4f00 { O2 `(XW) ecp rev` }, \
                         \* { ` hkdata=X2 d1=$D1 d2=$D2 d3=$D3 d4=$DW d5=$D5` }
3C1 2.144 L=KERN "@ecpadd" "ecp send:  " \
                    {{ btype(t) $t, \
                        0 { "none" }, \
                        1 { "poa" }, \
                        2 { "diag" }, \
                        3 { "devstr" }, \
                        4 { "ps" }, \
                        5 { "pcl" }, \
                        6 { "coded" }, \
                        7 { "dot1" }, \
                        8 { "dot3" }, \
                        9 { "dot4" }, \
                        \* { $t%XW } \
                    }} \
                    {{ capable(cap) $cap, \
                        0x0000 { "CapNone" }, \
                        0x0001 { "CapSPP" }, \
                        0x0002 { "CapNibble" }, \
                        0x0004 { "CapByte" }, \
                        0x0008 { "CapEPP" }, \
                        0x0010 { "CapECP" }, \
                        \* { $cap%X2 } \
                    }} \
                    {{ d_err(err) $err, \
                        0xfffffffe { "EDMA_NOACC" }, \
                        0xfffffffd { "EDMA_NORES" }, \
                        0xfffffffc { "EDMA_DIOFULL" }, \
                        0xfffffffb { "EDMA_TC_NOTREACHED" }, \
                        0xfffffffa { "EDMA_BAD_MODE" }, \
                        0xffffffff { "EDMA_FAIL" }, \
                        \* { $err%DW } \
                    }} \
                    {{ dot(protocol) BITFLAGS $protocol, \
                        0x00000001 "dot1", \
                        0x00000004 "dot3", \
                        0x00000008 "dot4" \
                    }} \
                    {{ interp(in) $in, \
                        0 { "CMD" }, \
                        1 { "PCL" }, \
                        2 { "Postscript" }, \
                        3 { "Other" }, \
                        \* { $interp%XW } \
                    }} \
                    {{ pflags(flags) $flags, \
                        \* { $flags%XW } \
                    }} \
                    {{ phase(ph) $ph, \
                        0x00000000 { "None" }, \
                        0x00000001 { "Negotiate" }, \
                        0x00000002 { "GenericSetup" }, \
                        0x00000003 { "Setup" }, \
                        0x00000004 { "Terminate" }, \
                        0x00000005 { "GenericTerminate" }, \
                        0x00000006 { "FwdIdle" }, \
                        0x00000007 { "Forward" }, \
                        0x00000008 { "FwdToRev" }, \
                        0x00000009 { "RevIdle" }, \
                        0x0000000a { "Reverse" }, \
                        0x0000000b { "RevToFwd" }, \
                        \* { $ph%XW } \
                    }} \
                    {{ pio_state(pio) $pio, \
                        0x00000000 { "StateNone" }, \
                        0x00000001 { "SetupFirst" }, \
                        0x00000002 { "DataWrite" }, \
                        0x00000003 { "ClockByte" }, \
                        0x00000004 { "ClearStrobe" }, \
                        0x00000005 { "AckFirst" }, \
                        0x00000006 { "AckFirstDone" }, \
                        0x00000007 { "AckRest" }, \
                        0x00000008 { "AckConfirm" }, \
                        0x00000009 { "BusySleep" }, \
                        0x0000000a { "BusySleepDone" }, \
                        0x0000000b { "BusyWait" }, \
                        0x0000000c { "BufDone" }, \
                        \* { $pio } \
                    }} \
                    {{ wakeup(est) $est, \
                        0x00000000 { "SLEEP_NONE" }, \
                        0x00000001 { "THR_AWAKENED" }, \
                        0x00000004 { "THR_INTR" }, \
                        0x00000002 { "THR_TIMEOUT" }, \
                        0x00002284 { "DMA_TC" }, \
                        0x00002285 { "HOST_RECOVERY" }, \
                        0x00002286 { "D1_REPLY" }, \
                        0x00002287 { "D1_OUTPUT" }, \
                        0x00002288 { "INPUT_FIFO" }, \
                        0x00002289 { "INPUT_DATAR" }, \
                        0x0000228a { "INPUT_NIBBLE" }, \
                        0x0000228b { "FIFO_EMPTY" }, \
                        0x0000228c { "FIFO_BUSY" }, \
                        0x0000228d { "NFAULT" }, \
                        0x0000228e { "NACK" }, \
                        0x0000228f { "FIFO_RESTART" }, \
                        0x00002290 { "REV_REQ" }, \
                        0x00002291 { "INTR_LOCKING" }, \
                        0x00002292 { "PM_SLEPT" }, \
                        0x00002293 { "PIO_DONE" }, \
                        0x00002294 { "PIF_MISSING" }, \
                        0x00002295 { "STATUS_CHECK" }, \
                        0x00002296 { "DIAG" }, \
                        0x00003000 { "NEGO_EVENT" }, \
                        0x00003002 { "EVENT2" }, \
                        0x00003005 { "EVENT5" }, \
                        0x00003006 { "EVENT6" }, \
                        0x00003033 { "EVENT51" }, \
                        0x00003034 { "EVENT52" }, \
                        0x00003035 { "EVENT53" }, \
                        0x00003037 { "EVENT55" }, \
                        0x0000304b { "EVENT75" }, \
                        0x0000304c { "SETUP" }, \
                        0x0000304d { "TERMINATED" }, \
                        0x0000304e { "SLEEP_ECP" }, \
                        0x0000304f { "SLEEP_LAST" }, \
                        \* { $est%XW } \
                    }} \
			 $HD, \
              		 0x0720 { O2 `(XW) shortout p=XW ` O3 `c=X1` }, \
                         0x1200 { O2 `(XW) d1 init` }, \
                         0x1201 { O2 `(XW) d1 initx error=EW` }, \
                         0x1270 { O2 `(XW) dot protocol` }, \
                         0x1271 { O2 `(XW) dot protocolx supported( ` dot(XW) `)` }, \
                         0x1280 { O2 `(XW) d1 state old=D2 new=D2` }, \
                         0x1281 { O2 `(XW) d1 statex error=E2 state=D2` }, \
                         0x1310 { O2 `(XW) d1 PCC-RP   length=X2 query=X1 cmd=X1 subcmd=X1 d1=X1 d2=X1 d3=X1` }, \
                         0x1320 { O2 `(XW) d1 PCC-DLB  length=X2 query=X1 cmd=X1 subcmd=X1 d1=X1 d2=X1 d3=X1` }, \
                         0x1330 { O2 `(XW) d1 PCC-SHPS length=X2 query=X1 cmd=X1 subcmd=X1 d1=X1 d2=X1 d3=X1` }, \
                         0x1500 { O2 `(XW) d1 JC-SS    length=X2 query=X1 cmd=X1 subcmd=X1 d1=X1 d2=X1 d3=X1` }, \
                         0x1510 { O2 `(XW) d1 JC-SJ    length=X2 query=X1 cmd=X1 subcmd=X1 d1=X1 d2=X1 d3=X1` }, \
                         0x1520 { O2 `(XW) d1 JC-EJ    length=X2 query=X1 cmd=X1 subcmd=X1 d1=X1 d2=X1 d3=X1` }, \
                         0x1530 { O2 `(XW) d1 JC-ES    length=X2 query=X1 cmd=X1 subcmd=X1 d1=X1 d2=X1 d3=X1` }, \
                         0x1550 { O2 `(XW) d1 interp type=` interp(D2) ` ` bool(D2) }, \
                         0x2000 { O2 `(XW) buffer resid=DW first_data=` bool(DW) ` pflags( ` pflags(XW) `) astatus(` astatus(XW) `)` }, \
                         0x2001 { O2 `(XW) bufferx errno=EW resid=DW offset=DW pflags( ` pflags(XW) `)` }, \
                   	 0x2010 { O2 `(XW) buf_space DW` }, \
                    	 0x2020 { O2 `(XW) need DW` }, \
                         0x2200 { O2 `(XW) format in=DW space=DW` }, \
                         0x2201 { O2 `(XW) formatx out=DW` }, \
                         0x2300 { O2 `(XW) eof` }, \
                         0x2301 { O2 `(XW) eofx errno=EW chars=DW` }, \
			 0x2710 { O2 `(XW) blocking DW` }, \
                         0x2700 { O2 `(XW) busy sleep` }, \
                         0x2701 { O2 `(XW) busy sleepx loops=DW` }, \
                         0x2900 { O2 `(XW) spp write` O3 ` char=X1` }, \
                         0x3000 { O2 `(XW) d1command cmds=XW data= XW` }, \
                         0x31a0 { O2 `(XW) read` O3 `datar=X1` }, \
                         0x31b0 { O2 `(XW) write` O3 `datar=X1` }, \
                         0x31c0 { O2 `(XW) read` O3 `dfifo=X1` }, \
                         0x31d0 { O2 `(XW) write` O3 `dfifo=X1` }, \
                         0x5020 { O2 `(XW) pifbuf rcv data_len=DW offset=D2 btype=` btype(D2) `iov_base=XW iov_len=DW` }, \
                         0x5030 { O2 `(XW) pifbuf detail1 pbp=XW buf_len=DW wanted=DW btype=` btype(D1) `free `bool(D1) `segflag=` uio_rw(X1) O1 }, \
                         0x5040 { O2 `(XW) pifbuf detail2 offset=DW iov_base=XW iov_len=DW xmp=XW` }, \
                         0x5060 { O2 `(XW) pifbuf start=XW buf=XW` }, \
                         0x507c { O2 `(XW) pifbuf end=XW buf=XW` }, \
                         0x507e { O2 `(XW) pifbuf pop buf=XW len=DW` }, \
                         0x5080 { O2 `(XW) pifbuf push len=DW` }, \
                         0x5088 { O2 `(XW) pifbuf btype=`btype(DW) }, \
                         0x5091 { O2 `(XW) datastream_type=`btype(DW) }, \
                         0x5010 { O2 `(XW) pifbuf snd  data_len=DW offset=D2 btype=` btype(D2) `iov_base=XW iov_len=DW` }, \
                         0x5100 { O2 `(XW) datar output` }, \
                         0x5101 { O2 `(XW) datar outputx errno=EW out=DW ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x5110 { O2 `(XW) datar slept ` wakeup(XW) ` DW DW ecr=X1 dsr=X1 dcr=X1` O1 }, \
			 0x5120 { O2 `(XW) cvgd output` }, \
                         0x5121 { O2 `(XW) cvgd outputx errno=EW ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x5130 { O2 `(XW) cvgd slept ` wakeup(XW) ` ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x5132 { O2 `(XW) cvgd status ` cvgd_status(XW) ` ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x5400 { O2 `(XW) dma output` }, \
                         0x5401 { O2 `(XW) dma outputx errno=EW out=DW ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x5420 { O2 `(XW) dma slept ` wakeup(XW) ` DW DW` }, \
                         0x5440 { O2 `(XW) dma fault rearm DW` }, \
                         0x5450 { O2 `(XW) dma fault restart` }, \
                         0x5460 { O2 `(XW) dma short sleep DW ecr=X1 dsr=X1 dcr=X1` O1 }, \
                         0x5820 { O2 `(XW) outx istate ` istate(XW) ` DW` }, \
                         0x5830 { O2 `(XW) outx sleep ` wakeup(XW) }, \
			 0x5a00 { O2 `(XW) start out XW data_len=DW busy_delay=DW` }, \
                         0x5a01 { O2 `(XW) start outx errno=EW data_out=DW phase ` phase(XW) }, \
			 0x5a10 { O2 `(XW) start idle wait` }, \
                         0x5a50 { O2 `(XW) start out2  btype=` btype(DW) `pri=DW phase ` phase(XW) `pflags( ` pflags(DW) `)` }, \
			 0x5a10 { O2 `(XW) out spp` }, \
                         0x6800 { O2 `(XW) diag_d out slept derr=` d_err(XW) }, \
                         \* { ` hkdata=X2 d1=$D1 d2=$D2 d3=$D3 d4=$DW d5=$D5` }
3C2 2.144 L=KERN "@ecpadd" "ecp recv:  " \
			 $HD, \
                         0x1260 { O2 `(XW) d1 cvrs lun=DW` }, \
                         0x1261 { O2 `(XW) d1 cvrsx error=EW` }, \
                         0x3100 { O2 `(XW) d1reply` }, \
                         0x3101 { O2 `(XW) d1replyx cmds=XW data=XW` }, \
                         0x3110 { O2 `(XW) d1parse JC-SJ channel=X2 jobid=X2` }, \
                         0x3120 { O2 `(XW) d1parse RIC-FD numfonts=DW fdmax=DW` }, \
                         0x3160 { O2 `(XW) fifo pio recvbuf=XW wanted=DW` }, \
                         0x31a0 { O2 `(XW) read` O3 `datar=X1` }, \
                         0x31b0 { O2 `(XW) write` O3 `datar=X1` }, \
                         0x31c0 { O2 `(XW) read` O3 `dfifo=X1` }, \
                         0x31d0 { O2 `(XW) write` O3 `dfifo=X1` }, \
                         0x5000 { O2 `(XW) datar in requested=DW` }, \
                         0x5001 { O2 `(XW) datar inx error= EW received=DW` }, \
                         0x5500 { O2 `(XW) fifo in requested=DW` }, \
                         0x5501 { O2 `(XW) fifo inx error= EW received=DW` }, \
                         0x5700 { O2 `(XW) nibble in requested=DW` }, \
                         0x5701 { O2 `(XW) nibble inx error= EW received=DW` }, \
                         0x5200 { O2 `(XW) d_in requested=DW` }, \
                         0x5201 { O2 `(XW) d_inx error=EW received=DW` }, \
                         0x5b00 { O2 `(XW) start wanted=DW buf=XW buf_len=DW` }, \
                         0x5b01 { O2 `(XW) startx error=EW buf=XW data_len=DW` }, \
                         0x6800 { O2 `(XW) diag_d in slept dma_error=DW` }, \
                         \* { ` hkdata=X2 d1=$D1 d2=$D2 d3=$D3 d4=$DW d5=$D5` }
3E3 2.144 L=KERN "@ecpadd" "ecp odata: " \
			 $D1, \
                         \* { `(XW) olen=$HD%D2` LOOP $HL { X1 } }
3E4 2.144 L=KERN "@ecpadd" "ecp idata: " \
			 $D1, \
                         \* { `(XW) ilen=$HD%D2` LOOP $HL { X1 } }
2A1 1.0 "IDEDISKDD" \
        $HDU, \
        0x0F { strategy: bp=$D2 starttimer(0x2A1,$D2) }, \
        0x1E { `coalesce: (bp,ataidebuf)=($D2,$D3)` }, \
        0x1F { iodone: devtoname($D1) bp=$D2 buftofilename($D2) \
                endtimer(0x2A1,$D2) }, \
        0x17 { $D2, 0 { $SKIP } \
                bstart_entry: devtoname($D1) bp=$D2 buftofilename($D2) \
                        blkno=$D3 bcount=$D4 bflags($D5) \
        }, \
        0x18 { $D2, 0 { $SKIP } \
                bstart_exit: devtoname($D1) \
        }, \
        0x1b { $D2, 0 { $SKIP } \
               iodone : devtoname($D1) b_resid=$D2 b_error=$D3 \
        }, \
        \*   { $DD1 }
2A2 1.0 "IDECDROMDD" \
        {{$loc = X1 }} \
        $loc, \
        0x01 { entry_open: $DD2 rwflag: XW chan: XW ext: XW }, \
        0x02 { exit_open: $DD2 line: XW }, \
        0x03 { entry_close: $DD2 chan: XW ext: XW }, \
        0x04 { exit_close: $DD2 line: XW }, \
        0x05 { entry_read: $DD2 uiop: XW chan: XW ext: XW }, \
        0x06 { exit_read: $DD2 }, \
        0x07 { entry_write: $DD2 }, \
        0x08 { exit_write: $DD2 uiop: XW chan: XW ext: XW }, \
        0x09 { entry_ioctl: $DD2 op: XW arg: XW devflag: XW }, \
        0x0A { exit_ioctl: $DD2 line: XW }, \
        0x0D { entry_config: $DD2 op: XW uiop: XW }, \
        0x0E { exit_config: $DD2 line: XW }, \
        0x0F { entry_strategy: $DD2 bp: XW b_flags: XW b_blkno: XW \
               b_bcount: XW }, \
        0x10 { exit_strategy: $DD2 }, \
        0x1B { entry_iodone: $DD2 old_pri: XW bp: XW }, \
        0x1C { exit_iodone: $DD2 dk_status: XW }, \
        0x8B { entry_start: $DD2 state: XW flags: XW head: XW line: XW }, \
        0x8C { exit_start: $DD2 line: XW }, \
        0xC5 { entry_rdwr: $DD2 block_size: XW }, \
        0xC6 { exit_rdwr: $DD2 line: XW }, \
        0xC7 { entry_raw: $DD2 uio_iovcnt: XW ext: XW rw_flag: XW }, \
        0xC8 { exit_raw: $DD2 i: XW line: XW }, \
        0xC9 { entry_raw_io: $DD2 offset: XW rw_flag: XW }, \
        0xCA { exit_raw_io: $DD2 line: XW }, \
        0xCB { entry_ioctl2: $DD2 chan: XW ext: XW }, \
        0xCC { entry_start_opri: $DD2 ipri: XW }, \
        0xCD { entry_start2: $DD2 b_flags: XW b_blkno: XW b_bcount: XW }, \
        0xCE { entry_start_pri: $DD2 opri: XW }, \
        0xCF { entry_process_buf_error: $DD2 error_type_group_type: XW \
               b_error: XW b_resid: XW b_bcount: XW }, \
        0xD0 { exit_process_buf_error: $DD2 first_bad_bp: XW \
               line: XW }, \
        0xD1 { entry_process_buf_error2: $DD2 b_error: XW b_resid: XW }, \
        0xD2 { entry_process_buf_error3: $DD2 b_error: XW current_bp: XW }, \
        0xD3 { entry_process_buf_error4: $DD2 b_error: XW b_resid: XW } , \
        0xD4 { entry_process_buf_error5: $DD2 b_error: XW b_resid: XW }, \
        0xD5 { entry_failed_data_veriify: $DD2 bp: XW line: XW }, \
        0xD6 { exit_failed_data_verify: $DD2 data_verify_saved_buf: XW \
                line: XW }, \
        0xD7 { entry_process_buf2: $DD2 curbp: XW b_bcount: XW }, \
        0xD8 { entry_process_buf3: $DD2 curbp: XW b_bcount: XW }, \
        0xD9 { entry_process_buf4: $DD2 curbp: XW b_bcount: XW }, \
        0xDA { entry_fragmented_build_cmd: $DD2 bp: XW good_path: XW }, \
        0xDB { exit_fragmented_build_cmd: $DD2 line: XW }, \
        0xDC { entry_build_cmd: $DD2 bp: XW good_path: XW }, \
        0xDD { exit_build_cmd: $DD2 line: XW }, \
        0xDE { entry_build_cmd2: $DD2 bp: XW b_flags: XW b_bcount: XW }, \
        0xDF { entry_cmd_alloc_disable: $DD2 cmd_type: XW }, \
        0xE0 { exit_cmd_alloc_disable: $DD2 old_pri: XW }, \
        0xE1 { iodone: $DD2 b_flags: XW b_resid: XW }, \
        \*   { unknown trace: }
5E9 1.0 "IDECDROMDD_ERR" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3 }} \
        {{ $cnt = B0.5 }} \
        $loc, \
        0x70 { "idecdrom_opentrc:\t\t\t"} , \
        0x71 { "idecdrom_closetrc:\t\t\t"} , \
        0x74 { "idecdrom_rdwr:\t\t\t"}, \
        0x75 { "idecdrom_mincnt:\t\t\t"}, \
        0x76 { "idecdrom_raw:\t\t\t"}, \
        0x77 { "idecdrom_io_buf:\t\t\t"}, \
        0x78 { "idecdrom_raw_buff:\t\t\t"}, \
        0x79 { "idecdrom_raw_io:\t\t\t"}, \
        0x7a { "idecdrom_raw_bld:\t\t\t"}, \
        0x7b { "idecdrom_ioctls:\t\t\t"}, \
        0x7c { "idecdrom_failed_dverify:\t\t\t"}, \
        0x7d { "idecdrom_adapter_error:\t\t\t"}, \
        0x7e { "idecdrom_cmdtimer:\t\t\t"}, \
        0x7f { "idecdrom_proc_dverify:\t\t\t"}, \
        0x80 { "idecdrom_dmp_error:\t\t\t"}, \
        0x81 { "idecdrom_dmp_sns:\t\t\t"}, \
        0x82 { "idecdrom_dmp_start_unit:\t\t\t"}, \
        0x83 { "idecdrom_dmp_reqsns:\t\t\t"}, \
        0x84 { "idecdrom_process_error:\t\t\t"}, \
        0x85 { "idecdrom_process_buf_error:\t\t\t"}, \
        0x86 { "idecdrom_fail_disk:\t\t\t"}, \
        0x87 { "idecdrom_iodonetrc:\t\t\t"}, \
        0x88 { "idecdrom_process_ioctl_error:\t\t\t"}, \
        0x89 { "idecdrom_log_error:\t\t\t"}, \
        0x8a { "idecdrom_proc_dver_err:\t\t\t"}, \
        0x8b { "idecdrom_pm_watchdog:\t\t\t"}, \
        0x8c { "idecdrom_process_reset:\t\t\t"}, \
        0x8d { "idecdrom_build_data_verify:\t\t\t"}, \
        0x8e { "idecdrom_request_sense:\t\t\t"}, \
        0x8f { "idecdrom_process_reqsns_error:\t\t\t"}, \
        0x90 { "idecdrom_process_reset_error:\t\t\t"}, \
        0x91 { "idecdrom_fragmented_data_verify:\t\t\t"}, \
        0x92 { "idecdrom_process_ide_error:\t\t\t"}, \
        0x93 { "idecdrom_process_sense:\t\t\t"}, \
        0x94 { "sdiodone:\t\t\t\t"}, \
        0x95 { "idecdrom_get_medium_type:\t\t\t"}, \
        0x96 { "idecdrom_read_dvd_structure:\t\t\t"}, \
        0x97 { "idecdrom_start_watchdog:\t\t\t"}, \
        0x98 { "idecdrom_set_pio_xfer_mode:\t\t\t"}, \
        0x99 { "idecdrom_write_verify:\t\t\t"}, \
        0x9a { "idecdrom_set_dma_xfer_mode:\t\t\t"}, \
        0x9b { "idecdrom_build_cmd:\t\t\t:"}, \
        0x9c { "idecdrom_cmd_alloc:\t\t\t"}, \
        0x9d { "idecdrom_free_cmd:\t\t\t"}, \
        0x9e { "idecdrom_coales:\t\t\t"}, \
        0x9f { "idecdrom_dmpwrt:\t\t\t"}, \
        0xa0 { "dmpissue:\t\t\t\t"}, \
        0xa1 { "idecdrom_dqcmd:\t\t\t"}, \
        0xa2 { "idecdrom_process_good:\t\t\t"}, \
        0xa3 { "idecdrom_start_issue:\t\t\t"}, \
        0xa4 { "idecdrom_pm_handler:\t\t\t"}, \
        0xa5 { "idecdrom_process_buf:\t\t\t"}, \
        0xa6 { "idecdrom_qcmd:\t\t\t"}, \
        0xa7 { "idecdrom_start_trc:\t\t\t"}, \
        0xa8 { "idecdrom_strategy:\t\t\t"}, \
        0xa9 { "idecdrom_start_unit:\t\t\t"}, \
        0xaa { "idecdrom_test_unit_ready:\t\t\t"}, \
        0xab { "idecdrom_mode_sense:\t\t\t"}, \
        0xac { "idecdrom_mode_select:\t\t\t"}, \
        0xad { "idecdrom_prevent_allow:\t\t\t"}, \
        0xae { "idecdrom_read_cap:\t\t\t"}, \
        0xaf { "idecdrom_read_disc_info:\t\t\t"}, \
        0xb0 { "idecdrom_synch_cache:\t\t\t"}, \
        \*   { "unknown trace:\t\t\t"} \
        $typ, \
        0x0 { "Entry" $cnt%X1 XW XW XW XW XW }, \
        0x1 { "Trace" $cnt%X1 XW XW XW XW XW }, \
        0X2 { "Exit " $cnt%X1 XW XW XW XW XW }
707 1.0 "LFTDD:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        100  { "lftcfg  " }, \
        120  { "lftinit " }, \
        140  { "lftterm " }, \
        160  { "lftfont " }, \
        161  { "fntinit " }, \
        162  { "ldfnts  " }, \
        163  { "fntterm " }, \
        170  { "lftswkb " }, \
        200  { "lftopen " }, \
        201  { "lftclse " }, \
        202  { "strinit " }, \
        203  { "strterm " }, \
        204  { "lftout  " }, \
        205  { "vtmupd  " }, \
        206  { "vtmupd3 " }, \
        207  { "KiSak   " }, \
        208  { "KiCb    " }, \
        209  { "KiOffl  " }, \
        210  { "KiInit  " }, \
        211  { "KiTerm  " }, \
        212  { "lftst   " }, \
        213  { "lftwput " }, \
        214  { "lftwsrv " }, \
        215  { "lftrsrv " }, \
        216  { "lft_ctl " }, \
        300  { "fkproc  " }, \
        301  { "crfkp   " }, \
        302  { "killfkp " }, \
        303  { "pinfont " }, \
        304  { "fontadr " }, \
        305  { "att_shm " }, \
        306  { "det_shm " }, \
        307  { "partfnt " }, \
        308  { "dd_fun  " }, \
        320  { "fsqueue " }, \
        321  { "fsp_enq " }, \
        322  { "fsp_deq " }, \
        340  { "k_ftok  " }, \
        400  { "lft_dpms" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        HT & 0x07, \
        02 {O2 "  d0=" X4 }, \
        06 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }
1CA 1.0 "TAPEDD" \
        {{ $loc = X1 }} R1 \
        $DD1 \
        $loc, \
        19  { "command:" XW "baddress:" XW "bcount:" XW \
                } , \
        1B  { "command:" XW "baddress:" XW "bcount:" XW \
                }
5E8 1.0 "SCTAPE_ERR" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3 }} \
        {{ $cnt = B0.5 }} \
        $loc, \
        0x70 { "pstrconfig:\t\t\t"} , \
        0x71 { "pstropen:\t\t\t"} , \
        0x72 { "pstrclose:\t\t\t"} , \
        0x73 { "READ    :\t\t\t\t"}, \
        0x74 { "WRITE   :\t\t\t\t"}, \
        0x75 { "pstrioctl:\t\t\t"}, \
        0x76 { "pstrpin:\t\t\t"}, \
        0x77 { "pstrchange:\t\t\t"}, \
        0x78 { "pstrsoft:\t\t\t"}, \
        0x79 { "pstrdump:\t\t\t"}, \
        0x7a { "pstrstart:\t\t\t"}, \
        0x7b { "pstrsleep:\t\t\t"}, \
        0x7c { "pstriodone:\t\t\t"}, \
        0x7d { "pstr_request_sense:\t\t\t"}, \
        0x7e { "pstrbldcmd:\t\t\t"}, \
        0x7f { "pstrreadwrite:\t\t\t"}, \
        0x80 { "pstr_general:\t\t\t"}, \
        0x81 { "pstr_load:\t\t\t"}, \
        0x82 { "pstr_erase:\t\t\t"}, \
        0x83 { "pstr_space:\t\t\t"}, \
        0x84 { "pstr_write_filemarks:\t\t\t"}, \
        0x85 { "pstrlog:\t\t\t"}, \
        0x86 { "pstrstore:\t\t\t"}, \
        0x87 { "pstrsend:\t\t\t"}, \
        0x88 { "pstrwatchdog:\t\t\t"}, \
        0x89 { "pstrpmhandler:\t\t\t"}, \
        0x8a { "sctape_cdt_func:\t\t\t"}, \
        0x8b { "pstrreset:\t\t\t"}, \
        0x8c { "sctape_info_ras_callback:\t\t\t"}, \
        0x8d { "sctape_device_ras_callback:\t\t\t"}, \
        0x8e { "sctape_ras_unregister:\t\t\t"}, \
        0x8f { "pstr_dev_restart:\t\t\t"}, \
        0x90 { "pstrpassthru:\t\t\t"}, \
        0x91 { "pstrerror:\t\t\t"}, \
        0x92 { "pstrprocess_adapter_error:\t\t\t"}, \
        0x93 { "pstrprocess_check_condition:\t\t\t"}, \
        0x94 { "pstrprocess_scsi_error:\t\t\t\t"}, \
        0x95 { "pstr_mode_sense:\t\t\t"}, \
        0x96 { "pstr_mode_select:\t\t\t"}, \
        0x97 { "pstrpush:\t\t\t"}, \
        0x98 { "pstrpop:\t\t\t"}, \
        0x99 { "pstrfindpage:\t\t\t"}, \
        0x9a { "pstr_extract_inquiry_data:\t\t\t"}, \
        0x9b { "pstr_inquiry:\t\t\t:"}, \
        0x9c { "sctape_ras_error:\t\t\t"}, \
        \* { "Unidentified Trace from location :" $loc \
        " with data:\t\t\t\t\t"} \
        $typ, \
        0x0 { "Entry" $cnt%X1 XW XW XW XW XW }, \
        0x1 { "Trace" $cnt%X1 XW XW XW XW XW }, \
        0X2 { "Exit " $cnt%X1 XW XW XW XW XW }
233 1.0 "SCARRAYDD_ERR" \
	{{ $loc = X1 }} \
	{{ $typ = B0.3}} \
	{{ $cnt = B0.5}} \
	$loc, \
	0x70 { "fcparray_strategy:\t\t\t\t"} , \
	0x71 { "INSERT_Q:\t\t\t\t\t"} , \
	0x72 { "DEQUEUE :\t\t\t\t\t"} , \
	0x73 { "fcparray_process_adapter_error:\t\t"} , \
	0x74 { "fcparray_start:\t\t\t\t"} , \
	0x75 { "fcparray_coalesce:\t\t\t\t"} , \
	0x76 { "RELOCATE:\t\t\t\t\t"} , \
	0x77 { "fcparray_iodone:\t\t\t\t"} , \
	0x78 { "fcparray_process_good:\t\t\t"} , \
	0x79 { "fcparray_process_error:\t\t\t"} , \
	0x7a { "SDIODONE:\t\t\t\t\t"} , \
	0x7b { "BUFRETRY:\t\t\t\t\t"} , \
	0x7c { "fcparray_process_buf_error:\t\t\t"} , \
	0x7d { "fcparray_fail_array:\t\t\t\t"} , \
	0x7e { "fcparray_process_scsi_error:\t\t\t"} , \
	0x7f { "fcparray_process_buf:\t\t\t\t"} , \
	0x80 { "fcparray_process_reset:\t\t\t"} , \
	0x81 { "fcparray_q_cmd:\t\t\t\t"} , \
	0x82 { "fcparray_d_q_cmd:\t\t\t\t"} , \
	0x83 { "fcparray_cmd_alloc:\t\t\t\t"} , \
	0x84 { "fcparray_free_cmd:\t\t\t\t"} , \
	0x85 { "FAIL_CMD:\t\t\t\t\t"} , \
	0x86 { "PIORECOV:\t\t\t\t\t"} , \
	0x87 { "STRTUNIT:\t\t\t\t\t"} , \
	0x88 { "fcparray_test_unit_ready:\t\t\t"} , \
	0x89 { "fcparray_request_sense:\t\t\t"} , \
	0x8a { "fcparray_reserve:\t\t\t\t"} , \
	0x8b { "fcparray_release:\t\t\t\t"} , \
	0x8c { "fcparray_mode_sense:\t\t\t\t"} , \
	0x8d { "fcparray_mode_select:\t\t\t\t"} , \
	0x8e { "fcparray_read_cap:\t\t\t\t"} , \
	0x8f { "fcparray_inquiry:\t\t\t\t"} , \
	0x90 { "SCSISENS:\t\t\t\t\t"} , \
	0x91 { "fcparray_log_error:\t\t\t\t"} , \
	0x92 { "fcparray_watchdog:\t\t\t\t"} , \
	0x93 { "fcparray_write_verify:\t\t\t"} , \
	0x94 { "fcparray_process_special_error:\t\t"} , \
	0x95 { "fcparray_process_reqsns_error:\t\t"} , \
	0x96 { "fcparray_build_cmd:\t\t\t\t"} , \
	0x97 { "fcparray_process_diagnostic_error:\t\t"} , \
	0x98 { "fcparray_process_ioctl_error:\t\t\t"} , \
	0x99 { "fcparray_process_reset_error:\t\t\t"} , \
	0x9a { "fcparray_start_watchdog:\t\t\t"} , \
	0x9b { "ISSUE   :\t\t\t\t\t"} , \
	0x9c { "DUMP    :\t\t\t\t\t"} , \
	0x9d { "fcparray_dmp_reqsns:\t\t\t\t"} , \
	0x9e { "DMPSTRTU:\t\t\t\t\t"} , \
	0x9f { "fcparray_process_dmp_sns:\t\t\t"} , \
	0xa0 { "fcparray_process_dmp_error:\t\t\t"} , \
	0xa1 { "DMPISSUE:\t\t\t\t\t"} , \
	0xa2 { "fcparray_raw_iodone:\t\t\t\t"} , \
	0xa3 { "fcparrary_recover_adap_q:\t\t\t"} , \
	0xa4 { "MONITOR :\t\t\t\t\t"} , \
	0xa5 { "fcparray_monitor_wants_switch:\t\t"} , \
	0xa6 { "fcparray_monitor_wants_healthcheck:\t\t"} , \
	0xa7 { "fcparray_monitor_wants_aen_and_reserve:\t"} , \
	0xa8 { "fcparray_router_switch:\t\t\t"} , \
	0xa9 { "fcparray_router_switch_status:\t\t"} , \
	0xaa { "fcparray_fail_check:\t\t\t\t"} , \
	0xab { "fcparray_router_polled_aen:\t\t\t"} , \
	0xac { "AENPOLL :\t\t\t\t\t"} , \
	0xad { "fcparray_router_aen_status:\t\t\t"} , \
	0xae { "fcparray_fail_aen:\t\t\t\t"} , \
	0xaf { "fcparray_router_reserve:\t\t\t"} , \
	0xb0 { "RESPOLL :\t\t\t\t\t"} , \
	0xb1 { "fcparray_dump_write:\t\t\t\t"} , \
	0xb2 { "fcparray_router_reserve_status:\t\t"} , \
	0xb3 { "fcparray_fail_reserve:\t\t\t"} , \
	0xb4 { "fcparray_router_interpret_sense:\t\t"} , \
	0xb5 { "fcparray_router_request_sense:\t"} , \
	0xb6 { "HEALTHCK:\t\t\t\t\t"} , \
	0xb7 { "fcparray_router_watchdog:\t\t\t"} , \
	0xb8 { "CLACAISS:\t\t\t\t\t"} , \
	0xb9 { "fcparray_claca_iodone:\t\t\t"} , \
	0xba { "fcparray_fail_controller:\t\t\t"} , \
	0xbb { "fcparray_unfail_controller:\t\t\t"} , \
	0xbc { "fcparray_router_monitor_jobs:\t\t\t"} , \
	0xbd { "OPENADP :\t\t\t\t\t"} , \
	0xbe { "fcparray_destroy_router:\t\t\t"} , \
	0xbf { "fcparray_dev_restart:\t\t\t\t"} , \
	0xc0 { "fcparray_router_dev_restart:\t\t\t"} , \
	0xc1 { "fcparray_get_prefer:\t\t\t\t"} , \
	0xc2 { "fcparray_router_prefer_status:\t\t"} , \
	0xc3 { "fcparray_pr_in:\t\t\t\t"} , \
	0xc4 { "fcparray_pr_register_ignore:\t\t\t"} , \
	0xc5 { "fcparray_pr_reserve_release:\t\t\t"} , \
	0xc6 { "fcparray_pr_clear:\t\t\t\t"} , \
	0xc7 { "fcparray_pr_preempt:\t\t\t\t"} , \
	0xc8 { "fcparray_read:\t\t\t\t"} , \
	0xc9 { "fcparray_write:\t\t\t\t"} , \
	0xca { "fcparray_mincnt:\t\t\t\t"} , \
	0xcb { "fcparray_ioctl:\t\t\t\t"} , \
	0xcc { "fcparray_raw:\t\t\t\t"} , \
	0xcd { "fcparray_raw_buffer:\t\t\t\t"} , \
	0xce { "fcparray_raw_io:\t\t\t\t"} , \
	0xcf { "RAWIOD  :\t\t\t\t\t"} , \
	0xd0 { "fcparray_bld_raw_cmd:\t\t\t\t"} , \
	0xd1 { "fcparray_arrayctrl_open:\t\t\t"} , \
	0xd2 { "fcparray_arrayctrl_close:\t\t\t"} , \
	0xd3 { "fcparray_ras_callback_rt:\t\t\t"} , \
	0xd4 { "fcparray_rt_ras_callback:\t\t\t"} , \
	0xd5 { "fcparray_read_cap16:\t\t\t\t"} , \
	0xd6 { "fcparray_fail_switch:\t\t\t\t"} , \
	0xd7 { "fcparray_router_check:\t\t\t"} , \
	0xd8 { "fcparray_router_check_status:\t\t\t"} \
	$typ, \
	0x0 { "Entry" $cnt%X1 XW XW XW XW XW } , \
	0x1 { "Trace" $cnt%X1 XW XW XW XW XW } , \
	0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }
499 1.0 "SCSDISKDD_ERR" \
	{{ $loc = X1 }} \
	{{ $typ = B0.3}} \
	{{ $cnt = B0.5}} \
	$loc, \
	0x70 { "scsidisk_open:\t\t\t"} , \
	0x71 { "scsidisk_close:\t\t\t"} , \
	0x72 { "READ    :\t\t\t\t"} , \
	0x73 { "WRITE   :\t\t\t\t"} , \
	0x74 { "scsidisk_rdwr:\t\t\t"} , \
	0x75 { "scsidisk_mincnt:\t\t\t"} , \
	0x76 { "scsidisk_raw:\t\t\t"} , \
	0x77 { "scsidisk_io_buffer:\t\t\t"} , \
	0x78 { "scsidisk_raw_buffer:\t\t\t"} , \
	0x79 { "scsidisk_ras_io:\t\t\t"} , \
	0x7a { "scsidisk_build_raw_cmd:\t\t"} , \
	0x7b { "scsidisk_ioctl:\t\t\t"} , \
	0x7c { "scsidisk_dk_rwbuffer:\t\t\t"} , \
	0x7d { "scsidisk_process_adapter_error:\t"} , \
	0x7e { "scsidisk_watchdog:\t\t\t"} , \
	0x7f { "scsidisk_process_diagnostic_error:\t"} , \
	0x80 { "scsidisk_process_dmp_error:\t"} , \
	0x81 { "scsidisk_process_dmp_sns:\t\t"} , \
	0x82 { "scsidisk_dmp_start_unit:\t\t"} , \
	0x83 { "scsidisk_dmp_reqsns:\t\t\t"} , \
	0x84 { "scsidisk_process_error:\t\t"} , \
	0x85 { "scsidisk_process_buf_error:\t\t"} , \
	0x86 { "scsidisk_fail_disk:\t\t\t"} , \
	0x87 { "scsidisk_iodone:\t\t\t"} , \
	0x88 { "scsidisk_process_ioctl_error:\t"} , \
	0x89 { "scsidisk_log_error:\t\t\t"} , \
	0x8a { "scsidisk_lun_reset:\t\t\t"} , \
	0x8b { "scsidisk_pm_watchdog:\t\t\t"} , \
	0x8c { "scsidisk_process_reset:\t\t"} , \
	0x8d { "scsidisk_recover_adap_q:\t\t"} , \
	0x8e { "scsidisk_request_sense:\t\t"} , \
	0x8f { "scsidisk_process_reqsns_error:\t"} , \
	0x90 { "scsidisk_process_reset_error:\t"} , \
	0x91 { "scsidisk_retry_cmd:\t\t\t"} , \
	0x92 { "scsidisk_process_scsi_error:\t\t"} , \
	0x93 { "scsidisk_process_sense:\t\t"} , \
	0x94 { "SDIODONE:\t\t\t\t"} , \
	0x95 { "scsidisk_select_path:\t\t\t"} , \
	0x96 { "scsidisk_process_special_error:\t"} , \
	0x97 { "scsidisk_start_watchdog:\t\t"} , \
	0x98 { "scsidisk_target_reset:\t\t"} , \
	0x99 { "scsidisk_write_verify:\t\t"} , \
	0x9a { "BUFRETRY:\t\t\t\t"} , \
	0x9b { "scsidisk_build_cmd:\t\t\t"} , \
	0x9c { "scsidisk_build_error:\t\t\t"} , \
	0x9d { "scsidisk_cmd_alloc:\t\t\t"} , \
	0x9e { "FAIL_CMD:\t\t\t\t"} , \
	0x9f { "scsidisk_free_cmd:\t\t\t"} , \
	0xa0 { "scsidisk_coalesce:\t\t\t"} , \
	0xa1 { "DEQUEUE :\t\t\t\t"} , \
	0xa2 { "DUMP    :\t\t\t\t"} , \
	0xa3 { "scsidisk_dump_write:\t\t\t"} , \
	0xa4 { "DMPISSUE:\t\t\t\t"} , \
	0xa5 { "scsidisk_d_q_cmd:\t\t\t"} , \
	0xa6 { "scsidisk_process_good:\t\t"} , \
	0xa7 { "INSERT_Q:\t\t\t\t"} , \
	0xa8 { "ISSUE   :\t\t\t\t"} , \
	0xa9 { "scsidisk_issue_multicmd:\t\t"} , \
	0xaa { "scsidisk_pm_handler:\t\t\t"} , \
	0xab { "scsidisk_pr_clear:\t\t\t"} , \
	0xac { "scsidisk_pr_in:\t\t\t"} , \
	0xad { "scsidisk_pr_preempt:\t\t\t"} , \
	0xae { "scsidisk_pr_register_ignore:\t\t"} , \
	0xaf { "scsidisk_pr_reserve_release:\t\t"} , \
	0xb0 { "scsidisk_process_inquiry:\t\t"} , \
	0xb1 { "scsidisk_process_buf:\t\t\t"} , \
	0xb2 { "scsidisk_q_cmd:\t\t\t"} , \
	0xb3 { "RELOCATE:\t\t\t\t"} , \
	0xb4 { "scsidisk_dev_restart:\t\t\t"} , \
	0xb5 { "RAWIODON:\t\t\t\t"} , \
	0xb6 { "scsidisk_start:\t\t\t"} , \
	0xb7 { "scsidisk_strategy:\t\t\t"} , \
	0xb8 { "scsidisk_reserve:\t\t\t"} , \
	0xb9 { "scsidisk_start_unit:\t\t\t"} , \
	0xba { "scsidisk_test_unit_ready:\t\t"} , \
	0xbb { "scsidisk_mode_sense:\t\t\t"} , \
	0xbc { "scsidisk_mode_select:\t\t\t"} , \
	0xbd { "scsidisk_prevent_allow:\t\t"} , \
	0xbe { "scsidisk_inquiry:\t\t\t"} , \
	0xbf { "scsidisk_read_cap:\t\t\t"} , \
	0xc0 { "scsidisk_read_cap16:\t\t\t"} , \
	0xc1 { "scsidisk_get_read_toc:\t\t"} , \
	0xc2 { "scsidisk_read_disc_info:\t\t"} , \
	0xc3 { "scsidisk_get_medium_type:\t\t"} , \
	0xc4 { "scsidisk_get_medium_info:\t\t"} , \
	0xc5 { "scsidisk_release:\t\t\t"} , \
	0xc6 { "scsidisk_process_inband_error:\t"} , \
	0xc7 { "scsidisk_process_inband_sense:\t"} , \
	0xc8 { "scsidisk_ras_callback:\t\t"} , \
	0xc9 { "scsidisk_open_adapter:\t\t"} , \
	0xca { "scsidisk_close_adapter:\t\t"} , \
	0xcb { "mpioAddDrvrPath:\t\t\t"}, \
	0xcc { "mpioAddPcm:\t\t\t\t"}, \
	0xcd { "mpioDelPcm:\t\t\t\t"}, \
	0xce { "mpioAddDevice:\t\t\t"}, \
	0xcf { "mpioChgDevice:\t\t\t"}, \
	0xd0 { "mpioDelDevice:\t\t\t"}, \
	0xd1 { "mpioSetDeviceState:\t\t\t"}, \
	0xd2 { "mpioGetDeviceState:\t\t\t"}, \
	0xd3 { "mpioAddPath:\t\t\t\t"}, \
	0xd4 { "mpioChgPath:\t\t\t\t"}, \
	0xd5 { "mpioDelPath:\t\t\t\t"}, \
	0xd6 { "mpioSetPathState:\t\t\t"}, \
	0xd7 { "mpioGetPathState:\t\t\t"}, \
	0xd8 { "mpioPassThru:\t\t\t"}, \
	0xd9 { "mpioSelectPath:\t\t\t"}, \
	0xda { "mpioRetryPath:\t\t\t"}, \
	0xdb { "mpioForcePath:\t\t\t"}, \
	0xdc { "mpioSelectIoctlPath:\t\t\t"}, \
	0xdd { "mpioSelectDumpPath:\t\t\t"}, \
	0xde { "mpioIoDone:\t\t\t\t"}, \
	0xdf { "mpioTerm:\t\t\t\t"}, \
	0xe0 { "mpioGetPathPvt:\t\t\t"}, \
	0xe1 { "mpioNotifyPolicy:\t\t\t"}, \
	0xe2 { "mpioSetPolicy:\t\t\t"}, \
	0xe3 { "mpioUpdatePathStats:\t\t\t"}, \
	0xe4 { "mpioHandleBufX:\t\t\t"}, \
	0xe5 { "mpioCfg:\t\t\t\t"}, \
	0xe6 { "mpioValidatePcm:\t\t\t"}, \
	0xe7 { "mpioRegPaths:\t\t\t"}, \
	0xe8 { "mpioRegPath:\t\t\t\t"}, \
	0xe9 { "mpioUnregPath:\t\t\t"}, \
	0xea { "mpioSelectPcm:\t\t\t"}, \
	0xeb { "mpioCopyinPvtData:\t\t\t"}, \
	0xec { "mpioGetPathIds:\t\t\t"}, \
	0xed { "mpioIbcPending:\t\t\t"}, \
	0xee { "mpioRegPathStat:\t\t\t"}, \
	0xef { "mpioDelDriver:\t\t\t"}, \
	0xf0 { "mpioddieRAS:\t\t\t"}, \
	0xf1 { "mpioeRAS:\t\t\t\t"}, \
	0xf2 { "mpioRasCallBack:\t\t\t"}, \
	0xf3 { "mpioeRASunReg:\t\t\t"}, \
	0xf4 { "mpioEnqCmd:\t\t\t\t"}, \
	0xf5 { "mpioSetPofState:\t\t\t"}, \
	0xf6 { "mpioNotifyPathFlags:\t\t\t"}, \
	0xf7 { "mpioPathOpenFail:\t\t\t"}, \
	0xf8 { "mpioSuperInit:\t\t\t"}, \
	0xf9 { "mpioInit:\t\t\t\t"}, \
	0xfa { "mpioAddDriver:\t\t\t"}, \
        0xfb { "scsidisk_fail_pcm_inband_cmds:\t"} , \
        0xfc { "scsidisk_fail_q_recov :\t\t"} \
	$typ, \
	0x0 { "Entry" $cnt%X1 XW XW XW XW XW } , \
	0x1 { "Trace" $cnt%X1 XW XW XW XW XW } , \
	0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }
647 1.0 "@rrhbadd" \
	"RRHBADD GEN: " W1 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
648 1.0 "@rrhbadd" \
	"RRHBADD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
649 1.0 "@rrhbadd" \
	"RRHBADD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
658 1.0 "RRLCT3:  " \
	"LCT3: " W1 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
644 1.0 "@rrentdd" \
        "RRENTDD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
645 1.0 "@rrentdd" \
        "RRENTDD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57454E44 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
646 1.0 "@rrentdd" \
        "RRENTDD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW }
738 1.0 "USBD:    " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "config " }, \
        02  { "ioctl  " }, \
        03  { "cfgproc" }, \
        04  { "opndev " }, \
        05  { "clsdev " }, \
        06  { "addhc  " }, \
        07  { "delhc  " }, \
        08  { "fnddev " }, \
        09  { "deldev " }, \
        0A  { "adddev " }, \
        0B  { "setaddr" }, \
        0C  { "pipeio " }, \
        0D  { "pipecnt" }, \
        0E  { "pipedis" }, \
        10  { "stcfg  " }, \
        11  { "stpcfg " }, \
        12  { "cmdcfg " }, \
        13  { "rstport" }, \
        14  { "addhub " }, \
        15  { "delhub " }, \
        16  { "qchgirp" }, \
        17  { "getstat" }, \
        18  { "pstat  " }, \
        19  { "iowait " }, \
        1A  { "ioabort" }, \
        1B  { "pipeclr" }, \
        1C  { "pipstat" }, \
        1D  { "chgirp " }, \
        1E  { "recnt  " }, \
        1F  { "discnt " }, \
        20  { "log    " }, \
        21  { "opndeve" }, \
        22  { "enum   " }, \
        24  { "getdesi" }, \
        25  { "getdes " }, \
        26  { "devreq " }, \
        27  { "powck  " }, \
        28  { "mapmem " }, \
        29  { "umapmem" }, \
        2A  { "postiob" }, \
        2B  { "timepop" }, \
        2C  { "clrherr" }, \
        2D  { "getdevs" }, \
        2E  { "getfram" }, \
        2F  { "setinte" }, \
        30  { "eRAScb " }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
1025 1.0 "SFWCOM"        \
        {{ $loc = X1 }}    \
        {{ $typ = B0.3 }}  \
        {{ $cnt = B0.5 }}  \
        $loc,              \
        0x10 { "nc_config:          " } , \
        0x11 { "nc_open:            " } , \
        0x12 { "nc_close:           " } , \
        0x13 { "nc_ctl:             " } , \
        0x14 { "nc_1st_time_cfg:    " } , \
        0x15 { "nc_config_init:     " } , \
        0x16 { "nc_config_term:     " } , \
        0x17 { "nc_config_undo:     " } , \
        0x18 { "nc_start_kproc:     " } , \
        0x19 { "nc_stop_kproc:      " } , \
        0x1A { "nc_kproc:           " } , \
        0x1B { "nc_fwd_fail:        " } , \
        0x1C { "nc_query:           " } , \
        0x1D { "nc_query_resp:      " } , \
        0x1E { "nc_find_node:       " } , \
        0x1F { "nc_found:           " } , \
        0x20 { "nc_shutdown:        " } , \
        0x21 { "nc_nnadvert:        " } , \
        0x22 { "nc_nnack:           " } , \
        0x23 { "nc_proc_msg:        " } , \
        0x24 { "nc_proc_uni:        " } , \
        0x25 { "nc_proc_multi:      " } , \
        0x26 { "nc_proc_ptoc:       " } , \
        0x27 { "nc_receive:         " } , \
        0x28 { "nc_status:          " } , \
        0x29 { "nc_output:          " } , \
        0x2A { "nc_tx_mcast_pkt:    " } , \
        0x2B { "nc_tx_ucast_pkt:    " } , \
        0x2C { "nc_forward_packet:  " } , \
        0x2D { "nc_ctl_advert:      " } , \
        0x2E { "nc_1st_time_cf2:    " } , \
        0x2F { "nc_proc_stat:       " } , \
        0x30 { "nc_ctl_join:        " } , \
        0x31 { "nc_create_list:     " } , \
        0x32 { "nc_tx_scast_pkt:    " } , \
        0x33 { "nc_proc_join:       " } , \
        0x34 { "nc_dup_mcast:       " } , \
        0x35 { "nc_promo_node:      " } , \
        0x36 { "nc_tbl_sanity:      " } , \
        0x37 { "nc_add_node:        " } , \
        0x38 { "nc_remove_node:     " } , \
        0x39 { "nc_send_advert:     " } , \
        0x3A { "nc_ctl_find:        " } , \
        0x3B { "nc_hc_timer:        " } , \
        0x3C { "nc_hcheck:          " } , \
        0x3D { "nc_build_nnack:     " } , \
        0x3E { "nc_set_tx_error:    " } , \
        0x3F { "nc_tx_direct:       " } , \
        0x40 { "nc_hop_update:      " } , \
        0x41 { "nc_check_hop:       " } , \
        0x42 { "nc_create_jnode:    " } , \
        0x70 { "ncdmx_add_filt:     " } , \
        0x71 { "ncdmx_del_filt:     " } , \
        0x72 { "ncdmx_add_stat:     " } , \
        0x73 { "ncdmx_del_stat:     " } , \
        0x74 { "ncdmx_find_exm:     " } , \
        0x75 { "ncdmx_find_clm:     " } , \
        0x76 { "ncdmx_status:       " } , \
        0x77 { "ncdmx_receive:      " } , \
        0x7D { "vlc_get_if_state:   " } , \
        0x7E { "vlc_timer:          " } , \
        0x7F { "vlc_i_am_gone:      " } , \
        0x80 { "vlc_init:           " } , \
        0x81 { "vlc_output:         " } , \
        0x82 { "vlc_control:        " } , \
        0x83 { "vlc_receive:        " } , \
        0x84 { "vlc_config_if:      " } , \
        0x85 { "vlc_get_if_flags:   " } , \
        0x86 { "vlc_set_access:     " } , \
        0x87 { "vlc_leave:          " } , \
        0x88 { "vlc_halt:           " } , \
        0x89 { "vlc_who_there:      " } , \
        0x8A { "vlc_i_am_here:      " } , \
        0x8B { "vlc_unconfig_if:    " } , \
        0x8C { "vlc_offlevel:       " } , \
        0x8D { "vlc_find_tgt:       " } , \
        0x8E { "vlc_recv_ctl:       " } , \
        0x8F { "vlc_send_pkt:       " } , \
        0x90 { "snc_init:           " } , \
        0x91 { "snc_get_if_flags:   " } , \
        0x92 { "snc_output:         " } , \
        0x93 { "snc_control:        " } , \
        0x94 { "snc_receive:        " } , \
        0x95 { "snc_config_if:      " } , \
        0x96 { "snc_set_access:     " } , \
        0x97 { "snc_leave:          " } , \
        0x98 { "snc_term:           " } , \
        0x99 { "snc_start_kproc:    " } , \
        0x9a { "snc_stop_kproc:     " } , \
        0x9b { "snc_kproc:          " } , \
        0x9c { "snc_unconfig_if:    " } , \
        0x9d { "snc_query:          " } , \
        0x9e { "snc_check_new:      " } , \
        0x9f { "snc_add_tgt:        " } , \
        0xa0 { "snc_remove_tgt:     " } , \
        0xa1 { "snc_recv_data:      " } , \
        0xa2 { "snc_create_id:      " } , \
        0xa3 { "snc_send_data:      " } , \
        0xa4 { "snc_start_if:       " } , \
        0xa5 { "snc_get_if_state:   " } , \
        0xa6 { "snc_rx_thread:      " } , \
        0xc0 { "sd_init:            " } , \
        0xc1 { "sd_check_if:        " } , \
        0xc2 { "sd_identify_target: " } , \
        0xc3 { "sd_inquiry_iodone:  " } , \
        0xc4 { "sd_iodone:          " } , \
        0xc5 { "sd_queue_iodone:    " } , \
        0xc6 { "sd_recv_buffer:     " } , \
        0xc7 { "sd_query_fc:        " } , \
        0xc8 { "sd_query_sas:       " } , \
        0xc9 { "sd_stop_rtgt:       " } , \
        0xca { "sd_recov_q:         " } , \
        0xcb { "sd_output:          " } , \
        0xcc { "sd_resend:          " } , \
        0xcd { "sd_halt_tgt:        " } , \
        0xce { "sd_check_wwpn:      " } , \
        0xd0 { "dp_config:             " } , \
        0xd1 { "dp_open:               " } , \
        0xd2 { "dp_close:              " } , \
        0xd3 { "dp_ctl:                " } , \
        0xd4 { "dp_first_time_config:  " } , \
        0xd5 { "dp_config_init:        " } , \
        0xd6 { "dp_first_time_config2: " } , \
        0xd7 { "dp_config_term:        " } , \
        0xd8 { "dp_config_undo:        " } , \
        0xd9 { "dp_output:             " } , \
        0xda { "dp_start_kproc:        " } , \
        0xdb { "dp_stop_kproc:         " } , \
        0xdc { "dp_kproc:              " } , \
        0xdd { "dp_ctl_join:           " } , \
        0xde { "dp_ctl_leave:          " } , \
        0xdf { "dp_process_state:      " } , \
        0xe0 { "dp_attempt_lock:       " } , \
        0xe1 { "dp_verify_lock:        " } , \
        0xe5 { "dp_open_repos:         " } , \
        0xe6 { "dp_close_repos:        " } , \
        0xe7 { "dp_read_idx:           " } , \
        0xe8 { "dp_write_idx:          " } , \
        0xe9 { "dp_read_lock:          " } , \
        0xea { "dp_write_lock:         " } , \
        0xeb { "dp_release_lock:       " } , \
        0xec { "dp_rd_msgs:            " } , \
        0xed { "dp_rd_msg:             " } , \
        0xee { "dp_wr_msg:             " } , \
        0xef { "dp_wr_msgcb:           " } , \
        0xf0 { "dp_rd_msgcb:           " } , \
        0xf1 { "dp_rd_init:            " } , \
        0xf8 { "dpdmx_add_filter:      " } , \
        0xf9 { "dpdmx_del_filter:      " } , \
        0xfa { "dpdmx_add_status:      " } , \
        0xfb { "dpdmx_del_status:      " } , \
        0xfc { "dpdmx_find_exact_match:" } , \
        0xfd { "dpdmx_find_clust_match:" } , \
        0xfe { "dpdmx_status:          " } , \
        0xff { "dpdmx_receive:         " } , \
        \*   { "unknown subhook:    " $loc }  \
        $typ, \
        0x0  { "Ent" $cnt%X1 XW XW XW XW XW }, \
        0x1  { "Trc" $cnt%X1 XW XW XW XW XW }, \
        0x2  { "Ext" $cnt%X1 XW XW XW XW XW }
1029 1.0 "SFW"        \
        {{ $loc = X1 }}    \
        {{ $typ = B0.3 }}  \
        {{ $cnt = B0.5 }}  \
        $loc,              \
        0x70 { "sfwEnqu:          " } , \
        0x71 { "sfwDequ:          " } , \
        0x72 { "sfwLook:          " } , \
        0x73 { "sfwAddIf:         " } , \
        0x74 { "sfwDelIf:         " } , \
        0x75 { "sfwGetIf:         " } , \
        0x76 { "sfwSetIf:         " } , \
        0x77 { "sfwAddDsk:        " } , \
        0x78 { "sfwDelDsk:        " } , \
        0x79 { "sfwGetDsk:        " } , \
        0x7A { "sfwSetDsk:        " } , \
        0x7B { "sfwAddFencGrp:    " } , \
        0x7C { "sfwDelFencGrp:    " } , \
        0x7D { "sfwGetFencGrp:    " } , \
        0x7E { "sfwSetFencGrp:    " } , \
        0x7F { "sfwAddEvt:        " } , \
        0x80 { "sfwDelEvt:        " } , \
        0x81 { "sfwGetEvt:        " } , \
        0x82 { "sfwSetEvt:        " } , \
        0x83 { "sfwAddLnr:        " } , \
        0x84 { "sfwDelLnr:        " } , \
        0x85 { "sfwGetLnr:        " } , \
        0x86 { "sfwSetLnr:        " } , \
        0x87 { "sfwAddNd:         " } , \
        0x88 { "sfwDelNd:         " } , \
        0x89 { "sfwGetNd:         " } , \
        0x8A { "sfwSetNd:         " } , \
        0x8B { "sfwAddCl:         " } , \
        0x8C { "sfwDelCl:         " } , \
        0x8D { "sfwGetCl:         " } , \
        0x8E { "sfwSetCl:         " } , \
        0x8F { "sfwGetUu:         " } , \
        0x90 { "sfwAddLtoE:       " } , \
        0x91 { "sfwNotLis:        " } , \
        0x92 { "sfwSciolEvent:    " } , \
        0x93 { "sfwAddIntToEvent: " } , \
        0x94 { "sfwProcSciolEvt:  " } , \
        \*   { "unknown subhook:  " $loc }  \
        $typ, \
        0x0  { "Ent" $cnt%X1 XW XW XW XW XW }, \
        0x1  { "Trc" $cnt%X1 XW XW XW XW XW }, \
        0x2  { "Ext" $cnt%X1 XW XW XW XW XW }
5DD 1.0 "SISSAS_ERR" \
	{{ $loc = X1 }} \
	{{ $unused = X1 }} \
	$loc, \
	0x10 { "SAS CFG INIT:\t\t\t" XW XW XW } , \
	0x11 { "SAS_CFG_TERM:\t\t\t" XW XW XW } , \
	0x12 { "Enter SAS Strat:\t\t\t" XW XW XW } , \
	0x13 { "Exit SAS Strat 1:\t\t" XW XW XW } , \
	0x14 { "Exit SAS Strat 2:\t\t" XW XW XW } , \
	0x15 { "Exit SAS Strat 3:\t\t" XW XW XW } , \
	0x16 { "Exit SAS Strat 4:\t\t" XW XW XW } , \
	0x17 { "Exit SAS Strat 5:\t\t" XW XW XW } , \
	0x18 { "Exit SAS Strat 6:\t\t" XW XW XW } , \
	0x19 { "Enter JBOD Start:\t\t" XW XW XW } , \
	0x1a { "SAS Start !cte:\t\t\t" XW XW XW } , \
	0x1b { "Proc CLEAR_ACA:\t\t\t" XW XW XW } , \
	0x1c { "SAS Start NOACC:\t\t\t" XW XW XW } , \
	0x1d { "DMA_R_NORES:\t\t\t" XW XW XW } , \
	0x1e { "SAS Start TO:\t\t\t" XW XW XW } , \
	0x1f { "Vset Init map:\t\t\t" XW XW XW } , \
	0x20 { "SAS Start R_FAIL:\t\t" XW XW XW } , \
	0x21 { "Process LUN_RESET:\t\t" XW XW XW } , \
	0x22 { "Process Q_CLR:\t\t\t" XW XW XW } , \
	0x23 { "JBOD Start:\t\t\t" XW XW XW } , \
	0x24 { "SYNC Cmpt/Over:\t\t\t" XW XW XW } , \
	0x25 { "SCSI buf complete:\t\t" XW XW XW } , \
	0x26 { "AF buf complete:\t\t\t" XW XW XW } , \
	0x27 { "Dev Non-0 IOASC:\t\t\t" XW XW XW } , \
	0x28 { "SAS IOCTL FAIL1:\t\t\t" XW XW XW } , \
	0x29 { "SAS IOCTL:\t\t\t\t" XW XW XW } , \
	0x2a { "SAS IOCTL FAIL2:\t\t\t" XW XW XW } , \
	0x2b { "SAS lstart copyin:\t\t" XW XW XW } , \
	0x2c { "VSET lstart alloc:\t\t" XW XW XW } , \
	0x2d { "JBOD dump cmd_rsrc:\t\t" XW XW XW } , \
	0x2e { "JBOD dump map:\t\t\t" XW XW XW } , \
	0x2f { "JBOD dump ioadl:\t\t\t" XW XW XW } , \
	0x30 { "Fail nonAct Op:\t\t\t" XW XW XW } , \
	0x31 { "Vset Init md:\t\t\t" XW XW XW } , \
	0x32 { "Vset Init vlist:\t\t\t" XW XW XW } , \
	0x33 { "Vset Init blist:\t\t\t" XW XW XW } , \
	0x34 { "Vset flags ERR:\t\t\t" XW XW XW } , \
	0x35 { "Vset q_tag ERR:\t\t" XW XW XW } , \
	0x36 { "Enter Vset Strat:\t\t" XW XW XW } , \
	0x37 { "Exit 1 Vset Strat:\t\t" XW XW XW } , \
	0x38 { "Exit 2 Vset Strat:\t\t" XW XW XW } , \
	0x39 { "Vset Start NoDev:\t\t" XW XW XW } , \
	0x3a { "Vset Start NOACC:\t\t" XW XW XW } , \
	0x3b { "Vset DMA_R_NORES:\t\t" XW XW XW } , \
	0x3c { "Vset Start >90:\t\t\t" XW XW XW } , \
	0x3d { "Vset Start DMA_R:\t\t" XW XW XW } , \
	0x3e { "Start Vset:\t\t\t" XW XW XW } , \
	0x3f { "AF Non-0 IOASC:\t\t\t" XW XW XW } , \
	0x40 { "Vset dump Unsupt:\t\t" XW XW XW } , \
	0x41 { "Vset dump size:\t\t\t" XW XW XW } , \
	0x42 { "Vset dump cmd_rsrc:\t\t" XW XW XW } , \
	0x43 { "Vset dump map:\t\t\t" XW XW XW } , \
	0x44 { "   Dev FD_IOASC:\t\t\t" XW XW XW } , \
	0x45 { "Send chkexp:\t\t\t" XW XW XW } , \
	0x46 { "End chkexp Block:\t\t" XW XW XW } , \
	0x47 { "sciolchkexp ver:\t\t\t" XW XW XW } , \
	0x48 { "sciolchkexp mode:\t\t" XW XW XW } , \
	0x49 { "sciolchkexp LUN:\t\t\t" XW XW XW } , \
	0x4a { "sciolchkexp IABW:\t\t" XW XW XW } , \
	0x4b { "sciolchkexp FAIL:\t\t" XW XW XW } , \
	0x4c { "SATA CFG_INIT:\t\t\t" XW XW XW } , \
	0x4d { "SATA_CFG_TERM:\t\t\t" XW XW XW } , \
	0x4e { "SATA Start:\t\t\t" XW XW XW } , \
	0x4f { "Exit SATA Strat 1:\t\t" XW XW XW } , \
	0x50 { "Enter SATA Strat:\t\t" XW XW XW } , \
	0x51 { "Exit SATA Strat 2:\t\t" XW XW XW } , \
	0x52 { "Exit SATA Strat 3:\t\t" XW XW XW } , \
	0x53 { "Exit SATA Strat 4:\t\t" XW XW XW } , \
	0x54 { "SATA Start 1:\t\t\t" XW XW XW } , \
	0x55 { "SATA Start !cte:\t\t\t" XW XW XW } , \
	0x56 { "SATA Start DMA:\t\t\t" XW XW XW } , \
	0x57 { "SATA DIOFULL:\t\t\t" XW XW XW } , \
	0x58 { "SATA IOASC!=0:\t\t\t" XW XW XW } , \
	0x59 { "Exit SATA PASSTH:\t\t" XW XW XW } , \
	0x5a { "SATA AttRdBuf:\t\t\t" XW XW XW } , \
	0x5b { "SATA DmpWDev !cte:\t\t" XW XW XW } , \
	0x5c { "SATA DmpWDev !Rsc:\t\t" XW XW XW } , \
	0x5d { "SATA DmpWDev DMA:\t\t" XW XW XW } , \
	0x5e { "ATA buf complete:\t\t" XW XW XW } , \
	0x5f { "SATA DmpWDev:\t\t\t" XW XW XW } , \
	0x60 { "SATA call Strat :\t\t" XW XW XW } , \
	0x61 { "SATA pthru RC!=0:\t\t" XW XW XW } , \
	0x62 { "Identify RC!=0  :\t\t" XW XW XW } , \
	0x63 { "SATA TUR RC!=0  :\t\t" XW XW XW } , \
	0x64 { "SATA INQ RC!=0  :\t\t" XW XW XW } , \
	0x65 { "SATA RDBLK RC!=0:\t\t" XW XW XW } , \
        0x66 { "SavPciCfg DevCtrl:\t\t" XW XW XW } , \
        0x67 { "SavPciCfg LnkCap:\t\t" XW XW XW } , \
        0x68 { "SavPciCfg LnkCtrl:\t\t" XW XW XW } , \
        0x69 { "SavPciCfg MSIladr:\t\t" XW XW XW } , \
        0x6a { "SavPciCfg MSIuadr:\t\t" XW XW XW } , \
        0x6b { "SavPciCfg MSIdata:\t\t" XW XW XW } , \
        0x6c { "SavPciCfg AER:\t\t" XW XW XW } , \
        0x6d { "AdptCfg ddi:\t\t" XW XW XW } , \
        0x6e { "AdptCfg dev_md:\t\t" XW XW XW } , \
        0x6f { "AdptCfg sata_md:\t\t" XW XW XW } , \
	0x70 { "AdptCfg CDT:\t\t\t" XW XW XW } , \
	0x71 { "AdptCfg dmp_add:\t\t\t" XW XW XW } , \
	0x72 { "AdptCfg afdev:\t\t\t" XW XW XW } , \
	0x73 { "AdptCfg ioh:\t\t\t" XW XW XW } , \
	0x74 { "AdptCfg D_MAP:\t\t\t" XW XW XW } , \
	0x75 { "AdptCfg DIO_INIT:\t\t" XW XW XW } , \
	0x76 { "AdptCfg ioa_md:\t\t\t" XW XW XW } , \
	0x77 { "AdptCfg MAP_PAGE:\t\t" XW XW XW } , \
	0x78 { "AdptCfg pincode:\t\t\t" XW XW XW } , \
	0x79 { "AdptCfg rstTime:\t\t\t" XW XW XW } , \
	0x7a { "AdptCfg pndTime:\t\t\t" XW XW XW } , \
	0x7b { "AdptCfg noEEH:\t\t\t" XW XW XW } , \
	0x7c { "AdptCfg EEHFail:\t\t\t" XW XW XW } , \
	0x7d { "AdptCfg i_init:\t\t\t" XW XW XW } , \
	0x7e { "AdptCfg pci_cfg:\t\t\t" XW XW XW } , \
	0x7f { "Adap CFG_INIT:\t\t\t" XW XW XW } , \
	0x80 { "AdptCfg Shdn:\t\t\t" XW XW XW } , \
	0x81 { "AdptCfg BrngUp:\t\t\t" XW XW XW } , \
	0x82 { "CFG_TERM:\t\t\t\t" XW XW XW } , \
	0x83 { "CFG_TERM err1:\t\t\t" XW XW XW } , \
	0x84 { "CFG_TERM err2:\t\t\t" XW XW XW } , \
	0x85 { "Enter CFG_QVPD:\t\t\t" XW XW XW } , \
	0x86 { "CFG_QVPD err1:\t\t\t" XW XW XW } , \
	0x87 { "Enter Open:\t\t\t" XW XW XW } , \
	0x88 { "Exit Open:\t\t\t" XW XW XW } , \
	0x89 { "Adpt Open err1:\t\t\t" XW XW XW } , \
	0x8a { "Adpt Open err2:\t\t\t" XW XW XW } , \
	0x8b { "Enter Close:\t\t\t" XW XW XW } , \
	0x8c { "Exit Close:\t\t\t" XW XW XW } , \
	0x8d { "Adpt Close err1:\t\t\t" XW XW XW } , \
	0x8e { "Adpt Strategy:\t\t\t" XW XW XW } , \
	0x8f { "Intr ALL masked:\t\t\t" XW XW XW } , \
	0x90 { "Intr EEH:\t\t\t\t" XW XW XW } , \
	0x91 { "Intr NOT ME:\t\t\t" XW XW XW } , \
	0x92 { "Intr EEH2:\t\t\t\t" XW XW XW } , \
	0x93 { "Intr UC Buff:\t\t\t" XW XW XW } , \
	0x94 { "Intr Err no UC Buff:\t\t" XW XW XW } , \
	0x95 { "Intr Error interrupt:\t\t" XW XW XW } , \
	0x96 { "IOA Non-0 IOASC:\t\t\t" XW XW XW } , \
	0x97 { "Send command:\t\t\t" XW XW XW } , \
	0x98 { "Blocking command end:\t\t" XW XW XW } , \
	0x99 { "Wdog timer intr:\t\t\t" XW XW XW } , \
	0x9a { "HRRQ Wdog:\t\t\t\t" XW XW XW } , \
	0x9b { "SCSI buf timeout:\t\t" XW XW XW } , \
	0x9c { "AF buf timeout:\t\t\t" XW XW XW } , \
	0x9d { "Enter IOCTL:\t\t\t" XW XW XW } , \
	0x9e { "Exit IOCTL:\t\t\t" XW XW XW } , \
	0x9f { "reset_sleep start:\t\t" XW XW XW } , \
	0xa0 { "reset_sleep done:\t\t" XW XW XW } , \
	0xa1 { "PT sis ioctl:\t\t\t" XW XW XW } , \
	0xa2 { "Phys Dev Attr:\t\t\t" XW XW XW } , \
	0xa3 { "CnvgdDmp Err1:\t\t\t" XW XW XW } , \
	0xa4 { "CnvgdDmp Err2:\t\t\t" XW XW XW } , \
	0xa5 { "CnvgdDmp Err3:\t\t\t" XW XW XW } , \
	0xa6 { "CnvgdDmp Err4:\t\t\t" XW XW XW } , \
	0xa7 { "CnvgdDmp Err5:\t\t\t" XW XW XW } , \
	0xa8 { "CnvgdDmp Err6:\t\t\t" XW XW XW } , \
	0xa9 { "CnvgdDmp Err7:\t\t\t" XW XW XW } , \
	0xaa { "CnvgdDmp Err8:\t\t\t" XW XW XW } , \
	0xab { "CnvgdDmp Err9:\t\t\t" XW XW XW } , \
	0xac { "TM start:\t\t\t\t" XW XW XW } , \
	0xad { "TM stop:\t\t\t\t" XW XW XW } , \
	0xae { "TM Dealloc BP:\t\t\t" XW XW XW } , \
	0xaf { "Undo StartTgt:\t\t\t" XW XW XW } , \
	0xb0 { "Unspted Evnt:\t\t\t" XW XW XW } , \
	0xb1 { "dump ERROR:\t\t\t" XW XW XW } , \
	0xb2 { "DUMPINIT:\t\t\t" XW XW XW } , \
	0xb3 { "DUMPTERM:\t\t\t" XW XW XW } , \
	0xb4 { "dump TimeOut:\t\t\t" XW XW XW } , \
	0xb5 { "dump ErrInt:\t\t\t" XW XW XW } , \
	0xb6 { "dump Non-0 IOASC:\t\t" XW XW XW } , \
	0xb7 { "EEH Dead:\t\t\t\t" XW XW XW } , \
	0xb8 { "EEH suspend:\t\t\t" XW XW XW } , \
	0xb9 { "EEH max retry:\t\t\t" XW XW XW } , \
	0xba { "EEH Resume:\t\t\t" XW XW XW } , \
	0xbb { "Reset IOA error:\t\t\t" XW XW XW } , \
	0xbc { "Reset IOA job:\t\t\t" XW XW XW } , \
	0xbd { "Reset Ioa EEH:\t\t\t" XW XW XW } , \
	0xbe { "INQ_PAGE_D0:\t\t\t" XW XW XW } , \
	0xbf { "NOT Dual HA:\t\t\t" XW XW XW } , \
	0xc0 { "CCN CTE Exist:\t\t\t" XW XW XW } , \
	0xc1 { "CCN CTE New:\t\t\t" XW XW XW } , \
	0xc2 { "CCN Destroyed:\t\t\t" XW XW XW } , \
	0xc3 { "Error HCAM:\t\t\t" XW XW XW } , \
	0xc4 { "Error Blocked:\t\t\t" XW XW XW } , \
	0xc5 { "Cfg IOA BAR0:\t\t\t" XW XW XW } , \
	0xc6 { "RdPciCfg VndID:\t\t\t" XW XW XW } , \
	0xc7 { "Cfg Ioa EEH:\t\t\t" XW XW XW } , \
	0xc8 { "Cfg IOA ChipID:\t\t\t" XW XW XW } , \
	0xc9 { "EEH Failed:\t\t\t" XW XW XW } , \
	0xca { "AF ST error:\t\t\t" XW XW XW } , \
	0xcb { "AF ST done:\t\t\t" XW XW XW } , \
	0xcc { "AF ST INCOMPLETE:\t\t" XW XW XW } , \
	0xcd { "AF Startup:\t\t\t" XW XW XW } , \
	0xce { "Set DASD TO:\t\t" XW XW XW } , \
	0xcf { "AF ST ERROR p01:\t\t\t" XW XW XW } , \
	0xd0 { "AF ST ERROR p0A:\t\t\t" XW XW XW } , \
	0xd1 { "AF ST ERROR p0A:\t\t\t" XW XW XW } , \
	0xd2 { "Brain Dead:\t\t\t" XW XW XW } , \
	0xd3 { "Fail Doomed Op:\t\t\t" XW XW XW } , \
	0xd4 { "Smart Dump:\t\t\t" XW XW XW } , \
	0xd5 { "Smart Dump End:\t\t\t" XW XW XW } , \
	0xd6 { "RdPciCfg BIST:\t\t\t" XW XW XW } , \
	0xd7 { "RdPciCfg CapPtr:\t\t\t" XW XW XW } , \
	0xd8 { "RdPciCfg NxtCap:\t\t\t" XW XW XW } , \
	0xd9 { "Fail SavePciCfg:\t\t\t" XW XW XW } , \
	0xda { "SATA buf timeout:\t\t" XW XW XW } , \
	0xdb { "p83 NO VPD:\t\t\t" XW XW XW } , \
	0xdc { "RdPciCfg REV:\t\t\t" XW XW XW } , \
	0xdd { "RdPciCfg SUBIDS:\t\t\t" XW XW XW }, \
	0xde { "noFUNDA rst:\t\t\t" XW XW XW }, \
	0xdf { "Enter CFG_QDIN:\t\t\t" XW XW XW }, \
	0xe0 { "CFG_QDIN err1:\t\t\t" XW XW XW }, \
	0xe1 { "Save PCI EEH:\t\t\t" XW XW XW }, \
	0xe2 { "EEH debug:\t\t\t" XW XW XW }, \
	0xe3 { "Poll Deactivated:\t\t\t" XW XW XW }, \
	0xe4 { "Poll Activated:\t\t\t" XW XW XW }, \
	0xe5 { "AdptCfg pollTime:\t\t\t" XW XW XW }, \
	0xe6 { "JBOD Init map:\t\t\t" XW XW XW }
65B 1.0 "MPTSCSIDD" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3}} \
        {{ $cnt = B0.5}} \
        $loc, \
        0x0 { "entry" }, \
        0x1 { "trc" }, \
        0x2 { "exit" }, \
        0x71 { "mptscsi_cmn_strategy:                " }, \
        0x72 { "mptscsi_start:                       " }, \
        0x73 { "mptscsi_start_pending_cmds:          " }, \
        0x74 { "mptscsi_logi_complete:               " }, \
        0x75 { "mptscsi_process_cmd_error:           " }, \
        0x76 { "mptscsi_process_device_status:       " }, \
        0x77 { "mptscsi_flush_pending_cmds:          " }, \
        0x78 { "mptscsi_complete_scsi_elem:          " }, \
        0x79 { "mptscsi_process_login:               " }, \
        0x7b { "mptscsi_process_adapter_error:       " }, \
        0x7c { "mptscsi_process_task_mgm_cmds:       " }, \
        0x7e { "mptscsi_issue_target_reset:          " }, \
        0x7f { "mptscsi_send_target_reset:           " }, \
        0x80 { "mptscsi_issue_abort_task_set:        " }, \
        0x81 { "mptscsi_issue_clear_aca:             " }, \
        0x82 { "mptscsi_fail_cmd:                    " }, \
        0x84 { "mptscsi_fail_scsi:                   " }, \
        0x85 { "mptscsi_cdt_proto_func:              " }, \
        0x86 { "mptscsi_log_err:                     " }, \
        0x87 { "mptscsi_scsi_cmd_timeout:            " }, \
        0x88 { "mptscsi_cancel_timeout:              " }, \
        0x89 { "mptscsi_event:                       " }, \
        0x8a { "mptscsi_bld_target_cancel:           " }, \
        0x8b { "mptscsi_issue_cancel_cmd:            " }, \
        0x8c { "mptscsi_issue_target_cancel:         " }, \
        0x8d { "mptscsi_issue_lun_reset:             " }, \
        0x8e { "mptscsi_dump_start:                  " }, \
        0x8f { "mptscsi_init_dev_finish:             " }, \
        0x90 { "mptscsi_clear_dev:                   " }, \
        0x91 { "mptscsi_send_ilog:                   " }, \
        0x92 { "mptscsi_issue_logi:                  " }, \
        0x93 { "mptscsi_process_logout:              " }, \
        0x94 { "mptscsi_delete_target_scsi:          " }, \
        0x95 { "mptscsi_add_target_scsi:             " }, \
        0x96 { "mptscsi_add_dev_scsi:                " }, \
        0x97 { "mptscsi_add_dev_target:              " }, \
        0x98 { "mptscsi_delete_dev_scsi:             " }, \
        0x99 { "mptscsi_clear_target:                " }, \
        0x9a { "mptscsi_halt_dev:                    " }, \
        0x9b { "mptscsi_send_lun_reset:              " }, \
        0x9c { "mptscsi_logi_timeout:                " }, \
        0x9d { "mptscsi_process_ctl_elem_status:     " }, \
        0x9e { "mptscsi_login_success:               " }, \
        0x9f { "mptscsi_process_task_mgm_to:         " }, \
        0xa0 { "mptscsi_cleanup_target_cancel:       " }, \
        0xa1 { "mptscsi_clear_aca_timeout:           " }, \
        0xa2 { "mptscsi_async_timeout:               " }, \
        0xa3 { "mptscsi_watchdog_proto:              " }, \
        0xa4 { "mptscsi_lun_reset_timeout:           " }, \
        0xab { "mptscsi_ras_callback_compdump_scsi:  " }, \
        0xac { "mptscsi_ras_callback_compdump_target:" }, \
        0xad { "mptscsi_ras_callback_compdump_dev:   " }, \
        0xb1 { "mptscsi_rebuild__proto_cdt:          " }, \
        0xb2 { "mptscsi_cmn_close:                   " }, \
        0xb3 { "mptscsi_cmn_ioctl:                   " }, \
        0xb4 { "mptscsi_inquiry:                     " }, \
        0xb5 { "mptscsi_start_unit:                  " }, \
        0xb6 { "mptscsi_test_unit_rdy:               " }, \
        0xb7 { "mptscsi_read_blk:                    " }, \
        0xb8 { "mptscsi_sciocmd:                     " }, \
        0xb9 { "mptscsi_passthru:                    " }, \
        0xba { "mptscsi_bld_scsi_buf:                " }, \
        0xbb { "mptscsi_sas_sciolqsas:               " }, \
        0xbc { "mptscsi_init_dev:                    " }, \
        0xbd { "mptscsi_ras_register_dev:            " }, \
        0xbe { "mptscsi_ras_register_target:         " }, \
        0xbf { "mptscsi_fail_open:                   " }, \
        0xc0 { "mptscsi_cmn_open:                    " }  \
        $typ, \
        0x0 { "Entry" $cnt%X1 XW XW XW XW XW } , \
        0x1 { "Trace" $cnt%X1 XW XW XW XW XW } , \
        0x2 { "Exit  " $cnt%X1 XW XW XW XW XW }
65C 1.0 "MPT2ADAPDD" \
        {{ $loc = X1 }} \
        {{ $typ = B0.3}} \
        {{ $cnt = B0.5}} \
        $loc, \
        0x0 { "entry" }, \
        0x1 { "trc" },  \
        0x2 { "exit" }, \
        0x71 { "mpt2sas_output:                            " }, \
        0x72 { "mpt2sas_adap_start:                        " }, \
        0x73 { "mpt2sas_flush_adap:                        " }, \
        0x74 { "mpt2sas_io_unit_reset:                     " }, \
        0x75 { "mpt2sas_force_reset_adapter:               " }, \
        0x76 { "mpt2sas_finish_eeh_reset:                  " }, \
        0x77 { "mpt2sas_intr:                              " }, \
        0x78 { "mpt2sas_eeh_callback:                      " }, \
        0x79 { "mpt2sas_target_scan:                       " }, \
        0x7a { "mpt2sas_ioc_msg_unit_reset:                " }, \
        0x7b { "mpt2sas_diagnostic_reset:                  " }, \
        0x7c { "mpt2sas_exchange_doorbell_msg:             " }, \
        0x7d { "mpt2sas_issue_cmd:                         " }, \
        0x7e { "mpt2sas_make_adap_ready:                   " }, \
        0x7f { "mpt2sas_exchange_doorbell_msg_intr:        " }, \
        0x80 { "mpt2sas_cdt_func:                          " }, \
        0x81 { "mpt2sas_logerr:                            " }, \
        0x82 { "mpt2sas_event_to:                          " }, \
        0x83 { "mpt2sas_process_config:                    " }, \
        0x84 { "mpt2sas_process_address_reply:             " }, \
        0x85 { "mpt2sas_process_context_reply:             " }, \
        0x86 { "mpt2sas_kthread:                           " }, \
        0x87 { "mpt2sas_process_task_management:           " }, \
        0x88 { "mpt2sas_open:                              " }, \
        0x89 { "mpt2sas_mpt_passthru:                      " }, \
        0x8a { "mpt2sas_adapt_open:                        " }, \
        0x8b { "mpt2sas_offlevel:                          " }, \
        0x8c { "mpt2sas_prep_dma:                          " }, \
        0x8d { "mpt2sas_SG_build:                          " }, \
        0x8e { "mpt2sas_build_sg_list:                     " }, \
        0x8f { "mpt2sas_dump_adap:                         " }, \
        0x90 { "mpt2sas_check_slot:                        " }, \
        0x91 { "mpt2sas_alloc_tag:                         " }, \
        0x92 { "mpt2sas_alloc_iovec:                       " }, \
        0x93 { "mpt2sas_config:                            " }, \
        0x94 { "mpt2sas_process_event:                     " }, \
        0x95 { "mpt2sas_build_command:                     " }, \
        0x96 { "mpt2sas_build_scsi_req:                    " }, \
        0x97 { "mpt2sas_build_config_req:                  " }, \
        0x98 { "mpt2sas_alloc_resources:                   " }, \
        0x99 { "mpt2sas_free_resources:                    " }, \
        0x9a { "mpt2sas_alloc_sg_buffer:                   " }, \
        0x9b { "mpt2sas_alloc_reply_buffer:                " }, \
        0x9c { "mpt2sas_read_cfg:                          " }, \
        0x9d { "mpt2sas_good_status:                       " }, \
        0x9e { "mpt2sas_bad_status:                        " }, \
        0x9f { "mpt2sas_write_cfg:                         " }, \
        0xa0 { "mpt2sas_watchdog:                          " }, \
        0xa1 { "mpt2sas_close:                             " }, \
        0xa2 { "mpt2sas_strategy:                          " }, \
        0xa3 { "mpt2sas_adapt_ioctl:                       " }, \
        0xa4 { "mpt2sas_mpt_internal_cmd:                  " }, \
        0xa5 { "mpt2sas_build_task_mgmt_req:               " }, \
        0xa6 { "mpt2sas_build_event_req:                   " }, \
        0xa7 { "mpt2sas_build_event_ack_req:               " }, \
        0xa8 { "mpt2sas_free_iovec:                        " }, \
        0xa9 { "mpt2sas_free_sg_buffer:                    " }, \
        0xaa { "mpt2sas_set_dev:                           " }, \
        0xab { "mpt2sas_del_dev:                           " }, \
        0xac { "mpt2sas_free_dev:                          " }, \
        0xad { "mpt2sas_rebuild_cdt:                       " }, \
        0xae { "mpt2sas_adap_undo_config:                  " }, \
        0xaf { "mpt2sas_config_adapter:                    " }, \
        0xb0 { "mpt2sas_complete_io:                       " }, \
        0xb1 { "mpt2sas_get_dev:                           " }, \
        0xb2 { "mpt2sas_pending_q_timer:                   " }, \
        0xb3 { "mpt2sas_dump_write:                        " }, \
        0xb4 { "mpt2sas_dump_intr:                         " }, \
        0xb5 { "mpt2sas_eeh_check:                         " }, \
        0xb6 { "mpt2sas_adapt_close:                       " }, \
        0xb7 { "mpt2sas_undo_open:                         " }, \
        0xb8 { "mpt2sas_ioctl:                             " }, \
        0xb9 { "mpt2sas_apapt_ioctl:                       " }, \
        0xba { "mpt2sas_reboot:                            " }, \
        0xbb { "mpt2sas_alloc_hash:                        " }, \
        0xbc { "mpt2sas_eeh_init:                          " }, \
        0xbd { "mpt2sas_process_scsi_device_status_change: " }, \
        0xbe { "mpt2sas_process_sas_device_status_change:  " }, \
        0xbf { "mpt2sas_process_sas_expander_status_change:" }, \
        0xc0 { "mpt2sas_process_event_ack:                 " }, \
        0xc1 { "mpt2sas_issue_event_ack:                   " }, \
        0xc2 { "mpt2sas_issue_event:                       " }, \
        0xc3 { "mpt2sas_kproc:                             " }, \
        0xc4 { "mpt2sas_kproc_start:                       " }, \
        0xc5 { "mpt2sas_kproc_term:                        " }, \
        0xc6 { "mpt2sas_thread_spawn:                      " }, \
        0xc7 { "mpt2sas_thread_start:                      " }, \
        0xc8 { "mpt2sas_thread_work:                       " }, \
        0xc9 { "mpt2sas_thread_term:                       " }, \
        0xca { "mpt2sas_target_init:                       " }, \
        0xcb { "mpt2sas_target_term:                       " }, \
        0xcc { "mpt2sas_abort_cmds:                        " }, \
        0xcd { "mpt2sas_adap_cmd_alloc:                    " }, \
        0xce { "mpt2sas_adap_cmd_free:                     " }, \
        0xcf { "mpt2sas_cmd_get:                           " }, \
        0xd0 { "mpt2sas_cmd_release:                       " }, \
        0xd1 { "mpt2sas_alloc_sense_buffer:                " }, \
        0xd2 { "mpt2sas_start_adapter:                     " }, \
        0xd3 { "mpt2sas_alloc_reply_buff:                  " }, \
        0xd4 { "mpt2sas_dump_output:                       " }, \
        0xd5 { "mpt2sas_clr_reset_history:                 " }, \
        0xd6 { "mpt2sas_dump:                              " }, \
        0xd7 { "mpt2sas_set_ext_config:                    " }, \
        0xd8 { "mpt2sas_remove_dev:                        " }, \
        0xd9 { "mpt2sas_sasiounit:                         " }  \
        $typ, \
        0x0 { "Entry" $cnt%X1 XW XW XW XW XW } , \
        0x1 { "Trace" $cnt%X1 XW XW XW XW XW } , \
        0x2 { "Exit " $cnt%X1 XW XW XW XW XW }
17B 1.0 "PCMKE" \
	{{ $loc = X1 }} \
	{{ $typ = B0.3}} \
	{{ $cnt = B0.5}} \
	$loc, \
	0x70 { pcmAddDevice: dev_handle=$D1 $D2 $D3 $D4} , \
	0x71 { pcmChgDevice: dev_handle=$D1 $D2} , \
	0x72 { pcmDelDevice: $D1} , \
	0x73 { "pcmSetDeviceState:\t\t\t"} , \
	0x74 { "pcmGetDeviceState:\t\t\t"} , \
	0x75 { pcmAddPath: dev_handle=$D1 $D2 $D3 $D4} , \
	0x76 { pcmChgPath: dev_handle=$D1 path_handle=$D2 $D3} , \
	0x77 { pcmDelPath: dev_handle=$D1 path_handle=$D2} , \
	0x78 { "pcmSelectPath:\t\t\t"} , \
	0x79 { "pcmRetryPath:\t\t\t"} , \
	0x7a { "pcmForcePath:\t\t\t"} , \
	0x7b { pcmSetPathState: $D1 $D2 $D3 $D4 $D5} , \
	0x7c { pcmGetPathState: dev_handle=$D1 path_handle=$D2 $D3} , \
	0x7d { pcmPassThru_FailPath: dev_ptr=$D1 $D2 $D3} , \
	0x7e { pcmPassThru: dev_handle=$D1 $D2 $D3 $D4} , \
	0x7f { "pcmIoDone:\t\t\t\t"} , \
	0x80 { pcmSetPolicy: dev_handle=$D1 $D2} , \
	0x81 { pcmNotifyPolicy: dev_handle=$D1 path_handle=$D2 $D3} , \
	0x82 { pcmSelectDumpPath: dev_handle=$D1 $D2} , \
	0x83 { "pcmSelectIoctlPath:\t\t"} , \
	0x84 { enqueueDevice: $D1 $D2} , \
	0x85 { dequeueDevice: dev_ptr=$D1} , \
	0x86 { enqueuePath: dev_ptr=$D1 path_ptr=$D2} , \
	0x87 { dequeuePath: dev_ptr=$D1 path_ptr=$D2} , \
	0x88 { algorithmRoundRobin: $D1 $D2 $D3} , \
	0x89 { algorithmFailOver: $D1 $D2} , \
	0x8a { algorithmFirstAvailable: $D1 $D2 $D3} , \
	0x8b { validatePcmAttrs: $D1} , \
	0x8c { validatePathAttrs: $D1} , \
	0x8d { validatePolicy: $D1} , \
	0x8e { validatePolicyAlgorithm: $D1 $D2} , \
	0x8f { "cdtFunc:\t\t\t\t"} , \
	0x90 { cdtAlloc: $D1} , \
	0x91 { "pcmRegDevCallBacks:\t\t"} , \
	0x92 { "healthChecker:\t\t\t"} , \
	0x93 { "healthCheckerPathQueue:\t"} , \
	0x94 { "healthCheckFailBack:\t\t"} , \
	0x95 { "healthCheckIoDone:\t\t"} , \
	0x96 { buildInbandCmd: $D1 $D2 $D3 $D4} , \
	0x97 { "inbandCmdIoDone:\t\t\t"} , \
	0x98 { buildFcpCmd: $D1 $D2 $D3} , \
	0x99 { buildScsiCmd: $D1 $D2 $D3} , \
	0x9a { "pcmNotifyPathFlags:\t\t"} , \
	0x9b { "failAdapterPaths:\t\t\t"} , \
	0x9c { "processIoDone:\t\t\t"} , \
	0x9d { "processGood:\t\t\t\t"} , \
	0x9e { "processScsiError:\t\t\t"} , \
	0x9f { "processFcpError:\t\t\t"} , \
	0xa0 { "updateDistPathErrors:\t\t"} , \
	0xa1 { "inquiryIoDone:\t\t\t"} , \
	0xa2 { "processFcpSense:\t\t\t"} , \
	0xa3 { "pcmProcessStateMachine:\t\t"} , \
	0xa4 { "swapPathQueue:\t\t\t"} , \
	0xa6 { "failOverIOController:\t\t"} , \
	0xa7 { "CanSwapController:\t\t"} , \
	0xa8 { "inbandFailOverIOController:\t"} , \
	0xa9 { pcmeRAS: dev_ptr=$D1 mpio_ras_cb=$D2} , \
	0xaa { "pcmRasCallBack:\t\t\t"} , \
	0xab { "pcmeRASunReg:\t\t\t"} , \
	0xac { pcmConfig: $D1 $D2} , \
	0xad { "pcmSwapPathsMode22:\t\t\t" }, \
	0xae { "processScsiSenseMode22:\t\t" }, \
	0xaf { pcmPassThru_GetFrames: dev_ptr->lname=$D1 $D2 $D3 $D4 $D5} , \
	0xb0 { pcmPassThru_GetDisks: dev_ptr->lname=$D1 $D2} , \
	0xb1 { pcmPassThru_GetAllDisks: dev_ptr->lname=$D1 $D2} , \
	0xb2 { "processScsiSenseMode10:\t\t"} , \
	0xb3 { "buildError:\t\t\t\t"} , \
	0xb4 { buildErrorThreshold: dev_ptr=$D1 dev_ptr->lname=$D2 asc_ascq=$D3} , \
	0xb5 { "LogError:\t\t\t\t"} , \
	0xb6 { swapCtrls: dev_ptr=$D1 dev_ptr->lname=$D2 $D3 $D4} , \
	0xb7 { "processCtrlBusy:\t\t\t"} , \
	0xb8 { "ctrl_watchdog:\t\t\t"}, \
	0xb9 { "buildVendorCmd_I:\t\t"}, \
	0xba { "buildVendorCmd_J:\t\t"}, \
	0xbb { "VendorCmd_AEN_IoDone:\t"}, \
	0xbc { "VendorCmd_K_IoDone:\t"}, \
	0xbd { "VendorCmd_L_IoDone:\t"}, \
	0xbe { "VendorCmd_G_IoDone:\t"}, \
	0xbf { "VendorCmd_H_IoDone:\t"}, \
	0xc0 { "VendorCmd_I_IoDone:\t"}, \
	0xc1 { "VendorCmd_J_IoDone:\t"}, \
	0xc2 { "BuildReserveCmds:\t"}, \
	0xc3 { "VendorCmd_M_IoDone:\t"}, \
	0xc4 { "vendorCmd_A_IoDone:\t\t" }, \
	0xc5 { "vendorCmd_B_IoDone:\t\t" }, \
        0xc6 { "ctrlHcheckSeq:\t\t" }, \
	\*   { "unknown subhook:\t\t" $loc } \
	$typ, \
	0x1 { "Entry" $cnt%X1 XW XW XW XW XW } , \
	0x2 { "Trace" $cnt%X1 XW XW XW XW XW } , \
	0x3 { "Exit  " $cnt%X1 XW XW XW XW XW }
709 1.0 "INPUTDD:  " \
        {{ $a =  $HD & 0xfc00 }} \
        {{ $b =  $a / 1024 }} \
        {{ $func =  $b & 0x3f }} \
        {{ $c  = $HD - $a }} \
        {{ $routine  = $c & 0x03ff }} \
        $routine, \
        01  { "put_iq " }, \
        02  { "put_oq " }, \
        03  { "get_oq " }, \
        04  { "flush_q" }, \
        05  { "get_iq " }, \
        06  { "wait_oq" }, \
        07  { "sleep  " }, \
        08  { "putring" }, \
        09  { "log    " }, \
        0a  { "uring  " }, \
        0b  { "put_oq1" }, \
        0c  { "put_oq2" }, \
        0d  { "startwd" }, \
        0e  { "rring  " }, \
        0f  { "rflush " }, \
        20  { "kcnfig " }, \
        21  { "kmpx   " }, \
        22  { "kopen  " }, \
        23  { "kclose " }, \
        24  { "kioctl " }, \
        25  { "kintr  " }, \
        26  { "ksend_q" }, \
        27  { "k_wdog " }, \
        28  { "ksetup " }, \
        29  { "keyproc" }, \
        2a  { "sstatus" }, \
        2b  { "procsak" }, \
        2c  { "un_sak " }, \
        2e  { "put_key" }, \
        2f  { "polappl" }, \
        30  { "put_sq " }, \
        31  { "nsound " }, \
        32  { "appkill" }, \
        33  { "procevt" }, \
        34  { "keyictl" }, \
        35  { "sv_proc" }, \
        36  { "k_s8042" }, \
        40  { "mconfig" }, \
        41  { "mopen  " }, \
        42  { "mclose " }, \
        43  { "mioctl " }, \
        44  { "mintr  " }, \
        45  { "msndcmd" }, \
        46  { "msend_q" }, \
        47  { "m_wdog " }, \
        48  { "mseproc" }, \
        49  { "m_s8042" }, \
        50  { "ktscfg " }, \
        51  { "ktsmpx " }, \
        52  { "ktsopen" }, \
        53  { "ktsclse" }, \
        54  { "ktsictl" }, \
        55  { "ktsintr" }, \
        60  { "tconfig" }, \
        61  { "topen  " }, \
        62  { "tclose " }, \
        63  { "tioctl " }, \
        64  { "tabintr" }, \
        65  { "tsend_q" }, \
        66  { "t_wdog " }, \
        67  { "tabproc" }, \
        \*  { $routine%X2"    " } \
        $func%D2, \
        0  { " [ent ]" }, \
        32 { " [exit]" }, \
        \* { " ["$func%X2"]"  } \
        $HL,  \
        4  {O2 "  d0=" X4 }, \
        8  {O2 "  d0=" X8 }, \
        14 {O2 "  d0=" X4 " d1=" X4 " d2=" X4 " d3=" X4 " d4=" X4 }, \
        28 {O2 "  d0=" X8 " d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8 }
4B3 1.0 "@ICM" \
        "ICM PATH:  " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4B4 1.0 "@ICM" \
        "ICM ERR:  " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4B5 1.0 "@ICM" \
        "SA_PATH: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4B6 1.0 "@ICM" \
        "SA_ERR: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4B7 1.0 "@IbkaBase" \
        "IBKA PATH:  " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4B8 1.0 "@IbkaBase" \
        "IBKA ERR:  " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4BB 1.0 "@if_ib" \
        "IF_IB    : " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4BC 1.0 "@if_ib" \
        "IF_IB ERR: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4F3 1.0 "@IblBase" \
        "IBL_PATH: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4F4 1.0 "@IblBase" \
        "IBL_ERR: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
3AC 1.0 "@sciedd" \
        "SDLC COMIO EMUL: " O2 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
2FA 1.0 "@ethchandd" \
        "ETHERCHANNEL DD XMT: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
2FB 1.0 "@ethchandd" \
        "ETHERCHANNEL DD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3FD 1.0 "@vlandd" \
        "VLAN DD XMT: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3FE 1.0 "@vlandd" \
        "VLAN DD RCV: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3FF 1.0 "@vlandd" \
        "VLAN DD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
408 1.0 "@STTY CXMA" \
{{ \
scxma_cmdw(cmd) \
	$cmd, \
	00e0 "SRLOW ", \
	00e1 "SRHIGH ", \
	00e2 "FLUSHTX ", \
	00e3 "PAUSETX ", \
	00e4 "RESUMETX ", \
	00e5 "SMINT ", \
	00e6 "SAFLOWC ", \
	00e8 "SBREAK ", \
	00e9 "SMODEM ", \
	00ea "SIFLAG ", \
	00eb "SFLOWC ", \
	00ec "STLOW ", \
	00ee "RPAUSE ", \
	00ef "RRESUME ", \
	00f2 "BUFSETALL ", \
	00f3 "SOFLAG ", \
	00f4 "SHFLOW ", \
	00f5 "SCFLAG ", \
	00f6 "SVNEXT ", \
	00fd "SCOMMODE ", \
	00fe "CMDSYNC " \
}} \
{{ \
scxma_chflags(flag) \
	"chflags:" \
	BITFLAGS $flag, \
	0x00000001 "pron", \
	0x00000002 "cd", \
	0x00000004 "fcar", \
	0x00000008 "wempty", \
	0x00000010 "fcntl", \
	0x00000020 "pcntl", \
	0x00000040 "hangup", \
	0x00000080 "wopen", \
	0x00000100 "renable", \
	0x00000200 "ractive", \
	0x00000400 "rwait", \
	0x00000800 "ibypass", \
	0x00001000 "istall", \
	0x00002000 "obypass" \
}} \
{{ \
scxma_unflags(flag) \
	"unflags:" \
	BITFLAGS $flag, \
	0x00000001 "isopen", \
	0x00000002 "closing", \
	0x00000004 "busy", \
	0x00000008 "pwait", \
	0x00000010 "time", \
	0x00000020 "wempty", \
	0x00000040 "wlow", \
	0x00000080 "sak", \
	0x00000100 "stopo", \
	0x00000200 "stopi", \
	0x00000400 "hangup", \
	0x00000800 "ctlx", \
	0x00001000 "mstop", \
	0x00002000 "excl", \
	0x00010000 "ctson", \
	0x00020000 "ctsoff", \
	0x00040000 "rion", \
	0x00080000 "rioff", \
	0x00100000 "dsron", \
	0x00200000 "dsroff", \
	0x00400000 "cdon", \
	0x00800000 "cdoff", \
	0x01000000 "overrun", \
	0x02000000 "brkint", \
	0x04000000 "sigint", \
	0x08000000 "sigquit", \
	0x10000000 "sigtstp", \
	0x20000000 "sigio" \
}} \
{{ \
scxma_ddstype(type) \
        "type:" \
	BITFLAGS $type, \
	& 007 000 "pcxi", \
	& 007 001 "pcxm", \
	& 007 002 "pcxe", \
	& 007 003 "pcxr", \
	& 007 004 "pcxs", \
	& 038 000 "comxi", \
	& 038 008 "pcxx", \
	& 038 010 "cx", \
	& 038 018 "epc", \
	& 038 020 "pclite", \
	& 0C0 000 "isa", \
	& 0C0 040 "mca", \
	& 0C0 080 "eisa", \
	& 0C0 0C0 "pci" \
}} \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "cxma" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000E "add ", \
	000F "del ", \
	0010 "initbd ", \
	0011 "wmove ", \
	0012 "param ", \
	0013 "xtimeo ", \
	0014 "xpoffl ", \
	0015 "event ", \
	0016 "download ", \
	0017 "fail ", \
	0018 "cmd ", \
	0019 "dl_open ", \
	001A "dl_close ", \
	001B "dl_ioctl ", \
	001C "dl_kme ", \
	001D "restart ", \
	001E "reset_port ", \
	001F "kill_apps ", \
	0020 "get_download_images ", \
	0021 "dl_reset ", \
	0022 "dl_diag ", \
	0023 "read ", \
	0024 "input ", \
	0025 "select ", \
	0026 "cx_pm_handler ", \
	0027 "do_suspend ", \
	0028 "do_resume ", \
	0029 "check_current_activity ", \
	002A "set_iflag ", \
	002B "set_oflag ", \
	002C "set_cflag ", \
	002D "cxma_rpdp ", \
	002E "process_eeh_state ", \
	002F "del_tty ", \
	0030 "intr slih ", \
	0031 "intr allow ", \
	0032 "intr fail ", \
	0033 "intr offl2 ", \
	0034 "intr offl2 restart " \
	$how, \
	0000 { $which, \
	    0001 { "devno" $D5%X4 }, \
	    0009 { "ptr" $D2%X4 "cmd" ioctlname($D3) }, \
            000E { scxma_ddstype($D3) "devno" $D4%X4 }, \
            000F { scxma_ddstype($D3) "devno" $D4%X4 }, \
            0010 { scxma_ddstype($D3) "devno" $D4%X4 }, \
            0011 { "bytes" $D3 }, \
	    0015 { "devno" $D3%X4 scxma_ddstype($D4) }, \
	    0016 { "devno" $D3%X4 }, \
	    0017 { "devno" $D3%X4 "vaddr" $D4%X4 }, \
            0018 { "cmd" scxma_cmdw($D3) "word" $D4%X1 "ncmd" $D5%D1 }, \
	    0019 { "devno" $D3%X4 "devflag" $D4%X4 "ext" $D5%X4 }, \
	    001A { "devno" $D3%X4 "devflag" $D4%X4 }, \
	    001B { "devno" $D3%X4 "cmd" ioctlname($D3) "arg" $D5%X4 }, \
	    001C { "devno" $D3%X4 "arg" $D4%X4 }, \
	    001D { "bd" $D3%X4 }, \
	    001E { "bd" $D3%X4 }, \
	    001F { "bd" $D3%X4 }, \
	    0020 { "bd" $D3%X4 }, \
	    0021 { "devno" $D3%X4 "arg" $D4%X4 }, \
	    0022 { "devno" $D3%X4 "cmd" ioctlname($D3) "arg" $D5%X4 }, \
	    0023 { "ext" $D3%X4 }, \
	    0025 { "evt" $D3%X4 }, \
	    0026 { "private" $D3%X4 "ctrl" $D4%X4 }, \
	    0027 { "bd" $D3%X4 }, \
	    0028 { "bd" $D3%X4 }, \
	    0029 { "bd" $D3%X4 }, \
	    0030 { "bd" $D2%XW "pend" $D3%X1 }, \
	    0031 { $D3%DW "bd" $D2%XW "pend" $D4%X1 "Line" $D5%DW }, \
	    0032 { "bd" $D3%XW }, \
	    0033 { "bd" $D3%XW }, \
	    0034 { "bd" $D2%XW "restarts" $D3%DW "cpu" $D4%DW } \
	}, \
	0001 { $which, \
	    0002 { "Line:" $D3%D4 scxma_unflags($D4) scxma_chflags($D5) }, \
	    0003 { "Line:" $D3%D4 scxma_unflags($D4) scxma_chflags($D5) }, \
	    0015 { "port" $D3%D4 \
		   "reason" BITFLAGS $D4%X2, \
			0x0001 "BREAK", \
			0x0002 "TLW", \
			0x0004 "TEM", \
			0x0008 "DATA", \
			0x0020 "MODEM", \
			0x0040 "CMDSYNC", \
			0x0080 "UARTORUN" \
 		    "modem" BITFLAGS $D5%X2, \
			0x0001 "DTR", \
			0x0002 "RTS", \
			0x0010 "CTS", \
			0x0020 "DSR", \
			0x0040 "RI", \
			0x0080 "CD" \
		}, \
	    002A { "iflag:" BITFLAGS $D3%X4, \
		0x0001 "ignbrk", \
		0x0002 "brkint", \
		0x0004 "ignpar", \
		0x0008 "parmrk", \
		0x0010 "inpck", \
		0x0020 "istrip", \
		0x0040 "itoss", \
		0x0400 "ixon", \
		0x0800 "ixany", \
		0x1000 "ixoff", \
		0x2000 "ixona", \
		0x8000 "dosmode" }, \
	    002B { "oflag:" BITFLAGS $D3%X4, \
		0x0001 "xcase", \
		0x0002 "olcuc", \
		0x0004 "onlcr", \
		0x0008 "ocrnl", \
		0x0010 "onocr", \
		0x0020 "onlret", \
		0x0040 "ofill", \
		0x0080 "ofdel", \
		0x0100 "nl1", \
		0x0200 "cr1", \
		0x0400 "cr2", \
		0x0600 "cr3", \
		0x0800 "tab1", \
		0x1000 "tab2", \
		0x1800 "tab3", \
		0x2000 "bs1", \
		0x4000 "vt1", \
		0x8000 "ff1" }, \
	    002C { "cflag:" BITFLAGS $D3%X4, \
		& 0x040F 0x0000 "B0", \
		& 0x040F 0x0001 "B50", \
		& 0x040F 0x0002 "B75", \
		& 0x040F 0x0003 "B110", \
		& 0x040F 0x0004 "B134", \
		& 0x040F 0x0005 "B150", \
		& 0x040F 0x0006 "B200", \
		& 0x040F 0x0007 "B300", \
		& 0x040F 0x0008 "B600", \
		& 0x040F 0x0009 "B1200", \
		& 0x040F 0x000A "B1800", \
		& 0x040F 0x000B "B2400", \
		& 0x040F 0x000C "B4800", \
		& 0x040F 0x000D "B9600", \
		& 0x040F 0x000E "B19200", \
		& 0x040F 0x000F "B38400", \
		& 0x040F 0x0400 "B0", \
		& 0x040F 0x0401 "B57600", \
		& 0x040F 0x0402 "B76800", \
		& 0x040F 0x0403 "B115200", \
		& 0x040F 0x0404 "B134", \
		& 0x040F 0x0405 "B150", \
		& 0x040F 0x0406 "B230000", \
		& 0x040F 0x0407 "B300", \
		& 0x040F 0x0408 "B600", \
		& 0x040F 0x0409 "B1200", \
		& 0x040F 0x040A "B1800", \
		& 0x040F 0x040B "B2400", \
		& 0x040F 0x040C "B4800", \
		& 0x040F 0x040D "B9600", \
		& 0x040F 0x040E "B19200", \
		& 0x040F 0x040F "B38400", \
		& 0x0030 0x0000 "CS5", \
		& 0x0030 0x0010 "CS6", \
		& 0x0030 0x0020 "CS7", \
		& 0x0030 0x0030 "CS8", \
		0x0040 "cstopb", \
		0x0080 "cstopb1", \
		& 0x0B00 0x0000 "none", \
		& 0x0B00 0x0100 "even", \
		& 0x0B00 0x0200 "none", \
		& 0x0B00 0x0300 "odd", \
		& 0x0B00 0x0800 "none", \
		& 0x0B00 0x0900 "space", \
		& 0x0B00 0x0A00 "none", \
		& 0x0B00 0x0B00 "mark" } \
 	}, \
	0002 { $which, \
	       0013 { "ret from line" $D4%D4 }, \
	       0014 { "ret from line" $D4%D4 }, \
	       0015 { "ret from line" $D4%D4 }, \
	       0016 { "ret from line" $D4%D4 }, \
	       0018 { "ret from line" $D4%D4 }, \
	       002A { "ret from line" $D4%D4 }, \
	       002B { "ret from line" $D4%D4 }, \
	       002C { "ret from line" $D4%D4 }, \
	       \* { "ret" $D3%E4 "from line" $D4%D4 } \
	}, \
	0003 { $D3, \
	       0000 { "break at line" $D4%D4 }, \
	       0001 { "continue at line" $D4%D4 }, \
	       0002 { "goto from line" $D4%D4 } \
	}
49C 1.2 L=KERN "pci_busdd" \
		 {{ $loc = X1 }} \
		 {{ $resv = X1 }} \
		 $loc, \
		 0x01 {"EEH_INIT_ENTER:" "pbid:" XW "slot:" XW "flag:" XW}, \
		 0x0F {"EEH_INIT_EXIT:" "pbid:" XW "slot:" XW "handle:" XW}, \
		 0x11 {"EEH_INIT_MULTIFUNC_ENTER:" "gpbid:" XW "pbid:" XW  \
				"slot:" XW "flag:" XW "dds_ptr:" XW}, \
		 0x1F {"EEH_INIT_MULTIFUNC_EXIT:" "gpbid:" XW "pbid:" XW \
					"slot:" XW "Line:" DW "rc:" XW}, \
		 0x21 {"EEH_CLEAR_ENTER:" "pbid:" XW "slot:" XW "handle:" XW}, \
		 0x2F {"EEH_CLEAR_EXIT:" "pbid:" XW "slot:" XW "handle:" XW \
							"Line:" DW}, \
		 0x34 {"EEH_READ_SLOT_STATE1:" "pbid:" XW "slot:" XW \
				"handle:" XW "state:" XW "capability:" XW}, \
		 0x37 {"EEH_READ_SLOT_STATE2:" "pbid:" XW "slot:" XW \
						"handle:" XW "delay:" XW}, \
		 0x3F {"EEH_READ_SLOT_STATE_EXIT:" "pbid:" XW "slot:" XW \
					"handle:" XW "Line:" DW "rc:" XW}, \
		 0x41 {"EEH_RESET_SLOT_ENTER:" "pbid:" XW "slot:" XW \
						"handle:" XW "inflag:" XW}, \
		 0x45 {"EEH_RESET_SLOT_RTAS:" "token:" $resv "pbid:" XW \
				"slot:" XW "handle:" XW "configaddr:" XW}, \
		 0x4F {"EEH_RESET_SLOT_EXIT:" "pbid:" XW "slot:" XW \
					"handle:" XW "Line:" DW "rc:" XW}, \
		 0x51 {"EEH_ENABLE_SLOT_ENTER:" "pbid:" XW "slot:" XW  \
								"handle:" XW}, \
		 0x55 {"EEH_ENABLE_SLOT_RTAS:" "token:" $resv "pbid:" XW \
				"slot:" XW "handle:" XW "configaddr:" XW}, \
		 0x5F {"EEH_ENABLE_SLOT_EXIT:" "pbid:" XW "slot:" XW \
					"handle:" XW "Line:" DW "rc:" XW}, \
		 0x61 {"EEH_DISABLE_SLOT_ENTER:" "pbid:" XW "slot:" XW  \
								"handle:" XW}, \
		 0x65 {"EEH_DISABLE_SLOT_RTAS:" "token:" $resv "pbid:" XW \
				"slot:" XW "handle:" XW "configaddr:" XW}, \
		 0x6F {"EEH_DISABLE_SLOT_EXIT:" "pbid:" XW "slot:" XW \
					"handle:" XW "Line:" DW "rc:" XW}, \
		 0x71 {"EEH_ENABLE_DMA_ENTER:" "pbid:" XW "slot:" XW  \
								"handle:" XW}, \
		 0x75 {"EEH_ENABLE_DMA_RTAS:" "token:" $resv "pbid:" XW \
				"slot:" XW "handle:" XW "configaddr:" XW}, \
		 0x7F {"EEH_ENABLE_DMA_EXIT:" "pbid:" XW "slot:" XW \
					"handle:" XW "Line:" DW "rc:" XW}, \
		 0x81 {"EEH_ENABLE_PIO_ENTER:" "pbid:" XW "slot:" XW  \
								"handle:" XW}, \
		 0x85 {"EEH_ENABLE_PIO_RTAS:" "token:" $resv "pbid:" XW \
				"slot:" XW "handle:" XW "configaddr:" XW}, \
		 0x8F {"EEH_ENABLE_PIO_EXIT:" "pbid:" XW "slot:" XW \
					"handle:" XW "Line:" DW "rc:" XW}, \
		 0x91 {"EEH_SLOT_ERROR_ENTER:" "pbid:" XW "slot:" XW \
				"handle:" XW "func_flag:" XW "dd_buf:" XW}, \
		 0x95 {"EEH_SLOT_ERROR_RTAS:" "token:" $resv "pbid:" XW \
			"slot:" XW "handle:" XW "configaddr:" XW "buf:" XW}, \
		 0x97 {"EEH_SLOT_ERROR_RTAS2:" "token:" $resv "pbid:" XW \
					"slot:" XW "handle:" XW "status:" XW}, \
		 0x9F {"EEH_SLOT_ERROR_EXIT:" "pbid:" XW "slot:" XW \
					"handle:" XW "Line:" DW "rc:" XW}, \
		 0xA1 {"EEH_CONFIGURE_BRIDGE_ENTER:" "pbid:" XW "slot:" XW \
								"handle:" XW}, \
		 0xA5 {"EEH_CONFIGURE_BRIDGE_RTAS:" "token:" $resv "pbid:" XW \
				"slot:" XW "handle:" XW "configaddr:" XW}, \
		 0xAF {"EEH_CONFIGURE_BRIDGE_EXIT:" "pbid:" XW "slot:" XW \
						"handle:" XW "loc:" XW}, \
		 0xB1 {"EEH_ISSUE_CALLBACKS_ENTER:" "tpe_config_addr:" XW \
			"PHB_Unit_ID:" XW "eadshandle:" XW "state:" XW \
								"flags:" XW}, \
		 0xB2 {"EEH_ISSUE_CALLBACKS_ENTER2:" "tpe_config_addr:" XW \
			"PHB_Unit_ID:" XW "eadshandle:" XW "kmsgs:" XW \
								"umsgs:" XW}, \
		 0xB5 {"EEH_ISSUE_CALLBACKS_MASTER:" "tpe_config_addr:" XW \
			"PHB_Unit_ID:" XW "eadshandle:" XW "master_index:" XW \
							"m_arg:" XW}, \
		 0xB6 {"EEH_ISSUE_CALLBACKS_RESTR:" "caller:" $resv \
			"tpe_config_addr:" XW "PHB_Unit_ID:" XW "eadshandle:" XW \
			"busy_save_state:" XW "busy_msgs:" XW}, \
		 0xB8 {"EEH_ISSUE_CALLBACKS_KCALL:" "n:" $resv \
			"tpe_config_addr:" XW "PHB_Unit_ID:" XW "eadshandle:" XW \
						"next_kmsg:" XW "arg:" XW}, \
		 0xB9 {"EEH_ISSUE_CALLBACKS_UCALL:" "n:" $resv \
			"tpe_config_addr:" XW "PHB_Unit_ID:" XW "eadshandle:" XW \
						"next_umsg:" XW "arg:" XW}, \
		 0xBA {"EEH_ISSUE_CALLBACKS_RET:" "n:" $resv \
			"tpe_config_addr:" XW "PHB_Unit_ID:" XW "eadshandle:" XW \
								"rc:" XW}, \
		 0xBF {"EEH_ISSUE_CALLBACKS_EXIT:" "tpe_config_addr:" XW \
			"PHB_Unit_ID:" XW "eadshandle:" XW "state:" XW \
								"Line:" DW}, \
		 0xC1 {"EEH_CALL_FIRMWARE:" "token:" XW "status:" XW}, \
		 0xD1 {"EEH_CONFIGURE_PE_ENTER:" "pbid:" XW "slot:" XW \
								"handle:" XW}, \
		 0xD5 {"EEH_CONFIGURE_PE_RTAS:" "token:" $resv "pbid:" XW \
				"slot:" XW "handle:" XW "configaddr:" XW}, \
		 0xDF {"EEH_CONFIGURE_PE_EXIT:" "pbid:" XW "slot:" XW \
						"handle:" XW "loc:" XW}
49D 1.2 L=KERN "pci_busdd:" \
		{{hcallrc(hrc)\
		  $hrc%D1, \
		  14  "H_IN_PROGRESS",\
		  5   "H_PARTIAL",\
          	  0   "H_SUCCESS",\
		  15  "H_PAGE_REGISTERED", \
		  \*  { $hrc%D1} }} \
		$HD, \
		0x000D { "xlate start: \n" "\tliobn="$D1%X4 "sla="$D2%X8 "ela="$D3%X8 "sioba="$D4%X8 \
				"pageshift="$D5%D2 starttimer(0x49D, $D1) }, \
		0x000E { "xlate run: rc=" hcallrc($D1) "\t"endtimer(0x49D, $D2) \
				"\n\tliobn=" $D2%X4 "\t\t\t    cla=" $D3%X8 " ioba =" $D4%X8 \
				"loopcount=" $D5%D4}, \
		0x000F { "xlate end: rc=" hcallrc($D1) "\t"endtimer(0x49D, $D2) \
				"\n\tliobn=" $D2%X4 "\t\t\t    cla=" $D3%X8 " ioba =" $D4%X8 \
				"loopcount=" $D5%D4}
5DF 1.0 "@headd" \
        "HEADD XMT: " \
        $D1, \
        0x57515545 { "WQUE    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x57515545 { "WEND    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
5E0 1.0 "@headd" \
        "HEADD RCV: " \
        $D1, \
        0x52444154 { "RDAT    location=" W2 A4.4 " mbuf=" XW }, \
        0x524E4F54 { "RNOT    location=" W2 A4.4 " mbuf=" XW " size=" XW }, \
        0x52454E44 { "REND    location=" W2 A4.4 " mbuf=" XW }, \
        \*         { W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW }
5E1 1.0 "@headd" \
        "HEADD GEN: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
4B1 1.0 "@gxib" \
        "GXIB PATH:  " O2 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
4B2 1.0 "@gxib" \
        "GXIB ERR:  " O2 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
637 1.0 "@gxib" \
        "GXL PATH:  " O2 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
638 1.0 "@gxib" \
        "GXL ERR:  " O2 A8.8 W2 "d1=" XW " d2=" XW " d3=" XW " d4=" XW
29F 1.1 L=KERN "ddricio" \
        $DDA
DDA 1.2 "" \
        {{ $loc = X1 }} \
        $loc, \
        01  { "entry_open     :" \
                $DDC } , \
        02  { "exit_open      :" \
                $DDC $DDE } , \
        03  { "entry_close    :" $DDC } , \
        04  { "exit_close     :" $DDC $DDE } , \
        09  { "entry_ioctl    :" $DDC "cmd       :" XW} , \
        0A  { "exit_ioctl     :" $DDC "cmd       :" XW \n $DDE} , \
        0B  { "entry_select   :" $DDC } , \
        0C  { "exit_select    :" $DDC $DDE} , \
        0D  { "entry_config   :" $DDC "cmd       : " XW} , \
        0E  { "exit_config    :" $DDC "cmd       :" XW \n $DDE } , \
        11  { "entry_mpx      :" $DDC } , \
        12  { "exit_mpx       :" $DDC $DDE } , \
        21  { "entry_str_Enq  :" $DDC "scb elem @:"  XW } , \
        22  { "exit_str_Enq   :" "unit num  :" O1.0 XW "retcode   :" XW } , \
        25  { "entry_cscb_sig :" "unit num  :" O1.0 XW } , \
        26  { "exit_cscb_sig  :" "unit num  :" O1.0 XW } , \
        27  { "entry_RxRouter :" "unit data@:" O1.0 XW "scb elem @:" XW } , \
        28  { "exit_RxRouter  :" "unit data@:" O1.0 XW "retcode   :" XW } , \
        62  { "inth_entry     :" "level     :" O1.0 XW} , \
        63  { "inth_exit      :" "level     :" O1.0 XW "retcode   :" XW } , \
        64  { "oflinth_entry  :" "level     :" O1.0 XW "mycpu     :" XW } , \
        65  { "oflinth_exit   :" "level     :" O1.0 XW $DDC "mycpu     :" XW } , \
        66  { "dirxfer_entry  :" $DDC "type      :" XW \
              \n "card_addr :" XW "length    :" XW} , \
        67  { "dirxfer_exit   :" $DDC "type      :" XW \
              \n "card_addr :" XW "retcode   :" XW} , \
        68  { "scbxfer_entry  :" $DDC "type      :" XW \
              \n "card_addr :" XW "length    :" XW} , \
        69  { "scbxfer_exit   :" $DDC "type      :" XW \
              \n "card_addr :" XW "retcode   :" XW} , \
        6A  { "ioxfer_entry   :" $DDC "type      :" XW \
              \n "card_addr :" XW "length    :" XW} , \
        6B  { "ioxfer_exit    :" $DDC "type      :" XW \
              \n "card_addr :" XW "retcode   :" XW} , \
        82  { "issuecmd_entry :" $DDC "command   :" XW \
              \n "ret_code  :" XW } , \
        83  { "issuecmd_exit  :" $DDC "command   :" XW \
              \n "ret_code  :" XW } , \
        84  { "ricio_init_eeh :" $DDC "Loc:" XW  "Parameter:" XW "eeh_enabled:" XW "eeh_handle:" XW } , \
        85  { "ricio_eeh_callback :" $DDC "Loc:" XW  "Parameter:" XW "eeh_enabled:" XW "eeh_handle:" XW } , \
        86  { "ricio_free_eeh :" $DDC "Loc:" XW  "Parameter:" XW "eeh_enabled:" XW "eeh_handle:" XW } , \
        87  { "ricio_eeh_read_slot_state :" $DDC "Loc:" XW  "Paramter:" XW "eeh_enabled:" XW "eeh_handle:" XW } , \
        88  { "ricio_eeh_finish_reset :" $DDC "Loc:" XW  "Parameter:" XW "eeh_enabled:" XW "eeh_handle:" XW } , \
        89  { "ricio_eeh_test :" $DDC "Loc:" XW  "Parameter:" XW "eeh_enabled:" XW "eeh_handle:" XW } , \
        29  { "ReadPCIWord : " $DDC "Loc:" XW "CardAddress: " XW } , \
        30  { "GetROSData  : " $DDC "Loc:" XW "Parameter: " XW } , \
        32  { "InitDMA     : " $DDC "Loc:" XW "Parameter: " XW } , \
        31  { "SeeIfROS_IsReady  : " $DDC "Loc:" XW "Parameter: " XW } , \
        33  { "ddricio_general: " W1 A4.8 W2 "d1=" XW " d2=" XW " d3=" XW },\
        34  { "EEH FROZEN : " $DDC "Loc:" XW "Parameter: " XW } , \
        35  { "EEH DEAD   : " $DDC "Loc:" XW "Parameter: " XW } , \
        36  { "EEH SUSPEND: " $DDC "Loc:" XW "Parameter: " XW } , \
        37  { "EEH RESUME : " $DDC "Loc:" XW "Parameter: " XW } , \
        38  { "RestorePCI960Cnfg  : " $DDC "Loc:" XW "Parameter: " XW } , \
        39  { "RestorePCIConfg    : " $DDC "Loc:" XW "Parameter: " XW } , \
        3A  { "RestorePCIRPCnfg   : " $DDC "Loc:" XW "Parameter: " XW } , \
        3B  { "RestoreCLSizeLTimer: " $DDC "Loc:" XW "Parameter: " XW } , \
        3C  { "SaveCLSizeLTimer   : " $DDC "Loc:" XW "Parameter: " XW } , \
        3D  { "WatchdogTimer      : " $DDC "Loc:" XW "Parameter: " XW } , \
        40  { "ProcessInterrupt   : " $DDC "Loc:" XW "Parameter: " XW } , \
        41  { "ricintr            : " $DDC "Loc:" XW "Parameter: " XW } , \
        42  { "ReadPCIDataViaIO   : " $DDC "Loc:" XW "Parameter: " XW } , \
        43  { "GetException       : " $DDC "Loc:" XW "Parameter: " XW } , \
        44  { "DisableInterrupts960: " $DDC "Loc:" XW "Parameter: " XW } , \
        45  { "DisableInterruptsRP: " $DDC "Loc:" XW "Parameter: " XW } , \
        46  { "WaitForKernResp    : " $DDC "Loc:" XW "Parameter: " XW } , \
        47  { "IssueCommand       : " $DDC "Loc:" XW "Parameter: " XW } , \
        48  { "ReadPCI_AdapterIO  : " $DDC "Loc:" XW "Parameter: " XW } , \
        49  { "ReadPCIData        : " $DDC "Loc:" XW "Parameter: " XW } , \
        4A  { "ReadPCIData2U_Space: " $DDC "Loc:" XW "Parameter: " XW } , \
        4B  { "PCIReadReg         : " $DDC "Loc:" XW "Parameter: " XW } , \
        4C  { "ActualReadData2U_Space: " $DDC "Loc:" XW "Parameter: " XW } , \
        4D  { "Set_RP_LocalBusSpeed: " $DDC "Loc:" XW "Parameter: " XW } , \
        4E  { "ResetCard          : " $DDC "Loc:" XW "Parameter: " XW } , \
        4F  { "SeeIfRPROS_IsReady : " $DDC "Loc:" XW "Parameter: " XW } , \
        50  { "SeeIfThereIsA_ROS_Error: " $DDC "Loc:" XW "Parameter: " XW } , \
        D0  { "scb_enq_restart:" "unit num  :"  XW }

DDC 1.0 "" \
       O1 "cardnum   :" XW
DDE 1.0 "" \
        "errno     :" XW
001 1.0 "TRACE ON" channel D2 \
	{{$PID = $D1}} {{ $TRCONTIME = $D2 }} {{$TID = $TID}} \
	\n $TRCONTIME%T8
002 1.1 "@TRACE OFF" \
        {{ $B = B0.1 }} {{ $chan = B0.15 }} {{ $TRCOFFTIME = $D1 }} \
        $B, 0x1 "AUTOMATIC" \
        "TRACE OFF" "channel" $chan $TRCOFFTIME%T8
003 1.2 L=0 "@TRACE HEADER" W2 \
        $D1, \
        1 { \
		{{ $TC = $TOTALCPUS }} {{ $TRC = $TRACEDCPUS }} \
		{{ $INITIALTIME = X4 }} \
		{{ $UTSNAME = M160 }} \
		W2\
\n\
T4 \n\
{{ $sys = A32 }} {{ $node = A32 }} {{ $rel = A32 }} {{ $ver = A32 }} {{ $mach = A32 }} \
System:  $sys $ver"."$rel  Node: $node \n\
Machine: $mach \n\
Internet Address: $IPADDR%X4 sinaddr($IPADDR) \n\
"At trace startup, the system contained" $TC%D1 "cpus, of which" $TRC%D1 "were traced.\n"\
$BUFF, \
  1 {"Buffering: Kernel Heap\n"}, \
  2 {"Buffering: Separate Segments\n"}, \
  \* {} \
$TRACEENV,\
  '32' { "This is from a 32-bit kernel." }, \
  '64' { "This is from a 64-bit kernel." } \
	},\
	2 { {{ $CMD = $HL%S1 }} $CMD \n\n }, \
	3 { "Tracing all hooks." }, \
	4 { "Tracing only these hooks," $HL%S1 {{ $CONDTRACE = 1 }} }, \
	5 { "Tracing all hooks except these hooks," $HL%S1 {{ $CONDTRACE = 2 }} }, \
	6 { {{ $BITMAP = M4096 }} }, \
	7 { {{ $BITMAP = M4096 }} }, \
	255 { $HL%S1\n }
005 1.0 "LOGFILE WRAPAROUND" $HD
006 1.1 "TRACEBUFFER WRAPAROUND" $HD \
        $D1, \
        0 {}, \
        \* { `$D1 missed entries` }
007 1.0 "UNDEFINED TRACE ID" idx $LOGIDX0 \
        G0 {{ $hookword = XW }} \
        $HOOKENV, \
        '32' { G0 {{ $traceid = B0.12 }} }, \
	'64' { G4 {{ $traceid = B0.16 }} } \
        G2 {{ $length = X2 }} \
        traceid $traceid \n\
        hookword $hookword type HT \n\
        $DEFAULT
008 1.1 "@DEFAULT TEMPLATE" \
	$GENERIC, \
	0 { {{ $length = $HL / $WORDSIZE }} \
	  hookdata $HD W1 LOOP $length {XW " "} },\
	1 { "d1" $D1 W2 {{ $length = $HL }} LOOP $length {X0} }
009 1.2 "@trace internal events" \
	$GENERIC, \
	1 {\
	  $D1, \
	  0 { err code=X4  lineno=D4  file=A128 } \
	  }, \
	0 {\
	  $HD, \
	  0 { cpu $D1%D1 added to the trace }, \
	  1 { cpu $D1%D1 removed from the trace }, \
	  2 { "preemption buffer created, cpu" $D1%D1 }, \
	  3 { "preemption buffer creation failed, cpu" $D1%D1 }, \
	  4 { `trace conferred $D1%D1 times.` } \
	  }
00A 1.5 @TRACE_UTIL \
        $GENERIC, \
        1  { {{ $mode = $D1 }} }, \
        \* { {{ $mode = $HD }} } \
	W2 \
        $mode, \
        0x1a "LMT Suspend", \
        0x1b "LMT Restart", \
	\* { $mode,\
		0 ".9 second", \
		1 { {{ $PID = X8 }} pidinstall($PID,X8,A16,X8,X4,X4) }, \
		2 { loaderinstall(X8,X8,A16) }, \
		3 { {{ $PID = $D1 }} }, \
		4 { deviceinstall(X8,A16) }, \
		5 { {{ $IPADDR = $D1 }} }, \
		6 { {{ $BUFF = $D1 }} }, \
		7 { cpumap(0) }, \
		0xc { {{ $addr = X8 }} syminstall(A32, $addr, 1) }, \
		0x25c { timefact(X8, X8, X8) }, \
		0x10 { {{ $cpuid = X4 }} {{ $strlen = $HL - 4 }} \
			{{$string = $HL%S1}} \
			install_logfile($cpuid,$string,$strlen) }, \
		0x12 { {{ $TOTALCPUS = X4 }} {{ $TRACEDCPUS = X4 }} \
			$REPORTEDCPUS,\
				0 { {{ $REPORTEDCPUS = $TRACEDCPUS }} } }, \
		0x13 { {{ $LARGEDATATYPES = 1 }} }, \
		0x14 { reginstall() }, \
		0x16 {  {{ $PID = X8 }} \
			O48 {{ $string = $HL%S1 }} \
			W2 O8 \
			pidinstall($PID,X8,$string,X8,X4,X4) }, \
		0x17 { {{ $strlen = $HL }} {{$string = $HL%S1}} \
			install_componentfile($string,$strlen) }, \
		0x1c {  {{ $PID = X8 }} \
			O56 {{ $string = $HL%S1 }} \
			W2 O8 \
			pidinstall($PID,X8,$string,X8,X4,X4) }, \
		0x1e { {{ $PID = $D3 }} \
			pidinstall($PID, 1, "trace", $TID, $D4, $D5) \
			cidinstall($TID, $D2, 0, 0, 0, 0) }, \
		0x20 {  {{ $PID = X8 }} \
			{{ $pid = $PID }} \
			{{ $ppid = X8 }} \
			{{ $tid = X8 }} \
			O24 {{ $vpid = X8 }} \
			{{ $vtid = X8 }} \
			{{ $cid = X4 }} \
			O16 {{ $string = A36 }} \
			W2 O8 \
			pidinstall($PID,X8,$string,X8,X4,X4) \
			cidinstall($tid, $cid, $vpid, $vtid, 0, 0) \
			"pid="prpid($pid) "ppid="prpid($ppid) "tid="prpid($tid) \
			"string="$string "CID="$cid%D4 "vTID="prpid($vtid) "vPID="prpid($vpid)}, \
		0x21 {  {{ $cid = X4 }} \
			{{ $wp_name = S2 }} \
			{{ $wp_path = S2 }} \
			cidinstall($TID, $cid, 0, 0, 0, $wp_name) \
			"cid="$cid%D4 "name="$wp_name "root_path="$wp_path} \
		$NOPRINT }
100 1.2 L=INT "@FLIH" {{ $level = $HD }} \
    {{ intrtype(type) \
        $type%D1,\
        0       INTR_REGULAR,\
        1       INTR_PADJUNCT,\
        /* { $type%D4 } \
    }} \
    $PLATFORMTYPE, \
    0 { \
        $level, \
        2 { "MACHINE CHECK" "iar="$D1 "cpuid="$CPUID }, \
        3 { "DATA ACCESS PAGE FAULT" "iar="$D1 "cpuid="$CPUID }, \
        4 { "INSTRUCTION PAGE FAULT" "iar="$D1 "cpuid="$CPUID }, \
        5 { "I/O INTERRUPT" O2 "iar="XW "cede="XW "plvl="XW "xirr=" XW intrtype(XW) "cpuid="$CPUID  }, \
        6 { "ALIGNMENT ERROR" "iar="$D1 "cpuid="$CPUID }, \
        7 { "PROGRAM CHECK" "iar="$D1 "cpuid="$CPUID }, \
        8 { "FLOATING POINT UNAVAILABLE" "iar="$D1 "cpuid="$CPUID }, \
	0x0a { "FLOATING POINT IMPRECISE" "iar="$D1 "cpuid="$CPUID }, \
	0x20 { "RUN-MODE INTERRUPT" "iar="$D1 "cpuid="$CPUID }, \
	0x31 { "DECREMENTER INTERRUPT" "iar="$D1 "cpuid="$CPUID },\
	0x32 { "QUEUED INTERRUPT" "iar="$D1 "cpuid="$CPUID }, \
	0x40 { "PROCESSING DEFERRED INTERRUPT" "i_softpri=" $D1%X2 \
                        "previous intpri="$D2%X1 "padj_intpri=" $D3%X2 "cpuid="$CPUID},\
        0x41 { "CONFER ADJUNCT INTERRUPT" "q_pri=" $D1%X2 "set=" $D2%X2 \
                        "hrc=" $D3%X2 "hcall_try=" $D4%X2 "cpuid="$CPUID}, \
	0x64 { "I/O INTERRUPT (EOI)" O2 "xirr="XW "hrc="XW "cpuid="$CPUID }, \
        \* { flih "iar="$D1 "cpuid="$CPUID $level } \
      }, \
    1 { \
	$level, \
	1 { "INSTRUCTION TLB FAULT" "ip="$D1 "cpuid="$CPUID }, \
	2 { "DATA TLB FAULT" "ip="$D1 "cpuid="$CPUID }, \
	3 { "ALTERNATE ITLB FAULT" "ip="$D1 "cpuid="$CPUID }, \
	4 { "ALTERNATE DTLB FAULT" "ip="$D1 "cpuid="$CPUID }, \
        0xb { "BREAK FAULT" "ip="$D1 "cpuid="$CPUID  }, \
        0xc { "EXTERNAL INTERRUPT" flih($level) "ip="$D1 "cpuid="$CPUID  }, \
	0x16 { "INSTR ACCESS-RIGHTS FAULT" "ip="$D1 "cpuid="$CPUID }, \
	0x17 { "DATA ACCESS-RIGHTS FAULT" "ip="$D1 "cpuid="$CPUID }, \
	0x18 { "GENERAL PROTECTION FAULT" "ip="$D1 "cpuid="$CPUID }, \
	0x19 { "DISABLE FP FAULT" "ip="$D1 "cpuid="$CPUID }, \
	0x1a { "NAT CONSUMPTION FAULT" "ip="$D1 "cpuid="$CPUID }, \
	0x1d { "DEBUG FAULT" "ip="$D1 "cpuid="$CPUID }, \
	0x1e { "ALIGNMENT FAULT" "ip="$D1 "cpuid="$CPUID }, \
	0x22 { "LOWER-PRIVILEGE TRANSFER TRAP" "ip="$D1 "cpuid="$CPUID }, \
	0x23 { "TAKEN BRANCH TRAP" "ip="$D1 "cpuid="$CPUID }, \
	0x24 { "SINGLE STEP TRAP" "ip="$D1 "cpuid="$CPUID }, \
	0x33 { "QUEUED INTERRUPT" "ip="$D1 "cpuid="$CPUID }, \
	0x34 { "NESTED INTERRUPT" "ip="$D1 "cpuid="$CPUID }, \
	0x35 { "MACHINE CHECK" "ip="$D1 "cpuid="$CPUID }, \
	 \* { flih "ip="$D1 "cpuid="$CPUID $level } \
      }
1001 1.0 L=KERN "@OFED Trace" \
    {{ \
    print_subhook_src_file(subhook_id) \
	$subhook_id, \
	    0x0000 { "src/bos/kernel/lib/libofed_wrappers/linked_lists.c" }, \
	    0x0001 { "src/bos/kernel/lib/libofed_wrappers/syncronization_primitives.c" }, \
	    0x0002 { "src/bos/kernel/lib/libofed_wrappers/work_queues.c" }, \
	    0x0003 { "src/ofed/kernext/rds/af_rds.c" }, \
	    0x0004 { "src/ofed/kernext/rds/aix_rds_config.c" }, \
	    0x0005 { "src/ofed/kernext/rds/aix_ofed_socket.c" }, \
	    0x0006 { "src/ofed/kernext/rds/bind.c" }, \
	    0x0007 { "src/ofed/kernext/rds/cong.c" }, \
	    0x0008 { "src/ofed/kernext/rds/connection.c" }, \
	    0x0009 { "src/ofed/kernext/rds/info.c" }, \
	    0x000A { "src/ofed/kernext/rds/loop.c" }, \
	    0x000B { "src/ofed/kernext/rds/message.c" }, \
	    0x000C { "src/ofed/kernext/rds/page.c" }, \
	    0x000D { "src/ofed/kernext/rds/recv.c" }, \
	    0x000E { "src/ofed/kernext/rds/send.c" }, \
	    0x000F { "src/ofed/kernext/rds/stats.c" }, \
	    0x0010 { "src/ofed/kernext/rds/aix_rds_sysctl.c" }, \
	    0x0011 { "src/ofed/kernext/rds/threads.c" }, \
	    0x0012 { "src/ofed/kernext/rds/transport.c" }, \
	    0x0013 { "src/bos/kernel/lib/libofed_wrappers/ofed_ras.c" }, \
	    0x0014 { "src/ofed/kernext/rds/aix_rds_proto.c" }, \
	    0x0015 { "src/bos/kernel/lib/libofed_wrappers/memory_management.c" }, \
	    0x0016 { "src/bos/kernel/lib/libofed_wrappers/multiprocessor.c" }, \
	    0x0017 { "src/ofed/kernext/rds/ib.c" }, \
	    0x0018 { "src/ofed/kernext/rds/ib_cm.c" }, \
	    0x0019 { "src/ofed/kernext/rds/ib_ring.c" }, \
	    0x001a { "src/ofed/kernext/rds/ib_stats.c" }, \
	    0x001b { "src/ofed/kernext/rds/ib_recv.c" }, \
	    0x001c { "src/ofed/kernext/rds/ib_send.c" }, \
	    0x001d { "src/ofed/kernext/rds/aix_ofed_ib_dma.c" }, \
	    0x001e { "src/ofed/kernext/rds/aix_ib_wrapper.c" }, \
	    0x001f { "src/ofed/kernext/rds/aix_ib_arp_provider.c" }, \
	    0x0020 { "src/bos/kernel/lib/libofed_wrappers/ofed_misc_wrappers.c" }, \
	    0x0021 { "src/bos/kernel/lib/libofed_wrappers/hash_tables.c" }, \
	    0x0022 { "src/bos/kernel/lib/libofed_wrappers/red_black_trees.c" }, \
	    0x0023 { "src/ofed/kernext/rds/aix_ib_cm.c" }, \
	    0x0024 { "src/ofed/kernext/rds/rdma.c" }, \
	    0x0025 { "src/ofed/kernext/rds/ib_rdma.c" }, \
	    0x0026 { "src/ofed/kernext/rds/aix_ib_device.c" }, \
	    0x0027 { "src/ofed/kernext/rds/aix_ib_dma_page_pool.c" }, \
	    0x0028 { "src/ofed/kernext/rds/aix_rdma_wrappers.c" }, \
	    0x0029 { "src/ofed/kernext/rds/aix_rds_wire_tracing.c" }, \
	    0X002A { "src/rnic/kernext/ofed_core/aix_ofed_core.c" }, \
	    0X002B { "src/rnic/kernext/ofed_core/iwcm.c" }, \
	    0X002C { "src/rnic/kernext/ofed_core/verbs.c" }, \
	    0X002D { "src/rnic/kernext/ofed_core/cma.c" }, \
	    0X002E { "src/rnic/kernext/ofed_core/device.c" }, \
	    0X002F { "src/rnic/kernext/ofed_core/cache.c" }, \
	    0X0030 { "src/rnic/kernext/ofed_core/packer.c" }, \
	    0X0031 { "src/rnic/kernext/ofed_core/ucma.c" }, \
	    0X0032 { "src/rnic/kernext/ofed_core/ud_header.c" }, \
	    0X0033 { "src/rnic/kernext/ofed_core/uverbs_main.c" }, \
	    0X0034 { "src/rnic/kernext/ofed_core/addr.c" }, \
	    0X0035 { "src/rnic/kernext/ofed_core/aix_addr.c" }, \
	    0X0036 { "src/bos/kernel/lib/libofed_wrappers/idr.c" }, \
	    0X0037 { "src/rnic/kernext/ofed_core/uverbs_cmd.c" }, \
	    \*  { $subhook_id } \
    }} \
    {{ $subhook_id = $HD }} \
    {{ $src_line = XW }} \
    {{ $seq_num = X2 }} \
    {{ $num_data_args = X2 }} \
    {{ $stktrace_len = X2 }} \
    {{ $stktrace_sel = X1 }} \
    {{ $stktrace_skip_bytes = X1 }} \
    \n "TID:" $TID "CPU:" $CPUID \n \
    "Seq num: " $seq_num \n \
    print_subhook_src_file($subhook_id) ":" $src_line%UW \n \
    "Data args: " \n \
    LOOP $num_data_args { XW \n } \
    LOOP $stktrace_skip_bytes { O1 } \
    $stktrace_sel, \
        0 { }, \
        1 { "Stack trace: " \n \
	    $stktrace_len%S2 }, \
        2 { {{ $stktrace_len  = $stktrace_len / 8 }} \
            "Stack trace: " \n \
	    LOOP $stktrace_len { XW \n } \
          }, \
    \*  { "unknown stktrace selector " $stktrace_sel }
100B 1.0 "TRACE_UNMANAGED" \
                $HD, \
                \* { `subhook=$HD` `cpu=$CPUID` D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
101 1.0 L=SVC "@SYSTEM CALL" \
        {{ $SVC = $D1 }} \
        $SVC "LR = "$D2\
        starttimer(0x101,$TID)
101D 1.0 "@DISPATCH SRAD" \
	"Home SRAD="$D1%DW "Home ref1="$D2%DW\
	"Dispatch SRAD="$D3%DW "Dispatch ref1="$D4%DW
101E 1.0 "@DISPATCH Affinity" \
	"Pid="$D1  "tid="$D2  "Old SRAD Id="$D3%DW  "New SRAD Id="$D4%DW
102 1.2 L=INT "@SLIH" \
       "slih" "cpuid="$CPUID slihlookup($D1) \
        endtimer(0x102,0x102) starttimer(0x102,0x102) starttimer(0x103,0x103)
1027 1.0 "@THRD_REAFF" \
	$HD, \
	0x00 { `THREAD REAFFIN: tid=$D1 pid=$D2 home_sradid=$D3 home_pgs=$D4 total_pgs=$D5` }
1028 1.0 "@THRD_MREAFF" \
	$HD, \
	0x00 { `THREAD MEM REAFFIN0: tid=$D1 pid=$D2 sidx=$D3 refcnts=$D4 flags_errs=$D5` }, \
	0x01 { `THREAD MEM REAFFIN1: st_home_pgs=$D1 st_tot_pgs=$D2 end_home_pgs=$D3 end_tot_pgs=$D4 retry=$D5` }, \
	0x02 { `THREAD MEM REAFFIN2: segmark tid=$D1 pid=$D2 home_sradid=$D3 sidx=$D4 state=$D5` }, \
	0x03 { `THREAD MEM REAFFIN3: done tid=$D1 pid=$D2 cur state=$D3 orig state=$D4` }
103 1.2 L=INT "@RETURN FROM SLIH" \
	"return from slih" "rc="$D1 "cpuid="$CPUID endtimer(0x103,0x103)
104 1.0 L=SVC "@RETURN FROM SYSTEM CALL" {{ $errno = $D1 }} \
        $errno, \
        0  { `return from $SVC` }, \
        \* { `return from $SVC. error $errno%EW` } \
        {{ $SVC = 0 }} \
        endtimer(0x101,$TID)
105 1.0 "@LVM EVENTS" \
        $HD%D2, \
         1  { `LVM relocingblk:	pbp=$D1 pblock=$D2 relblock=$D3` },\
         2  { `LVM oldbadblock:	pbp=$D1 pblock=$D3 state=$D3` \
		bflags($D2) },\
         3  { `LVM badblkdone:	pbp=$D1` },\
         4  { `LVM newbadblock:	pbp=$D1 badblock=$D4 error=$D3` \
		bflags($D2) },\
         5  { `LVM swreloc:	pbp=$D1 status=$D2 error=$D3 retry=$D4` },\
         6  { {{ $smsk = $D4 & 0xFF }} {{ $pptmp = $D4 / 0x100 }} \
		{{ $ppstate = $pptmp & 0xFF }} {{ $strk = $D4 / 0x10000 }} \
	       `LVM resyncpp:	pbp=$D1 LP=$D3 sync_trk=$strk \
		ppstate=$ppstate sync_msk=$smsk` bflags($D2) },\
         7  { `LVM open:	` devtoname($D1) flags=$D2 },\
         8  { `LVM close:	` devtoname($D1) },\
         9  { `LVM read:	` devtoname($D1) ext=$D2 },\
        10  { `LVM write:	` devtoname($D1) ext=$D2 },\
        11  { `LVM ioctl:	` devtoname($D1) cmd=$D2 arg=$D3 },\
        12  { `LVM upd_bbdir:	pb=$D1 bbop=$D2 bb_pbuf flags=$D3` },\
        13  { `LVM bbdirend:	` devtoname($D1) `bb_pbuf:pb:flags=$D2` \
				:b_error=$D3 },\
        14  { `LVM bbdirop:	` devtoname($D1)` bb_pbuf:pb_bbop=$D2` \
				"\n               " ` origpb:pb_bbop=$D3` },\
        15  { `LVM bbadd:	bb_pbuf ptr=$D1 orig pb_bad ptr=$D2` \
				"\n               " \
				`bad block=$D3 relblk=$D4 status=$D5` },\
        16  { `LVM bbdel:	orig pb_bad ptr=$D1  bad block=$D2` },\
        17  { `LVM bbupd:	bad_ptr=$D1 bad_ptr:blkno=$D2` \
				"\n               " \
				relblk=$D3 status=$D4 },\
        18  { `LVM bbdirdone:	origpb=$D1 pb_bbstat=$D2 pb_bbop=$D3` },\
        19  { `LVM ca_chkcach:	`devtoname($D1) `b_dev=$D1 b_blkno=$D2` \
				"\n               " \
				`ltg=$D3` },\
        20  { `LVM ca_chkhit:	`devtoname($D1) `b_dev=$D1 b_blkno=$D2` \
				"\n               " `ltg=$D3` },\
        21  { `LVM ca_wrt:	`devtoname($D1) ` pvol dev=$D1` },\
        22  { `LVM ca_wend:	`devtoname($D2) `pb=$D1 pvol dev=$D2` \
				"\n               " \
				`pb:flags=$D3 :b_error=$D4` },\
        23  { `LVM mwccwcomp:	`devtoname($D2) `lb_wait=$D1` \
				"\n               " \
				`lb_wait b_dev=$D2 lb_wait b_blkno=$D3` },\
        24  { `LVM ca_clnup:	`devtoname($D1) },\
        25  { `LVM ca_term:	lb=$D1` },\
        26  { `LVM mvhld:	`devtoname($D1) },\
        27  { `LVM hd_aiomir:   d1=$D1 d2=$D2 d3=$D3 d4=$D4 line=$D5%DW` },\
        28  { `LVM hd_sched:    d1=$D1 d2=$D2 d3=$D3 d4=$D4 line=$D5%DW` },\
        \*   { `LVM subhook=$HD%DW	d1=$D1 d2=$D2 d3=$D3 d4=$D4` }
106 1.3 "@DISPATCH" \
        {{ $pidsv = $PID }} {{ $TID = $D2 }} {{ $PID = $D1 }} {{ $CPUID = $D5 }} {{ $e = $EXECPATH }} {{ $PRI = $D4%W16.31 }} \
        "dispatch:   " \
        $e, \
        swapper { "scheduler" }, \
	\* { $PRI, 7F { $SKIP }, \* { "cmd="$e%A14.14  "pid="prKernelPID($PID)  "tid=" prKernelTID($TID) W4 \
	$HOOKENV, \
	'64' { O4 }\
        "priority="U2 "old_tid="prKernelTID($D3) "old_priority="U2 "CPUID="$D5%U1 } } \
        $PRI, \
        7F { "idle time:" endtimer(0x10c,0x10C) } \
        endtimer(0x106,0x106) starttimer(0x106,0x106)
107 1.1 "@LFS: vnop_lookup (filename to vnode)" \
     $GENERIC, \
     1  { W2 `lookuppn: $HL%S1` W2 lookuppninstall1($HL%S1) }, \
     \* { \
	  $HD, \
          0xFF { `vnop_lookup(dvp = $D3, flag = $D4) = $D1, *vpp = $D2` }, \
	  0    { \
		 $D1, \
		 0  { `lookuppn exit: file not found` }, \
		 \* { lookuppninstall2($D1) `lookuppn exit: '`vnodetofilename($D1)`' = vnode $D1`} \
	       }, \
          \*   { vnop_lookup unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 } \
        }
108 1.1 L=SVC "@LFS: file oriented system calls (deprecated, use lfs trace group)" \
        $HD%D1, \
        5  { access $CURRFILE filemode($D1) }, \
        10 { fchmod fdtofilename($D1) filemode($D2) }, \
        6  { chown  $CURRFILE uid=$D1%D1 gid=$D2%D1 }, \
        11 { fchown fdtofilename($D1) uid=$D2%D1 gid=$D3%D1 }, \
        7  { chownx $CURRFILE uid=$D1%D1 gid=$D2%D1 }, \
        12 { fchownx fdtofilename($D1) uid=$D2%D1 gid=$D3%D1 }, \
        16 { ftruncate fdtofilename($D1) to $D3 vp=$D2 }, \
        17 { truncate $CURRFILE to $D1 }, \
        18 { ioctlx fdtofilename($D1) cmd=$D2 }, \
        2  { lockfx fdtofilename($D1) start=$D3 length=$D4 whence=$D2 }, \
        4  { mknod  $CURRFILE filemode($D1) }, \
        15 { fsync fdtofilename($D1) }, \
        19 { `readx($D1%D1,$D3%XW,$D4%X0)` fdtofilename($D1) }, \
        20 { `writex($D1%D1,$D3%XW,$D4%X0)` fdtofilename($D1) }, \
        21 { \
            {{ $fd = $D1 }} {{ $offset = $D2 }} {{ $offset1 = $D3 }} \
            {{ $whence = $D4 }} $whence, \
            0 { lseek fd=prfd($D1) to $offset$offset1 errno=$D5 } ,\
            1 { lseek fd=prfd($D1) relative $offset$offset1 errno=$D5 } ,\
            2 { lseek fd=prfd($D1) relative $offset$offset1 from end of file \
                                                            errno=$D5 },\
           \* { lseek fd=prfd($D1) offset=$offset$offset1 whence=$whence \
						 "(invalid)" errno=$D5 } \
           }, \
        9  { fdinstall($D1) openx fdtofilename($D1) fd=prfd($D1) filemode($D2) }
10A 1.1 @KERN_PFS \
        $HD, \
        0x01  { `PFS rdwr (vp,ip)=($D1,$D2)` \
                        pfsrdwrinstall1($D1,$D2) vnodetofilename($D1) $BREAK }, \
        2  { {{ $h = "readi " }} }, \
        3  { {{ $h = "writei" }} }, \
        \* { `PFS mode=$HD` } \
        `PFS $h VA.S=$D3$D4.$D2 bcount=$D5 ip=$D1` \
        pfsrdwrinstall2($D4,$D5,$D2,$D1) \
	{{ $mspage = $D3 * 1048576 }} \
	{{ $lspage = $D4 / 4096 }} \
        {{ $vpage = $mspage + $lspage }} vpagetofilename($vpage,$D2)
10B 1.0 "@LVM BUF STRUCT FLOW" \
{{ \
        lvmflags(flags) \
                BITFLAGS $flags, \
                0x0001 WRITEV, \
                0x0002 HWRELOC, \
                0x0004 UNSAFEREL, \
                0x0008 RORELOC, \
                0x0010 NO_MWC, \
                0x0020 MWC_RCV_OP, \
                0x0080 RESYNC_OP, \
                0x0100 AVOID_C1, \
                0x0200 AVOID_C2, \
                0x0400 AVOID_C3 \
}} \
        $HD%D2, \
         1 { `LVM pend:		pbp=$D1 resid=$D4 error=$D3` bflags($D2) },\
         2 { {{ $flgs = $D3 & 0xFFFF }} {{ $opts = $D3 / 0x10000 }} \
             `LVM pstart:	` devtoname($D5) \
             `pblock=$D4 (lbp,pbp)=($D2,$D1)` bflags($flgs) `opts:` \
	     lvmflags($opts) bufinstall($D2,$D1) buftofilename($D2) }, \
         3 { {{ $flgs = $D2 & 0xFFFF }} {{ $opts = $D2 / 0x10000 }} \
            `LVM lstart:	` devtoname($D3) \
            `lbp=$D1 lblock=$D4 bcount=$D5` bflags($flgs) `opts:` \
	     lvmflags($opts) }, \
         4 { `LVM rblocked:	lbp=$D1` },\
         5 { `LVM lend:		`devtoname($D5) \
	     `lbp=$D1 resid=$D4 error=$D3` bflags($D2) },\
	 6  { `LVM i_hdbegin:	` enter=$D1 pb=$D2 lb=$D3 },\
	 7  { `LVM i_hdresume:	` pb=$D1 },\
	 8  { `LVM i_hdstart:	` pb=$D1 },\
	 9  { `LVM i_hdstrategy:	` reqlist=$D1 },\
        \*  { `LVM mode=$HD` }
10C 1.2 "@DISPATCH IDLE PROCESS" \
	 {{ $PID = $D1 }} {{ $TID = $D2 }} {{ $CPUID = $D5 }} \
        "dispatch:   idle process  pid="prKernelPID($D1)  "tid="prKernelTID($D2) \
	W4 \
	$HOOKENV, \
	'64' { O4 } \
	"priority="U2 "old_tid="prKernelPID($D3) "old_priority="U2 \
	"CPUID="$D5%U1	\
        starttimer(0x10c,0x10C)
10D 1.1 "@FILE VFS AND INODE" \
        `vfs number=$HD, inode number=$D1`
10E 1.0 L=KERN "@LOCK OWNERSHIP CHANGE"	\
	"relock:	lock addr="$D3"  oldtid="$D1%DW"  newtid="$D2%DW
10F 0.0 KERN_EOF                  $DEFAULT
110 0.0 KERN_STDERR               $DEFAULT
111 0.0 KERN_LOCKF                $DEFAULT
112 1.0  L=KERN "@LOCK" \
	$HD & 0x00F0, \
    	0 { \
        	"lock:          " $HD & 0x000F , \
		1 { "lock " }, \
		2 { "miss " }, \
		3 { "recu " }, \
		4 { "busy " }, \
		9 { "dlock " }, \
		A { "dmiss " }, \
		B { "drecu " }, \
		C { "dbusy " }, \
 		\* { "error HD=" $HD } \
		"lock addr=" $D1	" lock status=" $D2 \
		$D3, \
		1 { "requested_mode=LOCK_SWRITE "}, \
		2 { "requested_mode=LOCK_CWRITE "}, \
		3 { "requested_mode=LOCK_READ "}, \
		4 { "requested_mode=LOCK_UPGRADE "},\
		5 { "requested_mode=LOCK_DOWNGRADE "}, \
		\* { "unknown requested mode "} \
		"return addr="$D4 \
		$HOOKENV, \
		32 { \
			{{ $z1 = $D5%W16.31 }} \
			{{ $z2 = $D5%W0.15 }} \
			"name=" $z1%X2"."$z2%X2 \
		}, \
		64 { \
			{{ $z1 = $D5%W32.63 }} \
			{{ $z2 = $D5%W0.31 }} \
			$PLATFORMTYPE, \
			0 { "name=" $z1%X4"."$z2%X4 }, \
			1 { "name=" $z2%X4"."$z1%X4 } \
		} \
	}, \
	0x10 { \
		"krlock:" \
		"cpuid="$CPUID \
		$HD & 0x00FF, \
		0x11 { "alloc addr="$D1"" }, \
		0x12 { "free addr="$D1"" }, \
		0x13 { "acquire addr="$D1"" }, \
		0x14 { "release addr="$D1"" }, \
		0x15 { "handoff: addr="$D1" target cpuid="$D2"" }, \
		0x16 { "confer: addr="$D1" target cpuid="$D2")" }, \
		0x17 { "prod: addr="$D1" target cpuid="$D2")" }, \
		0x18 { "spin: addr="$D1"" }, \
		0x19 { "assoc.krlock/slock old="$D1%X8" new="$D2%X8" kp="$D3" lp="$D4"" }, \
		0x1A { "inc. requesters old="$D1%X8" new="$D2%X8" addr="$D3"" }, \
		0x1B { "dec. requesters old="$D1%X8" new="$D2%X8" addr="$D3"" }, \
		\* { "error HD=" $HD } \
	}, \
        0x20 { \
                "slock:          " $HD & 0x000F , \
                1 { "lock_hang " }, \
                \* { "error HD=" $HD } \
                "lock addr=" $D1        " lock status=" $D2 \
                $D3, \
                1 { "simple_lock "}, \
                \* { "unknown requested mode "} \
                "return addr="$D4 \
        }, \
	0x30 { \
		"krgroup:" \
		"cpuid="$CPUID \
		"laddr="$D3 \
		$HD & 0x00FF, \
		0x31 { "SetCpuRequest oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x33 { "SetOwnerNoContend oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x34 { "UnlockClearGroup oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x35 { "UnlockReleaseGroup oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x36 { "rruptClearGroup oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x37 { "TryLockHandoff oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x38 { "FinishLockHandoff oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x3A { "UnlockRelClearGroup oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x3B { "rruptClearCpu oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x3C { "rruptClearRelease oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x3E { "UnlockSetKRRelease oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x3F { "UnlockClearKRRelease oldmask="$D1%X8" newmask="$D2%X8"" }, \
		\* { "error HD=" $HD } \
	}, \
	0x40 { \
		"krgroup:" \
		"cpuid="$CPUID \
		"addr="$D3 \
		$HD & 0x00FF, \
		0x41 { "FreeRuntimeGroup kep="$D1" knfp="$D2"" }, \
		0x42 { "FreeRuntimeGlobal kep="$D1" knfp="$D2"" }, \
		0x45 { "UnlockRelClearRelease oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x46 { "ReleasefClearRelease oldmask="$D1%X8" newmask="$D2%X8"" }, \
		0x47 { "FreeRuntimeLocal kpkep="$D1" kcfp="$D2"" }, \
		\* { "error HD=" $HD } \
	}, \
        0x50 { \
                "c_lock:" \
                "laddr="$D1 \
                $HD & 0x00FF, \
                0x51 { "Allocate Reader lock. val: "$D2" rladdr: "$D3"" }, \
                0x52 { "Downgrade CLock val: "$D2" rladdr: "$D3"" }, \
                0x53 { "Upgrade CLock val: "$D2" rladdr: "$D3"" }, \
                0x54 { "Free Reader lock val: "$D2" rladdr: "$D3"" }, \
                0x55 { "sleep w/ il status: "$D2" owner: "$D3"" }, \
                0x56 { "sleep w/o il status: "$D2" owner: "$D3"" }, \
                0x57 { "lw set want write old="$D2" new="$D3"" }, \
                0x58 { "lw take free lock  old="$D2" new="$D3"" }, \
                0x59 { "lr take ug lk enabled  old="$D2" new="$D3"" }, \
                0x5A { "lr take il rmode old="$D2" new="$D3"" }, \
                0x5B { "lr inc rl miss oner old="$D2" new="$D3"" }, \
                0x5C { "lr inc rl oner old="$D2" new="$D3"" }, \
                0x5D { "lr ug fin state old="$D2" new="$D3"" }, \
                0x5E { "lr ug take il frlk old="$D2" new="$D3"" }, \
                0x5F { "lr ug set oner frlk old="$D2" new="$D3"" }, \
                \* { "error HD=" $HD } \
        }, \
        0x60 { \
                "c_lock:" \
                "laddr="$D1 \
                $HD & 0x00FF, \
                0x61 { "lr ug fin state frlk old="$D2" new="$D3"" }, \
                0x62 { "lr ex and ug old="$D2" new="$D3"" }, \
                0x63 { "lr ex and ug 2 old="$D2" new="$D3"" }, \
                0x64 { "lr ex and ug 3 old="$D2" new="$D3"" }, \
                0x65 { "lr no reader locks avail old="$D2" new="$D3"" }, \
                0x66 { "lr exp after wait 1 old="$D2" new="$D3"" }, \
                0x67 { "lr exp after wait 2 old="$D2" new="$D3"" }, \
                0x68 { "lr exp after wait 3 old="$D2" new="$D3"" }, \
                0x69 { "lr no reader locks avail 2 old="$D2" new="$D3"" }, \
                0x6A { "lr take dg be old="$D2" new="$D3"" }, \
                0x6B { "ld ug enabled done old="$D2" new="$D3"" }, \
                0x6C { "ld dg enabled done old="$D2" new="$D3"" }, \
                0x6D { "ld take il all old="$D2" new="$D3"" }, \
                0x6E { "ld dec rl old="$D2" new="$D3"" }, \
                0x6F { "ld wu writer ug old="$D2" new="$D3"" }, \
                \* { "error HD=" $HD } \
        }, \
        0x70 { \
                "c_lock:" \
                "laddr="$D1 \
                $HD & 0x00FF, \
                0x71 { "ld complete state ug old="$D2" new="$D3"" }, \
                0x72 { "ld dec rl w/ il old="$D2" new="$D3"" }, \
                0x73 { "ld complete state dg l w/ il old="$D2" new="$D3"" }, \
                0x74 { "ld wu writer dg old="$D2" new="$D3"" }, \
                0x75 { "ld complete state dg old="$D2" new="$D3"" }, \
                0x76 { "r2w take il old="$D2" new="$D3"" }, \
                0x77 { "r2w no wakeup fail old="$D2" new="$D3"" }, \
                0x78 { "r2w wakeup writer fail old="$D2" new="$D3"" }, \
                0x79 { "r2w wakeup other fail old="$D2" new="$D3"" }, \
                0x7A { "r2w miss and sleep old="$D2" new="$D3"" }, \
                0x7B { "r2w take lock now old="$D2" new="$D3"" }, \
                0x7C { "w2r rl set oner old="$D2" new="$D3"" }, \
                0x7D { "w2r take lock old="$D2" new="$D3"" }, \
                0x7E { "ltr enabled old="$D2" new="$D3"" }, \
                0x7F { "ltr take il1 old="$D2" new="$D3"" }, \
                \* { "error HD=" $HD } \
        }, \
        0x80 { \
                "c_lock:" \
                "laddr="$D1 \
                $HD & 0x00FF, \
                0x81 { "ltr rl set oner old="$D2" new="$D3"" }, \
                0x82 { "ltr take il 2 old="$D2" new="$D3"" }, \
                0x83 { "ltr rl set oner 2 old="$D2" new="$D3"" }, \
                0x84 { "ltr complete state old="$D2" new="$D3"" }, \
                0x85 { "ltr dg take avail old="$D2" new="$D3"" }, \
                0x86 { "ltr2w set ww old="$D2" new="$D3"" }, \
                0x87 { "ltr2w take avail old="$D2" new="$D3"" }, \
                0x88 { "clk_ug take il old="$D2" new="$D3"" }, \
                0x89 { "clk_ug rl init old="$D2" new="$D3"" }, \
                0x8A { "clk_ug complete state old="$D2" new="$D3"" }, \
                \* { "error HD=" $HD } \
	}, \
        0x90 { \
                "drw_lock:" \
                "laddr="$D1 \
                $HD & 0x00FF, \
                0x91 { "lr inc reader lock old="$D2" new="$D3"" }, \
                0x92 { "lr set il old="$D2" new="$D3"" }, \
                0x93 { "lr inc rl miss oner old="$D2" new="$D3"" }, \
                0x94 { "lr take rl oner old="$D2" new="$D3"" }, \
                0x95 { "lr clear il ug old="$D2" new="$D3"" }, \
                0x96 { "lr set il free ug old="$D2" new="$D3"" }, \
                0x97 { "lr take free rl ug oner old="$D2" new="$D3"" }, \
                0x98 { "lr clear il set rm old="$D2" new="$D3"" }, \
                0x99 { "lr take il w/ count old="$D2" new="$D3"" }, \
                0x9A { "lr finish ug rl w/ count old="$D2" new="$D3"" }, \
                0x9B { "lr finish ug clear old="$D2" new="$D3"" }, \
                0x9C { "lr fail ug take lock old="$D2" new="$D3"" }, \
                0x9D { "ld release ug old="$D2" new="$D3"" }, \
                0x9E { "ltr enabled old="$D2" new="$D3"" }, \
                \* { "error HD=" $HD } \
        }, \
        0xA0 { \
                "drw_lock:" \
                "laddr="$D1 \
                $HD & 0x00FF, \
                0xA1 { "ld dec count dg old="$D2" new="$D3"" }, \
                0xA2 { "ld unlock writer old="$D2" new="$D3"" }, \
                0xA3 { "ld set il old="$D2" new="$D3"" }, \
                0xA4 { "ld clear rl old="$D2" new="$D3"" }, \
                0xA5 { "ld last unlock old="$D2" new="$D3"" }, \
                0xA6 { "ld dec count ug old="$D2" new="$D3"" }, \
                0xA7 { "ld unlock writer ug old="$D2" new="$D3"" }, \
                0xA8 { "w2r set oner ug old="$D2" new="$D3"" }, \
                0xA9 { "w2r complete either old="$D2" new="$D3"" }, \
                0xAA { "r2w miss and return old="$D2" new="$D3"" }, \
                0xAB { "r2w set ww old="$D2" new="$D3"" }, \
                0xAC { "r2w take lock now old="$D2" new="$D3"" }, \
                0xAD { "ltr set ww old="$D2" new="$D3"" }, \
                0xAE { "ltr take lock now old="$D2" new="$D3"" }, \
                \* { "error HD=" $HD } \
        }, \
        0xB0 { \
                "drw_lock:" \
                "laddr="$D1 \
                $HD & 0x00FF, \
                0xB1 { "ltw take free lock old="$D2" new="$D3"" }, \
                0xB2 { "lw take free lock old="$D2" new="$D3"" }, \
                0xB3 { "lw set want write old="$D2" new="$D3"" }, \
                0xB4 { "lw take lock after spin old="$D2" new="$D3"" }, \
                \* { "error HD=" $HD } \
        }
113 1.0 L=KERN "@UNLOCK" \
	"unlock:	"\
	"lock addr=" $D1       " lock status=" $D2 \
	"return addr=" $D3 \
	$HOOKENV, \
	32 { \
		{{ $z1 = $D4%W16.31 }} \
		{{ $z2 = $D4%W0.15 }} \
		"name=" $z1%X2"."$z2%X2 \
	}, \
	64 { \
		{{ $z1 = $D4%W32.63 }} \
		{{ $z2 = $D4%W0.31 }} \
		$PLATFORMTYPE, \
		0 { "name=" $z1%X4"."$z2%X4 }, \
		1 { "name=" $z2%X4"."$z1%X4 } \
	}
114 1.0 L=KERN "@LOCKALLOC" \
	"lockalloc:	" \
	"lock_addr=" $D1 	" name=" $D2%X2"."$D3%X2 \
	" return_addr=" $D4
115 1.0 L=KERN "@SETRECURSIVE" \
	$HD, \
	1 { "SETRECURSIVE		" }, \
	2 { "CLEARRECURSIVE		" }, \
	\* { "error HD=" $HD } \
	" lock_addr=" $D1 " return_addr=" $D2
116 1.2 "@XMALLOC size,align,heap" \
        $D5, \
        0x01 { `xmalloc fastpath:   size=$D1 align=$D2 heap=$D3` },\
        0x02 { `xmalloc back end:   size=$D1 align=$D2 heap=$D3 xmd_flags=$D4` },\
        0x03 { `xmalloc return:     result=$D1 size=$D2` }
117 1.0 "@XMFREE address,heap" \
        $D5, \
        0x01 { `xmfree fastpath:    address=$D1 heap=$D2` },\
        0x02 { `xmfree back end:    address=$D1 heap=$D2 xmd_flags=$D3 LR=$D4` },\
        0x04 { `xmalloc garbage collection started on heap $D1` }
118 1.0 "@FORKCOPY" vmm_forkcopy
119 1.0 L=KERN "@SENDSIGNAL"	\
    	$PLATFORMTYPE, \
    	0 { "pidsig:   pid="prKernelPID($D1)  "signal="prsignal($D2)  "lr="$D3 }, \
    	1 { "pidsig:   pid="prKernelPID($D1)  "signal="prsignal($D2)  "b0="$D3 }
11A 0.0 KERN_RCVSIGNAL            $DEFAULT
11C 1.0 L=KERN "@P_SLIH"	\
        "p_slih:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "addr="$D3  "except="$D4%D1
11D 0.0 KERN_SIGDELIVER           $DEFAULT
11E 1.0 L=KERN "@ISSIG"	\
        "issig:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "t_cursig="prsignal($D3)
11F 1.1 "@SET ON READY QUEUE"  \
	"setrq:   " \
       $D3, \
       FF { $SKIP }, \
       \* { "cmd="$D1%PW "pid="prKernelPID($D1) "tid="prKernelTID($D2) "priority="$D3%D1 \
	    "policy="$D4%D1 "rq="$D5 }
120 1.1 "@LFS: vnop_access" \
     $HD, \
     0xFF { `vnop_access(vp = $D2, mode = $D3, who = $D4) = $D1` }, \
     \*   { vnop_access unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
121 1.0 L=SVC "@SYSC_ACCT" acct fname=$D1
122 1.0 L=SVC "@ALARM SYSTEM CALL" {{ $secs = $D1 }} \
        $secs, \
        0  { "alarm off" }, \
        \* { `alarm $secs seconds` }
129 1.1 "@LFS: vnop_setattr" \
     $HD, \
     0xFF { `vnop_setattr(vp = $D2, arg1 = $D3, arg2 = $D4, arg3 = $D5) = $D1` }, \
     \*   { vnop_setattr unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
12E 1.1 "@LFS: vnop_close (close system call)" \
     $HD, \
     0xFF { `vnop_close(vp = $D2, flags = $D3) = $D1` }, \
     0x0  { close fdtofilename($D1) fd=prfd($D1) \
	    lookuppninstall1('') lookuppninstall2(-1) fdinstall($D1) }, \
     \*   { vnop_close unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
130 1.1 "@LFS: vnop_create (creat system call)" \
     $HD, \
     0xFF { `vnop_create(dvp = $D3, flags = $D4, mode = $D5) = $D1, *vpp = $D2` }, \
     0xFE { `vnop_mknod(dvp = $D2, mode = $D3, dev = $D4) = $D1` }, \
     0x0  { creat lookuppninstall2($D1) $NOPRINT }, \
     \*   { vnop_create unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
131 1.0 L=SVC "@DISCLAIM SYSTEM CALL" \
	$HD, \
	0x00 { W1 " address ="X8 " len = "XW " flags = "XW },\
	0x10 { W1 "64 address ="X8 " len = "X8 " flags = "XW }
134 1.0 L=SVC "@EXEC SYSTEM CALL" \
       W2 \
       $D1, \
       0 { "exec SIGKILLed:   pid="prKernelPID($PID)  "reason="$D2 }, \
       1 { "exec:   cmd="prargs($HL)  "pid="prKernelPID($PID)  \
            "tid="prKernelTID($TID) pidinstall($PID,0,$HL%S1,$TID,$CPUID,$PRI) }
135 1.0 L=SVC "@EXIT SYSTEM CALL" \
        {{ $waitstat = $D1 }} {{ $pid = $D2 }} {{ $lockct = $D3 }} \
        kexit() \
        exit wait_status=$waitstat lockct=$lockct
136 1.1 "@LFS: vnop_fclear" \
     $HD, \
     0xFF { `vnop_fclear(vp = $D2, offset = $D3, length = $D4) = $D1` }, \
     0xEF { `vnop_fclear(vp = $D2, ...) = $D1` }, \
     0xEE { `vnop_fclear(vp = $D1, offset = ` W2 X8`, length = ` W4 X8`) = ...` }, \
     \*   { vnop_fclear unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
137 1.1 "@FCNTL SYSTEM CALL (deprecated)" \
        fcntl fdtofilename($D1) \
        $D2, \
        0 { F_DUPFD original file descriptor $D3 }, \
        1 { 'F_GETFD' }, \
        2 { 'F_SETFD' }, \
        3 { 'F_GETFL' }, \
        4 { 'F_SETFL' }, \
        10 { 'F_CLOSEM' } \
        return value $D4
139 1.0 L=SVC "@FORK SYSTEM CALL" \
        $HD, \
        0x00 { `fork:   pid=$D1%D1 tid=$D2%D1 kcid=$D3%D4` pidinstall($D1,$PID,$EXECPATH,$D2,0xff,0xff) \
		cidinstall($D2, $D3, $D4, $D5, 0, 0) }, \
        0x01 { `fork:   Process limit reached by uid=$D1%D4`\n\
               `        pid=$D2%D1 kcid=$D3%D4 num=$D4%D4 lim=$D5%D8` }, \
        0x02 { `fork:   ld_fork_prepare failed rc=$D1%DW`\n\
               `        pid=$D2%D1 kcid=$D3%D4` }, \
        \*   { fork unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 }
13A 1.1 "@LFS: vnop_getattr (fstat system call)" \
     $HD, \
     0xFF { `vnop_getattr(vp = $D2) = $D1` }, \
     0x0  { fstat fdtofilename($D1) fd=prfd($D1) }, \
     \*   { vnop_getattr unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
13B 1.1 "@LFS: vfs_statfs / vfs_statfsvp (fstatfs system call)" \
     $HD, \
     0xFF { `vfs_statfs(vfsp = $D2, vp = $D3) = $D1` }, \
     0x0  { fstatfs fdtofilename($D1) fd=prfd($D1) }, \
     \*   { vfs_statfs unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
13C 1.1 "@LFS: vnop_fsync" \
     $HD, \
     0xFF { `vnop_fsync(vp = $D2, flags = $D3, offset = $D4, length = $D5) = $D1` }, \
     0xEF { `vnop_fsync(vp = $D2, flags = $D3, ...) = $D1` }, \
     0xEE { `vnop_fsync(vp = $D1, offset = ` W2 X8`, length = ` W4 X8`) = ...` }, \
     \*   { vnop_fsync unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
13D 1.1 "@LFS: vnop_ftrunc" \
{{ int64(x) $HOOKENV, 64 { O4 {{ $high = X4 }} {{ $high = $high * 0x100000000 }} O4 {{ $low = X4 }} {{ $high = $high + $low  }} $high%X8 }, 32 { X8 } }} \
     $HD, \
     0xFF { `vnop_ftrunc(vp = $D2, flags = $D3, length = ` W4 int64()`) = $D1` }, \
     \*   { vnop_ftrunc unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
13E 1.0 L=SVC "@FULLSTAT SYSTEM CALL" \
        {{ $filename = XW }} {{ $cmd = XW }} {{ $buf = XW }} \
        fullstat filename=$filename cmd=$cmd
14C 1.1 "@LFS: vnop_ioctl (ioctl system call)" \
     $HD, \
     0xFF { `vnop_ioctl(vp = $D2, cmd = $D3, arg = $D4, flags = $D5) = $D1` }, \
     0x0  { \
	    {{ $fd = $D1 }} \
	    {{ $command = $D2 }} W2 \
	    $HOOKENV, '32' { O2 }, '64' { O6 }\
	    {{ $ttycmdhi = X1 }} {{ $ttycmdlo = X1 }} \
	    {{ $arg = $D3 }} \
	    ioctl fd=prfd($D1) \
	    $ttycmdhi, \
	    54 { \
                $ttycmdlo, \
                01 { TCGETA  $BREAK }, \
                02 { TCSETA  $BREAK }, \
                03 { TCSETAW $BREAK }, \
                04 { TCSETAF $BREAK }, \
                05 { TCSBRK  arg=$arg $BREAK }, \
                06 { TCXONC  arg=$arg $BREAK }, \
                07 { TCXFLSH arg=$arg $BREAK } \
	    } \
	    command=$command arg=$arg \
          }, \
     \*   { vnop_ioctl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
14E 1.0 "@KILL SYSTEM CALL" \
        kill: signal prsignal($D2) to process prKernelPID($D1) $D1%P4
150 1.1 "@LFS: vnop_link" \
     $HD, \
     0xFF { `vnop_link(dvp = $D3, vp = $D2) = $D1` }, \
     \*   { vnop_link unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
152 1.1 "@LFS: vnop_lockctl (lockf system call)" \
{{ int64(x) $HOOKENV, 64 { O4 {{ $high = X4 }} {{ $high = $high * 0x100000000 }} O4 {{ $low = X4 }} {{ $high = $high + $low  }} $high%X8 }, 32 { X8 } }} \
     $HD, \
     0xFF { `vnop_lockctl(vp = $D2, cmd = $D3, offset = ` W4 int64()`) = $D1` }, \
     0x0  { \
	    {{ $size = $D3 }} {{ $size1 = $D4 }} \
	    lockf fdtofilename($D1) fd=prfd($D1) \
	    $D2, \
	    0  { "unlock" }, \
	    1  { "lock wait" }, \
	    2  { "lock busy" }, \
	    \* { cmd=$D2 } \
	    $size$size1 bytes \
	  }, \
     \*   { vnop_lockctl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
154 1.1 "@LFS: vnop_seek (lseek system call)" \
{{ int64(x) $HOOKENV, 64 { O4 {{ $high = X4 }} {{ $high = $high * 0x100000000 }} O4 {{ $low = X4 }} {{ $high = $high + $low  }} $high%X8 }, 32 { X8 } }} \
     $HD, \
     0xFF { `vnop_seek(vp = $D2, offset = ` W3 int64()`) = $D1` }, \
     0x0 { \
           {{ $fd = $D1 }} {{ $offset = $D2 }} {{ $offset1 = $D3 }} {{ $whence = $D4 }} \
           $whence, \
           0 { lseek fd=prfd($D1) to $offset$offset1 } ,\
           1 { lseek fd=prfd($D1) relative $offset$offset1 } ,\
           2 { lseek fd=prfd($D1) relative $offset$offset1 from end of file } ,\
           \* { lseek fd=prfd($D1) offset=$offset$offset1 whence=$whence "(invalid)" } \
	 }, \
     \*   { vnop_seek unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
156 1.1 "@LFS: vnop_mkdir" \
     $HD, \
     0xFF { `vnop_mkdir(vp = $D2, mode = $D3) = $D1` }, \
     \*   { vnop_mkdir unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
159 1.1 "@LFS: vfs_mount" \
     $HD, \
     0xFF { `vfs_mount(vfsp = $D2, vmt_fsid[0] = $D3, vmt_fsid[1] = $D4, mntdover = $D5) = $D1` }, \
     \*   { vfs_mount unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
15B 1.1 "@LFS: vnop_open (open system call)" \
     $HD, \
     0xFF { `vnop_open(vp = $D2, flags = $D3, ext = $D4) = $D1` }, \
     0x0  { \
	    fdinstall($D1) \
	    open fdtofilename($D1) fd=prfd($D1) openflags($D2) \
	    $D2%o4 & 0400, 0400 { mode=filemode($D3) } \
	  }, \
     \*   { vnop_open unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
15F 1.1 "@PIPE SYSTEM CALL (deprecated)" \
        `pipe read_fd=prfd($D1) write_fd=prfd($D2)`
160 1.0 L=SVC "@PLOCK" \
        plock $EXECPATH \
        $D1, \
        0 "UNLOCK", \
        1 "PROCESS LOCK", \
        2 "TEXT SEGMENT LOCK", \
        4 "DATA SEGMENT DATLOCK"
163 1.1 "@LFS: vnop_rdwr (read)" \
{{ int64(x) $HOOKENV, 64 { O4 {{ $high = X4 }} {{ $high = $high * 0x100000000 }} O4 {{ $low = X4 }} {{ $high = $high + $low  }} $high%X8 }, 32 { X8 } }} \
     $HD, \
     0xFF { `vnop_rdwr_read(vp = $D1, offset = ` W2 int64()`, length = $D4, flags = $D5, ...) = ...` }, \
     0xFE { `vnop_rdwr_read(vp = $D2, ext = $D4, ...) = $D1, $D3 bytes moved` }, \
     0x0  { `read($D1%D1,$D3%XW,$D4%X0)` fdtofilename($D1) }, \
     \*   { vnop_rdwr unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
164 1.1 "@LFS: vnop_readlink" \
     $HD, \
     0xFF { `vnop_readdir(vp = $D2) = $D1` }, \
     \*   { vnop_readdir unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
167 1.1 "@LFS: vnop_rename" \
     $HD, \
     0xFF { `vnop_rename(from_dvp = $D3, from_vp = $D2, to_dvp = $D5, to_vp = $D4) = $D1` }, \
     \*   { vnop_rename unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
168 1.1 "@LFS: vnop_rmdir" \
     $HD, \
     0xFF { `vnop_rmdir(dvp = $D3, vp = $D2) = $D1` }, \
     \*   { vnop_rmdir unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
169 1.0 "@SBREAK SYSTEM CALL" \
  $D1, \
  '20' { `sbreak   new dmax is $D2%X4` }, \
  '40' { `sbreak   new dmax is $D2%X4 $D3%X4` }
16A 1.0 L=SVC "@SELECT SYSTEM CALL" \
        $HD, \
        0 { `ifds=$D1 rfds=$D2 msgs=$D3 secs=$D4 usecs=$D5` }
16E 1.0 "@SETPGRP" \
	{{ $WDS = $HL / $WORDSIZE }} \
        $WDS, \
	  0 { "SETPRGP" },\
	  1 { "SETPRGP" },\
	  \* { `setpgid pid=prKernelPID($D1) pgrp=$D2%D1` }
16F 1.0 "SBREAK SYSTEM CALL"  $DEFAULT
180 2.0 L=SVC "@SIGACTION SYSTEM CALL" \
        sigaction signal prsignal($D1) \n\
	addr new sigaction=$D2%XW addr old sigaction=$D3%XW
181 1.0 "SIGCLEANUP"
183 1.0 L=SVC "@SIGRETURN"	\
        "sigreturn:   pid="$D1%D1  "tid="$D2%D1
18B 1.1 "@LFS: vnop_symlink" \
     $HD, \
     0xFF { `vnop_symlink(dvp = $D2) = $D1` }, \
     \*   { vnop_symlink unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
18E 1.0 "@TIMES" \
	"times:   "	\
        {{ $u = $D1 }} {{ $s = $D2 }} {{ $cu = $D3 }} {{ $cs = $D4 }} \
        `times u=$u%D1 s=$s%D1 cu=$cu%D1 cs=$cs%D1 (ticks)`
18F 1.0 L=SVC "@ULIMIT SYSTEM CALL" \
        ulimit \
        $D1%D1, \
        1 { `get fsize` }, \
        2 { `set fsize to $D2` }, \
        3 { `get data limit` }, \
        1004 { `set data limit to $D2` }, \
        1005 { `get stack` }, \
        1006 { `set stack limit to $D2` }, \
        1007 { "get RAWDIR compatibility mode (REALDIR)" }, \
        1008 { \
                $D2, \
                0  { "clear RAWDIR compatibility mode (REALDIR)" }, \
                \* { "set RAWDIR compatibility mode (REALDIR)" } \
        }, \
        1009 { "get TRUNCATES compatibility mode (SYSVLOOKUP)" }, \
        1010 { \
                $D2, \
                0  { "clear TRUNCATES compatibility mode (SYSVLOOKUP)" }, \
                \* { "set TRUNCATES compatibility mode (SYSVLOOKUP)" } \
        }
191 1.1 "@LFS: vfs_unmount" \
     $HD, \
     0xFF { `vfs_unmount(vfsp = $D2, vmt_fsid[0] = $D3, vmt_fsid[1] = $D4, mntdover = $D5) = $D1` }, \
     \*   { vfs_unmount unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
194 1.1 "@LFS: vnop_remove" \
     $HD, \
     0xFF { `vnop_remove(dvp = $D3, vp = $D2) = $D1` }, \
     \*   { vnop_remove unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
195 1.0 L=SVC "@USRINFO SYSTEM CALL" "usrinfo"
19B 1.0 L=SVC "@WAIT SYSTEM CALL" \
        {{ $rv = $D1 }} {{ $pid = $D2 }} {{ $pflag = $D3 }} {{ $wstat = $D4 }} \
        wait rv=$rv pid=prKernelPID($pid) pflag=$pflag wstat=$wstat
19C 1.1 "@LFS: vnop_rdwr (write)" \
{{ int64(x) $HOOKENV, 64 { O4 {{ $high = X4 }} {{ $high = $high * 0x100000000 }} O4 {{ $low = X4 }} {{ $high = $high + $low  }} $high%X8 }, 32 { X8 } }} \
     $HD, \
     0xFF { `vnop_rdwr_write(vp = $D1, offset = ` W2 int64()`, length = $D4, flags = $D5, ...) = ...` }, \
     0xFE { `vnop_rdwr_write(vp = $D2, ext = $D4, ...) = $D1, $D3 bytes moved` }, \
     0x0  { `write($D1%D1,$D3%XW,$D4%X0)` fdtofilename($D1) }, \
     \*   { vnop_rdwr unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
1A0 1.1 "@LFS: vnop_readdir" \
     $HD, \
     0xFF { `vnop_readdir(vp = $D2, offset = $D3, length = $D4) = $D1, offset = $D5` }, \
     0xEF { `vnop_readdir(vp = $D2, offset = ` W3 X8`, length = $D5) = $D1, offset = ...` }, \
     0xEE { `vnop_readdir(vp = $D1, ...) = ..., offset = ` W2 X8 }, \
     \*   { vnop_readdir unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
1A4 1.0 L=SVC "@GETRLIMIT SYSTEM CALL" \
{{ \
prresource(resource) \
$resource, \
        0 "CPU TIME", \
        1 "MAX FILE SIZE", \
        2 "DATA SEGMENT SIZE", \
        3 "SIZE SIZE", \
        4 "CORE FILE SIZE", \
        5 "RESIDENT SET SIZE" \
}} \
        getrlimit resource=$D1 prresource($D1)
1A5 1.0 L=SVC "@SETRLIMIT SYSTEM CALL" \
        setrlimit resource=$D1 prresource($D1)
1A6 1.0 L=SVC "@GETRUSAGE SYSTEM CALL" \
        getrusage who=$D1%D1 \
        $D1, \
        0  "of self", \
        \* "of children"
1A7 1.0 L=SVC "@GETPRIORITY SYSTEM CALL" \
        {{ $which = $D1 }} {{ $who = $D2 }} \
        getpriority \
        $which, \
        0 { \
                "of process" \
                $who, \
                0  { prKernelPID($PID) $PID%PW }, \
                \* { prKernelPID($who) $who%PW } \
        }, \
        1 { \
                "of process group" \
                $who, \
                0  { prKernelPID($PID) $PID%PW }, \
                \* { prKernelPID($who) $who%PW } \
        }, \
        2 { \
                "of uid" \
                $who, \
                0  { "(current process)" }, \
                \* { prKernelPID($who) } \
        }
1A8 1.0 L=SVC "@SETPRIORITY SYSTEM CALL" \
        {{ $which = $D1 }} {{ $who = $D2 }} {{ $nice = $D3 }} \
        setpriority  \
        $which, \
        0 { \
                "of process" \
                $who, \
                0  { prKernelPID($PID) $PID%PW }, \
                \* { prKernelPID($who) $who%PW } \
        }, \
        1 { \
                "of process group" \
                $who, \
                0  { prKernelPID($PID) $PID%PW }, \
                \* { prKernelPID($who) $who%PW } \
        }, \
        2 { \
                "of uid" \
                $who, \
                0  { "(current process)" }, \
                \* { prKernelPID($who) } \
        } \
        "to" $nice%D1
1A9 1.0 "@ABSINTERVAL SYSTEM CALL" \
        absinterval timerid=$D1
1AA 1.0 "@GETINTERVAL SYSTEM CALL" \
        getinterval timerid=$D1
1AB 1.0 "@GETTIMER SYSTEM CALL" \
        gettimer timer_type=$D1
1AC 1.0 "@INCINTERVAL SYSTEM CALL" \
        incinterval timerid=$D1
1AD 1.0 "@RESTIMER SYSTEM CALL" \
        restimer timer_type=$D1
1AE 1.0 "@RESABS SYSTEM CALL" \
        resabs timer_type=$D1
1AF 1.0 "@RESINC SYSTEM CALL" \
        resinc timer_type=$D1
1B0 1.0 "@VMM_ASSIGN (assign virtual page to a physical page)" \
{{ \
vmmsibits(sibits) \
        $sibits & 0xC4800000, \
        \* { \
                "\n    " \
                BITFLAGS $sibits, \
                & 0x38000000 0x00000000 "invalid_segment",    \
                & 0x38000000 0x08000000 "working_storage",    \
                & 0x38000000 0x10000000 "mapping_segment",    \
                & 0x38000000 0x18000000 "real_mem_mapping",   \
                & 0x38000000 0x20000000 "client_segment",     \
                & 0x38000000 0x28000000 "persistent_storage", \
                0x04000000 "intrseg",      \
                0x02000000 "delpend",      \
		0x01000000 ".",            \
                0x00800000 "iodelete",     \
                0x00400000 "shrlib",       \
                0x00200000 "jseg",         \
                0x00100000 "defseg",       \
                0x00080000 "system",       \
                0x00040000 "combit",       \
                0x00020000 "chgbit",       \
                0x00010000 "compseg",      \
                0x00008000 "eio",          \
		& 0x00007C00 0x00000000 "(hkey 0)",      \
		& 0x00007C00 0x00000400 "(hkey 1)",      \
		& 0x00007C00 0x00000800 "(hkey 2)",      \
		& 0x00007C00 0x00000C00 "(hkey 3)",      \
		& 0x00007C00 0x00001000 "(hkey 4)",      \
		& 0x00007C00 0x00001400 "(hkey 5)",      \
		& 0x00007C00 0x00001800 "(hkey 6)",      \
		& 0x00007C00 0x00001C00 "(hkey 7)",      \
		& 0x00007C00 0x00002000 "(hkey 8)",      \
		& 0x00007C00 0x00002400 "(hkey 9)",      \
		& 0x00007C00 0x00002800 "(hkey 10)",     \
		& 0x00007C00 0x00002C00 "(hkey 11)",     \
		& 0x00007C00 0x00003000 "(hkey 12)",     \
		& 0x00007C00 0x00003400 "(hkey 13)",     \
		& 0x00007C00 0x00003800 "(hkey 14)",     \
		& 0x00007C00 0x00003C00 "(hkey 15)",     \
		& 0x00007C00 0x00004000 "(hkey 16)",     \
		& 0x00007C00 0x00004400 "(hkey 17)",     \
		& 0x00007C00 0x00004800 "(hkey 18)",     \
		& 0x00007C00 0x00004C00 "(hkey 19)",     \
		& 0x00007C00 0x00005000 "(hkey 20)",     \
		& 0x00007C00 0x00005400 "(hkey 21)",     \
		& 0x00007C00 0x00005800 "(hkey 22)",     \
		& 0x00007C00 0x00005C00 "(hkey 23)",     \
		& 0x00007C00 0x00006000 "(hkey 24)",     \
		& 0x00007C00 0x00006400 "(hkey 25)",     \
		& 0x00007C00 0x00006800 "(hkey 26)",     \
		& 0x00007C00 0x00006C00 "(hkey 27)",     \
		& 0x00007C00 0x00007000 "(hkey 28)",     \
		& 0x00007C00 0x00007400 "(hkey 29)",     \
		& 0x00007C00 0x00007800 "(hkey 30)",     \
		& 0x00007C00 0x00007C00 "(hkey 31)",     \
		& 0x00000300 0x00000000 "P_DEFAULT",     \
		& 0x00000300 0x00000100 "P_FIRST_TOUCH", \
		& 0x00000300 0x00000200 "P_BALANCED",    \
		& 0x000000C0 0x00000000 "4K",            \
		& 0x000000C0 0x00000040 "64K",           \
		& 0x000000C0 0x00000080 "16M",           \
		& 0x000000C0 0x000000C0 "16G",           \
                0x00000020 "psearlyalloc", \
                0x00000010 "large",        \
                0x00000008 "dmapseg",      \
                0x00000004 "inactive",     \
                0x00000002 "acctseg",      \
                0x00000001 "modlist_req",  \
                & 0xC0000000 0xC0000000 "(pkey 3)", \
                & 0xC0000000 0x80000000 "(pkey 2)", \
                & 0xC0000000 0x40000000 "(pkey 1)", \
                & 0xC0000000 0x00000000 "(pkey 0)"  \
        } \
}} \
        `VMM page assign:      V.S=$D3.$D1 ppage=$D4` vmmsibits($D2)
1B1 1.0 "@VMM_DELETE (delete a virtual page)" \
        `VMM page delete:      V.S=$D3.$D1 ppage=$D4` vmmsibits($D2)
1B2 1.0 "@VMM_PGEXCT (pagefault)" \
	$HD, \
	0 {`VMM pagefault:        V.S=$D3.$D1            ` vmmsibits($D2)},\
	1 {`pagefault worklim err: sid=$D1 pagex=$D3 ` vmmsibits($D2) \
	   `\n uplim=$D4 downlim=$D5`},\
	2  {`pagefault filelim err: sid=$D1 pagex=$D3 ` vmmsibits($D2) \
	   `\n filelim=$D4 user flags=$D5`},\
	3  {`pagefault spaceok err: sidx=$D1 pagex=$D3 ` vmmsibits($D2) \
	   `\n rc=$D4`},\
	4  {`pagefault pagein err: sidx=$D1 pagex=$D3 ` vmmsibits($D2) \
	   `\n flags=$D4 rc=$D5`},\
	5  {`pagefault handle err: eaddr=$D1, SLB hand=$D2, adsp hand=$D3`}
1B3 1.0 "@VMM_PROTEXCT (protection fault)" \
        `VMM protection fault: V.S=$D3.$D1 ppage=$D4` vmmsibits($D2)
1B4 1.0 "@VMM_XMEMCNT (xmemcnt change, CT only)" \
	`VMM xmemcnt0: caller=$D1 caller2=$D2 sid=$D3 incr=$D4 xmemcnt=$D5`
1B5 1.0 "@VMM_RECLAIM" \
        $HD, \
        0 { `VMM reclaim:          V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) }, \
        1 { `VMM ping-pong:        V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) }
1B6 1.0 @VMM_GETPARENT \
        `VMM getparent:        V.S=$D3.$D1 ppage=$D4` vmmsibits($D2)
1B7 1.0 "@VMM_COPYPARENT" \
	$HD, \
	0 { `VMM copyparent:       V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) }, \
	1 { `VMM mapparent:	   V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) }, \
	2 { `VMM cowreload:	   V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) }
1B8 1.0 "@VMM_VMAP (fault on a shared process private segment)" \
        `VMM vmapped page:     V.S=$D3.$D1 ppage=$D4` vmmsibits($D2)
1B9 1.0 "@VMM_ZFOD (zero fill a page)" \
        `VMM zero filled page: V.S=$D3.$D1 ppage=$D4` vmmsibits($D2)
1BA 1.0 "@VMM_PAGEIO" \
	$HD, \
	0 { `VMM sio pgout:    V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) \
                               "\n    " `bp=$D5` \
                               vmmbufinstall($D3,$D1,$D5) \
                               sidtofilename($D5) }, \
	1 { `VMM sio pgin:     V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) \
                               "\n    " `bp=$D5` \
                               vmmbufinstall($D3,$D1,$D5) \
                               sidtofilename($D5) }, \
	2 { `VMM sio pp pgin:  V.S=$D2.$D1 bp=$D3 poffset=$D4 size=$D5` }, \
	3 { `VMM sio pp pgout: V.S=$D2.$D1 bp=$D3 poffset=$D4 size=$D5` }
1BB 1.0 "@VMM_SEGCREATE (segment create)" \
	`VMM segment creation:	S=$D1 sibits2=$D3 pvproc=$D4 ` vmmsibits($D2)
1BC 1.0 "@VMM_SEGDELETE (segment delete)" \
	`VMM segment deletion:	S=$D1 sibits2=$D3 pvproc=$D4 ` vmmsibits($D2)
1BD 1.0 "@VMM_DALLOC" \
	$HD, \
	0 { `VMM disk alloc:    V.S=$D3.$D1 dblk=$D5 ` vmmsibits($D2) \
                                "\n    " `pdtx/devid=$D4` }, \
	1 { `VMM pp disk alloc:	xptp=$D1 pdtx=$D2 dblk=$D3 nblks=$D4` }, \
	2 { `VMM disk free:	V.S=$D3.$D1 dblk=$D5 ` vmmsibits($D2) \
				"\n    " `pdtx/devid=$D4` }, \
	3 { `VMM pp disk free:	nfr=$D1 idx=$D2 pdtx=$D3 dblk=$D4 nblks=$D5` }, \
	4 { `VMM pp disk free:	xptp=$D1 pdtx=$D2 dblk=$D3 nblks=$D4` }
1BE 1.0 "@VMM_PFEND" \
	$HD, \
	0 { `VMM pfendout:    V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) \
                              "\n    " `error=$D5` }, \
	1 { `VMM pfendin:     V.S=$D3.$D1 ppage=$D4` vmmsibits($D2) \
                              "\n    " `error=$D5` }, \
	2 { `VMM pp pfendout: V.S=$D2.$D1 bp=$D3 poffset=$D4 size=$D5` }, \
	3 { `VMM pp pfendin:  V.S=$D2.$D1 bp=$D3 poffset=$D4 size=$D5` }, \
	4 { `VMM pfend cksum: nfr=$D1 psx=$D2 cksum=$D3 saved_cksum=$D4 cp=$D5` }, \
	5 { `VMM vtiol enqueue: buf=$D1 vtiolID=$D2 qidx=$D3 nreqs=$D4 sidx=$D5` }, \
	6 { `VMM vtiol dequeue: buf=$D1 buf_tb=$D2 nreqs=$D3 qidx=$D4` }, \
	7 { `VMM vtiol ch active: numth_active=$D1 old_active=$D2 req_avg=$D3 tot_reqs=$D4` }
1BF 1.0 @VMM_EXCEPT \
        `VMM exception:        sregval=$D2 vaddr=$D3` vmmsibits($D1) \
        "\n    " `error=$D4 pid=prKernelPID($D5)`
1C8 1.0 "PPDD" \
        {{ $loc = X1 }} R1 \
        $DD1 \
        $loc, \
        01  { "flags:" XW \
                } , \
        07  { "resid:" DW "iovcnt:" DW "offset:" XW "fmode:" XW \
                }
1CF 1.0 "C327DD" \
        {{ $loc = X1 }} R1 \
        $DD1 \
        $loc, \
        03  {  "chan:" XW \
                } , \
        05  { "uiop:" XW "chan:" XW "ext:" XW \
                } , \
        07  { "uiop:" XW "chan:" XW "ext:" XW \
                } , \
        0B  { "event:" XW "chan:" XW \
                } , \
        11  { "name:" XW "chan:" XW \
                } , \
        21  { "ID:" O1 A4.8     \
                "d1=" XW " d2=" XW " d3=" XW " d4=" XW  \
                }
1D0 0.0 DDSPEC_GRAPHIO            $DEFAULT
1D1 1.0 ERRLG {{ $errno = $HDL }} {{ $mmdev = X2 }} {{ $cmd = X2 }} \
{{ \
errioctl1D1(cmd) \
        $cmd, \
        0x4501 "ERRIOC_STOP", \
        0x4502 "ERRIOC_SYNC", \
        \*     { `cmd=$cmd` } \
}} \
	$GENERIC,\
	0 { {{ $MODE = $HDU }} },\
	1 { {{ $MODE = $D1 }} }\
        $MODE%D1, \
        1  { erropen:  $errno%E1 }, \
        2  { errclose: $errno%E1 }, \
        3  { errioctl: $errno%E1 devtoname($D1) errioctl1D1($cmd) }, \
        4  { errread:  bad erec: "magic" $D1 "length" $D2 bytes }, \
        5  { errread:  $errno%E1 }, \
        6  { errwrite  $errno%E1 }, \
        7  { errput: error id=$D1%XW }, \
        8  { `errput: buffer overflow: state=$errno` }, \
        9  { `errdd:  lockl from $errno already locked by $D1%PW` }, \
        10 { `errdd:  unlockl from $errno. not locked` }, \
	13 { `errlast: error id=$D1` }, \
	14 { `errresume: errlast error id=$D1` }, \
        16 { `errdemon: cannot write to error log. error id=$D1` }, \
	17 { "Duplicate error id:" $D1 "\n"\
	     "count:" $D2 "times:" $D3%T4 $D4%T4},\
	18 { "errlast_log error id" $D1}, \
	19 { "errlast error!" $D1 "should be an RTAS error" }, \
	20 { "bad length for error" $D1 "in" \
	  $HDL, \
	    0 { "errput_logger" }, \
	    1 { "errput_active_demon" }, \
	    2 { "errput_inactive_demon" }, \
	    3 { "errnv_write-1" }, \
	    4 { "errnv_write-2" } \
	}, \
	21 { "bad err_count" $D1 "in" \
	  $HDL, \
	    0 { "errput_active_demon" }, \
	    1 { "errput_inactive_demon" } \
	}, \
	22 { "errduptstart, wpar:" $D1 }, \
	23 { "errinttimer, wpar:" $D1 }, \
	24 { "errduptstop, wpar:" $D1 }, \
	25 { "errduptstart_initial, wpar:" $D1 }, \
        \* { `ERRLG: unknown trace mode $HDU` }
1D2 1.0 DUMP {{ $errno = $HDL }} {{ $mmdev = X2 }} {{ $cmd = X2 }} \
{{ \
dumpop1D2(op) \
        $op, \
        1 "DUMPINIT", \
        2 "DUMPSTART", \
        3 "DUMPWRITE", \
        4 "DUMPEND", \
        5 "DUMPTERM", \
        6 "DUMPQUERY", \
        \* { `dumpop: op=$op` } \
}} \
{{ \
dmpioctl1D2(cmd) \
        $cmd, \
        0x6401 "DMPSET_PRIM", \
        0x6402 "DMPSET_SEC", \
        0x6404 "DMPNOW_PRIM", \
        0x6405 "DMPNOW_SEC", \
        \*     { `dmpioctl: cmd=$cmd` } \
}} \
        $HDU%D1, \
        1  { dmpopen: $errno%E1 devtoname($D1) }, \
        3  { dmpioctl: $errno%E1 devtoname($D1) dmpioctl1D2($cmd) }, \
        4  { dmpdump: dumpop1D2($HDL) devtoname($D1) }, \
        5  { dmpadd: calling func is approxlookup($D1) }, \
        6  { dmpadd: return: $errno%E1 }, \
        7  { dmpdel: calling func is approxlookup($D1) }, \
        8  { dmpdel: $errno%E1 }, \
        9  { dmp_do: $HDL, 1 PRIMARY, 2 SECONDARY }, \
        10 { dmp_do: return:$errno%E1 }, \
        11 { dmpwrcdt: ptr=$D1 length=D2 }, \
        13 { dump_op: return: $errno%E1 }, \
        14 { dmpnull:  dumpop1D2($HDL) }, \
        15 { dmpfile:  dumpop1D2($HDL) }, \
        \* { `DUMP: unknown trace mode $HDU` }
1D9 1.0 "@VMM_ZERO "  \
	$HD, \
	0x0000 { `VMM ZERO_0: Page Zero request page=$D2 sid=$D1`}, \
	0x0001 { `VMM ZERO_1: Page Zero request page=$D2 sid=$D1`}
1DA 1.0 "@VMM_MKP "  \
        `VMM MKP: Page Create  sidx=$D1 Page=$D2 sid=$D3`
1DB 1.0 "@VMM_FPGIN "  \
        `VMM FPGIN: Page in for a persistent seg. Page=$D2 sidx=$D1`
1DC 1.0 "@VMM_SPACEOK" \
        $HD, \
        0 { `VMM spaceok: Activating LRU               CPU=$D1 MEMPOOL=$D2` }, \
	1 { `VMM spaceok: Inserting thread on waitlist CPU=$D1 MEMPOOL=$D2 FREEWTS=$D3` }, \
	2 { `VMM spaceok: PSM free threshold   memp=$D1 numfrb=$D2` }, \
	3 { `VMM spaceok: LRU request  mp=$D1 psx=$D2 req=$D3 nfrb=$D4 newfr=$D5` }, \
	4 { `VMM spaceok: LRU fstats ` vmmsibits($D1) `maxcl=$D2 numcl=$D3 maxpm=$D4 numpm=$D5` }
1DD 1.0 "@VMM_LRU" \
{{ \
lru_start_unmunge(munge) \
        $munge & 0xC0000007, \
        \* { \
                " " \
                BITFLAGS $munge, \
                & 0x80000000 0x80000000 "CFBLRU", \
                & 0x80000000 0x00000000 "LFBLRU", \
                0x40000000 "file-only", \
                0x20000000 "progress guaranteed", \
                & 0x00000007 0x00000000 "(mode 0: default)", \
                & 0x00000007 0x00000001 "(mode 1: strict maxperm)", \
                & 0x00000007 0x00000002 "(mode 2: client only)", \
                & 0x00000007 0x00000003 "(mode 3: client/compress)", \
                & 0x00000007 0x00000004 "(mode 4: WLM red)", \
                & 0x00000007 0x00000005 "(mode 5: unknown)", \
                & 0x00000007 0x00000006 "(mode 6: unknown)", \
                & 0x00000007 0x00000007 "(mode 7: unknown)" \
        } \
}} \
        $HD, \
        0x0  { `VMM LRU: Pager start        memp=$D1 psx=$D2 lru_rq=$D3 `lru_start_unmunge($D4)` lru_goal=$D5` }, \
        0x1  { `VMM LRU: Pager end          memp=$D1 scans=$D2 steals=$D3 numfrb=$D4` }, \
        0x2  { `VMM LRU: Main Loop          memp=$D1 scans=$D2 pass=$D5 stolen $D3/$D4` }, \
        0x3  { `VMM LRU: Page steals        memp=$D1 steals=$D2 nfr=$D3 sid=$D4 page=$D5` }, \
        0x4  { `VMM LRU: Move P2 to P1 CCB  memp=$D1 scans=$D2 ccb=$D3 listidx=$D4` }, \
        0x5  { `VMM LRU TIMER: Start        Memp=$D1 Timer=$D2 Msec=$D3 Flags=$D4` }, \
        0x6  { `VMM LRU TIMER: Stop         Memp=$D1 Timer=$D2` }, \
        0x7  { `VMM LRU TIMER: Ipoll        Memp=$D1 ISoftpri=$D2` }, \
        0x8  { `VMM LRU TIMER: Timeout      Memp=$D1 Timer=$D2` }, \
        0x9  { `VMM LRU DLA TIMER: Start    Memp=$D1 psx=$D2 Timer=$D3 msec=$D4 Flags=$D5` }, \
        0xA  { `VMM LRU DLA TIMER: Stop     Memp=$D1 psx=$D2 Timer=$D3` }, \
        0xB  { `VMM LRU DLA TIMER: Timeout  Memp=$D1 psx=$D2 Timer=$D3` }, \
        0xC  { `VMM LRU DLA TIMER: Done     Memp=$D1 psx=$D2 Timer=$D3` }, \
	0xD  { `VMM LRU: No Work            memp=$D1 numfrb=$D2 goal=$D3` }, \
	0xE  { `VMM LRU: MPSS success       memp=$D1 numfrb=$D2 goal=$D3 steals=$D4` }, \
	0xF  { `VMM LRU: MPSS reenter LRU   memp=$D1 numfrb=$D2 goal=$D3 steals=$D4 MPSS_time=$D5` }, \
	0x10  { `VMM LRU: Pager start2       maxcl=$D1 numcl=$D2 maxpm=$D3 numpm=$D4 minpm=$D5` }
1F0 1.0 "@SETTIMER SYSTEM CALL" \
        settimer timer_type=$D1
1F2 1.0 L=SVC "@GETPROC RELATED SYSTEM CALL" \
        $HD, \
        0x01 { `getprocs:   Invalid argument received by getprocs or getprocs64. ` \n \
               `            Arguments received: ` \n \
               `                  procsinfo=0x$D1%XW sizproc=$D2%D4 ` \n \
               `                  fdsinfo=0x$D3%XW sizfd=$D4%D4 count=$D5%D4` }, \
        0x02 { `getprocs:         Valid sizproc: $D1%D4 $D2%D4 $D3%D4 $D4%D4 $D5%D4` },\
        0x03 { `getprocs64:       Valid sizproc: $D1%D4 $D2%D4 $D3%D4 `},\
        0x04 { `getprocs:         Valid sizfd: $D1%D4 $D2%D4 $D3%D4` }, \
        0x05 { `getprocs64:       Valid sizfd: $D1%D4 $D2%D4 ` }, \
        \*   { getprocs unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 }
200 1.2 "@RESUME" {{ $procflg = $HD }} {{ $e = $EXECPATH }} \
    resume($procflg) \
    $PLATFORMTYPE, \
    0 { \
        $procflg, \
        0  { $PRI, 7F { "resume  IDLE" "iar="$D1 "cpuid="$CPUID }, \
	   \* { `resume  $EXECPATH iar=$D1 cpuid=$CPUID` } }, \
        \* { L=INT `resume interrupt process   iar=$D1 cpuid=$CPUID` } \
      }, \
    1 { \
        $procflg, \
	0  { $PRI, 7F { "resume  IDLE" "ip="$D1 "cpuid="$CPUID }, \
	   \* { `resume  $EXECPATH ip=$D1 cpuid=$CPUID` } }, \
	\* { L=INT `resume interrupt process ip=$D1 cpuid=$CPUID` } \
      }
201 1.1 L=KERN @KERN_HFT W2 \
	$HOOKENV,\
	'64' { O4 }\
	A25 "devno "  \
	$HOOKENV,\
	'64' { O4 }\
	A5 \n \t\t\t " channel " A3 \n
202 1.1 L=KERN @KERN_KTSM W2 \
	$HOOKENV,\
	'64' { O4 }\
	A25 "minor_number " \
	$HOOKENV,\
	'64' { O4 }\
	A5 \n
204 1.0 L=KERN "@SWAPPER swapin process" \
	"sched swapin:   pid="prKernelPID($D1)  "thrashing="$D2%DW
205 1.0 L=KERN "@SWAPPER swapout process" \
	"sched swapout:   pid="prKernelPID($D1)  "tid=" prKernelTID($D2)  "p_suspended="$D3%DW \
	"n_active="$D4%DW  "v_min_process="$D5%DW
206 1.0 L=KERN "@SWAPPER post process for suspension" \
	"sched post:   pid=" prKernelPID($D1)  "p_repage="$D2%DW  \
        "v_proc_repage="$D3%DW  "u_minflt="$D4%DW  "u_majflt="$D5%DW
207 1.0 L=KERN "@SWAPPER sched stats" \
	"sched sys stats:   thrashing="$D1%DW  \
	"v_repage_hi="$D2%DW  "pgflts="$D3%DW  "pgstls="$D4%DW
208 1.0 L=KERN "@SWAPPER process stats" \
	"sched proc stats:   nrun="$D1%DW  "nsusp="$D2%DW  \
	"npageio="$D3%DW  "nevents="$D4%DW  "nstarting=" $D5%DW
209 1.0 L=KERN "@SWAPPER sched stats" \
	"sched sys stats:   pageins="$D1%DW  \
	"pageouts="$D2%DW  "pgspgins=" $D3%DW \
	"pgspgouts="$D4%DW
20A 1.0 L=KERN "@MEMORY SCRUBBING disable" \
	"scrub disable"
20B 1.0 L=KERN "@MEMORY SCRUBBING enable" \
	"scrub enable"
20C 1.0 L=KERN "@MEMORY SCRUBBING choose segment of memory" \
	"scrub memory:   start="$D1 "end="$D2
20D 1.0 L=KERN "@MEMORY SCRUBBING report single bit errors" \
	"scrub report:   sbssr="$D1  "sbsr="$D2  "sbar="$D3
20E 1.0 L=KERN "@LOCKL locks a conventional process lock" \
	"lockl		lock addr=" $D1 "lock val=" $D2%DW \
	"tid=" prKernelTID($D3) "return addr=" $D4 "flags=" $D5
20F 1.0 L=KERN "@UNLOCKL unlocks a conventional process lock" \
	"unlockl		lock addr=" $D1 "lock val=" $D2%DW \
	"tid=" prKernelTID($D3) "return addr=" $D4
210 1.0 L=KERN "@initp" W2 \
	$D1, \
	0 {	 {{ $pid = X8 }} \
                 {{ $tid = X8 }} \
		 {{ $ppid = $PID }} \
		 {{ $string = A40 }} \
		 {{ $vpid = X8 }} \
		 {{ $vtid = X8 }} \
		 {{ $cid = X4 }} \
		 "initp: pid="prpid($pid) "tid="prpid($tid) \
		 "name="$string "vpid=" prpid($vpid) "vtid="prpid($vtid) "cid=" $cid%D4 \
		 pidinstall($pid,$ppid,$string,$tid,0xff,0xff) \
		 cidinstall($tid, $cid, $vpid, $vtid, 0, 0) }
220 1.0 "FDDD" \
        $DD1
221 1.0 "SCDISKDD" \
        $HDU, \
        0x0F { strategy: bp=$D2 b_flags=$D3 b_blkno=$D4 b_bcount=$D5 starttimer(0x221,$D2) }, \
        0x1E { `coalesce: (bp,sc_bp)=($D2,$D3)` }, \
        0x1F { iodone: devtoname($D1) bp=$D2 buftofilename($D2) \
               bflags($D3) endtimer(0x221,$D2) }, \
        0x17 { $D2, 0 { $SKIP } \
                bstart: devtoname($D1) bp=$D2 buftofilename($D2) \
                        pblock=$D4 bcount=$D5 bflags($D3) }, \
        0x18 { $D5, 0 { $SKIP } \
                bstart_exit: devtoname($D1) scsi_buf=$D2 bp=$D3 \
                        scsi_op_code=$D4 scsi_len=$D5 }, \
        0xc8 { mpioSuperInit: mpio_ptr=$D1 $D2 $D3 $D4}, \
        0xc9 { mpioInit: mpio_ptr=$D1 $D2}, \
        0xca { mpioAddDriver: mpio_ptr=$D1 $D2}, \
        0xcb { mpioAddDrvrPath: ddi=$D1 $D2 $D3}, \
        0xcc { mpioAddPcm: ddi=$D1 pcm_entrypt=$D2}, \
        0xcd { mpioDelPcm: ddi=$D1}, \
        0xce { mpioAddDevice: $D1 $D2}, \
        0xd0 { mpioDelDevice: mpio_ptr=$D1}, \
        0xd3 { mpioAddPath: mpio_ptr=$D1 $D2 $D3}, \
        0xd4 { mpioChgPath: ddi=$D1 }, \
        0xd5 { mpioDelPath: mpio_ptr=$D1 $D2}, \
        0xd6 { mpioSetPathState: ddi=$D1 path_id=$D2 state=$D3}, \
        0xd7 { mpioGetPathState: ddi=$D1 path_id=$D2 state=$D3}, \
        0xd8 { mpioPassThru: mpio_ptr=$D1  $D2 $D3}, \
        0xdd { mpioSelectDumpPath: mpio_ptr=$D1 $D2}, \
        0xdf { mpioTerm: $D1}, \
        0xe4 { mpioHandleBufX: mpio_ptr=$D1 $D2 $D3}, \
        0xe5 { mpioCfg: mpio_ptr=$D1 $D2}, \
        0xe6 { mpioValidatePcm: $D1}, \
        0xe9 { mpioUnregPath: ddi=$D1 $D2}, \
        0xeb { mpioCopyinPvtData: $D1 $D2}, \
        0xee { mpioRegPathStat: mpio_ptr=$D1 $D2}, \
        0xef { mpioDelDriver: ddi=$D1 }, \
        0xf0 { mpioddieRAS: errnoval=$D1 info_ptr=$D2}, \
        0xf1 { mpioeRAS: mpio_ptr=$D1 diskinfo_ras_cb=$D2}, \
        0xf3 { mpioeRASunReg: ddi=$D1 location=$D2}, \
        0xf5 { mpioSetPofState: dev_handle=$D1 state=$D2 }, \
        0xf7 { mpioPathOpenFail: dev_handle=$D1 path_id=$D2 flag=$D3 identifier=$D4 }, \
        \*   { $DD1 }
222 1.0 "BADISKDD" \
        $DD1
223 1.0 "SCSIDD" \
        $DD1
226 1.0 "GIODD" \
        {{ $loc = X1 }} R1 \
        $DD1 \
        $loc, \
        03  {  "chan:" XW \
                } , \
        05  { "uiop:" XW "chan:" XW "ext:" XW \
                } , \
        07  { "uiop:" XW "chan:" XW "ext:" XW \
                } , \
        0B  { "event:" XW "chan:" XW \
                } , \
        11  { "name:" XW "chan:" XW \
                } , \
        21  { "ID:" O1 A4.8     \
                "d1=" XW " d2=" XW " d3=" XW " d4=" XW  \
                }
228 1.0 "SERDASDD" \
        $HDU, \
        0x0F { strategy: bp=$D2 starttimer(0x228,$D2) }, \
        0x1E { `coalesce: (bp,cmd)=($D2,$D3)` }, \
        0x1F { iodone: devtoname($D1) bp=$D2 buftofilename($D2) \
                endtimer(0x228,$D2) }, \
        0x17 { $D2, 0 { $SKIP } \
                bstart: devtoname($D1) bp=$D2 buftofilename($D2) \
                        pblock=$D4 bcount=$D5 bflags($D3) \
        }, \
        \*   { $DD1 }
229 1.0 "TMSCSIDD" \
        $DD1
234 1.0 L=KERN "@CLOCK"    \
    $GENERIC, \
    1 { \
      $D1%D1, \
          1 { "command: " {{ $notused = X4 }} {{ $strlen = $HL - 4 }} {{$string = $HL%S1}} "cmd=" $string }, \
          \* { "Unknown subhook for 0x234: "$HD%D1 } \
    }, \
    0 { \
      $PLATFORMTYPE, \
      0 { \
        {{ $subhookid = $HD & 0xFFF}} \
          $subhookid, \
          10 { "Start/Stop user command"}, \
          \* { W1 "clock:   iar="X8  "lr="X8 } \
          } ,\
      1 { "clock:   ip="$D1  "b0="$D2 } \
    } \
    endtimer(0x234,0x234) starttimer(0x234,0x234)
250 1.0 '' \
 	$HD%D1, \
        1  { "SOCK  (entry) sendit" }, \
        2  { "SOCK  (entry) sosend" }, \
        3  { "SOCK  (entry) put data in send mbufs" }, \
        4  { "SOCK  (entry) main loop data to mbufs" }, \
        5  { `SOCK  (entry) uiomove len=$D1%D1` }, \
        6  { "SOCK  (entry) recvit" }, \
        7  { "SOCK  (entry) soreceive" }, \
        8  { "SOCK  (entry) soreceive while loop" }, \
        9  { "MBUF  (entry) m_pullup bcopy" }, \
        10 { "IP   (entry) looutput" }, \
        11 { "IP   (entry) raw_input" }, \
        12 { "IP   (entry) rip_output" }, \
        13 { "IP   (entry) in_cksum" }, \
        14 { "IP   (entry) in_pcblookup" }, \
        15 { "IP   (entry) ipintr" }, \
        16 { "IP   (entry) reassembly" }, \
        17 { "IP   (entry) ip_output" }, \
        18 { "IP   (entry) fragmentation" }, \
        19 { "TCP  (entry) reassembly" }, \
        20 { "TCP  (entry) tcp_input" }, \
        21 { "TCP  (entry) tcp_output" }, \
        22 { "TCP  (entry) send packet" }, \
        23 { "UDP  (entry) udp_input" }, \
        24 { "UDP  (entry) udp_output" }, \
        25 { "NETIF_EN   (entry) enet: en_output" }, \
        26 { "NETIF_EN  (entry) enet: en_recv" }, \
    	27 { "NETIF_TOK   (entry) token: ie5_output" }, \
        28 { "NETIF_TOK   (entry) token: ie5_recv" }, \
        29 { "NETIF_802.3   (entry) 802.3: ie3_output" }, \
        30 { "NETIF_802.3   (entry) 802.3: ie3_recv" }, \
        31 { "NETIF_X25   (entry) X.25:  xt_output" }, \
        32 { "NETIF_X25   (entry) X.25:  xt_recv" }, \
        33 { "NETIF_SLIP   (entry) slip:  sloutput" }, \
        34 { "NETIF_SLIP   (frame escape) slip:  slinput" }, \
        35 { "NETIF_SER   (entry) Net_Service: find_input_type" }, \
        101  { "SOCK  (rtn)  sendit" }, \
        102  { "SOCK  (rtn)  sosend" }, \
        103  { "SOCK  (rtn)  put data in send mbufs" }, \
        104  { "SOCK  (rtn)  main loop data to mbufs" }, \
        105  { "SOCK  (rtn)  uiomove" }, \
        106  { "SOCK  (rtn)  recvit" }, \
        107  { "SOCK  (rtn)  soreceive" }, \
        108  { "SOCK  (rtn)  soreceive while loop" }, \
        109  { "MBUF  (rtn)  m_pullup bcopy" }, \
        110 { "IP   (rtn)  looutput" }, \
        111 { "IP   (rtn)  raw_input" }, \
        112 { "IP   (rtn)  rip_output" }, \
        113 { "IP   (rtn)  in_cksum" }, \
        114 { "IP   (rtn)  in_pcblookup" }, \
        115 { "IP   (rtn)  ipintr" }, \
        116 { "IP   (rtn)  reassembly" }, \
        117 { "IP   (rtn)  ip_output" }, \
        118 { "IP   (rtn)  fragmentation" }, \
        119 { "TCP  (rtn)  reassembly" }, \
        120 { "TCP  (rtn)  tcp_input" }, \
        121 { "TCP  (rtn)  tcp_output" }, \
        122 { "TCP  (rtn)  send packet" }, \
        123 { "UDP  (rtn)  udp_input" }, \
        124 { "UDP  (rtn)  udp_output" }, \
        125 { "NETIF_EN   (rtn)  enet: en_output" }, \
        126 { "NETIF_EN   (rtn)  enet: en_recv" }, \
        127 { "NETIF_TOK   (rtn)  token: ie5_output" }, \
        128 { "NETIF_TOK   (rtn)  token: ie5_recv" }, \
        129 { "NETIF_802.3   (rtn)  802.3: ie3_output" }, \
        130 { "NETIF_802.3   (rtn)  802.3: ie3_recv" }, \
        131 { "NETIF_X25   (rtn)  X.25:  xt_output" }, \
        132 { "NETIF_X25   (rtn)  X.25:  xt_recv" }, \
        133 { "NETIF_SLIP   (rtn)  slip:  sl_output" }, \
        134 { "NETIF_SLIP   (frame end)  slip:  slinput" }, \
        135 { "NETIF_SER   (rtn) Net_Service: find_input_type" }, \
        \*  { unknown subhook $HD%D1 $ERROR }
251 1.0 'NETERR ' \
 	$HD%D1, \
	0  {`CIO_OK ifp=$D1%XW` }, \
	1  {`CIO_BAD_MICROCODE ifp=$D1%XW` }, \
	2  {`CIO_BUF_OVFLW ifp=$D1%XW` }, \
	3  {`CIO_HARD_FAIL ifp=$D1%XW` }, \
	4  {`CIO_LOST_DATA ifp=$D1%XW` }, \
	5  {`CIO_NOMBUF ifp=$D1%X4` }, \
	6  {`CIO_NOT_STARTED ifp=$D1%W4` }, \
	7  {`CIO_TIMEOUT ifp=$D1%XW` }, \
	8  {`CIO_NET_RCVRY_ENTER ifp=$D1%XW` }, \
	9  {`CIO_NET_RCVRY_EXIT ifp=$D1%XW` }, \
	10 {`CIO_NET_RCVRY_MODE ifp=$D1%XW` }, \
	11 {`CIO_INV_CMD ifp=$D1%XW` }, \
	12 {`CIO_BAD_RANGE ifp=$D1%XW` }, \
	13 {`CIO_NETID_INV ifp=$D1%XW` }, \
	14 {`CIO_NETID_DUP ifp=$D1%XW` }, \
	15 {`CIO_NETID_FULL ifp=$D1%XW` }, \
	65 {`XT_BAD_CALL_ID ifp=$D1%XW` }, \
	66 {`XT_CLEAR ifp=$D1%XW` }, \
	67 {`XT_INV_CTR ifp=$D1%XW` }, \
	68 {`XT_NAME_USED ifp=$D1%XW` }, \
	69 {`XT_NOT_PVC ifp=$D1%XW` }, \
	70 {`XT_NO_ACK ifp=$D1%XW` }, \
	71 {`XT_NO_ACK_REQ ifp=$D1%XW` }, \
	72 {`XT_NO_LINK ifp=$D1%XW` }, \
	73 {`XT_NO_NAME ifp=$D1%XW` }, \
	74 {`XT_PROTOCOL ifp=$D1%XW` }, \
	75 {`XT_PVC_USED ifp=$D1%XW` }, \
	76 {`XT_RESET ifp=$D1%XW` }, \
	77 {`XT_TABLE ifp=$D1%XW` }, \
	78 {`XT_TOO_MANY_VCS ifp=$D1%XW` }, \
	79 {`XT_AUTH_LISTEN ifp=$D1%XW` }, \
	80 {`XT_BAD_PKT_TYPE ifp=$D1%XW` }, \
	81 {`XT_BAD_SESSION_TYPE ifp=$D1%XW` }, \
	100 {`invalid xmit complete intr ifp=$D1%XW` }, \
	101 {`find_arp_iftype() fail ifp=$D1%XW` }, \
	102 {`if_detach() fail ifp=$D1%XW` }, \
	103 {`find_input_type() fail ifp=$D1%XW` }, \
	104 {`no mbufs ifp=$D1%XW` }, \
	105 {`if not running ifp=$D1%XW` }, \
	106 {`clear indication ifp=$D1%XW` }, \
	107 {`unknown packet type ifp=$D1%XW` }, \
	108 {`NET_XMIT_FAIL ifp=$D1%XW` }, \
	109 {`NET_DETACH_FAIL ifp=$D1%XW` }, \
	110 {`ARP, wrong header ifp=$D1%XW` }, \
	111 {`ARP, unknown protocol ifp=$D1%XW` }, \
	112 {`ARP, ip broadcast address ifp=$D1%XW` }, \
	113 {`ARP, duplicate address ifp=$D1%XW` }, \
	114 {`ARP, arp table full ifp=$D1%XW` }, \
	115 { `slinput overrun error` }, \
 	116 { `slinput parity/framing error` }, \
 	117 { `slinput no frame escape/end` }, \
 	118 { `slinput slbtom rtn NULL` }, \
 	119 { `slinput ilen>slmtu` }, \
 	120 { `pdu_max < mtu+8, pdu_max=$D1%DW mtu=$D2%DW` }, \
 	122 { `ie5_arpinput no arp` }, \
 	123 { `ie5_arpinput no route` }, \
 	124 { `ie5_arpinput largest_frame(mac)=$D1%XW` }, \
 	125 { `ie5_arpinput has_route(&hdrp->ie5_mac)=$D1%XW, at->at_rcf=$D2%XW, route_bytes(&hdrp->ie5_mac)=$D3%XW` }, \
 	126 { `ie5_arpinput proto=$D1%XW` }, \
 	127 { `ie5_arpinput tat=$D1%XW, tat->at_flags=$D2%XW` }, \
 	128 { `ie5_arpinput m_gethdr(M_DONTWAIT, MT_DATA)) == NULL` }, \
        \*  { unknown subhook $HD%D1 $ERROR }
252 1.0 L=SVC "SOCK" \
{{ \
sodomain(qqq) \
	$qqq%D1, \
	0   AF_UNSPEC, \
	1   AF_UNIX, \
	2   AF_INET, \
	3   AF_IMPLINK, \
	4   AF_PUP, \
	5   AF_CHAOS, \
	6   AF_NS, \
	7   AF_ISO, \
	8   AF_ECMA, \
	9   AF_DATAKIT, \
	10  AF_CCITT, \
	11  AF_SNA, \
	12  AF_DECnet, \
	13  AF_DLI, \
	14  AF_LAT, \
	15  AF_HYLINK, \
	16  AF_APPLETALK, \
	17  AF_ROUTE, \
	18  AF_LINK, \
	19  AF_XTP, \
	20  AF_INTF, \
	21  AF_RIF, \
	22  AF_NETWARE, \
	23  AF_NDD, \
	24  AF_INET6, \
	40  AF_MAX,  \
	\*  {$qqq%D1} \
}} \
{{ \
sotype(rrr) \
	$rrr%D1, \
	1   SOCK_STREAM, \
	2   SOCK_DGRAM, \
	3   SOCK_RAW, \
	4   SOCK_RDM, \
	5   SOCK_SEQPACKET, \
	6   SOCK_CONN_DGRAM, \
	\*  {$rrr%D1} \
}} \
{{ \
soproto(sss) \
	$sss%D2, \
	0   IPPROTO_IP, \
	1   IPPROTO_ICMP, \
	2   IPPROTO_IGMP, \
	3   IPPROTO_GGP, \
	4   IPPROTO_IPIP, \
	6   IPPROTO_TCP, \
	8   IPPROTO_EGP, \
	12  IPPROTO_PUP, \
	17  IPPROTO_UDP, \
	22  IPPROTO_IDP, \
	29  IPPROTO_TP, \
	41  IPPROTO_IPV6, \
	43  IPPROTO_ROUTING, \
	45  IPPROTO_QOS, \
	58  IPPROTO_ICMPV6, \
	62  IPPROTO_MH, \
	80  IPPROTO_EON, \
	255 IPPROTO_RAW, \
	256 IPPROTO_MAX, \
	\*  {$sss%D2} \
}} \
{{ \
soflag(uuu) \
	$uuu%XW, \
	0x1   MSG_OOB, \
	0x2   MSG_PEEK, \
	0x4   MSG_DONTROUTE, \
	0x8   MSG_EOR, \
	0x10  MSG_TRUNC, \
	0x20  MSG_CTRUNC, \
	0x40  MSG_WATTALL, \
	\*  {$uuu%XW} \
}} \
{{ \
sohow(vvv) \
	$vvv%D1, \
	0   DISABLE_RECV, \
	1   DISABLE_SEND, \
	2   DISABLE_RECV&SEND, \
	\*  {$vvv%D1} \
}} \
{{ \
soopt(www) \
	$www%XW, \
	0x0001   SO_DEBUG,\
	0x0002   SO_ACCEPTCONN, \
	0x0004   SO_REUSEADDR, \
	0x0008   SO_KEEPALIVE, \
	0x0010   SO_DONTROUTE, \
	0x0020   SO_BROADCAST, \
	0x0040   SO_USELOOPBACK, \
	0x0080   SO_LINGER, \
	0x0100   SO_OOBINLINE, \
	0x1001   SO_SNDBUF, \
	0x1002   SO_RCVBUF, \
	0x1003   SO_SNDLOWAT, \
	0x1004   SO_RCVLOWAT, \
	0x1005   SO_SNDTIMEO, \
	0x1006   SO_RCVTIMEO, \
	0x1007   SO_ERROR, \
	0x1008   SO_TYPE, \
	\*  {$www%XW} \
}} \
{{ \
sin6addr(addr1, addr2) \
        {{ $addr1 }} {{ $addr2 }} \
        {{ $a1 = $addr1%W48.63 }} \
        {{ $a2 = $addr1%W32.47 }} \
        {{ $a3 = $addr1%W16.31 }} \
        {{ $a4 = $addr1%W0.15 }} \
        {{ $a5 = $addr2%W48.63 }} \
        {{ $a6 = $addr2%W32.47 }} \
        {{ $a7 = $addr2%W16.31 }} \
        {{ $a8 = $addr2%W0.15 }} \
        `$a1:$a2:$a3:$a4:$a5:$a6:$a7:$a8` \
}} \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
 	1   { `accept sofd=$D1%DW name=$D2%XW namelen=$D3%DW` }, \
 	2   { `return from accept s=$D1%DW error=$D2%DW` }, \
 	3   { `bind sofd=$D1%DW name=$D2%XW namelen=$D3%DW` }, \
	4   { `return from bind error=$D1%DW so=$D2%XW nam=$D3%XW` }, \
 	5   { `connect sofd=$D1%DW name=$D2%XW namelen=$D3%DW` }, \
	6   { `return from connect error=$D1%DW so=$D2%XW` }, \
 	7   { `getkerninfo op=$D1%DW uap_where=$D2%XW uap_size=$D3%DW =$D4%XW` }, \
	8   { `return from getkerninfo error=$D1%DW` }, \
 	9   { `getpeername sofd=$D1%DW name=$D2%XW namelen=$D3%DW` }, \
 	10  { `return from getpeername so=$D1%XW error=$D2%DW` }, \
 	11  { `getsockname sofd=$D1%DW name=$D2%XW namelen=$D3%DW` }, \
 	12  { `return from getsockname so=$D1%XW error=$D2%DW` }, \
 	13  { `getsockopt sofd=$D1%DW level=$D2%DW ` optname=soopt($D3) `optvalue=$D4%D1 optlen=$D5%DW` }, \
 	14  { `return from getsockopt sofd=$D1%DW error=$D2%DW` }, \
 	15  { `listen sofd=$D1%DW backlog=$D2%DW` }, \
 	16  { `return from listen sofd=$D1%DW error=$D2%DW` }, \
 	17  { `recv sofd=$D1%DW buf=$D2%XW buflen=$D3%DW ` flag=soflag($D4) }, \
 	18  { `return from recv sofd=$D1%DW error=$D2%DW len=$D3%DW` }, \
 	19  { `recvfrom sofd=$D1%DW buf=$D2%XW buflen=$D3%DW ` flag=soflag($D4) `from=$D5%XW` }, \
 	20  { `return from recvfrom sofd=$D1%DW error=$D2%DW` }, \
 	21  { `recvit sofd=$D1%DW mp=$D2%XW namelenp=$D3%XW` }, \
 	22  { `return from recvit sofd=$D1%DW error=$D2%DW` }, \
 	23  { `return from recmsg sofd=$D1%DW error=$D2%DW` }, \
 	24  { `recvmsg sofd=$D1%DW mesg=$D2%XW ` flag=soflag($D3) }, \
 	25  { `return from recmsg sofd=$D1%DW error=$D2%DW len=$D3%DW` }, \
 	26  { `rmsock so=$D1%XW` }, \
 	27  { `return from rmsock error=$D1%DW` }, \
 	28  { `sbwakeup so=$D1%XW sb=$D2%XW what=$D3%DW` }, \
 	29  { `return from sbwakeup so=$D1%XW sb=$D2%XW state=$D3%DW` }, \
 	30  { `send sofd=$D1%DW mesg=$D2%XW len=$D3%DW ` flag=soflag($D4) }, \
 	31  { `return from send sofd=$D1%DW error=$D2%DW` }, \
 	32  { `sendfile so_p=$D1%XW mesg=$D2%XW flag=$D3%XW` }, \
 	33  { `return from sendfile sofd=$D1%DW error=$D2%DW` }, \
 	34  { `sendit sofd=$D1%DW mesg=$D2%XW ` flag=soflag($D3) }, \
 	35  { `return from sendit sofd=$D1%DW error=$D2%DW` }, \
 	36  { `sendmsg sofd=$D1%DW mesg=$D2%XW ` flag=soflag($D3) }, \
 	37  { `return from sendmsg sofd=$D1%DW error=$D2%DW` }, \
 	38  { `sendto sofd=$D1%DW mesg=$D2%XW len=$D3%DW ` flag=soflag($D4) `to=$D5%XW ` }, \
 	39  { `setsockopt sofd=$D1%DW level=$D2%DW ` optname=soopt($D3) `optvalue=$D4%D1 optlen=$D5%DW` }, \
 	40  { `return from setsockopt sofd=$D1%DW error=$D2%DW` }, \
 	41  { `shutdown sofd=$D1%DW ` how=sohow($D2) }, \
 	42  { `return from shutdown sofd=$D1%DW error=$D3%DW` }, \
 	43  { `soabort so=$D1%XW` }, \
 	44  { `return from soabort so=$D1%XW error=$D2%DW` }, \
 	45  { `soaccept so=$D1%XW nam=$D2%XW` }, \
 	46  { `return from soaccept so=$D1%XW error=$D2%DW` }, \
 	47  { `soaccessfailure so=$D1%XW` }, \
 	48  { `return from soaccessfailure so=$D1%XW` }, \
 	49  { `sobind so=$D1%XW nam=$D2%XW` }, \
 	50  { `return from sobind so=$D1%XW error=$D2%DW` }, \
 	51  { `sockargs mp=$D1%XW buf=$D2%XW buflen=$D3%DW type=$D4%DW` }, \
 	52  { `return from sockargs error=$D1%DW` }, \
	53  { `socket_aio_dequeue` }, \
	54  { `return from socket_aio_dequeue error=$D1%D1 value=$D2%DW` }, \
 	55  { `socket ` dom=sodomain($D1) type=sotype($D2) proto=soproto($D3) }, \
	56  { `return from socket sofd=$D1%D1, soaddr=$D2%XW` \
		lookuppninstall1('SOCKET') \
		lookuppninstall2($D2) fdinstall($D1)  }, \
	57  { `return from socketpair error=$D1%D1` }, \
 	58  { `socketpair ` dom=sodomain($D1) type=sotype($D2) proto=soproto($D3) `socktvect=$D4%XW ` }, \
	59  { `return from socketpair sofd1=$D1%D1, sofd2=$D2%D1, soaddr1=$D3%X4, soaddr2=$D4%X4 error=$D5%DW` \
		 lookuppninstall1('SOCKET') \
		 lookuppninstall2($D3) fdinstall($D1) \
		 lookuppninstall2($D4) fdinstall($D2) }, \
 	60  { `socksetup fdp=$D1%XW fpp=$D2%XW` }, \
	61  { `return from socksetup error=$D1%D1` }, \
 	62  { `soclose so=$D1%XW` }, \
 	63  { `return from soclose so=$D1%XW error=$D2%DW` }, \
 	64  { `soconnect2 so1=$D1%XW so2=$D2%XW` }, \
 	65  { `return from soconnect2 so1=$D1%XW so2=$D2%XW error=$D3%DW` }, \
 	66  { `soconnect so=$D1%XW nam=$D2%XW` }, \
 	67  { `return from soconnect so=$D1%XW error=$D2%DW` }, \
 	68  { `return from socreate ` dom=sodomain($D1) type=sotype($D2) proto=soproto($D3) `error=$D4%DW` }, \
 	69  { `socreate ` dom=sodomain($D1) `soaddr=$D2%XW` type=sotype($D3) proto=soproto($D4) }, \
 	70  { `return from socreate so=$D1%XW error=$D2%DW` }, \
 	71  { `return from socreategroup ` dom=sodomain($D1) type=sotype($D2) proto=soproto($D3) `error=$D4%DW` }, \
 	72  { `socreategroup ` dom=sodomain($D1) `soaddr=$D2%XW` type=sotype($D3) proto=soproto($D4) `num=$D5%DW` }, \
 	73  { `return from socreategroup so=$D1%XW` }, \
 	74  { `sodisconn so=$D1%XW` }, \
 	75  { `return from sodisconn so=$D1%XW error=$D2%DW` }, \
 	76  { `sodisconnect so=$D1%XW` }, \
 	77  { `return from sodisconnect so=$D1%XW error=$D2%DW` }, \
 	78  { `return from sofree so=$D1%XW error=$D2%DW` }, \
 	79  { `sofree so=$D1%XW` }, \
 	80  { `return from sofree so=$D1%XW` }, \
 	81  { `sogetopt soaddr=$D1%XW level=$D2%D1 ` optname=soopt($D3) `m0=$D4%XW` }, \
 	82  { `return from sogetopt so=$D1%XW error=$D2%DW` }, \
 	83  { `sohasoutofband so=$D1%XW` }, \
 	84  { `return from sohasoutofband so=$D1%XW` }, \
 	85  { `soisconnected so=$D1%XW` }, \
 	86  { `return from soisconnected so=$D1%XW` }, \
 	87  { `soisdisconnected so=$D1%XW` }, \
 	88  { `return from soisdisconnected so=$D1%XW` }, \
 	89  { `solisten so=$D1%XW backlog=$D2%DW` }, \
 	90  { `return from solisten so=$D1%XW error=$D2%DW` }, \
 	91  { `sonewsock head=$D1%XW connstatus=$D2%DW` }, \
 	92  { `return from sonewsock so=$D1%XW` }, \
 	93  { `soo_close fp=$D1%XW so=$D2%XW` }, \
 	94  { `soo_close fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	95  { `soo_ioctl fp=$D1%XW so=$D2%XW cmd=$D3%XW udatap=$D4%XW` }, \
 	96  { `return from soo_ioctl fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	97  { `soo_read fp=$D1%XW so=$D2%XW uio=$D3%XW cread=$D4%XW` }, \
 	98  { `return from soo_read fp=$D1%XW error=$D2%DW` }, \
 	99  { `soo_select fp=$D1%XW so=$D2%XW corl=$D3%DW reqevents=$D4%XW rtneventsp=$D5%XW` }, \
 	100 { `return from soo_select fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	101 { `soo_stat fp=$D1%XW so=$D2%XW ub=$D3%XW` }, \
 	102 { `return from soo_stat fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	103 { `soo_write fp=$D1%XW so=$D2%XW uio=$D3%XW cread=$D4%XW` }, \
 	104 { `return from soo_write fp=$D1%XW error=$D2%DW` }, \
 	105 { `soreceive soaddr=$D1%XW paddr=$D2%XW uio=$D3%XW mpo=$D4%XW contrl=$D5%XW` }, \
 	106 { `return from soreceive soaddr=$D1%XW error=$D2%D1` dom=sodomain($D3) ` ` proto=soproto($D4) ` ` type=sotype($D5) ` ` }, \
 	107 { `soreserve soaddr=$D1%XW sndcc=$D2%XW rcvcc=$D3%XW` }, \
 	108 { `return from soreserve soaddr=$D1%XW error=$D2%D1` }, \
 	109 { `soflush soaddr=$D1%XW` }, \
 	110 { `return from soflush soaddr=$D1%XW` }, \
 	111 { `sosbwait sockbuf=$D1%XW soaddr=$D2%XW` }, \
 	112 { `return from sosbwait sockbuf=$D1%XW soaddr=$D2%XW error=$D3%DW` }, \
 	113 { `sosend soaddr=$D1%XW addr=$D2%XW uio=$D3%XW top=$D4%XW control=$D5%XW` }, \
 	114 { `return from sosend so=$D1%XW error=$D2%D1 ` dom=sodomain($D3) ` ` proto=soproto($D4) ` ` type=sotype($D5) ` ` }, \
 	115 { `sosetopt soaddr=$D1%XW level=$D2%D1` optname=soopt($D3) `m0=$D4%XW` }, \
 	116 { `return from sosetopt so=$D1%XW error=$D2%D1` }, \
 	117 { `soshutdown soaddr=$D1%XW ` how=sohow($D2) }, \
 	118 { `return from soshutdown soaddr=$D1%XW error=$D2%DW` }, \
 	119 { `sosleep soaddr=$D1%XW addr=$D2%XW pri=$D3%XW tmo=$D4%XW` }, \
        120 { `return from sosleep soaddr=$D1%XW error=$D2%DW` }, \
        121 { `sosplice so1=$D1%XW so2=$D2%XW flags=$D3%XW` }, \
        122 { `return from sosplice so1=$D1%XW so2=$D2%XW error=$D3%DW` }, \
 	123 { `sowakeup so=$D1%XW sb=$D2%XW` }, \
 	124 { `return from sowakeup so=$D1%XW sb=$D2%XW` }, \
 	125 { `splice s1=$D1%DW s2=$D2%DW flags=$D3%XW` }, \
 	126 { `return from splice error=$D1%DW` }, \
 	127 { "gethostid"  }, \
 	128 { `sethostid hostid=$D1%XW` }, \
 	129 { `gethostname name=$D1%XW namelen=$D2%DW` }, \
 	130 { `sethostname name=$D1%XW namelen=$D2%DW` }, \
        131 { `getdomainname name=$D1%XW namelen=$D2%DW` }, \
 	132 { `setdomainname name=$D1%XW namelen=$D2%DW` }, \
	133 { `return from getdomainname domainname=$D1%XW outdomainname=$D2%XW namelen=$D3%DW` }, \
        136 { `ksodebug s=$D1%DW so=$D2%XW trclev=$D3%DW` }, \
        137 { `return from ksodebug s=$D1%DW so=$D2%XW, error=$D3%DW` }, \
 	138 { `sbwakeup lmt  so=$D1%XW sb=$D2%XW state=$D3%DW what=$D4%DW` }, \
 	140 { `socreate error1 dom=$D1%DW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	141 { `socreate error2 dom=$D1%DW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	142 { `socreate error3 dom=$D1%DW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	143 { `socreate error4 dom=$D1%DW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	144 { `socreate error5 dom=$D1%DW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	145 { `socreate error6 dom=$D1%DW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	146 { `socreate error7 so=$D1%XW error=$D2%DW` }, \
 	147 { `socreate error8 so=$D1%XW error=$D2%DW` }, \
 	148 { `socreate error9 so=$D1%XW error=$D2%DW` }, \
 	149 { `socreate error10 so=$D1%XW error=$D2%DW` }, \
 	150 { `socreate error11 dom=$D1%DW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	151 { `soclose2 error1 so=$D1%XW error=$D2%DW` }, \
 	152 { `soclose2 error2 so=$D1%XW error=$D2%DW` }, \
 	153 { `soconnect error1 so=$D1%XW error=$D2%DW` }, \
 	154 { `sosend error1 so=$D1%XW error=$D2%DW dom=$D3%DW proto=$D4%DW type=$D5%DW` }, \
 	155 { `sosend error2 so=$D1%XW error=$D2%DW` }, \
 	156 { `sosend error3 so=$D1%XW error=$D2%DW` }, \
 	157 { `sosend error4 so=$D1%XW error=$D2%DW` }, \
 	158 { `sosend error5 so=$D1%XW error=$D2%DW` }, \
 	159 { `sosend error6 so=$D1%XW error=$D2%DW` }, \
 	160 { `sosend error7 so=$D1%XW error=$D2%DW` }, \
 	161 { `sosend error8 so=$D1%XW error=$D2%DW` }, \
 	162 { `sosend error9 so=$D1%XW clen=$D2%DW error=$D3%DW` }, \
 	163 { `sosend error10 so=$D1%XW error=$D2%DW` }, \
 	164 { `sosend error11 so=$D1%XW atomic=$D2%DW resid=$D3%DW clen=$D4%DW error=$D5%DW` }, \
 	165 { `sosend error12 so=$D1%XW error=$D2%DW` }, \
 	166 { `sokernrecv error1 error=$D1%DW` }, \
 	167 { `sokernrecv error1 so=$D1%XW error=$D2%DW` }, \
 	168 { `sokernrecv MSGWAITALL1 so=$D1%XW error=$D2%DW` }, \
 	169 { `sokernrecv MSGWAITALL2 so=$D1%XW error=$D2%DW` }, \
 	170 { `sosetopt error1 so=$D1%XW error=$D2%DW` }, \
 	171 { `sosetopt error2 so=$D1%XW m=$D2%XW error=$D3%DW` }, \
 	172 { `sosetopt error3 so=$D1%XW m=$D2%XW error=$D3%DW` }, \
 	173 { `sosetopt error4 so=$D1%XW m=$D2%XW error=$D3%DW` }, \
 	174 { `sosetopt error5 so=$D1%XW m=$D2%XW error=$D3%DW` }, \
 	175 { `sosetopt error6 so=$D1%XW m_data=$D2%XW error=$D3%DW` }, \
 	176 { `sosetopt error7 so=$D1%XW m_data=$D2%XW error=$D3%DW` }, \
 	177 { `sosetopt error8 so=$D1%XW error=$D2%DW` }, \
 	178 { `sosetopt error9 so=$D1%XW error=$D2%DW` }, \
 	179 { `sosetopt error10 so=$D1%XW m_len=$D2%XW error=$D3%DW` }, \
 	180 { `sosetopt error11 so=$D1%XW error=$D2%DW` }, \
 	181 { `sosetopt error12 so=$D1%XW error=$D2%DW` }, \
 	182 { `sogetopt error1 so=$D1%XW error=$D2%DW` }, \
 	183 { `sogetopt error2 so=$D1%XW error=$D2%DW` }, \
 	184 { `sodequeue error1 so=$D1%XW error=$D2%DW` }, \
 	185 { `sodequeue error2 so=$D1%XW error=$D2%DW` }, \
 	186 { `sodequeue error3 so=$D1%XW error=$D2%DW` }, \
 	187 { `sodequeue error4 so=$D1%XW error=$D2%DW` }, \
 	188 { `sodequeue error5 so=$D1%XW error=$D2%DW` }, \
 	189 { `sogetaddr error1 so=$D1%XW error=$D2%DW` }, \
 	190 { `sogetaddr error2 so=$D1%XW error=$D2%DW` }, \
 	192 { `socreategroup error2 dom=$D1%XW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	193 { `socreategroup error3 dom=$D1%XW type=$D2%DW proto=$D3%DW error=$D4%DW` }, \
 	194 { `socreategroup error4 so=$D1%XW error=$D2%DW` }, \
 	195 { `sosplice error1 so1=$D1%XW so2=$D2%XW error=$D3%DW` }, \
 	196 { `sosplice error2 so1=$D1%XW so2=$D2%XW error=$D3%DW` }, \
 	197 { `sodisconnectreuse so=$D1%XW` }, \
 	198 { `return from sodisconnectreuse so=$D1%XW` }, \
 	199 { `sonewsock error1 head=$D1%XW connstatus=$D2%DW` }, \
 	200 { `sonewsock error2 head=$D1%XW connstatus=$D2%DW` }, \
 	201 { `sonewsock error3 head=$D1%XW qlen=$D2%DW s0len=$D3%DW qlimit=$D4%DW` }, \
 	202 { `sonewsock error4 head=$D1%XW connstatus=$D2%DW` }, \
 	203 { `sonewsock error5 so=$D1%XW head=$D2%XW` }, \
 	204 { `sonewsock error6 so=$D1%XW head=$D2%XW` }, \
 	205 { `sonewsock error7 so=$D1%XW head=$D2%XW` }, \
 	206 { `sosbwait	error1 sb=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	207 { `soqaio error1 so=$D1%XW so_state=$D2%XW q_head=$D3%DW` }, \
 	208 { `soqaio error2 so=$D1%XW so_state=$D2%XW q_head=$D3%DW` }, \
 	209 { `soreserve error1 so=$D1%XW sndcc=$D2%XW error=$D3%DW` }, \
 	210 { `soreserve error2 so=$D1%XW rcvcc=$D2%XW error=$D3%DW` }, \
 	211 { `sbinsertoob error1 sb=$D1%XW m0=$D2%XW` }, \
 	212 { `sbappendaddr error1 sb=$D1%XW m0=$D2%XW` }, \
 	213 { `sbdrop sb=$D1%XW len=$D2%XW` }, \
 	214 { `return from sbdrop sb=$D1%XW len=$D2%XW` }, \
 	215 { `sbdroprecord sb=$D1%XW` }, \
 	216 { `return from sbdroprecord sb=$D1%XW` }, \
 	217 { `soexit` }, \
 	218 { `return from soexit` }, \
 	219 { `soiskernconnected so=$D1%XW` }, \
 	220 { `return from soiskernconnected so=$D1%XW` }, \
 	221 { `soiskerndisconnected so=$D1%XW` }, \
 	222 { `return from soiskerndisconnected so=$D1%XW` }, \
 	223 { `sndbufpool_dr_cpu_add cpu=$D1%DW` }, \
 	224 { `return from sndbufpool_dr_cpu_add cpu=$D1%DW` }, \
 	225 { `sndbufpool_dr_cpu_remove cpu=$D1%DW` }, \
 	226 { `return from sndbufpool_dr_cpu_remove cpu=$D1%DW` }, \
 	227 { `soo_read error1 fp=$D1%XW error=$D2%DW` }, \
 	229 { `soo_read error2 fp=$D1%XW error=$D2%DW` }, \
 	230 { `soo_ioctl error1 fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	231 { `soo_ioctl error2 fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	232 { `soo_ioctl error3 fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	233 { `soo_ioctl error4 fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	234 { `soo_ioctl error5 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	235 { `soo_ioctl error6 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	236 { `soo_ioctl error7 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	237 { `soo_ioctl error8 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	238 { `soo_ioctl error9 fp=$D1%XW cmd=$D2%DW error=$D3%DW buf=$D4%XW data=$D5%XW` }, \
 	239 { `soo_ioctl error10 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	240 { `soo_ioctl error11 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	241 { `soo_ioctl error12 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	242 { `soo_ioctl error13 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	243 { `soo_ioctl error14 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	244 { `soo_ioctl error15 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	245 { `soo_ioctl error16 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	246 { `soo_ioctl error17 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	247 { `soo_ioctl error18 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	248 { `soo_ioctl error19 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	249 { `soo_ioctl error20 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	250 { `rmsock error1 tmp=$D1%XW size=$D2%DW` }, \
 	251 { `rmsock error2 error=$D2%DW` }, \
 	252 { `connect error1 tmp=$D1%XW namelen=$D2%DW name=$D3%XW error=$D4%DW` }, \
 	253 { `connext error1 tmp=$D1%XW namelen=$D2%DW name=$D3%XW error=$D4%DW` }, \
 	254 { `socket error1 fd=$D1%XW fp=$D2%XW error=$D3%DW` }, \
 	255 { `bind error1 tmp=$D1%XW namelen=$D2%DW name=$D3%XW error=$D4%DW` }, \
 	256 { `bind error2 s=$D1%XW error=$D2%DW fp=$D3%XW` }, \
 	257 { `bind error3 s=$D1%XW error=$D2%DW` }, \
 	258 { `accept error1 tmp=$D1%XW size=$D2%DW namelen=$D3%XW error=$D4%DW` }, \
 	259 { `accept error2 s=$D1%XW namelen=$D2%XW len=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	260 { `accept error3 tmp=$D1%XW len=$D2%DW name=$D3%XW error=$D4%DW` }, \
 	261 { `accept error4 s=$D1%XW namelen=$D2%XW len=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	262 { `accept error5 namelen=$D1%DW error=$D2%DW` }, \
 	263 { `accept error6 s=$D1%XW error=$D2%DW fp=$D3%XW` }, \
 	264 { `accept error7 so=$D1%XW error=$D2%DW` }, \
 	265 { `accept error8 so=$D1%XW error=$D2%DW` }, \
 	266 { `accept error9 so=$D1%XW error=$D2%DW` }, \
 	267 { `accept error10 so=$D1%XW error=$D2%DW` }, \
 	268 { `accept error11 so=$D1%XW aso=$D2%XW error=$D3%DW` }, \
 	269 { `accept error12 fd=$D1%XW ndp=$D2%XW aso=$D3%XW error=$D4%DW` }, \
 	270 { `accept error13 s=$D1%XW fd=$D2%XW error=$D3%DW` }, \
 	271 { `_connect error1 s=$D1%XW error=$D2%DW fp=$D3%XW` }, \
	272 { `_connect error2 so=$D1%XW error=$D2%DW` }, \
 	273 { `_connect error3 so=$D1%XW error=$D2%DW` }, \
 	274 { `socketpair error1 tmp=$D1%XW size=$D2%DW rsv=$D3%XW error=$D4%DW` }, \
 	275 { `socketpair error2 error=$D1%DW` }, \
 	276 { `socketpair error3 so1=$D1%XW dom=$D2%DW error=$D3%DW` }, \
 	277 { `socketpair error4 so1=$D1%XW error=$D2%DW` }, \
 	278 { `socketpair error5 so2=$D1%XW fd=$D2%XW fp1=$D3%XW error=$D4%DW` }, \
 	279 { `socketpair error6 so2=$D1%XW fd=$D2%XW fp1=$D3%XW error=$D4%DW` }, \
 	280 { `socketpair error7 so1=$D1%XW so2=$D2%XW error=$D3%DW` }, \
 	281 { `socketpair error8 so1=$D1%XW so2=$D2%XW error=$D3%DW` }, \
 	282 { `socketpair error9 protocol=$D1%DW sv=$D2%XW uap_rsv=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	283 { `socketpair error10 error=$D1%DW` }, \
 	284 { `socketpair error11 error=$D1%DW` }, \
 	285 { `sendto error1 tmp=$D1%XW len=$D2%DW uap_buf=$D3%XW error=$D4%DW` }, \
 	286 { `sendto error2 tmp=$D1%XW tolen=$D2%DW uap_to=$D3%XW error=$D4%DW` }, \
 	287 { `send error1 tmp=$D1%XW len=$D2%DW uap_buf=$D3%XW error=$D4%DW` }, \
 	288 { `send error2 error=$D1%DW` }, \
 	289 { `sendmsg error1 s=$D1%XW uap_msg=$D2%XW msghdr=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	290 { `sendmsg error2 s=$D1%XW error=$D2%DW` }, \
 	291 { `sendmsg error3 s=$D1%XW error=$D2%DW` }, \
 	292 { `sendmsg error4 s=$D1%XW msghdr=$D2%DW uiov=$D3%XW len=$D4%DW error=$D5%DW` }, \
 	293 { `sendmsg error5 s=$D1%XW uapmsg=$D2%XW msg=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	294 { `sendmsg error6 s=$D1%XW error=$D2%DW` }, \
 	295 { `sendmsg error7 s=$D1%XW error=$D2%DW` }, \
 	296 { `sendmsg error8 s=$D1%XW tmp=$D2%XW size=$D3%DW msg=$D4%XW error=$D5%DW` }, \
 	297 { `sendmsg error9 s=$D1%XW msg=$D2%XW hdr=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	298 { `sendmsg error10 s=$D1%XW error=$D2%DW` }, \
 	299 { `sendmsg error11 name=$D1%XW len=$D2%DW msgname=$D3%DW error=$D4%DW` }, \
 	300 { `sendmsg error12 s=$D1%XW rights=$D2%DW len=$D3%DW control=$D4%XW error=$D5%DW` }, \
 	301 { `sendmsg error13 s=$D1%XW error=$D2%DW` }, \
 	302 { `sendmsg error14 s=$D1%XW iov=$D2%DW uiov=$D3%XW len=$D4%DW error=$D5%DW` }, \
 	303 { `sendmsg error15 base=$D1%XW len=$D2%DW iov=$D3%XW error=$D4%DW` }, \
 	304 { `sendmsg error16 s=$D1%XW uap=$D2%DW msg=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	305 { `sendmsg error17 s=$D1%XW error=$D2%DW` }, \
 	306 { `sendmsg error18 s=$D1%XW error=$D2%DW` }, \
 	307 { `nsendmsg error1 s=$D1%XW error=$D2%DW` }, \
 	308 { `nsendmsg error2 s=$D1%XW error=$D2%DW` }, \
 	309 { `nsendmsg error3 s=$D1%XW error=$D2%DW` }, \
 	310 { `nsendmsg error4 s=$D1%XW iov=$D2%DW uiov=$D3%XW len=$D4%DW error=$D5%DW` }, \
 	311 { `nsendmsg error5 s=$D1%XW uap=$D2%DW msg=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	312 { `nsendmsg error6 s=$D1%XW error=$D2%DW` }, \
 	313 { `nsendmsg error7 s=$D1%XW error=$D2%DW` }, \
 	314 { `nsendmsg error8 tmp=$D1%XW size=$D2%DW uap_msg=$D3%XW error=$D4%DW` }, \
 	315 { `nsendmsg error9 s=$D1%XW uap=$D2%DW msg=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	316 { `nsendmsg error10 s=$D1%XW error=$D2%DW` }, \
 	317 { `nsendmsg error11 name=$D1%XW len=$D2%DW msg=$D3%XW error=$D4%DW` }, \
 	318 { `nsendmsg error12 control=$D1%XW len=$D2%DW msg=$D3%XW error=$D4%DW` }, \
 	319 { `nsendmsg error13 s=$D1%XW error=$D2%DW` }, \
 	320 { `nsendmsg error14 s=$D1%XW iov=$D2%XW uiov=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	321 { `nsendmsg error15 base=$D1%XW len=$D2%DW iov=$D3%XW error=$D4%DW` }, \
 	322 { `nsendmsg error16 s=$D1%XW uap=$D2%XW msg=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	323 { `nsendmsg error17 s=$D1%XW error=$D2%DW` }, \
 	324 { `nsendmsg error18 s=$D1%XW error=$D2%DW` }, \
 	325 { `sendit error1 s=$D1%XW error=$D2%DW` }, \
 	326 { `sendit error2 s=$D1%XW error=$D2%DW len=$D3%DW resid=$D4%DW` }, \
 	327 { `sendit error3 s=$D1%XW error=$D2%DW to=$D3%XW name=$D4%XW len=$D5%DW` }, \
 	328 { `sendit error4 s=$D1%XW error=$D2%DW len=$D3%DW size=$D4%DW` }, \
 	329 { `sendit error5 s=$D1%XW error=$D2%DW control=$D3%XW msg=$D4%XW len=$D5%DW` }, \
 	330 { `sendit error6 s=$D1%XW error=$D2%DW control=$D3%DW size=$D4%DW` }, \
 	331 { `sendit error7 s=$D1%XW error=$D2%DW control=$D3%DW` }, \
 	332 { `sendit error8 s=$D1%XW error=$D2%DW` }, \
 	333 { `sendit error9 s=$D1%XW error=$D2%DW` }, \
 	334 { `sendit out1 s=$D1%XW error=$D2%DW` }, \
 	335 { `nrecvfrom error1 tmp=$D1%XW size=$D2%DW addr=$D3%XW error=$D4%DW` }, \
 	336 { `nrecvfrom error2 tmp=$D1%XW len=$D2%DW buf=$D3%XW error=$D4%DW` }, \
 	337 { `nrecvfrom error3 s=$D1%XW addr=$D2%XW len=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	338 { `nrecvfrom error4 tmp=$D1%XW len=$D2%DW from=$D3%XW error=$D4%DW` }, \
 	339 { `recv error1 tmp=$D1%XW len=$D2%DW buf=$D3%XW error=$D4%DW` }, \
 	340 { `recv error2 so=$D1%XW error=$D2%DW` }, \
 	341 { `recv error3 so=$D1%XW error=$D2%DW` }, \
 	342 { `soclose2_abort1 soq=$D1%XW` }, \
 	343 { `soclose2_abort2 soq=$D1%XW` }, \
 	346 { `sodisconn error1 so=$D1%XW error=$D2%DW` }, \
 	347 { `sodisconn error2 so=$D1%XW error=$D2%DW` }, \
 	348 { `soreceive error1 so=$D1%XW error=$D2%DW dom=$D3%DW proto=$D4%DW type=$D5%DW` }, \
 	349 { `soreceive error2 so=$D1%XW error=$D2%DW dom=$D3%DW proto=$D4%DW type=$D5%DW` }, \
 	350 { `soshutdown error1 so=$D1%XW error=$D2%DW` }, \
 	351 { `sonewsock out1 so=$D1%XW` }, \
 	352 { `sonewsock out2 so=$D1%XW` }, \
 	353 { `sosbwait out1 sb=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	354 { `sosbwait out2 sb=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	355 { `soo_select out1 fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	356 { `soo_select out2 fp=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	357 { `sendmsg out1 so=$D1%XW error=$D2%DW` }, \
 	358 { `sendmsg out2 so=$D1%XW error=$D2%DW` }, \
 	359 { `sendmsg out3 so=$D1%XW error=$D2%DW` }, \
 	360 { `sendmsg out4 so=$D1%XW error=$D2%DW` }, \
 	361 { `nsendmsg s=$D1%XW uap_msg=$D2%XW flags=$D3%XW` }, \
 	362 { `nsendmsg out1 so=$D1%XW error=$D2%DW` }, \
 	363 { `nsendmsg out2 so=$D1%XW error=$D2%DW` }, \
 	364 { `nsendmsg out3 so=$D1%XW error=$D2%DW` }, \
 	365 { `nsendmsg out4 so=$D1%XW error=$D2%DW` }, \
 	366 { `recvmsg error1 s=$D1%XW msg=$D2%XW hdr=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	367 { `recvmsg error2 so=$D1%XW error=$D2%DW` }, \
 	368 { `recvmsg error3 so=$D1%XW error=$D2%DW` }, \
 	369 { `recvmsg error4 s=$D1%XW iov=$D2%XW uiov=$D3%DW len=$D4%DW error=$D5%DW` }, \
 	370 { `recvmsg error5 s=$D1%XW len=$D2%DW acclen=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	371 { `recvmsg error6 s=$D1%XW uap=$D2%XW hdr=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	372 { `recvmsg error7 so=$D1%XW error=$D2%DW` }, \
 	373 { `recvmsg error8 so=$D1%XW error=$D2%DW` }, \
 	374 { `recvmsg error9 s=$D1%XW len=$D2%DW acclen=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	375 { `recvmsg error10 tmp=$D1%XW size=$D2%DW msg=$D3%XW error=$D4%DW` }, \
 	376 { `recvmsg error11 s=$D1%XW msg=$D2%XW hdr=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	377 { `recvmsg error12 so=$D1%XW error=$D2%DW` }, \
 	378 { `recvmsg error13 name=$D1%XW len=$D2%DW name=$D3%XW error=$D4%DW` }, \
 	379 { `recvmsg error14 rights=$D1%XW len=$D2%DW control=$D3%DW error=$D4%DW` }, \
 	380 { `recvmsg error15 so=$D1%XW error=$D2%DW` }, \
 	381 { `recvmsg error16 s=$D1%XW iov=$D2%XW uiov=$D3%DW len=$D4%DW error=$D5%DW` }, \
 	382 { `recvmsg error17 s=$D1%XW error=$D2%DW len=$D3%DW intmax=$D4%DW` }, \
 	383 { `recvmsg error18 uiov=$D1%XW len=$D2%DW iov=$D3%XW error=$D4%DW` }, \
 	384 { `recvmsg error19 s=$D1%XW len=$D2%XW acclen=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	385 { `recvmsg error20 s=$D1%XW uap=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	386 { `recvmsg error21 so=$D1%XW error=$D2%DW` }, \
 	387 { `recvmsg error22 so=$D1%XW error=$D2%DW` }, \
 	388 { `recvmsg error23 s=$D1%XW len=$D2%DW acclen=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	389 { `recvmsg out1 so=$D1%XW error=$D2%DW` }, \
 	390 { `recvmsg out2 so=$D1%XW error=$D2%DW len=$D3%DW` }, \
 	391 { `recvmsg out3 so=$D1%XW error=$D2%DW len=$D3%DW` }, \
 	392 { `recvmsg out4 so=$D1%XW error=$D2%DW len=$D3%DW` }, \
 	393 { `nrecvmsg s=$D1%XW uap_msg=$D2%DW flags=$D3%XW` }, \
 	394 { `nrecvmsg error1 s=$D1%XW uap=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	395 { `nrecvmsg error2 s=$D1%XW error=$D2%DW` }, \
 	396 { `nrecvmsg error3 s=$D1%XW error=$D2%DW` }, \
 	397 { `nrecvmsg error4 s=$D1%XW iov=$D2%XW uiov=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	398 { `nrecvmsg error5 s=$D1%XW error=$D2%DW len=$D3%DW ulen=$D4%DW size=$D5%DW` }, \
 	399 { `nrecvmsg error6 s=$D1%XW hdr=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	400 { `nrecvmsg error7 s=$D1%XW error=$D2%DW` }, \
 	401 { `nrecvmsg error8 s=$D1%XW uap=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	402 { `nrecvmsg error9 s=$D1%XW error=$D2%DW` }, \
 	403 { `nrecvmsg error10 s=$D1%XW error=$D2%DW` }, \
 	404 { `nrecvmsg error11 s=$D1%XW error=$D2%DW len=$D3%DW ulen=$D4%DW size=$D5%DW` }, \
 	405 { `nrecvmsg error12 s=$D1%XW msg=$D2%XW uap=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	406 { `nrecvmsg error13 tmp=$D1%XW size=$D2%DW msg=$D3%XW error=$D4%DW` }, \
 	407 { `nrecvmsg error14 s=$D1%XW uap=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	408 { `nrecvmsg error15 s=$D1%XW error=$D2%DW` }, \
 	409 { `nrecvmsg error16 name=$D1%XW len=$D2%DW msg=$D3%DW error=$D4%DW` }, \
 	410 { `nrecvmsg error17 control=$D1%XW len=$D2%DW msg=$D3%DW error=$D4%DW` }, \
 	411 { `nrecvmsg error18 s=$D1%XW error=$D2%DW` }, \
 	412 { `nrecvmsg error19 s=$D1%XW iov=$D2%XW uiov=$D3%DW len=$D4%DW error=$D5%DW` }, \
 	413 { `nrecvmsg error20 s=$D1%XW error=$D2%DW len=$D3%DW intmax=$D4%DW` }, \
 	414 { `nrecvmsg error21 base=$D1%XW len=$D2%XW iov=$D3%DW error=$D4%DW` }, \
 	415 { `nrecvmsg error22 s=$D1%XW len=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	416 { `nrecvmsg error23 s=$D1%XW hdr=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	417 { `nrecvmsg error24 s=$D1%XW uap=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	418 { `nrecvmsg error25 s=$D1%XW error=$D2%DW` }, \
 	419 { `nrecvmsg error26 s=$D1%XW error=$D2%DW` }, \
 	420 { `nrecvmsg error27 s=$D1%XW len=$D2%XW msg=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	421 { `nrecvmsg error28 s=$D1%XW msg=$D2%XW uap=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	422 { `nrecvmsg out1 s=$D1%XW error=$D2%DW len=$D3%DW` }, \
 	423 { `nrecvmsg out2 s=$D1%XW error=$D2%DW len=$D3%DW` }, \
 	424 { `nrecvmsg out3 s=$D1%XW error=$D2%DW len=$D3%DW` }, \
 	425 { `recvit error1 s=$D1%XW error=$D2%DW` }, \
 	426 { `recvit error2 s=$D1%XW error=$D2%DW` }, \
 	427 { `recvit error3 s=$D1%XW error=$D2%DW` }, \
 	428 { `recvit error4 s=$D1%XW data=$D2%XW name=$D3%XW len=$D4%DW error=$D5%DW` }, \
 	429 { `recvit error5 s=$D1%XW len=$D2%XW lenp=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	430 { `recvit error6 level=$D1%XW type=$D2%XW` }, \
 	431 { `recvit error7 s=$D1%XW data=$D2%XW len=$D3%DW clen=$D4%DW error=$D5%DW` }, \
 	432 { `shutdown error1 s=$D1%XW error=$D2%DW` }, \
 	433 { `setsockopt error1 tmp=$D1%XW valsize=$D2%DW uap=$D3%XW error=$D4%DW` }, \
 	434 { `setsockopt error2 s=$D1%XW error=$D2%DW` }, \
 	435 { `setsockopt error3 s=$D1%XW error=$D2%DW` }, \
 	436 { `setsockopt error4 s=$D1%XW error=$D2%DW` }, \
 	437 { `setsockopt error5 s=$D1%XW valp=$D2%DW data=$D3%XW valsize=$D4%DW error=$D5%DW` }, \
 	438 { `getsockopt error1 tmp=$D1%XW size=$D2%DW valsize=$D3%XW error=$D4%DW` }, \
 	439 { `getsockopt error2 s=$D1%XW avalsize=$D2%XW valsize=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	440 { `getsockopt error3 tmp=$D1%XW valsize=$D2%XW uap=$D3%XW error=$D4%DW` }, \
 	441 { `getsockopt error4 s=$D1%XW error=$D2%DW` }, \
 	442 { `getsockopt error5 s=$D1%XW error=$D2%DW` }, \
 	443 { `getsockopt error6 s=$D1%XW data=$D2%XW uap=$D3%XW valsize=$D4%DW error=$D5%DW` }, \
 	444 { `getsockopt error7 s=$D1%XW valsize=$D2%XW uap=$D3%XW valsize=$D4%DW error=$D5%DW` }, \
 	445 { `getsockname error1 tmp=$D1%XW size=$D2%XW alen=$D3%XW error=$D4%DW` }, \
 	446 { `getsockname error2 fdes=$D1%XW uap=$D2%XW len=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	447 { `getsockname error3 tmp=$D1%XW len=$D2%XW asa=$D3%XW error=$D4%DW` }, \
 	448 { `getsockname error4 fp=$D1%XW error=$D2%DW` }, \
 	449 { `getsockname error5 so=$D1%XW error=$D2%DW` }, \
 	450 { `getsockname error6 so=$D1%XW error=$D2%DW` }, \
 	451 { `getsockname error7 fdes=$D1%XW data=$D2%XW asa=$D3%XW len=$D4%DW error=$D5%DW` }, \
 	452 { `getsockname error8 fdes=$D1%XW len=$D2%XW alen=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	453 { `getpeername error1 tmp=$D1%XW size=$D2%DW alen=$D3%XW error=$D4%DW` }, \
 	454 { `getpeername error2 fdes=$D1%XW alen=$D2%XW len=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	455 { `getpeername error3 tmp=$D1%XW len=$D2%DW asa=$D3%XW error=$D4%DW` }, \
 	456 { `getsockname error4 fp=$D1%XW error=$D2%DW` }, \
 	457 { `getsockname error5 fp=$D1%XW error=$D2%DW` }, \
 	458 { `getsockname error6 so=$D1%XW error=$D2%DW` }, \
 	459 { `getsockname error7 so=$D1%XW error=$D2%DW` }, \
 	460 { `getpeername error8 fdes=$D1%XW data=$D2%XW asa=$D3%XW len=$D4%DW error=$D5%DW` }, \
 	461 { `getpeername error9 fdes=$D1%XW len=$D2%XW alen=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	462 { `getpeereid error1 tmp=$D1%XW size=$D2%DW euid=$D3%XW error=$D4%DW` }, \
 	463 { `getpeereid error2 tmp=$D1%XW size=$D2%DW egid=$D3%XW error=$D4%DW` }, \
 	464 { `getpeereid error3 fp=$D1%XW error=$D2%DW` }, \
 	465 { `getpeereid error4 so=$D1%XW error=$D2%DW` }, \
 	466 { `getpeereid error5 so=$D1%XW error=$D2%DW` }, \
 	467 { `getpeereid error6 fdes=$D1%XW uid=$D2%XW euid=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	468 { `getpeereid error7 fdes=$D1%XW gid=$D2%XW egid=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	469 { `sockargs error1 error=$D1%DW` }, \
 	470 { `sockargs error2 error=$D1%DW` }, \
 	471 { `sockargs error3 error=$D1%DW` }, \
 	472 { `sockargs error4 buf=$D1%XW data=$D2%XW buflen=$D3%DW error=$D4%DW` }, \
 	473 { `socksetup error1 error=$D1%DW` }, \
 	474 { `socksetup error2 error=$D1%DW` }, \
 	476 { `getkerninfo error1 tmp=$D1%XW size=$D2%XW uap=$D3%DW error=$D4%DW` }, \
 	477 { `getkerninfo error2 op=$D1%XW size=$D2%XW bufsize=$D3%DW sz=$D4%DW error=$D5%DW` }, \
 	478 { `getkerninfo error3 tmp=$D1%XW size=$D2%XW uap=$D3%DW error=$D4%DW` }, \
 	479 { `getkerninfo error4 tmp=$D1%XW LEN=$D2%DW arg=$D3%XW error=$D4%DW` }, \
 	480 { `getkerninfo error5 error=$D1%DW` }, \
 	481 { `getkerninfo error6 tmp=$D1%XW size=$D2%DW arg=$D3%XW error=$D4%DW` }, \
 	482 { `getkerninfo error7 error=$D1%DW` }, \
 	483 { `getkerninfo error8 tmp=$D1%XW size=$D2%DW arg=$D3%XW error=$D4%DW` }, \
 	484 { `getkerninfo error9 error=$D1%DW` }, \
 	485 { `getkerninfo error10 arg=$D1%XW kaddr=$D2%XW size=$D3%DW error=$D4%DW` }, \
 	486 { `getkerninfo error11 tmp=$D1%XW size=$D2%DW arg=$D3%XW error=$D4%DW` }, \
 	487 { `getkerninfo error12 error=$D1%DW` }, \
 	488 { `getkerninfo error13 tmp=$D1%XW size=$D2%DW arg=$D3%XW error=$D4%DW` }, \
 	489 { `getkerninfo error14 error=$D1%DW` }, \
 	490 { `getkerninfo error15 arg=$D1%XW kaddr=$D2%XW size=$D3%DW error=$D4%DW` }, \
 	491 { `getkerninfo error16 error=$D1%DW` }, \
 	492 { `getkerninfo error17 error=$D1%DW` }, \
 	493 { `getkerninfo error18 op=$D1%DW where=$D2%XW bufsize=$D3%DW xmd=$D4%XW error=$D5%DW` }, \
 	494 { `getkerninfo error19 op=$D1%DW where=$D2%XW bufsize=$D3%DW xmd=$D4%XW error=$D5%DW` }, \
 	495 { `getkerninfo error20 op=$D1%DW buf=$D2%XW uapsize=$D3%DW size=$D4%DW error=$D5%DW` }, \
 	496 { `socket_aio_dequeue error1 error=$D1%DW` }, \
 	497 { `socket_aio_dequeue error2 error=$D1%DW` }, \
 	498 { `kinfo_read error1 error=$D1%DW` }, \
 	499 { `kinfo_read error2 op=$D1%DW arg=$D2%XW where=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	500 { `kinfo_write error1 error=$D1%DW` }, \
 	501 { `kinfo_write error2 op=$D1%DW arg=$D2%XW where=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	502 { `splice error1 error=$D1%DW` }, \
 	503 { `splice error2 error=$D1%DW` }, \
 	504 { `sctp_opt_info error1 s=$D1%XW error=$D2%DW fp=$D3%XW` }, \
 	505 { `sctp_opt_info error2 valsize=$D1%DW MLEN=$D2%DW error=$D3%DW` }, \
 	506 { `sctp_opt_info error3 tmp=$D1%XW size=$D2%DW arg=$D3%XW error=$D4%DW` }, \
 	507 { `sctp_opt_info error4 s=$D1%XW arg=$D2%XW data=$D3%XW valsize=$D4%DW error=$D5%DW` }, \
 	508 { `sctp_opt_info error5 s=$D1%XW arg=$D2%XW data=$D3%XW valsize=$D4%DW error=$D5%DW` }, \
 	509 { `sctp_opt_info error6 s=$D1%XW arg=$D2%XW data=$D3%XW valsize=$D4%DW error=$D5%DW` }, \
 	510 { `sctp_peeloff error1 tmp=$D1%XW size=$D2%DW associd=$D3%DW error=$D4%DW` }, \
 	511 { `sctp_peeloff error2 s=$D1%XW associd=$D2%XW idp=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	512 { `sctp_peeloff error3 s=$D1%XW associd=$D2%XW idp=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	513 { `sctp_peeloff error4 s=$D1%XW associd=$D2%XW idp=$D3%XW size=$D4%DW error=$D5%DW` }, \
 	514 { `sctp_peeloff error5 s=$D1%XW error=$D2%DW fp=$D3%XW` }, \
 	515 { `sctp_peeloff error6 s=$D1%XW nsop=$D2%XW error=$D3%DW` }, \
 	516 { `sctp_peeloff error7 s=$D1%XW nso=$D2%XW error=$D3%DW` }, \
 	517 { `sctp_peeloff error7 nso=$D1%XW nsd=$D2%XW nfp=$D3%XW error=$D4%DW` }, \
 	518 { `k_getgroups error1 ngroups=$D1%DW error=$D2%DW` }, \
 	519 { `k_getgroups error2 ngroups=$D1%DW current_group=$D2%DW error=$D3%DW` }, \
 	520 { `sosplice error3 so1=$D1%XW so2=$D2%XW error=$D3%DW` }, \
 	521 { `sodisconnectreuse error1 so=$D1%XW error=$D2%DW` }, \
 	522 { `sosbwait	error2 sb=$D1%XW so=$D2%XW error=$D3%DW` }, \
 	523 { `soo_ioctl error21 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	524 { `soo_ioctl error22 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	525 { `soo_ioctl error23 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	526 { `soo_ioctl error24 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	527 { `soo_ioctl error25 fp=$D1%XW cmd=$D2%DW error=$D3%DW` }, \
 	528 { `socket error2 fd=$D1%XW domain=$D2%DW so=$D3%XW type=$D4%DW protocol=$D5%DW` }, \
 	529 { `bind error4 so=$D1%XW nam=$D2%DW uapname=$D3%XW namelen=$D4%DW error=$D5%DW` }, \
 	530 { `listen error1 so=$D1%XW error=$D2%DW` }, \
 	531 { `_connect error4 so=$D1%XW error=$D2%DW` }, \
 	532 { `_connect error5 so=$D1%XW error=$D2%DW` }, \
 	533 { `_connect error6 so=$D1%XW error=$D2%DW` }, \
 	534 { `send error3 so=$D1%XW error=$D2%DW` }, \
 	542{ `k_soaccept error1 so=$D1%XW nonblock=$D2%DW compat_43=$D3%DW `}, \
 	543{ `k_soaccept error2 so=$D1%XW error=$D2%DW`}, \
 	544{ `k_soaccept error3 so=$D1%XW error=$D2%DW`}, \
 	545{ `k_soaccept error4 so=$D1%XW error=$D2%DW`}, \
 	546{ `k_soaccept error5 so=$D1%XW error=$D2%DW`}, \
 	547{ `k_soaccept error6 so=$D1%XW nso=$D2%XW error=$D3%DW`}, \
 	548{ `k_soaccept error7 so=$D1%XW nso=$D2%XW nam=$D3%XW nonblock=$D4%DW`}, \
 	549 { `bind2addrsel sofd=$D1%XW name=$D2%XW namelen=$D3%DW` }, \
	550 { `return from bind2addrsel error=$D1%DW so=$D2%XW nam=$D3%XW` }, \
 	551 { `bind2addrsel error1 sofd=$D1%XW error=$D2%DW fp=$D3%XW` }, \
 	552 { `bind2addrsel error2 sofd=$D1%XW error=$D2%DW` }, \
 	553 { `bind2addrsel error3 sofd=$D1%XW error=$D2%DW` }, \
 	554 { `bind2addrsel error4 sofd=$D1%XW error=$D2%DW` }, \
 	555 { `inet6_is_srcaddr srcaddr=$D1%XW flags=%D2%XW` }, \
 	556 { `return from inet6_is_srcaddr srcaddr=sin6addr($D1, $D2) flags=%D2%XW` }, \
 	557 { `inet6_is_srcaddr error1 usrcaddr=$D1%XW ksrcaddr=$D2%XW addr_len=%D3%DW error=%D4%DW` }, \
 	558 { `inet6_is_srcaddr error2 family=$D1%DW srcaddr=sin6addr($D2, $D3) scope_id=$D4%DW` }, \
 	559 { `inet6_is_srcaddr error3 srcaddr=sin6addr($D1, $D2) flags=$D3%XW` }, \
	560 { `inet6_is_srcaddr error4 srcaddr=sin6addr($D1, $D2) flags=$D3%XW` }, \
	561 { `inet6_is_srcaddr error5 srcaddr=sin6addr($D1, $D2) flags=$D3%XW` }, \
 	562 { `bind2addrsel error5 sofd=$D1%XW error=$D2%DW` }, \
 	563 { `bind2addrsel error6 sofd=$D1%XW nam=$D2%DW dstaddr=$D3%XW dstaddrlen=$D4%DW error=$D5%DW` }, \
 	564 { `kern_socreate af error kerrno_t=$D1%XW af=$D2%DW` }, \
 	565 { `kern_socreate type error kerrno_t=$D1%XW type=$D2%DW` }, \
 	566 { `kern_socreate protocol error kerrno_t=$D1%XW protocol=$D2%DW` }, \
 	567 { `kern_socreate out kerrno_t=$D1%XW rc=$D2%DW` }, \
 	568 { `kern_sobind memory error kerrno_t=$D1%XW` }, \
 	569 { `kern_sobind af error kerrno_t=$D1%XW af=$D2%DW` }, \
 	570 { `kern_sobind address length error kerrno_t=$D1%XW af=$D2%DW len=$D3%DW` }, \
 	571 { `kern_sobind out kerrno_t=$D1%XW rc=$D2%DW` }, \
 	572 { `kern_soconnect memory error kerrno_t=$D1%XW` }, \
 	573 { `kern_soconnect af error kerrno_t=$D1%XW af=$D2%DW` }, \
 	574 { `kern_soconnect address length error kerrno_t=$D1%XW af=$D2%DW len=$D3%DW` }, \
 	575 { `kern_soconnect out1 kerrno_t=$D1%XW so=$D2%XW rc=$D3%DW` }, \
 	576 { `kern_soconnect out2 kerrno_t=$D1%XW so=$D2%XW rc=$D3%DW` }, \
 	577 { `kern_soconnect out3 kerrno_t=$D1%XW so=$D2%XW rc=$D3%DW` }, \
 	578 { `kern_soconnect out4 kerrno_t=$D1%XW so=$D2%XW rc=$D3%DW` }, \
 	579 { `kern_soconnect out5 kerrno_t=$D1%XW so=$D2%XW rc=$D3%DW` }, \
 	580 { `kern_solisten backlog error kerrno_t=$D1%XW backlog=$D2%DW` }, \
 	581 { `kern_solisten out kerrno_t=$D1%XW rc=$D2%DW backlog=$D3%DW` }, \
 	582 { `kern_soaccept out kerrno_t=$D1%XW rc=$D2%DW` }, \
 	583 { `kern_sogetopt out kerrno_t=$D1%XW rc=$D2%DW level=$D3%DW optname=$D4%DW` }, \
 	584 { `kern_sosetopt out kerrno_t=$D1%XW rc=$D2%DW level=$D3%DW optname=$D4%DW` }, \
 	585 { `kern_soreserve out kerrno_t=$D1%XW rc=$D2%DW sndcc=$D3%DW rcvcc=$D4%DW` }, \
 	586 { `kern_soshutdown out kerrno_t=$D1%XW rc=$D2%DW how=$D3%DW` }, \
 	587 { `kern_soclose out kerrno_t=$D1%XW rc=$D2%DW` }, \
 	588 { `kern_soreceive length error kerrno_t=$D1%XW len=$D2%DW` }, \
 	589 { `kern_soreceive out kerrno_t=$D1%XW rc=$D2%DW` }, \
 	590 { `kern_sosend memory error  kerrno_t=$D1%XW` }, \
 	591 { `kern_sosend af error kerrno_t=$D1%XW af=$D2%DW` }, \
 	592 { `kern_sosend addr length error kerrno_t=$D1%XW af=$D2%DW, len=$D3%DW` }, \
 	593 { `kern_sosend out kerrno_t=$D1%XW rc=$D2%DW` }, \
 	\* { unknown subhook $HD $ERROR }
254 1.0 'MBUF' \
{{ \
waittype(ppp) \
	$ppp%D1, \
	0    M_DONTWAIT, \
	1    M_WAIT, \
	\*  {$ppp%D1} \
}} \
{{ \
mbuftype(ttt) \
	$ttt%D1, \
	0   MT_FREE, \
	1   MT_DATA, \
	2   MT_HEADER, \
	3   MT_SOCKET, \
	4   MT_PCB, \
	5   MT_RTABLE, \
	6   MT_HTABLE, \
	7   MT_ATABLE, \
	8   MT_SONAME, \
	10  MT_SOOPTS, \
	11  MT_FTABLE, \
	12  MT_RIGHTS, \
	13  MT_IFADDR, \
	14  MT_CONTROL, \
	15  MT_OOBDATA, \
	\*  {$ttt%D1} \
}} \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
	1  { `m_get ` canwait=waittype($D1) type=mbuftype($D2) `callfrom=$D3%XW srad=$D4%DW` }, \
 	2  { `return from m_get mbuf=$D1%XW dataptr=$D2%XW` }, \
 	3  { `m_getclr ` canwait=waittype($D1) type=mbuftype($D2) `callfrom=$D3%XW` }, \
 	4  { `return from m_getclr mbuf=$D1%XW dataptr=$D2%XW` }, \
 	5  { `m_free mbuf=$D1%XW dataptr=$D2%XW callfrom=$D3%XW` `callfrom2=$D4%XW` `pid=`prKernelPID($D5)` ($D5%PW)`}, \
 	6  { `return from m_free mbuf=$D1%XW` }, \
 	7  { `m_copy mbuf=$D1%XW offset=$D2%D1 len=$D3%D1` }, \
 	8  { `return from m_copy top=$D1%XW` }, \
 	9  { `m_copydata mbuf=$D1%XW offset=$D2%D1 len=$D3%D1 cpaddr=$D4%XW` }, \
 	10 { "return from m_copydata" }, \
 	11 { "m_pullup bcopy" }, \
 	12 { "m_pullup bcopy end" }, \
 	13 { "mbuf low intr" }, \
 	14 { "return from mbuf low intr" }, \
 	15 { "m_low: schedule mlowintr" }, \
	16 { `m_clgetm ` canwait=waittype($D1) `mbuf=$D2%XW` `callfrom=$D3%XW` `callfrom2=$D4%XW` `pid=`prKernelPID($D5)` ($D5%PW)` }, \
	17 { `return from m_clgetm mbuf=$D1%XW dataptr=$D2%XW` }, \
	18 { `m_getclustm ` canwait=waittype($D1) type=mbuftype($D2) `callfrom=$D3%XW srad=$D4%DW` }, \
        19 { `return from m_getclustm mbuf=$D1%XW dataptr=$D2%XW` }, \
	20 { `m_clattach ` canwait=waittype($D1) `callfrom=$D2%XW callfrom2=$D3%XW`}, \
        21 { `return from m_clattach mbuf=$D1%XW dataptr=$D2%XW` }, \
        22 { `m_prepend m=$D1%XW len=$D2%DW how=$D3%DW ` }, \
        23 { `return from m_prepend mbuf=$D1%XW len=$D2%DW how=$D3%DW` }, \
        24 { `m_pullup ` canwait=waittype($D1) `callfrom=$D2%XW` `callfrom2=$D3%XW` `pid=`prKernelPID($D4)` ($D4%PW)` }, \
        25 { `return from m_pullup mbuf=$D1%XW dataptr=$D2%XW` }, \
        26 { `m_copy ` canwait=waittype($D1) `callfrom=$D2%XW` `callfrom2=$D3%XW` `pid=`prKernelPID($D4)` ($D4%PW)` }, \
        27 { `return from m_copy mbuf=$D1%XW dataptr=$D2%XW` }, \
        28 { `m_adj mbuf=$D1%XW reqlen=$D2%DW` }, \
        29 { `m_pullup type=$D1%DW len=$D2%DW` }, \
        30 { `m_retry error1 canwait=$D1%DW type=$D2%DW` }, \
        31 { `m_pullup error1 type=$D1%DW error=$D2%DW` }, \
        32 { `m_clattach error1 type=$D1%DW error=$D2%DW` }, \
        33 { `m_getclustm error1 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
        34 { `m_getclustm error2 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
        35 { `m_collapse error1 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
        36 { `m_copymext error1 type=$D1%DW error=$D2%DW` }, \
        37 { `m_copymext error2 size=$D1%DW error=$D2%DW` }, \
        38 { `m_create_clustpool error1 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
        39 { `m_create_clustpool error2 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
        40 { `m_get_from_clustpool_nolock error1` }, \
        41 { `mpool_grow error1 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
        42 { `mpool_grow error2 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
        43 { `mpool_clattach error1 p_size=$D1%DW debug_size=$D2%DW size=$D3%DW` }, \
        44 { `mpool_clattach error2 bufsize=$D1%DW ext_size=$D2%DW` }, \
        45 { `mpool_clattach error3 type=$D1%DW size=$D2%DW error=$D3%DW` }, \
	46 { `m_copymext m=$D1%XW off=$D2%DW len=$D3%DW srad=$D4%DW` }, \
        47 { `return from m_copymext top=$D1%XW` }, \
        48 { `m_create_clustpool pool_size=$D1%XW wait=$D2%DW clust_type=$D3%DW clust_size=$D4%DW` }, \
        49 { `return from m_create_clustpool mpool=$D1%XW` }, \
        50 { `mpool_grow mpool=$D1%XW newsize=$D2%DW wait=$D3%DW` }, \
        51 { `return from mpool_grow size=$D1%DW` }, \
        52 { `mpool_shrink mpool=$D1%XW newsize=$D2%DW mptr=$D3%XW` }, \
        53 { `return from mpool_shrink ret=$D1%DW` }, \
        54 { `m_free_clustpool mpool=$D1%XW` }, \
        55 { `return from m_free_clustpool` }, \
	56 { `m_copy_out1 mbuf=$D1%XW offset=$D2%DW len=$D3%DW` }, \
	57 { `m_copy_out2 morig=$D1%XW mbuf=$D2%XW offset=$D3%DW len=$D4%DW` }, \
	58 { `m_copy_err1 morig=$D1%XW mbuf=$D2%XW len=$D3%DW mprev=$D4%XW` }, \
	59 { `m_copymext_out1 mbuf=$D1%XW offset=$D2%DW len=$D3%DW` }, \
	60 { `m_copymext_out2 morig=$D1%XW mbuf=$D2%XW offset=$D3%DW mprev=$D4%XW` }, \
	61 { `m_copymext_err3 morig=$D1%XW mbuf=$D2%XW len=$D3%DW mprev=$D4%XW` }, \
	62 { `m_free_to_clustpool_err1 mbuf=$D1%XW Caller1=$D2%XW Caller2=$D3%XW Caller3=$D4%XW Caller4=$D5%XW` }, \
	63  { `m_gethdr ` canwait=waittype($D1) type=mbuftype($D2) `callfrom=$D3%XW srad=$D4%DW` }, \
        64  { `return from m_gethdr mbuf=$D1%XW dataptr=$D2%XW` }, \
 	\* {  unknown subhook $HD $ERROR }
255 1.0 'NETIF_EN' \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
 	1  { `en_statintr (entry)  ifp=$D1%XW, sbp_option=$D2%D1` }, \
 	2  { `en_statintr (rtn)` }, \
 	3  { `en_netintr (entry)  ifp=$D1%XW, status=$D2%D1` }, \
 	4  { `en_netintr (rtn)` }, \
 	5  { `en_attach (entry)  unit=$D1%D1` }, \
 	6  { `en_attach (rtn)` }, \
 	7  { `en_detach (entry)  ifp=$D1%XW` }, \
 	8  { `en_detach (rtn)` }, \
 	9  { `en_init (entry)` }, \
 	10 { `en_init (rtn)` }, \
 	11 { `en_ioctl (entry)  ifp=$D1%XW, cmd=$D2%D1 data=$D3%XW` }, \
 	12 { `en_ioctl (rtn) error=$D1%D1` }, \
 	13 { `en_output(entry) ifp=$D1%XW m=$D2%XW family=$D3%D1 `ipaddr=sinaddr($D4) }, \
 	14 { `en_output (rtn) error=$D1%D1` }, \
 	15 { `en_reset (entry)` }, \
 	16 { `en_reset (rtn)` }, \
 	17 { `en_recv (entry)  m=$D1%XW, ifp=$D2%W4` }, \
 	18 { `en_recv (rtn)` }, \
	26   { `expand_table_or_add_row out1 unit=$D1%DW` }, \
	27   { `expand_table_or_add_row out2 unit=$D1%DW` }, \
	28   { `expand_table_or_add_row out3 unit=$D1%DW` }, \
	29   { `config_en cmd=$D1%DW` }, \
	30   { `config_en out1 error=$D1%DW` }, \
	31   { `config_en out2 error=$D1%DW` }, \
	32   { `config_en out3 error=$D1%DW` }, \
	33   { `config_en out4 error=$D1%DW` }, \
	34   { `config_en out5 error=$D1%DW` }, \
	35   { `config_en out6 error=$D1%DW` }, \
	36   { `config_en out7 error=$D1%DW` }, \
	37   { `config_en out8 error=$D1%DW` }, \
	38   { `config_en out9 error=$D1%DW` }, \
	39   { `en_attach unit=$D1%DW type=$D2%DW` }, \
	40   { `en_ioctl ifp=$D1%XW cmd=$D2%DW` }, \
	41   { `en_ioctl out1 error=$D1%DW` }, \
	42   { `en_ioctl error1 error=$D1%DW` }, \
	43   { `en_ioctl error2 error=$D1%DW` }, \
	44   { `en_ioctl error3 error=$D1%DW` }, \
	45   { `en_ioctl error4 error=$D1%DW` }, \
	46   { `en_ioctl error5 error=$D1%DW` }, \
	47   { `en_ioctl error6 error=$D1%DW` }, \
	48   { `en_ioctl error7 error=$D1%DW` }, \
	49   { `en_ioctl debug1 error=$D1%DW` }, \
	50   { `en_ioctl debug2 error=$D1%DW` }, \
	51   { `en_ioctl debug3 error=$D1%DW` }, \
	52   { `en_ioctl debug4 error=$D1%DW` }, \
	53   { `en_ioctl out error=$D1%DW` }, \
	54   { `en_output_in ifp=$D1%XW m=$D2%XW dst=$D3%XW` }, \
	55   { `en_output out1 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	56   { `en_output out2 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	57   { `en_output out3 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	58   { `en_output out4 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	59   { `en_output out5 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	60   { `en_output out6 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	61   { `en_output out7 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	62   { `en_output out8 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	63   { `en_output out9 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	64   { `en_output out10 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	65   { `en_output out11 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	66   { `en_output out12 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	67   { `en_output out13 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	68   { `en_output out14 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	69   { `en_output out15 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	70   { `en_output out16 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	71   { `en_output out17 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	72   { `en_output out18 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	73   { `en_output out19 ifp=$D1%XW m=$D2%XW dst=$D3%XW error=$D4%DW` }, \
	74   { `arpresolve out1 ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	75   { `arpresolve out2 ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	76   { `arpresolve out3 ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	77   { `arpresolve out4 ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	78   { `arpresolve out5 ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	79   { `arpresolve out6 ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	80   { `arpresolve out7 ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	81   { `arpresolve out ac_if=$D1%XW m=$D2%XW fam=$D3%DW dst=$D4%XW` }, \
	82   { `arp_input ac_if=$D1%XW m=$D2%XW` }, \
	83   { `arp_input out1 ac_if=$D1%XW m=$D2%XW` }, \
	84   { `arp_input out2 ac_if=$D1%XW m=$D2%XW` }, \
	85   { `arp_input out3 ac_if=$D1%XW m=$D2%XW` }, \
	86   { `arp_input out4 ac_if=$D1%XW m=$D2%XW` }, \
	87   { `arp_input out5 ac_if=$D1%XW m=$D2%XW` }, \
	88   { `arp_input out ac_if=$D1%XW m=$D2%XW` }, \
	89   { `in_arp_input ac_if=$D1%XW m=$D2%XW` }, \
	90   { `in_arp_input out1 ac_if=$D1%XW m=$D2%XW` }, \
	91   { `in_arp_input out2 ac_if=$D1%XW m=$D2%XW` }, \
	92   { `in_arp_input out3 ac_if=$D1%XW m=$D2%XW` }, \
	93   { `in_arp_input out4 ac_if=$D1%XW m=$D2%XW` }, \
	94   { `in_arp_input out5 ac_if=$D1%XW m=$D2%XW` }, \
	95   { `in_arp_input out6 ac_if=$D1%XW m=$D2%XW` }, \
	96   { `in_arp_input out ac_if=$D1%XW m=$D2%XW` }, \
 	\* {  unknown subhook $HD $ERROR }
256 1.0 'NETIF_TOK' \
 	$HD%D1, \
 	1  { `ie5_statintr (entry)  ifp=$D1%XW, sbp_option=$D2%D1` }, \
 	2  { `ie5_statintr (rtn)` }, \
 	3  { `ie5_netintr (entry)  ifp=$D1%XW, status=$D2%D1` }, \
 	4  { `ie5_netintr (rtn)` }, \
 	5  { `ie5_attach (entry)  unit=$D1%D1` }, \
 	6  { `ie5_attach (rtn)` }, \
 	7  { `ie5_detach (entry)  ifp=$D1%XW` }, \
 	8  { `ie5_detach (rtn)` }, \
 	9  { `ie5_init (entry)` }, \
 	10 { `ie5_init (rtn)` }, \
 	11 { `ie5_ioctl (entry)  ifp=$D1%XW, cmd=$D2%D1 data=$D3%XW` }, \
 	12 { `ie5_ioctl (rtn) error=$D1%D1` }, \
 	13 { `ie5_outpt(entry) ifp=$D1%XW m=$D2%XW fmly=$D3%D1 `ipaddr=sinaddr($D4) }, \
 	14 { `ie5_outpt (rtn) error=$D1%D1` }, \
 	15 { `ie5_reset (entry)` }, \
 	16 { `ie5_reset (rtn)` }, \
 	17 { `ie5_recv (entry)  m=$D1%XW, ifp=$D2%XW` }, \
 	18 { `ie5_recv (rtn)` }, \
 	\* {  unknown subhook $HD $ERROR }
257 1.0 'NETIF_802.3' \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
 	1  { `ie3_statintr (entry)  ifp=$D1%XW, sbp_option=$D2%D1` }, \
 	2  { `ie3_statintr (rtn)` }, \
 	3  { `ie3_netintr (entry)  ifp=$D1%XW, status=$D2%D1` }, \
 	4  { `ie3_netintr (rtn)` }, \
 	5  { `ie3_attach (entry)  unit=$D1%D1` }, \
 	6  { `ie3_attach (rtn)` }, \
 	7  { `ie3_detach (entry)  ifp=$D1%XW` }, \
 	8  { `ie3_detach (rtn)` }, \
 	9  { `ie3_init (entry)` }, \
 	10 { `ie3_init (rtn)` }, \
 	11 { `ie3_ioctl (entry)  ifp=$D1%XW, cmd=$D2%D1 data=$D3%XW` }, \
 	12 { `ie3_ioctl (rtn) error=$D1%D1` }, \
 	13 { `ie3_outpt(entry) ifp=$D1%XW m=$D2%XW fmly=$D3%D1 `ipaddr=sinaddr($D4) }, \
 	14 { `ie3_outpt (rtn) error=$D1%D1` }, \
 	15 { `ie3_reset (entry)` }, \
 	16 { `ie3_reset (rtn)` }, \
 	17 { `ie3_recv (entry)  m=$D1%XW, ifp=$D2%XW` }, \
 	18 { `ie3_recv (rtn)` }, \
 	\* {  unknown subhook $HD $ERROR }
258 1.0 'NETIF_X25' \
 	$HD%D1, \
 	1  { `xt_statintr (entry)  ifp=$D1%XW, sbp_option=$D2%D1` }, \
 	2  { `xt_statintr (rtn)` }, \
 	3  { `xt_netintr (entry)  ifp=$D1%XW, status=$D2%D1` }, \
 	4  { `xt_netintr (rtn)` }, \
 	5  { `xt_attach (entry)  unit=$D1%D1` }, \
 	6  { `xt_attach (rtn)` }, \
 	7  { `xt_detach (entry)  ifp=$D1%XW` }, \
 	8  { `xt_detach (rtn)` }, \
 	9  { `xt_init (entry)` }, \
 	10 { `xt_init (rtn)` }, \
 	11 { `xt_ioctl (entry)  ifp=$D1%XW, cmd=$D2%D1 data=$D3%XW` }, \
 	12 { `xt_ioctl (rtn) error=$D1%D1` }, \
 	13 { `xt_outpt(entry) ifp=$D1%XW m=$D2%XW fmly=$D3%D1 `ipaddr=sinaddr($D4) }, \
 	14 { `xt_outpt(rtn) error=$D1%D1` }, \
 	15 { `xt_reset (entry)` }, \
 	16 { `xt_reset (rtn)` }, \
 	17 { `xt_recv (entry)  m=$D1%XW, ifp=$D2%XW` }, \
 	18 { `xt_recv (rtn)` }, \
 	19 { `xt_incoming_call(entry) m=$D1%XW ifp=$D2%XW callid=$D3%D1 sessid=$D4%D1` }, \
 	20 { `xt_incoming_call (rtn)` }, \
 	21 { `xt_call_complete (entry)  ifp=$D2%XW sessid=$D2%D1 m=$D3%XW` }, \
 	22 { `xt_call_complete (rtn)` }, \
 	23 { `xt_clear_indication (entry)  ifp=$D2%XW sessid=$D2%D1` }, \
 	24 { `xt_clear_indication (rtn)` }, \
 	\* {  unknown subhook $HD $ERROR }
259 1.0 'NETIF_SER' \
 	$HD%D1, \
 	5  { `slattach (entry)  unit=$D1%D1` }, \
 	6  { `slattach (rtn)` }, \
 	7  { `sl_detach (entry)  ifp=$D1%XW` }, \
 	8  { `sl_detach (rtn)` }, \
 	9  { `slinit (entry)` }, \
 	10 { `slinit (rtn)` }, \
 	11 { `slioctl (entry)  ifp=$D1%XW, cmd=$D2%D1 data=$D3%XW` }, \
 	12 { `slioctl (rtn) error=$D1%D1` }, \
 	13 { `sloutput(entry) ifp=$D1%XW m=$D2%XW family=$D3%D1 `ipaddr=sinaddr($D4) }, \
 	14 { `sloutput (rtn) error=$D1%D1` }, \
 	15 { `slreset (entry)` }, \
 	16 { `slreset (rtn)` }, \
 	25 { `slstart slip HIWAT reached ifp=$D1%XW hiwat=$D2%D1` }, \
 	\* {  unknown subhook $HD $ERROR }
25A 1.0 L=SVC 'TCPDBG' \
{{ \
soevents(events) \
	BITFLAGS $events, \
	0x0001  "POLLIN", \
	0x0002  "POLLOUT", \
	0x0004  "POLLPRI" \
}} \
{{ \
soflags(flags) \
	BITFLAGS $flags, \
	0x001  "SB_LOCK", \
	0x002  "SB_WANT", \
	0x004  "SB_WAIT", \
	0x008  "SB_SEL", \
	0x010  "SB_ASYNC", \
	0x020  "SB_COLL", \
	0x040  "SB_NOINTR", \
	0x080  "SB_KIODONE", \
	0x100  "SB_NOSELECT" \
}} \
{{ \
tcpflags(flags) \
	BITFLAGS $flags, \
	0x01  "TH_FIN", \
	0x02  "TH_SYN", \
	0x04  "TH_RST", \
	0x08  "TH_PUSH", \
	0x10  "TH_ACK", \
	0x20  "TH_URG" \
}} \
{{ \
sostate(state) \
	BITFLAGS $state, \
	0x001  "SS_NOFDREF", \
	0x002  "SS_ISCONNECTED", \
	0x004  "SS_ISCONNECTING", \
	0x008  "SS_ISDISCONNECTING", \
	0x010  "SS_CANTSENDMORE", \
	0x020  "SS_CANTRCVMORE", \
	0x040  "SS_RCVATMARK", \
	0x080  "SS_PRIV", \
	0x100  "SS_NBIO", \
	0x200  "SS_ASYNC", \
	0x400  "SS_ISCONFIRMING" \
}} \
{{ \
tcbflags(flags) \
	BITFLAGS $flags, \
	0x001  "TF_ACKNOW", \
	0x002  "TF_DELACK", \
	0x004  "TF_NODELAY", \
	0x008  "TF_NOOPT", \
	0x010  "TF_SENTFIN", \
	0x020  "TF_RFC1323", \
	0x040  "TF_SENT_WS", \
	0x080  "TF_RCVD_WS", \
	0x100  "TF_SENT_TS", \
	0x200  "TF_RCVD_TS" \
}} \
{{ \
sotype(type) \
	$type%D1, \
	1  "SOCK_STREAM", \
	2  "SOCK_DGRAM", \
	3  "SOCK_RAW", \
	4  "SOCK_RDM", \
	5  "SOCK_SEQPACKET" \
}} \
{{ \
soopts(opt) \
	BITFLAGS $opt%XW, \
	0x0001  "SO_DEBUG",\
	0x0002  "SO_ACCEPTCONN", \
	0x0004  "SO_REUSEADDR", \
	0x0008  "SO_KEEPALIVE", \
	0x0010  "SO_DONTROUTE", \
	0x0020  "SO_BROADCAST", \
	0x0040  "SO_USELOOPBACK", \
	0x0080  "SO_LINGER", \
	0x0100  "SO_OOBINLINE", \
	0x1001  "SO_SNDBUF", \
	0x1002  "SO_RCVBUF", \
	0x1003  "SO_SNDLOWAT", \
	0x1004  "SO_RCVLOWAT", \
	0x1005  "SO_SNDTIMEO", \
	0x1006  "SO_RCVTIMEO", \
	0x1007  "SO_ERROR", \
	0x1008  "SO_TYPE" \
}} \
{{ \
oobflags(flags) \
	BITFLAGS $flags%X2, \
	0x01  "TCPOOB_HAVEDATA",\
	0x02  "TCPOOB_HADDATA" \
}} \
{{ \
pract(act) \
	$act%D1, \
	0  "TA_INPUT", \
	1  "TA_OUTPUT", \
	2  "TA_USER", \
	3  "TA_RESPOND", \
	4  "TA_DROP" \
}} \
{{ \
tcpstate(tstate) \
	$tstate%D1, \
	0  "CLOSED", \
	1  "LISTEN", \
	2  "SYN_SENT", \
	3  "SYN_RECEIVED", \
	4  "ESTABLISHED", \
	5  "CLOSE_WAIT", \
	6  "FIN_WAIT_1", \
	7  "CLOSING", \
	8  "LAST_ACK", \
	9  "FIN_WAIT_2", \
	10 "TIME_WAIT" \
}} \
{{ \
prreq(req) \
	$req%D1, \
	0  "PRU_ATTACH", \
	1  "PRU_DETACH", \
	2  "PRU_BIND", \
	3  "PRU_LISTEN", \
	4  "PRU_CONNECT", \
	5  "PRU_ACCEPT", \
	6  "PRU_DISCONNECT", \
	7  "PRU_SHUTDOWN", \
	8  "PRU_RCVD", \
	9  "PRU_SEND", \
	10 "PRU_ABORT", \
	11 "PRU_CONTROL", \
	12 "PRU_SENSE", \
	13 "PRU_RCVOOB", \
	14 "PRU_SENDOOB", \
	15 "PRU_SOCKADDR", \
	16 "PRU_PEERADDR", \
	17 "PRU_CONNECT2", \
	18 "PRU_FASTTIMO", \
	19 "PRU_SLOWTIMO", \
	20 "PRU_PROTORCV", \
	21 "PRU_PROTOSEND" \
}} \
{{ \
prbuf(x) \
	`cc:UW  hiwat:UW  mbcnt:UW  mbmax:UW  lowat:DW`"\n\t\t\t" \
	`mb:XW  sel:XW  ` \
	$HOOKENV,  \
        '32' { O4 }, \
	'64' { O8 } \
	{{ $events = X2 }} `reqevents:$events (`soevents($events)")\n\t\t\t" \
        O2 \
	$HOOKENV,  \
	'64' { O4 } \
	`iodone:XW  ioarg:XW ` \
        ` lastpkt:XW `"\n\t\t\t"\
        `wakeone:XW  timer:XW` \
	{{ $flags = X2 }} `flags:$flags (`soflags($flags)")\n\t\t\t" \
	`timeo:D2 `  \
        $HOOKENV, \
        '32' { O12 }, \
        '64' { O28 } \
}} \
{{ \
prto6(x) \
        "\n\t" \
        O4 \
        `tcpip ipv6 hdr : len:U2  nh:U1  hlimit:U1`"\n\t\t" \
        `src:X2:X2:X2:X2:X2:X2:X2:X2`"\n\t\t" \
	`dst:X2:X2:X2:X2:X2:X2:X2:X2`"\n\t\t" \
}} \
{{ \
prto(x) \
        "\n\t" \
        `tcpip ipv4 hdr: next:X4  prev:X4  ` \
        O1  \
        `pr:U1  len:U2`"\n\t\t" \
        `src:`sinaddr(X4)`  dst:`sinaddr(X4)  \
}} \
{{ \
prth(x) \
        `sport:U2  dport:U2`"\n\t\t" \
        `seq:X4  ack:X4  ` \
        {{ $off = X1 }} {{ $off = $off%W4.7 }} `off:$off%D1` "\n\t\t" \
        {{ $flags = X1 }} `flags:$flags (`tcpflags($flags)")\n\t\t" \
        `win:X2 ` \
        `sum:X2  urp:X2` \
}} \
{{ \
prti(x) \
        R4 {{ $family = X1 }}\
        `family:$family` \
        O3  \
        $family, \
        18  { \
	      O4 \
                {{ $prlen = U2 }} R6 \
	  }, \
        \*  { \
	      $HOOKENV, \
        	      '32' { O10 \
		    {{ $prlen = U2 }} R12 }, \
	      '64' { O18 \
		    {{ $prlen = U2 }} R20 } \
            } \
        $prlen & 0xffffff, \
        0  { O40 \
           $HOOKENV, \
           '32' { O20 }, \
           '64' { O24 } \
           }, \
        \* { \
           $family, \
           18  { \
              prto6() \
              prth()  \
	      $HOOKENV, \
	      '64' { O4 } \
              }, \
           \* { \
              prto() \
              prth() \
              $HOOKENV, \
              '32' { O20 }, \
              '64' { O24 } \
              } \
           } \
}} \
{{ \
prtcb(x) \
	"\n\t" \
	`tcpcb:`"\t"`next:XW  prev:XW  ` \
	{{ $state = X2  }} `state:$state (`tcpstate($state)")\n\t\t" \
	{{ $softerror = X2 }} \
	`TCPT_REXMT:D2 ` \
        `TCPT_PERSIST:D2  `\
        `TCPT_KEEP:D2  `\
        `TCPT_2MSL:D2`"\n\t\t" \
	`rxtshift:X2  `\
        `rxtcur:X2  dupacks:X2 ` \
	O2 \
        `maxseg:X4`"\n\t\t" \
	{{ $flags = X4 }} `flags:$flags (`tcbflags($flags)`)`"\n" \
        "\t\t" `force:X1  ` \
	{{ $flags = X1 }} `oobflags:$flags (`oobflags($flags)\
        `)  iobc:X1 ` \
        O1 \
	`  template:XW`"\n\t\t" \
        $HOOKENV, \
        '32' { O76 }, \
        '64' { O72 } \
	`inpcb:XW timestamp:X4 snd_una:X4 snd_nxt:X4`"\n\t\t" \
	`snd_up:X4  snd_wl1:X4  snd_wl2:X4`"\n\t\t" \
	`iss:X4 ` \
        $HOOKENV, \
        '64' { O4 } \
        `snd_wnd:UW  rcv_wnd:UW`"\n\t\t" \
	`rcv_nxt:X4  rcv_up:X4  irs:X4`"\n\t\t" \
	`snd_wnd_scale:D2  rcv_wnd_scale:D2  `\
        `req_scale_sent:D2`"\n\t\t" \
	`req_scale_rcvd:D2  `\
        `last_ack_sent:X4  timestamp_recent:U4`"\n\t\t" \
	`timestamp_age:D4  rcv_adv:X4  snd_max:X4`"\n\t\t" \
	`snd_cwnd:UW  snd_ssthresh:UW  `\
        `idle:D2  rtt:D2`"\n\t\t" \
	`rtseq:X4  `\
        `srtt:D2  rttvar:D2  `\
        `rttmin:U2 ` \
        O2 \
        ` max_rcvd:UW` \
        ` max_sndwnd:UW`"\n\t\t" \
        `peermaxseg:X4  snd_in_pipe:X4` "\n\t\t" \
	`softerror:$softerror%D1 (`$softerror%E2`)` \
        $HOOKENV, \
        '32' { O36 }, \
        '64' { O48 } \
}} \
{{ \
prsock(sock) \
	`socket $sock%XW: ` \
	{{ $type = X2 }} `type:$type (`sotype($type)")\n\t\t" \
	{{ $opts = X2 }} `opts:$opts (`soopts($opts)")\n\t\t" \
	`linger:X2  ` \
	{{ $state = X2 }} `state:$state (`sostate($state)")\n\t\t" \
	`pcb:XW   proto:XW ` \
        $HOOKENV, \
        '32' { O4 }, \
        '64' { O8 } \
        ` head:XW  q0:XW`"\n\t\t" \
	`q:XW  `\
        $HOOKENV, \
        '32' { O4 }, \
        '64' { O8 } \
	`q0len:D2  qlen:D2  `\
        `qlimit:D2 ` \
        O2 \
        `timeo:D2`"\n\t\t" \
	`error:U2 `\
        O4 \
        ` pgid:DW  oobmark:UW`"\n\t\t" \
	`rcv:`"\t"prbuf()"\n\t\t" \
	`snd:`"\t"prbuf()"\n\t\t" \
	`tpcb:XW`"\n" \
}} \
 	$D1%D1, \
	0   { \
	      $HOOKENV, \
	      '32' { W3 }, \
	      '64' { O12 } \
	      "\t" \
	      {{ $act = X2 }} {{ $ostate = X2 }} {{ $tcb = XW }} \
	      O2 {{ $trclev = X2 }} \
	      `tcb $tcb%XW: `pract($act)`: ostate:$ostate` \
	      `(`tcpstate($ostate)`)` \
	      `trclev:$trclev` \
	      $act, \
	      0   { prti() O4 prtcb()"\n" }, \
	      1   { prti() O4 prtcb()"\n" }, \
	      2   { prti()  \
		      {{ $req = X2 }} `  req:$req (`prreq($req)`)` \
		      O2  prtcb()"\n" }, \
	      3   { prti() O4 prtcb()"\n" }, \
	      4   { prti() O4 prtcb()"\n" }, \
	      \*  { `unknown action $act` } \
	      "\t" \
	      {{ $taille = D1 }} \
	      `tcp opt: ` `tcpOpt_size = ` $taille%DW "\t" `tcp_opt :` LOOP $taille { X1 } "\n" \
	    }, \
          1   { \
	      $HOOKENV, \
	      '32' { W3 }, \
	      '64' { O12 } \
	      "\t" \
                {{ $act = X2 }} {{ $ostate = X2 }} {{ $tcb = XW }} \
	      O2 {{ $trclev = X2 }} \
                `tcb $tcb%XW: `pract($act)`: ostate:$ostate` \
                `(`tcpstate($ostate)`)` \
               `trclev:$trclev` \
	      $act, \
	      0   { prti() O4 }, \
	      1   { prti() O4 }, \
	      2   { prti()  \
		      {{ $req = X2 }} `  req:$req (`prreq($req)`)` O2 }, \
	      3   { prti() O4 }, \
	      4   { prti() O4 }, \
	      \*  { `unknown action $act` } \
	    }, \
	2   { \
	     `socket : ` $D2%XW \
	    }, \
        	\*  { \
	    W2 "\t" \
	    prsock($D1) \
	    }
272 1.0 L=KERN "@PSLA DR. OPEN(X) CALL " \
	D2, \
	0 "psla open(x) entry" {dev#=$D1 mode=$D2 channel=$D3 opnparms \
          	struct ptr=$D4}, \
	1 "psla open(x) return", \
	2 "ERROR-psla open(x) return" {errno=EW dev mnr#=$D2}, \
	3 "ERROR-psla open(x) return, diag. mode" {errno=EW}, \
	4 "psla open(x) return" {errno=E4 dev mnr#=$D2 status=\
		$D3%DW, \
		1 "IO NOT ALLOWED",\
		2 "GSW NOT CONF",\
		3 "SWITCHED TO HOST",\
		4 "NOT YET READY"}
273 1.0 L=KERN "@PSLA DR. CLOSE CALL" \
	D2, \
	0 "psla close entry" {dev#=$D1 mode=$D2 channel=$D3 opnparms \
          	struct ptr=$D4}, \
	1 "psla close return", \
	2 "ERROR-psla close return" {errno=E4 dev mnr#=$D2}
274 1.0 L=KERN "@PSLA DR. READ CALL" \
	D2, \
	0 "psla read entry" {dev#=$D1 uio struct ptr=$D2 channel=$D3 \
		rw_args union ptr=$D4}, \
	1 "psla read return", \
	2 "ERROR-psla read return" {errno=EW dev mnr#=$D2}, \
        3 "ERROR-psla read return" {errno=EW dev mnr#=$D2 dev mode=$D3}, \
	4 "ERROR-psla read return" {errno=EW dev mnr#=$D2 byte count=$D3%DW}
275 1.0 L=KERN "@PSLA DR. WRITE CALL" \
	D2, \
	0 "psla write entry" {dev#=$D1 uio struct ptr=$D2 \
		channel=$D3 lrw_args union ptr=$D4}, \
	1 "psla write return", \
	2 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2}, \
        3 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 dev mode=$D3}, \
	4 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 byte count=$D3%D4}
276 1.0 L=KERN "@PSLA DR. IOCTL CALLS " \
{{ \
ioctlcmds(cmd) \
	$cmd%D1, \
	10 "G_SET_MEM", \
 	11 "G_ALARM", \
	12 "G_STOP", \
	13 "G_START", \
	14 "G_SET_BF", \
	15 "G_SBF_START", \
	16 "G_SET_CUR", \
	17 "G_RESET_CUR", \
	18 "G_SET_IND", \
	19 "G_SET_IND_ON", \
	20 "G_SET_IND_OFF", \
	21 "G_WRITESF", \
	22 "G_DEF_MEM", \
	23 "G_DEL_MEM", \
	24 "G_REN_MEM", \
	25 "G_LOAD_BLNK", \
	26 "G_LOAD_LINE", \
	27 "G_READ_CUR", \
	28 "G_SENSE", \
	29 "G_LOAD_MEM_AREA", \
	31 "G_IOCTL", \
	32 "MSLA_START_DIAG", \
        33 "MSLA_QUERY_DIAG", \
        34 "MSLA_STOP_DIAG", \
	35 "MSLA_GET_ADDR", \
	36 "MSLA_RET_ADDR", \
	37 "MSLA_MOD_POS", \
	38 "MSLA_LOAD_UCODE", \
	39 "MSLA_START_DMA", \
	40 "MSLA_STOP_DMA", \
	65 "K_ENABLE", \
	66 "K_DISABLE", \
	67 "K_ENA_SIG", \
	68 "K_DIS_SIG", \
	69 "K_POLL", \
	70 "K_WAIT", \
	71 "K_FLUSH", \
	72 "K_REQUEST", \
	73 "K_STOP_DEVICE", \
	74 "K_LCW", \
	75 "FPGI_CONNECT", \
	76 "FPGI_DISCONNECT", \
	77 "FPGI_INFREE", \
	78 "FPGI_SEND", \
	79 "FPGI_WAIT", \
	/* "UNKNOWN input type" \
}} \
{{ \
intypes(itypes) \
	BITFLAGS $itypes, \
	0x01 "GPICK", \
	0x02 "GANK", \
	0x04 "GPFK", \
	0x08 "GLPFK", \
	0x10 "GTABLET", \
	0x20 "GSMI", \
	0x40 "GGEOP", \
	0x80 "GPGM_ERR" \
}} \
	D2, \
	0 "psla ioctl entry" {dev#=$D1 G11 ioctlcmds(X1) \
          "," ctl_args union ptr=$D3 flags=$D4}, \
	1 "psla ioctl return", \
	2 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2}, \
	3 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 \
	$HOOKENV, \
	'64' { G31 }, \
        '32' { G15 } \
	ioctlcmds(X1) "," ctl_args union ptr=$D4}, \
	4 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 \
	$HOOKENV, \
	'64' { G31 }, \
        '32' { G15 }  ioctlcmds(X1) \
	  "," blnk_number=DW blnk_pattern=DW}, \
	5 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 \
	$HOOKENV, \
	'64' { G31 }, \
        '32' { G15 }  ioctlcmds(X1) \
	  "," data length=DW}, \
	6 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 \
	$HOOKENV, \
	'64' { G31 }, \
        '32' { G15 }  ioctlcmds(X1) \
          "," input type=D4, 0 "GPICK", 1 "GANK", 2 "GPFK", 3 "GLPFK", \
          4 "GTABLET", 5 "GSMI", 6 "GGEOP", 7 "GPGM_ERR"}, \
	7 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 ntr. queue ptr=$D3 \
          input type=$D4%DW, 0 "GPICK", 1 "GANK", 2 "GPFK", 3 "GLPFK", \
          4 "GTABLET", 5 "GSMI", 6 "GGEOP", 7 "GPGM_ERR"}, \
	8 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 \
	$HOOKENV, \
	'64' { G31 },\
        '32' { G15 }  ioctlcmds(X1) \
	$HOOKENV, \
	'64' { G39 },\
        '32' { G19 } input types=intypes(X1)},\
	9 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2 \
	$HOOKENV, \
	'64' { G31 },\
        '32' { G15 }  ioctlcmds(X1)}, \
	10 "ERROR-psla ioctl return" {errno=EW dev mnr#=$D2  \
	$HOOKENV, \
	'64' { G31 }, \
        '32' { G15 }  \
           ioctlcmds(X1) "," struct fld ptr=$D4 write struc len=$D5%DW}, \
	11 "psla ioctl" {dev mnr#=$D1 G11 ioctlcmds(X1)  \
	$HOOKENV, \
	'64' { G31 }, \
        '32' { G15 }  \
           "," input types=intypes(X1)}
277 1.0 L=INT "@PSLA INTERRUPT HANDLER " \
{{ \
cmdcccodes(ccodes) \
	$ccodes, \
	0x04 "RdSense,", \
	0x05 "WrStruct,", \
	0x09 "WrMemArea,", \
	0x0A "RdMemArea,", \
	0x0E "Rmi,", \
	0x2B "SelcRdMemArea,", \
	0xF7 "SetMode,", \
	0xFB "SelcWrMemArea,", \
	0xFF "UnDefCmd," \
}} \
{{ \
initcccodes(intcode) \
	$intcodes, \
	0x01 "StartCmd,", \
	0x02 "StopCmd,", \
	0x03 "EnterMonMode,", \
	0x04 "ConfigDataPres,", \
	0x05 "DevNotPres,", \
	0x06 "DevNotResp,", \
	0x07 "LinkDown," \
}} \
{{ \
intrcodes(icodes) \
	$icodes, \
	0x00 {Cmd  $HOOKENV , '64' { G31 }, '32' { G15 } ccc=cmdcccodes(X1)}, \
	0x01 {LinkSwitch $HOOKENV , '64' { G31 }, '32' { G15 } \
		ccc=X1, 0x00 "connect host",  0x01 "connect pc"}, \
	0x02 "Diag,", \
	0x03 "Debug,", \
	0x04 {Init $HOOKENV , '64' { G31 }, '32' { G15 } ccc=initcccodes(X1)}, \
	0x05 "Progcode,", \
	0x06 "UnSolDevReq,", \
	0x07 "AdapterErr," \
}} \
{{ \
status(stat) \
	BITFLAGS $stat, \
 	0x80 "attention ", \
	0x40 "stat modifier ", \
	0x20 "adapter ready ", \
	0x10 "busy ", \
	0x08 "adapter end ", \
	0x04 "device end ", \
	0x02 "unit check ", \
	0x01 "unit exception " \
}} \
{{ \
pslaflags(flags) \
   	BITFLAGS $flags, \
	0x8000 "Solo in prog", \
	0x4000 "Rmi in prog", \
	0x2000 "Retry in prog", \
	0x1000 "Ipl_req", \
	0x0800 "Ipl in prog", \
	0x0400 "Dma enabled", \
	0x0200 "Start in prog", \
	0x0100 "stop in prog", \
	0x0080 "Need start", \
	0x0040 "Need stop", \
	0x0020 "Fpgi solo in prog", \
	0x0010 "Intio in prog" \
}} \
{{ \
retcode(rcode) \
	$rcode, \
	0x80 "Link monitor mode", \
	0x50 "No RMI data", \
	0x51 "No 5080 present", \
	0x52 "No resp. to req.", \
	0x70 "Host link down", \
	0x3F "Sense from bad async", \
        0x3E "Sense from bad SIO", \
	0x34 "Sense area not defined", \
	0x35 "Sense area full", \
	0x36 "Sense timeout occured" \
}} \
	D2, \
	0 "psla intr. hdlr entry" {struct intr ptr=$D1}, \
	1 "psla intr. data:" {dev mnr#=$D1 G11 icc=intrcodes(X1) \n\
        $HOOKENV, \
	 '64' { G39 }, '32' { G15 } status=status(X1) "," \
	$HOOKENV , \
	'64' { G46 }, '32' { G22 } pslaflags(X2)}, \
	2 "psla intr hdlr return, not psla intr" \
	{ $HOOKENV, \
	'64' { G15 }, '32' { G7 } stat reg=X1}, \
	3 "psla intr hdlr return, diag. mode, parity check", \
	4 "psla intr hdlr return, parity check, not sftwr intr.", \
	5 "psla intr hdlr return,diag. mode", \
	6 "psla intr hdlr return, not a sftwr intr.", \
	7 "psla intr hdlr return"  \
        { $HOOKENV, \
         '64' { G15 }, '32' { G7 }  retcode(X1)}, \
	8 "ERROR-Fatal, psla intr hdlr return", \
        9 "ERROR-device not open", \
       10 "psla intr hdlr return" {type=D4, 5 "GSMI", 6 "GGEOP" \
	  "," intr. queue ptr=$D2}, \
       11 "psla intr hdlr," { \
          input type=D4, 0 "GPICK", 1 "GANK", 2 "GPFK", 3 "GLPFK", \
          4 "GTABLET", 5 "GSMI", 6 "GGEOP", 7 "GPGM_ERR"}
278 1.0 L=KERN "@PSLA DR. CONFIG CALL " \
	D2, \
	0 "psla config entry" {dev #=$D1 cmd=$D2%DW, 1 "CFG_INIT ", \
          2 "CFG_TERM ", 3 "CFG_QVPD " struct uio ptr=$D3}, \
        1 "psla config return", \
	2 "ERROR-psla config return" {errno=EW}, \
	3 "psla config return, already configured", \
	4 "ERROR-psla config, in uimove" {errno=EW dds ptr=$D2 \
          dds size=$D3%DW uio struct ptr=$D4}, \
	5 "ERROR-psla config, in define" {errno=EW dev #=$D2 dds ptr=$D3}, \
	6 "ERROR-psla config, in devswadd" {errno=EW}, \
	7 "ERROR-psla config, in i_init", \
	8 "ERROR-psla config, in xmalloc" {errno=EW}, \
	9 "ERROR-psla config return" {errno=EW,dev mnr#=$D2}, \
       10 "ERROR-psla config, in loadpos" {errno=EW}
280 1.0 "HIADD" \
   {{ $loc = X1 }} \
   $loc, \
   21  { "ID:" O1 A4.8  \
      "d1=" XW " d2=" XW " d3=" XW " d4=" XW \
      }
292 1.0 "VCA DEVICE DRIVER" \
	{{ $loc = X1 }} \
	$loc, \
	0x1 { "entry_vca_open:" \
		"errno:" X1 "dev:" XW \
		"flag:" XW "channel:" XW "ext:" XW}, \
	0x2 { "exit_vca_open:" \
		"errno:" X1 "dev:" XW \
		"flag:" XW "channel:" XW "ext:" XW}, \
	0x3 { "entry_vca_close:" \
		"errno:" X1 "dev:" XW \
		"flag:" XW "ext:" XW }, \
	0x4 { "exit_close:" \
		"errno:" X1 "dev:" XW \
		"flag:" XW "ext:" XW }, \
	0x5 { "entry_vca_read:" \
		"errno:" X1 "dev:" XW \
		"uiop:" XW "mpschan:" XW "ext:" XW}, \
	0x6 { "exit_vca_read:" \
		"errno:" X1 "dev:" XW \
		"uiop:" XW "mpschan:" XW "ext:" XW}, \
	0x7 { "entry_vca_write:" \
		"errno:" X1 "dev:" XW \
		"uiop:" XW "mpschan:" XW "ext:" XW}, \
	0x8 { "exit_vca_write:" \
		"errno:" X1 "dev:" XW \
		"uiop:" XW "mpschan:" XW "ext:" XW}, \
	0x9 { "entry_vca_config:" \
		"errno:" X1 "dev:" XW \
		"cmd:" XW "uiop:" XW }, \
	0xA { "exit_vca_config:" \
		"errno:" X1 "dev:" XW \
		"cmd:" XW "uiop:" XW}, \
	0xB { "entry_vca_ioctl:" \
		"errno:" X1 "dev:" XW \
		"cmd:" XW "arg:" XW "flag:" XW "channel:" XW}, \
	0xC { "exit_vca_ioctl:" \
		"errno:" X1 "dev:" XW \
		"cmd:" XW "arg:" XW "flag:" XW "channel:" XW}, \
	0xD { "entry_vca_setup:" \
		"errno:" X1 "current_vca:" XW }, \
	0xE { "exit_vca_setup:" \
		"errno:" X1 "current_vca:" XW }, \
	0xF { "entry_vca_memcopy:" \
		"errno:" X1 "current_vca:" XW \
		"offset:" XW "count:" XW "direction:" XW }, \
	0x10 { "exit_vca_memcopy:" \
		"errno:" X1 "current_vca:" XW \
		"offset:" XW "count:" XW "direction:" XW }, \
	0x11 { "entry_mem_setup:" \
		"errno:" X1 "current_vca:" XW \
		"paddr:" XW "block:" XW \
		$HOOKENV, \
		'64' { O4 } "taram:" X2 }, \
	0x12 { "exit_mem_setup:" \
		"errno:" X1 "current_vca:" XW \
		"paddr:" XW "block:" XW \
		$HOOKENV, \
		'64' { O4 } "taram:" X2 }, \
	0x13 { "entry_mem_unset:" \
		"errno:" X1 "current_vca:" XW \
		"vaddr:" XW }, \
	0x14 { "exit_mem_unset:" \
		"errno:" X1 "current_vca:" XW \
		"vaddr:" XW }, \
	0x15 { "entry_getstatus:" \
		"errno:" X1 "current_vca:" XW }, \
	0x16 { "exit_getstatus:" \
		"errno:" X1 "current_vca:" XW }, \
	0x17 { "entry_setmask:" \
		"errno:" X1 "current_vca:" XW "mask:" XW }, \
	0x18 { "exit_setmask:" \
		"errno:" X1 "current_vca:" XW "mask:" XW }, \
	0x19 { "entry_capture_wait:" \
		"errno:" X1 "current_vca:" XW "seconds:" XW }, \
	0x1A { "exit_capture_wait:" \
		"errno:" X1 "current_vca:" XW "seconds:" XW }, \
	0x1B { "entry_intr_enable:" \
		"errno:" X1 "current_vca:" XW }, \
	0x1C { "exit_intr_enable:" \
		"errno:" X1 "current_vca:" XW }, \
	0x1D { "entry_intr_disable:" \
		"errno:" X1 "current_vca:" XW }, \
	0x1E { "exit_intr_disable:" \
		"errno:" X1 "current_vca:" XW }, \
	0x1F { "entry_vca_set_mode:" \
		"errno:" X1 "current_vca:" XW "vca_mode_ptr:" XW }, \
	0x20 { "exit_vca_set_mode:" \
		"errno:" X1 "current_vca:" XW "vca_mode_ptr:" XW }, \
	0x21 { "entry_vca_set_controls:" \
		"errno:" X1 "current_vca:" XW "vca_controls_ptr:" XW }, \
	0x22 { "exit_vca_set_controls:" \
		"errno:" X1 "current_vca:" XW "vca_controls_ptr:" XW }, \
	0x23 { "entry_vca_set_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \
	0x24 { "exit_vca_set_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \
	0x25 { "entry_vca_set_window:" \
		"errno:" X1 "current_vca:" XW "vca_window_ptr:" XW }, \
	0x26 { "exit_vca_set_window:" \
		"errno:" X1 "current_vca:" XW "vca_window_ptr:" XW }, \
	0x27 { "entry_vca_set_dacs:" \
		"errno:" X1 "current_vca:" XW "vca_dacs_ptr:" XW }, \
	0x28 { "exit_vca_set_dacs:" \
		"errno:" X1 "current_vca:" XW "vca_dacs_ptr:" XW }, \
	0x29 { "entry_vca_altdac:" \
		"errno:" X1 "current_vca:" XW "dacno:" XW \
		$HOOKENV, \
		'64' { O4 } "color:" X2 }, \
	0x2A { "exit_vca_altdac:" \
		"errno:" X1 "current_vca:" XW "dacno:" XW \
		$HOOKENV, \
		'64' { O4 } "color:" X2 }, \
	0x2B { "entry_vca_get_mode:" \
		"errno:" X1 "current_vca:" XW "vca_mode_ptr:" XW }, \
	0x2C { "exit_vca_get_mode:" \
		"errno:" X1 "current_vca:" XW "vca_mode_ptr:" XW }, \
	0x2D { "entry_vca_get_controls:" \
		"errno:" X1 "current_vca:" XW "vca_controls_ptr:" XW }, \
	0x2E { "exit_vca_get_controls:" \
		"errno:" X1 "current_vca:" XW "vca_controls_ptr:" XW }, \
	0x2F { "entry_vca_get_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \
	0x30 { "exit_vca_get_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \
	0x31 { "entry_vca_get_window:" \
		"errno:" X1 "current_vca:" XW "vca_window_ptr:" XW }, \
	0x32 { "exit_vca_get_window:" \
		"errno:" X1 "current_vca:" XW "vca_window_ptr:" XW }, \
	0x33 { "entry_vca_get_dacs:" \
		"errno:" X1 "current_vca:" XW "vca_dacs_ptr:" W4 }, \
	0x34 { "exit_vca_get_dacs:" \
		"errno:" X1 "current_vca:" XW "vca_dacs_ptr:" XW }, \
	0x35 { "entry_readdac:" \
		"errno:" X1 "current_vca:" XW "dacno:" XW }, \
	0x36 { "exit_readdac:" \
		"errno:" X1 "current_vca:" XW "dacno:" XW }, \
	0x37 { "entry_vca_set_dac_defaults:" \
		"errno:" X1 "current_vca:" XW "dacs_ptr:" XW }, \
	0x38 { "exit_vca_set_dac_defaults:" \
		"errno:" X1 "current_vca:" XW "dacs_ptr:" XW }, \
	0x39 { "entry_vca_intr:" \
		"errno:" X1 "handler:" XW }, \
	0x3A { "exit_vca_intr:" \
		"errno:" X1 "handler:" XW }, \
	0x3B { "entry_vca_outb:" \
		"errno:" X1 "port:" XW \
		$HOOKENV, \
		'64' { O4 } "data:" X1 }, \
	0x3C { "exit_vca_outb:" \
		"errno:" X1 "port:" XW \
		$HOOKENV, \
		'64' { O4 } "data:" X1 }, \
	0x3D { "entry_vca_inb:" \
		"errno:" X1 "port:" XW }, \
	0x3E { "exit_vca_inb:" \
		"errno:" X1 "port:" XW }, \
	0x3F { "entry_vca_timed_out:" \
		"errno:" X1 "w:" X4 }, \
	0x40 { "exit_vca_timed_out:" \
		"errno:" X1 "w:" XW }, \
	0x41 { "entry_vca_altreg:" \
		"errno:" X1 "current_vca:" XW  "reg:" XW \
		$HOOKENV, \
		'64' { O4 } "value:" X1 }, \
	0x42 { "exit_vca_altreg:" \
		"errno:" X1 "current_vca:" XW  "reg:" XW \
		$HOOKENV, \
		'64' { O4 } "value:" X1 }, \
	0x43 {  "entry_vca_readreg:"\
		"errno:" X1 "current_vca:" XW "reg:" XW }, \
	0x44 { "exit_vca_readreg:" \
		"errno:" X1 "current_vca:" XW "reg:" XW }, \
	0x45 { "entry_vca_kset_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \
	0x46 { "exit_vca_kset_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \ 0x47 { "entry_vca_kget_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \
	0x48 { "exit_vca_kget_cursor:" \
		"errno:" X1 "current_vca:" XW "vca_cursor_ptr:" XW }, \
	0x49 { "entry_vca_delay:" \
		"errno:" X1 "current_vca:" XW }, \
	0x4A { "exit_vca_delay:" \
		"errno:" X1 "current_vca:" XW }, \
	0x4B { "entry_vca_initialize:" \
		"errno:" X1 "current_vca:" XW }, \
	0x4C { "exit_vca_initialize:" \
		"errno:" X1 "current_vca:" XW }, \
	0x4D { "entry_vcaerr:" \
		"errno:" X1 "errid:" XW "lname:" XW "line_num:" XW \
		"dmodule:" XW "fmodule:" XW}, \
	0x4E { "exit_vcaerr:" \
		"errno:" X1 "errid:" XW "lname:" XW "line_num:" XW \
		"dmodule:" XW "fmodule:" XW}
2ED 1.0 "@nbc" \
        "NBC: " \
	$HOOKENV, \
	'64' { O6 }, \
	'32' { O2 } A4.8 "d1=" XW " d2=" XW " d3=" XW
2F9 1.0 "WLM" \
	$HD, \
	0x1 { `EXCL UID: pid=`prKernelPID($D1)` ruid=$D2%D4` },\
	0x2 { `EXCL GID: pid=`prKernelPID($D1)` rgid=$D2%D4` },\
	0x3 { `EXCL FILE: pid=`prKernelPID($D1)` dev=$D2%D4 inode=$D3%D4 gen=$D4%D4` },\
	0x4 { `FND: pid=`prKernelPID($D1)` class=$D2%D4 ruid=$D3%D4 rgid=$D4%D4 inode=$D5%D4` },\
	0x5 { `SYS CLASS: pid=`prKernelPID($D1) },\
	0x6 { `DFLT CLASS: pid=`prKernelPID($D1)` ruid=$D2%D4` },\
	0x7 { `CHNG CLASS: pid=`prKernelPID($D1)` old class=$D2%D4 new class=$D3%D4` },\
	0x8 { `SET LENGTH: pid=`prKernelPID($D1)` flag=$D2%X4 old length=$D3%D4 new length=$D4%D4` },\
	0x9 { "SET: pid="prKernelPID($D1)" flag="$D2%X4" old wlm_on=" \
		BITFLAGS $D3, \
			& 0x1 0x1 "CLASSIF", \
			& 0x10 0x10 "CPU_ACCT", \
			& 0x20 0x20 "CPU_REGUL", \
			& 0x40 0x80 "MEM_ACCT", \
			& 0x80 0x80 "MEM_REGUL", \
			& 0x100 0x100 "CHNG_LEN", \
			& 0x200 0x200 "TEST_ON", \
			& 0xffff 0x0 "-EMPTY-" \
		"new wlm_on="\
		BITFLAGS $D4, \
			& 0x1 0x1 "CLASSIF", \
			& 0x10 0x10 "CPU_ACCT", \
			& 0x20 0x20 "CPU_REGUL", \
			& 0x40 0x80 "MEM_ACCT", \
			& 0x80 0x80 "MEM_REGUL", \
			& 0x100 0x100 "CHNG_LEN", \
			& 0x200 0x200 "TEST_ON", \
			& 0xffff 0x0 "-EMPTY-" \
                },\
	0xa { `SWAPOUT: tier=$D1%D4 pid=`prKernelPID($D2) },\
	0xb { `PRIO UPDT class=$D1%D4 act_prev=$D2%D4 act=$D3%D4 old_pri=$D4%D4 new_pri=$D5%D4` },\
	0xc { `LOAD CLASS ON: CPU:min=$D1%D4 shares=$D2%D4 max=$D3%D4` },\
	0xd { `LOAD INV ON` },\
	0xe { `LOAD CLASS OFF: CPU:min=$D1%D4 shares=$D2%D4 max=$D3%D4` },\
	0xf { `LOAD NEWCLASS: nb_class=$D1%D4` },\
	0x10 { `LOAD RULES` },\
	0x11 { `UPDT DES START: tier=$D1%D4 tot_cpu_shares=$D2%D4 tot_mem_shares=$D3%D4` },\
	0x12 { `UPDT DES: cpu_des=$D1%D4 mem_des=$D2%D4` },\
	0x13 { O2.0 "NAME: " A16.16 },\
	0x14 { `CCB FULL` },\
	0x15 { `INVAL CLASS` },\
	0x16 { `STOP THREAD: pid=`prKernelPID($D1)` class=$D2%D4 nb_us=$D3%D4 time=$D4%D4` },\
	0x17 { `TIME: class=$D1%D4 ticks=$D2%D4 old_time=$D3%D4 new_time=$D4%D4` },\
        0x65 { `VMM SCB_SETCLASS: sidx=0x$D1%X2 class$D2%D4->class$D3%D4` },\
        0x66 { `VMM INSSCB: DECLASSIFY sidx=0x$D1%X2 segtype=$D2%D4 segcl=$D3%D4 curcl=$D4%D4` },\
        0x67 { `VMM MEMP_LRU: RESTART for RED PAGES mempid=`prKernelPID($D1) },\
        0x68 { `VMM MEMP_LRU: BAILOUT for RED CLASS mempid=`prKernelPID($D1) },\
        0x69 { `VMM FBLRU: BUCKET mempid=`prKernelPID($D1)` nbucket=$D2%D4 pg=$D3%D4 pcol=$D4%D4 col=$D5%D4` },\
        0x6a { `VMM FBLRU: bailout if color<1% mempid=`prKernelPID($D1)` numfrbcol=$D2%D4` },\
        0x6b { `VMM CBLRU: BUCKET mempid=`prKernelPID($D1)` nbucket=$D2%D4 pg=$D3%D4 pcol=$D4%D4 col=$D5%D4` },\
        0x6c { `VMM CBLRU: bailout if color<1% mempid=`prKernelPID($D1)` numfrbcol=$D2%D4` },\
        0xc9 { `BIO QUEUE-IN:   buf=$D1 bdev=$D2 exp time=$D3%D4 urap=$D4%D2 bcount=$D5%D4` },\
        0xca { `BIO QUEUE-OUT:  buf=$D1 bdev=$D2 exp time=$D3%D4 urap=$D4%D2 bcount=$D5%D4` },\
        0xcb { `BIO NOT-QUEUED: buf=$D1 bdev=$D2 bcount=$D3%D4` },\
	\* { `CALL mode=$HD` }
2FC 1.0 L=KERN "@ VMM_VWAIT EVENT" \
        "VMM WAIT: Link Register="$D1
2FD 1.0 L=KERN "RPDP:" \
	$HD, \
	0x0 { `start: failing CPU: $D2%DW (phys. $D1%DW) replacing CPU: $D4%DW (phys. $D3%DW)` }, \
	0x1 { `aborted` }, \
	0x2 { `successfully terminated` }, \
	0x10 { `HA handler: _fun=XW` W2 A4""W3""A4 `_data=XW_XW: ACCEPTED` }, \
	0x11 { `HA handler: _fun=XW` W2 A4""W3""A4 `_data=XW_XW: REFUSED` }, \
	0x20 { `interrupt re-route from phys. CPU $D1%DW to $D2%DW phase=$D3%D4 xchgflag=$D4%D4 ` }, \
	0x30 { `CPU swap: $D2%DW (phys. $D1%DW) <=> $D4%DW (phys. $D3%DW)` }, \
	0x40 { `TRB migrated from CPU $D1%DW to $D2%DW id=$D3%XW flags=$D4%X2 timerid=$D5%XW` }, \
	0x50 { `pal_stop_myself() on CPU $D1%DW (phys. $D2%DW)` }, \
	\*  { unknown subhook }
2FE 1.0 L=KERN "System freeze:" \
	$HD, \
	0x0 { `start on CPU $D1%DW` starttimer(0x2fb,0) starttimer(0x2fb,1) }, \
	0x1 { `end with rc=$D1%EW total freeze time:` endtimer(0x2fb,0) }, \
	0x20 { `master start: timeout=$D1%D4 time_out_signaled=$D2%D4` starttimer(0x2fb,0x20) }, \
	0x21 { `master end with rc=$D1%EW master running time:` endtimer(0x2fb,0x20) \
		`\nSystem freeze: avarage interrupt lock out time:` endtimer(0x2fb,0x40) }, \
	0x30 { `slave command start on CPU $D1%DW` }, \
	0x31 { `slave command end` }, \
	0x40 { `slaves at rendezvous in` endtimer(0x2fb,1) starttimer(0x2fb,0x40) \
		`\nSystem freeze: block all external interrupts` }, \
	0x41 { `re-enable all external interrupts` }, \
	0x50 { `before pal_i_disableplvl($D1)` starttimer(0x50,0x51) }, \
	0x51 { `after pal_i_disableplvl($D1)` endtimer(0x50,0x51) }, \
	0x60 { `before pal_i_enableplvl($D1)` starttimer(0x60,0x61) }, \
	0x61 { `after pal_i_enableplvl($D1)` endtimer(0x60,0x61) }, \
	\*  { unknown subhook }
2FF 1.0 L=KERN "tprof" \
    $GENERIC, \
    1 { \
        $D1%D1, \
            1 { "command: " {{ $notused = X4 }} {{ $strlen = $HL - 4 }} {{$string = $HL%S1}} "cmd=" $string }, \
            \* { "Unknown subhook for 0x2FF: "$HD%D1 } \
    }, \
    0 { \
         {{ $subhookid = $HD & 0xFFF}} \
         $subhookid, \
            2 { "context: frequency="$D1%D4 "UEvtId="$D2%D4 "procidx="$D3%D4 }, \
            3 { W1 "event: iar="X8 "dar="X8 }, \
            4 { "alignment: iar="$D1 "ea="$D2  "tid="$D5%D4}, \
            5 { "emulation: iar="$D1 "tid="$D5%D4}, \
            6 { "islbmiss: ear="$D1 "tid="$D5%D4}, \
            7 { "dslbmiss: ear="$D1 "tid="$D5%D4}, \
            8 { "data: iar="$D1 "dar="$D2 "sid="$D4 "pdar="$D5}, \
            9 { "too rapid sampling: max="$D1%D4}, \
	    a { "Start/Stop user command"}, \
	    b { "Partition migration"}, \
            \* { "Unknown subhook for 0x2FF: "$HD%D1 } \
    } \
    endtimer(0x2FF,0x2FF) starttimer(0x2FF,0x2FF)
300 1.0 "@ODM EVENTS"\
        $HD, \
        1       "ODM:   ADDR_CLXN",\
        2       "ODM:   ADD_VCHAR",\
        3       "ODM:   BREAKCRIT",\
        4       "ODM:   CHANGE_VCHAR",\
        5       "ODM:   CLOSE_CLXN",\
        6       "ODM:   CMPKMCH",\
        7       "ODM:   CREATE_CLXN",\
        8       "ODM:   DESTROY_CLXN",\
        9       "ODM:   GET_OFFSETS",\
        A       "ODM:   GET_STRING_DBOFF",\
        B       "ODM:   GET_VCHAR",\
        C       "ODM:   INIT_CLASS",\
        D       "ODM:   INIT_CLXN",\
        E       "ODM:   INVOKE",\
        F       "ODM:   MOUNT_CLXN",\
        10      "ODM:   NOTE_CLASS",\
        11      "ODM:   ODM_ADD_OBJ",\
        12      "ODM:   ODM_CHANGE_OBJ",\
        13      "ODM:   ODM_CLOSE_CLASS",\
        14      "ODM:   ODM_CREATE_CLASS",\
        15      "ODM:   ODM_FREE_LIST",\
        16      "ODM:   ODM_GET_BY_ID",\
        17      "ODM:   ODM_GET_FIRST",\
        18      "ODM:   ODM_GET_LIST",\
        19      "ODM:   ODM_GET_NEXT",\
        1A      "ODM:   ODM_GET_OBJ",\
        1B      "ODM:   ODM_INITIALIZE",\
        1C      "ODM:   ODM_MOUNT_CLASS",\
        1D      "ODM:   ODM_OPEN_CLASS",\
        1E      "ODM:   ODM_RM_BY_ID",\
        1F      "ODM:   ODM_RM_CLASS",\
        20      "ODM:   ODM_RM_OBJ",\
        21      "ODM:   ODM_SET_PATH",\
        22      "ODM:   ODM_SET_PERMS",\
        23      "ODM:   ODM_TERMINATE",\
        24      "ODM:   OPEN_CLXNP",\
        25      "ODM:   RAW_ADDR_CLASS",\
        26      "ODM:   RAW_ADD_OBJ",\
        27      "ODM:   RAW_ADD_STR",\
        28      "ODM:   RAW_CLOSE_CLASS",\
        29      "ODM:   RAW_CLOSE_CLXN",\
        2A      "ODM:   RAW_FIND_BYID",\
        2B      "ODM:   RAW_FIND_OBJ",\
        2C      "ODM:   RAW_RM_OBJ",\
        2D      "ODM:   VERIFY_CLASS_STRUCTURE",\
        \*      "ODM:   INVALID MODULE ID"\
        $D1,\
        0  " ENTRY",\
        1  " EXIT",\
        \*      "   INVALID DATA VALUE"
340 1.0 'NETM' \
	$GENERIC, \
	1 { \
	DW, \
		1  { `NET_MALLOC addr:XW size:DW type:DW cpu:DW caller1=XW caller2=XW caller3=XW caller4=XW caller5=XW` }, \
		2  { `NET_FREE addr:XW size:DW type:DW cpu:DW caller1=XW caller2=XW caller3=XW caller4=XW caller5=XW` }, \
		128 { `OSTD_ALLOC addr:XW size:DW type:DW cpu:DW caller1=XW caller2=XW caller3=XW caller4=XW caller5=XW` }, \
		\*  { `Unknown Generic hook` } \
		$BREAK \
	} \
	$HD%D1, \
	3  { `net_kmem_inslist_in: addr=$D1%XW kbp=$D2%XW indx=$D3%DW errlevel=$D4%DW srad=$D5%DW` }, \
	4  { `net_kmem_inslist_out` }, \
	5  { `net_kmem_rmlist_in: addr=$D1%XW kbp=$D2%XW indx=$D3%DW errlevel=$D4%DW srad=$D5%DW` }, \
	6  { `net_kmem_rmlist_out` }, \
	7  { `ostd_mem_expand_in` }, \
	8  { `ostd_mem_expand_out` }, \
	9  { `ostd_mem_del_in: addr=$D1%XW size=$D2%DW ostd_idx=$D3%DW` }, \
	10 { `ostd_mem_del_out1: ostd[ostd_idx].d_cnt=$D1%DW` }, \
	11 { `ostd_mem_del_out2` }, \
	12 { `ostd_mem_add_in: ostd_mem_rec=$D1%XW addr=$D2%XW cpu=$D3%DW size=$D4%DW memtype=$D5%DW` }, \
	13 { `ostd_mem_add_out1` }, \
	14 { `ostd_mem_add_out2` }, \
	15 { `log_police_event_in: cpu=$D1%DW type=$D2%DW size=$D3%DW addr=$D4%XW memtype=$D5%DW` }, \
	16 { `log_police_event_out1` }, \
	17 { `log_police_event_out2` }, \
	18 { `log_police_event_out3` }, \
	19 { `log_police_event_out4` }, \
	20 { `log_police_event_out5` }, \
	21 { `log_police_event_out6` }, \
	22 { `init_police_usage_in: netkmem=$D1%XW nm_seg=$D2%XW heap=$D3%DW` }, \
	23 { `init_police_usage_out1` }, \
	24 { `init_police_usage_out2` }, \
	25 { `init_police_usage_out3` }, \
	26 { `free_police_usage_all_in: p_netkmem=$D1%XW` }, \
	27 { `free_police_usage_all_out` }, \
	28 { `net_malloc_police_station_in: start_policing=$D1%DW nop=$D2%XW` }, \
	29 { `net_malloc_police_station_out1` }, \
	30 { `net_malloc_police_station_out2` }, \
	31 { `net_malloc_police_station_out3` }, \
	32 { `net_buf_type_nofct_in: buf_type_list=$D1%S1 nop=$D2%XW` }, \
	33 { `net_buf_type_nofct_out1` }, \
	34 { `net_buf_type_nofct_out2` }, \
	35 { `net_buf_type_nofct_out3` }, \
	36 { `net_buf_type_nofct_out4` }, \
	37 { `net_buf_type_nofct_out5` }, \
	38 { `net_buf_size_nofct_in: buf_size_list=$D1%S1 nop=$D2%XW` }, \
	39 { `net_buf_size_nofct_out1` }, \
	40 { `net_buf_size_nofct_out2` }, \
	41 { `net_buf_size_nofct_out3` }, \
	42 { `net_buf_size_nofct_out4` }, \
	43 { `net_malloc_frag_init_in: promote_size_list=$D1%S1 nop=$D2%XW` }, \
	44 { `net_malloc_frag_init_out1` }, \
	45 { `net_malloc_frag_init_out2` }, \
	46 { `net_malloc_frag_init_out3` }, \
	47 { `netm_page_promote_init_in: nm=$D1%DW nop=$D2%XW` }, \
	48 { `netm_page_promote_init_out` }, \
	49 { `net_malloc_in: size=$D1%DW type=$D2%DW flags=$D3%DW` }, \
	50 { `net_malloc1` }, \
	51 { `net_malloc2` }, \
	52 { `net_malloc3` }, \
	53 { `net_malloc4` }, \
	54 { `net_malloc5` }, \
	55 { `net_malloc6` }, \
	56 { `net_malloc7` }, \
	57 { `net_malloc_out1: va=$D1%XW` }, \
	58 { `net_malloc_out2: va=$D1%XW` }, \
	59 { `large_alloc_in: size=$D1%DW indx=$D2%DW ksp=$D3%XW cpu=$D4%DW kbp=$D5%XW` }, \
	60 { `large_alloc_out1` }, \
	61 { `large_alloc_out2` }, \
	62 { `empty_bucket_in: size=$D1%DW indx=$D2%DW ksp=$D3%XW cpu=$D4%DW netkmem=$D5%XW` }, \
	63 { `empty_bucket_out1` }, \
	64 { `empty_bucket_out2: va=$D1%XW` }, \
	65 { `net_free_in: addr=$D1%XW type=$D2%DW` }, \
	66 { `net_free1` }, \
	67 { `net_free2` }, \
	68 { `net_free_out1` }, \
	69 { `net_free_out2` }, \
	70 { `net_free_out3` }, \
	71 { `large_free_in: addr=$D1%XW` }, \
	72 { `large_free_out` }, \
	73 { `coalesce_in: kup=$D1%XW kbp=$D2%XW indx=$D3%DW addr=$D4%XW srad=$D5%DW` }, \
	74 { `coalesce_out` }, \
	75 { `malloc_loan_in: size=$D1%DW indx=$D2%DW flags=$D3%DW cpu=$D4%DW netkmem=$D5%XW` }, \
	76 { `malloc_loan_out1` }, \
	77 { `malloc_loan_out2` }, \
	78 { `malloc_thread_in: srad=$D1%DW` }, \
	79 { `malloc_thread1` }, \
	80 { `malloc_thread_out` }, \
	81 { `coalesce_pages_in: addr=$D1%XW kbp=$D2%XW indx=$D3%DW srad=$D4%DW` }, \
	82 { `coalesce_pages_out` }, \
	83 { `prime_the_buckets_cpu_in: netkmem=$D1%XW cpu=$D2%DW` }, \
	84 { `prime_the_buckets_cpu_out1` }, \
	85 { `prime_the_buckets_cpu_out2` }, \
	86 { `log_inuse_in: meminuse=$D1%DW thewall_value=$D2%DW` }, \
	87 { `log_inuse_out` }, \
	88 { `aix_kmem_alloc_in: netkmem=$D1%XW size=$D2%DW cpu=$D3%DW` }, \
	89 { `aix_kmem_alloc_out1: size=$D1%DW Maxsize=$D2%DW intpri=$D3%DW csa_prev=$D4%XW` }, \
	90 { `aix_kmem_alloc_out2` }, \
	91 { `aix_kmem_alloc_ou3` }, \
	92 { `aix_kmem_alloc2_in: netkmem=$D1%XW nsptr=$D2%XW heap=$D3%DW size=$D4%DW cpu=$D5%DW` }, \
	93 { `aix_kmem_alloc2_out1: lpages=$D1%DW sepgcnt=$D2%DW pages=$D3%DW` }, \
	94 { `aix_kmem_alloc2_out2` }, \
	95 { `aix_kmem_free_in: netkmem=$D1%XW addr=$D2%XW size=$D3%DW` }, \
	96 { `aix_kmem_free_out` }, \
	97 { `net_malloc_cpudata_in: size=$D1%DW ptr_array=$D2%XW` }, \
	98 { `net_malloc_cpudata_out1` }, \
	99 { `net_malloc_cpudata_out2` }, \
	100 { `kmem_set_highwat_in: netkmem=$D1%XW cpu=$D2%DW` }, \
	101 { `kmem_set_highwat_out` }, \
	102 { `netkmem_dr_handler_in: arg1=$D1%XW arg2=$D2%XW action=$D3%DW dri=$D4%XW` }, \
	103 { `netkmem_dr_handler_out1: rc=$D1%DW` }, \
	104 { `netkmem_dr_handler_out2: rc=$D1%DW` }, \
	105 { `netkmem_dr_handler_out3: rc=$D1%DW` }, \
	106 { `netkmem_dr_handler_out4: rc=$D1%DW` }, \
	107 { `netkmem_dr_handler_out5: rc=$D1%DW` }, \
	108 { `netkmem_dr_handler_out6: rc=$D1%DW` }, \
	109 { `netkmem_dr_handler_out7: rc=$D1%DW` }, \
	110 { `netkmem_dr_handler_out8: rc=$D1%DW` }, \
	111 { `netkmem_dr_handler_out9: rc=$D1%DW` }, \
	112 { `netkmem_dr_handler_out10: rc=$D1%DW` }, \
	113 { `netkmem_dr_handler_out11: rc=$D1%DW` }, \
	114 { `netkmem_dr_cpu_remove_in: cpu=$D1%DW` }, \
	115 { `netkmem_dr_cpu_remove_out` }, \
	116 { `netkmem_dr_cpu_add_in: cpu=$D1%DW` }, \
	117 { `netkmem_dr_cpu_add_out` }, \
	118 { `netkmem_dr_mem_remove_in: dri=$D1%XW` }, \
	119 { `netkmem_dr_mem_remove_out` }, \
	120 { `netkmem_dr_mem_add_in: dri=$D1%XW` }, \
	121 { `netkmem_dr_mem_add_out` }, \
	122 { `ostd_init_in: allocflag=$D1%DW` }, \
	123 { `ostd_init_out1` }, \
	124 { `ostd_init_out2` }, \
	125 { `log_ostd_event_in: cpuid=$D1%DW type=$D2%DW size=$D3%DW addr=$D4%XW memtype=$D5%XW` }, \
	126 { `log_ostd_event_out1` }, \
	127 { `log_ostd_event_out2` }, \
	129 { `set_netm_errlevel_in: new_errlevel=$D1%DW` }, \
	130 { `set_netm_errlevel_out` }, \
	131 { `net_malloc_frag_timer_in: indx=$D1%DW` }, \
	132 { `net_malloc_frag_timer_out1: dbgprom table for this indx is already enabled` }, \
	133 { `net_malloc_frag_timer_out2` }, \
	134 { `net_malloc_frag_timer_out3` }, \
	135 { `net_malloc_frag_timer_stop_in: indx=$D1%DW` }, \
	140 { `net_malloc_frag_timer_stop_out1` }, \
	141 { `net_malloc_page_timer_in: va=$D1%XW kbp=$D2%XW` }, \
	142 { `net_malloc_page_timer_out` }, \
	143 { `net_malloc_page_timer_stop_in` }, \
	144 { `net_malloc_page_timer_stop_out1: va=$D1%XW` }, \
	145 { `net_malloc_page_timer_stop_out2` }, \
	146 { `netkmem_dr_cpu_add_err1: cpu=$D1%DW Error=ENOBUFS` }, \
	147 { `netkmem_dr_cpu_add_err2: cpu=$D1%DW Error=ENOBUFS` }, \
	148 { `net_malloc_frag_timer_stop_out2` }, \
	149 { `log_illegal_mem_access_in` }, \
	150 { `log_illegal_mem_access_out` }, \
	151 { `net_malloc_out: va=$D1%XW` }, \
        152 { `net_malloc_cpu_in: size=$D1%DW type=$D2%DW flags=$D3%DW cpu=$D4%DW` }, \
        153 { `net_malloc_cpu1` }, \
        154 { `net_malloc_cpu2` }, \
        155 { `net_malloc_cpu3` }, \
        156 { `net_malloc_cpu4` }, \
        157 { `net_malloc_cpu5` }, \
        158 { `net_malloc_cpu6` }, \
        159 { `net_malloc_cpu7` }, \
        160 { `net_malloc_cpu_out1: va=$D1%XW` }, \
        161 { `net_malloc_cpu_out2: va=$D1%XW` }, \
        162 { `net_malloc_srad_in: size=$D1%DW type=$D2%DW flags=$D3%DW srad=$D4%DW` }, \
        163 { `net_malloc_srad_out1: va=$D1%XW` }, \
        164 { `net_malloc_srad_out2: va=$D1%XW` }, \
        165 { `net_malloc_srad_out3: va=$D1%XW` }, \
	166 { `net_malloc_srad_out4: va=$D1%XW` }, \
        167 { `hkwd_kmem_get_seg_in: p_netkmem=$D1%XW heap=$D2%DW` }, \
        168 { `hkwd_kmem_get_seg_out1: va=$D1%XW` }, \
        169 { `hkwd_kmem_get_seg_out2: va=$D1%XW` }, \
        170 { `hkwd_kmem_get_seg_out3: va=$D1%XW` }, \
        171 { `hkwd_netaddr2srad_in: addr=$D1%XW` }, \
        172 { `hkwd_netaddr2srad_out1: srad=$D1%DW` }, \
        173 { `hkwd_netaddr2srad_out2: srad=$D1%DW` }, \
        174 { `hkwd_netaddr2srad_out3: srad=$D1%DW` }, \
        175 { `hkwd_police_lock_init_in: cpu=$D1%XW srad=$D2%DW` }, \
        176 { `hkwd_police_lock_init_out1` }, \
        177 { `hkwd_police_lock_init_out2` }, \
        178 { `hkwd_police_lock_init_out3` }, \
        179 { `hkwd_baddr2netkmem_in: addr=$D1%XW hp=$D2%XW sradp=$D3%XW` }, \
        180 { `hkwd_baddr2netkmem_out1` }, \
        181 { `hkwd_baddr2netkmem_out2: p_netkmem=$D1%XW` }, \
        182 { `hkwd_bucket2usagep_in: addr=$D1%XW` }, \
        183 { `hkwd_bucket2usagep_ou1: p=$D1%XW` }, \
        184 { `hkwd_bucket2usagep_ou2: p=$D1%XW` }, \
        185 { `hkwd_addr2segidx_in: addr=$D1%XW` }, \
        186 { `hkwd_addr2segidx_out1: sid=$D1%DW` }, \
        187 { `hkwd_addr2segidx_out2: sid=$D1%DW` }, \
        188 { `hkwd_addr2segidx_and_heap_in: addr=$D1%XW hp=$D2%XW` }, \
        189 { `hkwd_addr2segidx_and_heap_out1: sid=$D1%DW` }, \
        190 { `hkwd_addr2segidx_and_heap_out2: sid=$D1%DW` }, \
        191 { `hkwd_kmem_search_in: p_netkmem=$D1%XW heap=$D2%DW size=$D3%DW cpu=$D4%DW` }, \
        192 { `hkwd_kmem_search_out1: addr=$D1%XW` }, \
        193 { `hkwd_kmem_search_out2: addr=$D1%XW` }, \
        194 { `hkwd_start_netm_thread_in: srad=$D1%DW` }, \
        195 { `hkwd_start_netm_thread_out1: rc=$D1%DW` }, \
        196 { `hkwd_start_netm_thread_out2: rc=$D1%DW` }, \
        197 { `hkwd_start_netm_thread_out3: rc=$D1%DW` }, \
        198 { `hkwd_start_netm_thread_out4: rc=$D1%DW` }, \
        199 { `hkwd_start_netm_thread_out5: rc=$D1%DW` }, \
	200 { `netkmem_dr_handler_out12: rc=$D1%DW` }, \
        201 { `netkmem_dr_handler_out13: rc=$D1%DW` }, \
        202 { `netkmem_dr_handler_out14: rc=$D1%DW` }, \
        203 { `netkmem_dr_handler_out15: rc=$D1%DW` }, \
        204 { `netkmem_dr_handler_out16: rc=$D1%DW` }, \
        205 { `netkmem_dr_handler_out17: rc=$D1%DW` }, \
        \*  { unknown subhook }
38D 1.1 "@AIO: Asynchronous I/O" \
	$HD%D1, \
	1 { "AIO_CLOSE_HOOK1" pid=$D1 fd=$D2 }, \
	2 { "AIO_CLOSE_HOOK2" pid=$D1 fd=$D2 }, \
	3 { "REMDEV1" dev=$D1 }, \
	4 { "REMDEV2" return }, \
	5 { "REMDEV3" return }, \
	6 { "FREEPOOL_INIT1" fp=$D1 size=$D2 low_count=$D3 sys_count=$D4 }, \
	7 { "FREEPOOL_INIT2" return after loop   count=$D1 }, \
	8 { "AIO_INIT1" cmd=$D1 uiop=$D2 }, \
	9 { "ARL_INIT" }, \
	10 { "MOREDEVS" }, \
	11 { "HKWD_KAIO_RDWR1" reqtype=$D1 fildes=$D2 ucbp=$D3 aio_type=$D4 }, \
	12 { "HKWD_KAIO_RDWR2" return 0 }, \
	13 { "HKWD_KAIO_RDWR64_1" reqtype=$D1 fildes=$D2 up32ucbp=$D3 lo32ucbp=$D4 aio_type=$D5 }, \
	14 { "HKWD_KAIO_RDWR64_2" return 0 }, \
	15 { "HKWD_UPDATE_UCB1" rp=$D1 errno=$D2 ret=$D3 }, \
	16 { "HKWD_UPDATE_UCB2" return 0 }, \
	17 { "HKWD_UPDATE_UCB3" return 0 }, \
	18 { "HKWD_ARDWR1" fildes=$D1 rp=$D2 knotp=$D3 }, \
	19 { "HKWD_ARDWR2" return 0 }, \
	20 { "HKWD_GET_RUNPATH1" fp=$D1 devp=$D2 }, \
	21 { "HKWD_GET_RUNPATH2" return AIO_KPROC }, \
	22 { "HKWD_ARL_RDWR1" rp=$D1 devp=$D2 splbuf=$D3 }, \
	23 { "HKWD_ARL_RDWR2" return 0 }, \
	24 { "HKWD_IOSUSPEND1" cnt=$D1 aiocbpa=$D2 }, \
	25 { "HKWD_IOSUSPEND2" rc=$D1 }, \
	26 { "HKWD_IOSUSPEND64_1" cnt=$D1 upper32=$D2 lower32=$D3 }, \
	27 { "HKWD_IOSUSPEND64_2" rc=$D1 }, \
	28 { "HKWD_IOSUSPEND_COMMON1" cnt=$D1 cbpa=$D2 flags=$D3 }, \
	29 { "HKWD_IOSUSPEND_COMMON2" return 0 }, \
	30 { "HKWD_ACANCEL" }, \
	31 { "HKWD_ACANCEL64_1" fildes=$D1 upper32=$D2 lower32=$D3 }, \
	32 { "HKWD_ACANCEL64_2" rc=$D1 }, \
	33 { "HKWD_LISTIO1" cmd=$D1 list=$D2 nent=$D3 eventp=$D4 }, \
	34 { "HKWD_LISTIO2" return 0 }, \
	35 { "HKWD_LISTIO64_1" cmd=$D1 up32cbp=$D2 lo32cbp=$D3 nent=$D4 up32evtp=$D5 }, \
	36 { "HKWD_LISTIO64_2" return 0 }, \
	37 { "HKWD_VALID_LIO1" cmd=$D1 nent=$D2 }, \
	38 { "HKWD_VALID_LIO2" return 0 }, \
	39 { "HKWD_QLIOREQ1" cmd=$D1 lcbp=$D2 nent=$D3 lkpp=$D4 asynciop=$D5 }, \
	40 { "HKWD_QLIOREQ2" return 0 }, \
	41 { "HKWD_QLIOREQ3" fatal error rc=$D1 }, \
	42 { "HKWD_LIOWAIT1" lkp=$D1 }, \
	43 { "HKWD_LIOWAIT2" return 0 }, \
	44 { "HKWD_LIOWAIT3" return EINTR }, \
	45 { "HKWD_LIODONE1" lcbp=$D1 flags=$D2 }, \
	46 { "HKWD_LIODONE2" ret=$D1 }, \
	47 { "HKWD_INIT_LIOREQ1" cmd=$D1 rpp=$D2 lcbp=$D3 asynciop=$D4 flags=$D5 }, \
	48 { "HKWD_INIT_LIOREQ2" return 0 }, \
	49 { "HKWD_KAIO_STATS" buf=$D1 len=$D2 }, \
	50 { "HKWD_AIO_NWAIT1" cnt=$D1 nwait=$D2 uaiocbpa=$D3 }, \
	51 { "HKWD_AIO_NWAIT2" rc=$D1 }, \
	52 { "HKWD_CHKBUF1" rp=$D1 }, \
	53 { "HKWD_CHKBUF2" return 1 }, \
	54 { "HKWD_AIOCB32_RESHAPE" cb32p=$D1 cbp=$D2 }, \
	55 { "HKWD_LIOCB32_RESHAPE" liocb32p=$D1 liocbp=$D2 }, \
	56 { "HKWD_ENSURE_P_ASYNCIO1" called }, \
	57 { "HKWD_ENSURE_P_ASYNCIO2" p_pp_asyncp=$D1 }, \
	58 { "HKWD_ENSURE_P_ASYNCIO3" p_pp_asyncp=$D1 }, \
	59 { "HKWD_UCB2KCB" ucbp=$D1 kcbp=$D2 }, \
	60 { "HKWD_KCB2UCB" kcbp=$D1 ucbp=$D2 }, \
	61 { "HKWD_KCB2UCB_32" kcbp=$D1 ucbp=$D2 }, \
	62 { "HKWD_ARL_IODONE1" bufp=$D1 }, \
	63 { "HKWD_ARL_IODONE2" return }, \
	64 { "HKWD_FETCHBUFS1" rp=$D1 }, \
	65 { "HKWD_FETCHBUFS2" abp=$D1 }, \
	66 { "HKWD_CHECK_SUSPENDER1" rp=$D1 }, \
	67 { "HKWD_CHECK_SUSPENDER2" }, \
	68 { "HKWD_CREAT_SUSPENDER1" pid=$D1 tid=$D2 susp_tid=$D3 gen=$D4 asyncp=$D5 }, \
	69 { "HKWD_CREAT_SUSPENDER2" susp=$D1 }, \
	70 { "HKWD_REMOVE_SUSPENDER1" susp=$D1 asyncp=$D2 }, \
	71 { "HKWD_REMOVE_SUSPENDER2" return }, \
	72 { "HKWD_ARL_SUSPENDER1" susp=$D1 aiocbp=$D2 pid=$D3 tid=$D4 asyncp=$D5 }, \
	73 { "HKWD_ARL_SUSPENDER2" return }, \
	74 { "HKWD_CREATE_KNOT1" asynciop=$D1 cmd=$D2 nent=$D3 }, \
	75 { "HKWD_CREATE_KNOT2" lkp=$D1 }, \
	76 { "HKWD_UNTIE_KNOT1" lkpp=$D1 num=$D2  }, \
	77 { "HKWD_UNTIE_KNOT2" return 1 }, \
	78 { "HKWD_UNTIE_KNOT3" return 0 }, \
	79 { "HKWD_SLIP_KNOT1" lkp=$D1 }, \
	80 { "HKWD_SLIP_KNOT2" knot found }, \
	81 { "HKWD_SLIP_KNOT3" knot NOT found }, \
	82 { "HKWD_CHECK_KNOT1" rp=$D1 }, \
	83 { "HKWD_CHECK_KNOT2" return }, \
	84 { "HKWD_CHECK_KNOT3" return }, \
	85 { "HKWD_DESTROY_KNOT" lkp=$D1 }, \
	86 { "HKWD_RELEASEREQ" rp=$D1 }, \
	87 { "HKWD_AIO_NWAIT_PINNED1" cnt=$D1 nwait=$D2 aiocbpa=$D3 asyncp=$D4 }, \
	88 { "HKWD_AIO_NWAIT_PINNED2 return" error=$D1 done=$D2 }, \
	89 { "HKWD_ASYNCIO_CLEANUP1" asyncp=$D1 }, \
	90 { "HKWD_ASYNCIO_CLEANUP2 second pass return" }, \
	91 { "HKWD_ASYNCIO_CLEANUP3 done" }, \
	92 { "HKWD_AIO_POST" asyncp=$D1 }, \
	93 { "HKWD_AIO_GETKRAD" }, \
	94 { "HKWD_FREEPOOL_ENQUE" fp=$D1 buf=$D2 }, \
	95 { "HKWD_FREEPOOL_GET1" fp=$D1 }, \
	96 { "HKWD_FREEPOOL_GET2" rp=$D1 }, \
	97 { "HKWD_FREEPOOL_GET3" rp=$D1 }, \
	98 { "HKWD_FREEPOOL_PUT1" fp=$D1 buf=$D2 }, \
	99 { "HKWD_FREEPOOL_PUT2 return" }, \
	100 { "HKWD_FREEPOOL_SHRINK" pkp=$D1 }, \
	101 { "HKWD_SERVER_MAIN1" data=$D1 spp=$D2 plen=$D3 }, \
	102 { "HKWD_SERVER_MAIN2 return" }, \
	103 { "HKWD_DO_REQUESTS1" sp=$D1 }, \
	104 { "HKWD_DO_REQUESTS2 return 1" }, \
	105 { "HKWD_RW_REQUEST1" rp=$D1 kfp=$D2 }, \
	106 { "HKWD_RW_REQUEST2 return" }, \
	107 { "HKWD_RW_REQUEST3 done" }, \
	108 { "HKWD_FIND_QUEUE1" fp=$D1 }, \
	109 { "HKWD_FIND_QUEUE2" qtabp=$D1 }, \
	110 { "HKWD_ADD_REQUEST1" rp=$D1 }, \
	111 { "HKWD_ADD_REQUEST2" s_tid=$D1 }, \
	112 { "HKWD_GET_REQUEST1" qp=$D1 }, \
	113 { "HKWD_GET_REQUEST2" rp=$D1 prio=$D2 count=$D3}, \
	114 { "HKWD_GET_REQUEST3 return NULL" }, \
	115 { "HKWD_DELETE_REQUEST" rp=$D1 qp=$D2 }, \
	116 { "HKWD_FIND_REQUEST1" qp=$D1 cbp=$D2 pid=$D3 tid=$D4 }, \
	117 { "HKWD_FIND_REQUEST2" rp=$D1 }, \
	118 { "HKWD_FIND_REQUEST3" rp=$D1 }, \
	119 { "HKWD_FIND_REQUEST4 return NULL" }, \
	120 { "HKWD_CANCEL_REQUEST" pid=$D1 tid=$D2 fp=$D3 cbp=$D4 qp=$D5 }, \
	121 { "HKWD_CANCEL_FD1" pid=$D1 fp=$D2 fd=$D3 block=$D4 }, \
	122 { "HKWD_CANCEL_FD2" rc=$D1 }, \
	123 { "HKWD_NEW_SERVER1" }, \
	124 { "HKWD_NEW_SERVER2" sp=$D1 }, \
	125 { "HKWD_GET_FREE_SERVER1" qp=$D1 }, \
	126 { "HKWD_GET_FREE_SERVER2" s_tid=$D1 }, \
	127 { "HKWD_FIND_WORK" }, \
	128 { "HKWD_SUSPEND_SET1" cnt=$D1 cbpa=$D2 pid=$D3 tid=$D4 susp=$D5 }, \
	129 { "HKWD_SUSPEND_SET2" rc=$D1 }, \
	130 { "HKWD_SUSPEND_IT1" cbpu=$D1 cbpl=$D2 tid=$D3 susp=$D4 asynciop=$D5 }, \
	131 { "HKWD_SUSPEND_IT2 return" SSOK=$D1 }, \
	132 { "HKWD_ADD_REQUEST3" rp=$D1 prio=$D2 s_tid=$D3 count=$D4}, \
	133 { `AIO control: opt = $D2, cmd = $D3, value = $D4, rc = $D1` }, \
	134 { `AIO suspend: cnt = $D2, aiocbplist = $D3, flags = $D4, rc = $D1` }, \
	135 { `AIO cancel: f_data = $D2, aiocbp = ` W3 int64()`, rc = $D1` }, \
	136 { `AIO wait: cnt = $D2, nwait = $D3, rc = $D1` }, \
	137 { `AIO sync: f_data = $D2, op = $D3, rc = $D1` }, \
	138 { `AIO ardwr: frw = $D1, f_data = $D2, offset = ` W4 int64()`, length = $D3` }, \
	139 { `AIO kproc req: rw = $D1, f_data = $D2, offset = ` W4 int64() `, length = $D3` }, \
	140 { `AIO kproc error: f_data = $D2, rc = $D1` }, \
	141 { `AIO fast path devstrat: bp = $D1, f_data = $D2, lv blk = $D3, bcount = $D4` }, \
	142 { `AIO fast path iodone: bp = $D1, fp = $D2, b_flags = $D3` }
38E 1.0 "SISADD" \
        $DD1
38F 1.0 "DYNAMIC RECONFIG:" \
	$HD%D1, \
	  1 { "Dr_register: DR Operation:" $D1%XW FORCE Option: $D2 }, \
	  2 { "Register_dr_event: DR Operation:" $D1 }, \
	  3 { "Dr_notify: DR Phase:" $D1 Flags: $D2 Timeout in secs: $D3 Input: $D4%XW }, \
	  4 { "Dr_unregister: Unregistering DR operation" }, \
	  5 { "Unregister_dr_event: DR Operation:" $D1 }, \
	  6 { "Dr_reconfig: Flags:" $D1 DR Info: $D2%XW DR Operation: $D3 DR Phase: $D4 }, \
	 20 { "Reconfig_register: handler:" $D1%XW actions: $D2 h_arg: $D3%XW }, \
	 21 { "Reconfig_register: handler id:" $D1 name: $D2%A16.16 }, \
	 22 { "Reconfig_unregister: handler id:" $D1 }, \
	 23 { "Reconfig_unregister: handler name:" $D1%A16.16 }, \
	 24 { "Reconfig_complete: handler:" $D1%XW Status: $D2 }, \
	 25 { "Reconfig_complete: handler name:" $D1%A16.16 }, \
	 26 { "Reconfig_complete: handlers still waiting for:" $D1 }, \
	 40 { "Invoke Reconfig Handlers: action:" $D1 }, \
	 41 { "Invoke Reconfig Handlers: Number of reconfig handlers waiting for:" $D1 }, \
	 42 { "Invoke Reconfig Handlers: All reconfig handlers completed, Status:" $D1 }, \
	 50 { "Call MPC remove handler" $CPUID }, \
	 51 { "Call MPC freeze handler" $CPUID }, \
	 60 { "dr_send_signal: Posting signal ("$D1") to all processes catching" }, \
	 61 { "dr_send_signal: Number of processes posted:" $D1 }, \
	 62 { "dr_send_signal: Number of unacknowledged signals:" $D1 }, \
	 70 { "get_user_data: DR Operation:" $D1%XW input data: $D2%XW }, \
	 71 { "dr_callout: DR Callout index:" $D1 DR Phase: $D2 }, \
	 72 { "validate_phase: Current Phase:" $D1 Requested Phase: $D2 Flags: $D3 }, \
	 73 { "Validate_notify: DR Phase:" $D1 Flags: $D2 }, \
	 74 { "Run_notify: Perform DR Check/Pre/Post/Posterror Phases" }, \
	 75 { "Kernel_notify: Perform DR Kernel Phase" }, \
	 76 { "Clearing DR Kernel Data..." }, \
	 90 { "HA_proc: Checking with Kernel for BAD CPU: Input:" $D1 Event: $D2%XW Retry: $D3%XW }, \
	 91 { "HA_proc: Found a BAD cpu: Logical cpu id:" $D1 }, \
	 92 { "HA_proc: Status of CPU Guard operation: Logical cpu id:" $D1 Status: $D2 }, \
	 93 { "migrate_watchdogs: From LCPU:" $D1 To LCPU: $D2 }, \
	 94 { "ha_memorize: Sending SIGCPUFAIL to Init process: LCPU:" $D1 Physid: $D2 }, \
	 98 { "DR Numa Reg: n_ele:" $D1 },\
	 99 { "DR Numa Reg: asso: " $D1 $D2 $D3 $D4 $D5 },\
	100 { "Addcpu_validate: DR Phase:" $D1 Input: $D2%XW }, \
	101 { "Addcpu_pre: Logical CPU coming online:" $D1 }, \
	102 { "Addcpu_cleanup: Logical CPU going offline:" $D1 }, \
	103 { "Addcpu_doit: Logical CPU:" $D1 Physical ID: $D2 }, \
	104 { "Start_bs_proc: Starting a new cpu: Physical ID:" $D1 Gserver: $D2%XW Server: $D3%XW }, \
	105 { "Main_bs_proc: Initializing the new CPU..." }, \
	106 { "Main_bs_proc: Initializing the VMM..." }, \
	107 { "Updating System Topology..." }, \
	108 { "Initializing/Rerouting the Interrupts... From Physical CPU:" $D1 To Physical CPU: $D2 Phase: $D3 Flags: $D3 }, \
	109 { "DR Numa Unreg: n_ele:" $D1 },\
	110 { "DR Numa Reg: asso: " $D1 $D2 $D3 $D4 $D5 },\
	120 { "Rm_attachments: Notify BOUND Processes: Action:" $D1 Kthread: $D2 Bind"/"Attach: $D3 }, \
	121 { "Migrating all PROCESSOR_CLASS_ANY work from the cpu being removed " }, \
	122 { "DR: Stopping logical CPU:" $D1 }, \
	123 { "Move_threads: Moving threads from logical cpu" $D1 to $D2 }, \
	124 { "Rmcpu_validate: DR Phase:" $D1 CPU id: $D2 CPU Type: $D3 }, \
	125 { "Rmcpu_pre: DR Phase:" $D1 Logical CPU id: $D2 }, \
	126 { "Rmcpu_doit: DR Phase:" $D1 CPU Guard Operation: $D2 }, \
	127 { "Rmcpu_cleanup: DR Phase:" $D1 Logical CPU: $D2 }, \
	128 { "Rmcpu_doit: Controlling LCPU:" $D1 Highest Bind cpuid: $D2 }, \
	129 { "Rmcpu_doit: Invoke HA Handlers... " }, \
	130 { "Rmcpu_doit: Disable Decrementer... " }, \
	131 { "Rmcpu_doit: Enable Decrementer... " }, \
	132 { "Rmcpu_doit: New Master logical CPU:" $D1 }, \
	133 { "Rmcpu_doit: DR CPU Removal: CPU Guard:" $D1 Status: $D2 }, \
	140 { "Sparecpu_doit: dummy ppda index:" $D1 }, \
	141 { "sparecpu_validate: DR Phase:" $D1 Input: $D2%XW }, \
	142 { "sparecpu_doit: DR CPU Spare Operation: failing physical cpuid:" $D1 Spare physical cpuid: $D2 }, \
	143 { "sparecpu_doit: Starting the spare cpu: physid:" $D1 Gserver: $D2 Server: $D3 }, \
	144 { "sparecpu_doit: CPU Sparing Success! Physical Cpuid:" $D1 }, \
	145 { "sparecpu_doit: Failing/BAD CPU (physid:" $D1") Stopped" }
390 1.0 "SISRAID" \
        $DD1
393 1.0 "@LVM NON-I/O EVENTS" \
        $HD%D2, \
         1   { `LVM cfg:	dev=$D1 cmd=$D2%DW` },\
         2   { `LVM sa_strt:	dev=$D1 flags=$D2 sa_spin_type=$D3 sa_pend_type= $D4 line=$D5%DW` },\
         3   { `LVM sa_cont:	current_type=$D1 pend_type=$D2 pend_to_act_type=$D3 pend_stop_pos=$D4 line=$D5%DW` },\
         4   { `LVM sa_wrt:	buf_resid=$D1 b_baddr=$D2 b_bcount=$D3 line=$D4%DW` },\
         5   { `LVM sa_iodone:	lb=$D1 b_flags=$D2 line=$D3%DW` },\
         6   { `LVM vgsa_dio:	sa_wrt_start=$D1 sa_wrt_end=$D2 pv_index=$D3 line=$D4%DW` },\
         7   { `LVM vgsa_dio_end: dev=$D1 flags=$D2 pvstate=$D3 line=$D4%DW` },\
         8   { `LVM sa_whladv:	current_type=$D1 current_position=$D2 pend_to_act_type=$D3 pend_stop_pos=$D4 line=$D5%DW` },\
         9   { `LVM sa_rtn:	`devtoname($D1) `pb.b_dev=$D1` \
				`pb.b_blkno=$D2` \
				"\n               " `pb.b_error=$D3` \
				`pb.b_flags=$D4 pb_lbuf=$D5` },\
        10 { `LVM sa_config:	`devtoname($D1) `type=$D2 vg flags=$D3` },\
	11 { `LVM sa_gs_read:	buf_resid=$D1 b_baddr=$D2 b_bcount=$D3 line=$D4%DW` },\
	12 { `LVM sa_gs_iodone:	lb=$D1 b_flags=$D2 line=$D3%DW` },\
        \*   { `LVM subhook=$HD%DW:	d1=$D1 d2=$D2 d3=$D3` }
3A5 1.0 "atmsock" \
{{ \
atmaddr(addr) \
        {{ $addr }} \
        $addr, \
        0xBADFCA11 { $addr }, \
        \* { \
                {{ $z1 = $addr%W24.31 }} \
                {{ $z2 = $addr%W16.23 }} \
                {{ $z3 = $addr%W8.15 }} \
                {{ $z4 = $addr%W0.7 }} \
                setdelim(0) \
                $z1%X1"."$z2%X1"."$z3%X1"."$z4%X1 \
                setdelim(1)  \
        } \
}} \
        $HD%D1, \
        01 {`netattac so $D1%XW pcb $D2%XW`}, \
        02 {`bind     so $D1%XW pcb $D2%XW ndd $S4 reg_id $D4%XW`}, \
        03 {`addr` atmaddr($D1)`.`atmaddr($D2)`.`atmaddr($D3)`.`atmaddr($D4)`.`atmaddr($D5)}, \
        04 {`listen   so $D1%XW pcb $D2%XW`}, \
        05 {`connpvc  so $D1%XW pcb $D2%XW reg_id $D3%XW vpi $D4%XW vci $D5%XW `}, \
        06 {`connsvc  so $D1%XW pcb $D2%XW reg_id $D3%XW`}, \
        07 {`accept   so $D1%XW pcb $D2%XW ndd $S4 reg_id $D3%XW`}, \
        08 {`disc     so $D1%XW pcb $D2%XW handle $D3%XW cause $D4%XW`}, \
        09 {`detach   so $D1%XW pcb $D2%XW`}, \
        10 {`abort    so $D1%XW pcb $D2%XW`}, \
        11 {`connerr  so $D1%XW pcb $D2%XW handle $D3%XW`}, \
        12 {`calldisc so $D1%XW pcb $D2%XW handle $D3%XW`}, \
        13 {`shut     so $D1%XW pcb $D2%XW handle $D3%XW`}, \
        14 {`indentry user_id $D1%XW ind_ie_p $D2%XW`}, \
        15 {`indexit  sn $D1%XW pcn $D2%XW`}, \
        16 {`callack  so $D1%XW pcb $D2%XW`}, \
        17 {`addfill  so $D1%XW pcb $D2%XW handle $D3%XW`}, \
        18 {`adderr   so $D1%XW pcb $D2%XW handle $D3%XW`}, \
        19 {`delfill  so $D1%XW pcb $D2%XW handle $D3%XW`}, \
        20 {`svcreg   so $D1%XW pcb $D2%XW reg_id $D3%XW`}, \
        21 {`svcdereg so $D1%XW pcb $D2%XW reg_id $D3%XW`}, \
        22 {`svcerr   so $D1%XW pcb $D2%XW reg_id $D3%XW`}, \
        23 {`netfree            pcb $D1%XW`}, \
        24 {`callacc  so $D1%XW pcb $D2%XW`}, \
        25 {`wrk      so $D1%XW pcb $D2%XW`}, \
        26 {`allocp   so $D1%XW pcb $D2%XW allocp $D3%XW`}, \
        27 {`allocfre so $D1%XW pcb $D2%XW allocp $D3%XW`}, \
        28 {`pcbenq             pcb $D1%XW` $D2, 0x10 "CONNECT", \
                                                 0x20 "LISTEN", \
                                                 0x40 "ACCEPT" }, \
        29 {`pcbdeq             pcb $D1%XW` $D2, 0x10 "CONNECT", \
                                                 0x20 "LISTEN", \
                                                 0x40 "ACCEPT" }, \
        30 {`listq              pcb $D1%XW`}, \
        31 {`regreg   so $D1%XW pcb $D2%XW reg_id $D3%XW`}, \
        32 {`regdereg so $D1%XW pcb $D2%XW reg_id $D3%XW`}, \
        33 {`regerr   so $D1%XW pcb $D2%XW reg_id $D3%XW`}, \
        34 {`reglis             pcb $D1%XW`}, \
        35 {`kill     so $D1%XW pcb $D2%XW handle $D3%XW`}, \
        36 {`fvtstart  $D1%DW---------------------------------------`}, \
        37 {`fvtfinish $D1%DW---------------------------------------`}, \
        38 {`rcventry so $D1%XW pcb $D2%XW length $D3%XW`}, \
        39 {`rcvexit  so $D1%XW pcb $D2%XW`}, \
        40 {`sndentry so $D1%XW pcb $D2%XW length $D3%XW`}, \
        41 {`sndexit  so $D1%XW pcb $D2%XW`}, \
        \* {"unknown atmsock subhook " $HD }
3B7 1.2 L=APPL "SECURITY:" O2.0 					      	\
	$HD%UW, 							      	\
	10 { `getconfattr: `$HOOKENV, '64' {O4}`sys=A4.4 ` $HOOKENV, '64' {O4}`atnam=A4.4 type=UW`}, \
	11 { `getconfattr FAIL: `$HOOKENV, '64' {O4}`sys=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW errno=EW`},       	\
	12 { `getconfattr succ: `$HOOKENV, '64' {O4}`sys=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW rc=UW errno=EW`}, 	\
	20 { `getgroupattr: group=` $HOOKENV, '64' {O4}A4.4""$HOOKENV, '64' {O4}` atnam=A4.4 type=UW`}, \
	21 { `getgroupattr FAIL: `$HOOKENV, '64' {O4}`group=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW errno=EW`},    	\
	22 { `getgroupattr succ: `$HOOKENV, '64' {O4}`group=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW`},	\
	30 { `putgroupattr: group=` $HOOKENV, '64' {O4}A4.4""$HOOKENV, '64' {O4}` atnam=A4.4 type=UW`}, \
	31 { `putgroupattr FAIL: `$HOOKENV, '64' {O4}`group=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW errno=EW`},    	\
	32 { `putgroupattr succ: `$HOOKENV, '64' {O4}`group=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW`},	\
	40 { `IDtogroup: id=UW`}, 					      	\
	41 { `IDtogroup FAIL: id=UW errno=EW`}, 			      	\
	42 { `IDtogroup succ: id=UW name=` $HOOKENV, '64' {O4}A4.4},	\
	50 { `grouptoID: name=` $HOOKENV, '64' {O4}A4.4}, 	\
	51 { `grouptoID FAIL: `$HOOKENV, '64' {O4}`name=A4.4 errno=EW`}, 	\
	52 { `grouptoID succ: `$HOOKENV, '64' {O4}`name=A4.4 id=UW`}, 		\
	60 { `IDtouser: id=UW`}, 					      	\
	61 { `IDtouser FAIL: id=UW errno=EW rc=UW`}, 			      	\
	62 { `IDtouser succ: id=UW user=` $HOOKENV, '64' {O4}A4.4}, 	\
	70 { `getuserattr: user=` $HOOKENV, '64' {O4} A4.4""$HOOKENV, '64' {O4} ` atnam=A4.4 type=UW`},\
	71 { `getuserattr FAIL: `$HOOKENV, '64' {O4}`user=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW errno=EW`},      	\
	72 { `getuserattr succ: `$HOOKENV, '64' {O4} `user=A4.4 ` $HOOKENV, '64' {O4} `atnam=A4.4 type=UW`}, \
	80 { `putuserattr: user=` $HOOKENV, '64' {O4}A4.4""$HOOKENV, '64' {O4}` atnam=A4.4 type=UW`}, 	\
	81 { `putuserattr FAIL: `$HOOKENV, '64' {O4}`user=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW errno=EW`},      	\
	82 { `putuserattr ret: `$HOOKENV, '64' {O4}`user=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW errno=EW rc=UW`}, 	\
	90 { `getuserpw: user=` $HOOKENV, '64' {O4}A4.4}, \
	91 { `getuserpw FAIL: `$HOOKENV, '64' {O4}`user=A4.4 errno=EW`}, 	\
	92 { `getuserpw succ: `$HOOKENV, '64' {O4}`user=A4.4`}, 		\
	100 { `putuserpw: user=` $HOOKENV, '64' {O4}A4.4}, \
	101 { `putuserpw FAIL: `$HOOKENV, '64' {O4}`user=A4.4 errno=EW`}, 	\
	102 { `putuserpw succ: `$HOOKENV, '64' {O4}`user=A4.4`}, 		\
	110 { `getgenericattr: `$HOOKENV, '64' {O4}`file=A4.4 `$HOOKENV, '64' {O4}`stanza=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW`}, \
	111 { `getgenericattr FAIL: `$HOOKENV, '64' {O4}`file=A4.4 `$HOOKENV, '64' {O4}`stanza=A4.4 type=UW errno=EW`},	\
	112 { `getgenericattr ret: `$HOOKENV, '64' {O4}`file=A4.4 `$HOOKENV, '64' {O4}`stnza=A4.4 typ=UW rc=UW er=EW`},	\
	120 { `putgenericattr: `$HOOKENV, '64' {O4}`file=A4.4 `$HOOKENV, '64' {O4}`stanza=A4.4 `$HOOKENV, '64' {O4}`atnam=A4.4 type=UW`}, \
	121 { `putgenericattr FAIL: `$HOOKENV, '64' {O4}`file=A4.4 `$HOOKENV, '64' {O4}`stanza=A4.4 type=UW errno=EW`},	\
	122 { `putgenericattr ret: `$HOOKENV, '64' {O4}`file=A4.4 `$HOOKENV, '64' {O4}`stnza=A4.4 typ=UW rc=UW er=EW`},	\
	130 { `getpenv: which=UW`}, 						\
	131 { `getpenv FAIL: which=UW errno=EW`}, 				\
	132 { `getpenv succ: which=UW`}, 					\
	140 { `setpenv: user=` $HOOKENV, '64' {O4}A4.4""$HOOKENV, '64' {O4}` mode=UW cmd=A4.4`}, \
	141 { `setpenv FAIL: `$HOOKENV, '64' {O4}`user=A4.4 mode=UW `$HOOKENV, '64' {O4}`cmd=A4.4 errno=EW`},		\
	142 { `setpenv execve: `$HOOKENV, '64' {O4}`user=A4.4 mode=UW `$HOOKENV, '64' {O4}`cmd=A4.4`},			\
	150 { `setpcred: `$HOOKENV, '64' {O4}`user=A4.4`},			\
	151 { `setpcred FAIL: `$HOOKENV, '64' {O4}`user=A4.4 errno=EW`}, 	\
	152 { `setpcred succ: `$HOOKENV, '64' {O4}`user=A4.4`}, 		\
	160 { `getpcred: which=UW`},						\
	161 { `getpcred FAIL: which=UW errno=EW`}, 				\
	162 { `getpcred succ: which=UW`}, 					\
	170 { `authenticate: `$HOOKENV, '64' {O4}`u=A4.4 `$HOOKENV, '64' {O4}`AUTHST=A4.4 ST=UW `$HOOKENV, '64' {O4}`FNAME=A4.4 `$HOOKENV, '64' {O4}`GRAM=A4.4`}, \
	171 { `authenticate END: `$HOOKENV, '64' {O4}`u=A4.4 `$HOOKENV, '64' {O4}`AUTHST=A4.4 ST=UW `$HOOKENV, '64' {O4}`GRAM=A4.4 rc=UW`},	\
	172 { `authenticate CONT: `$HOOKENV, '64' {O4}`u=A4.4 `$HOOKENV, '64' {O4}`AUTHST=A4.4 STATE=UW `$HOOKENV, '64' {O4}`GRAMMAR=A4.4`},	\
	173 { `authenticate grammar: `$HOOKENV, '64' {O4}`u=A4.4 `$HOOKENV, '64' {O4}`AUTHST=A4.4 ST=UW `$HOOKENV, '64' {O4}`GRAMMAR=A4.4`},	\
	180 { `getpwnam_r: `$HOOKENV, '64' {O4}`name=A4.4 `$HOOKENV, '64' {O4}`line=A4.4 line_len=UW`},			\
	181 { `getpwnam_r exit: `$HOOKENV, '64' {O4}`name=A4.4 `$HOOKENV, '64' {O4}`line=A4.4 rc=UW errno=EW`},		\
	190 { `getpwuid_r: uid=UW `$HOOKENV, '64' {O4}`line=A4.4 line_len=UW`},	\
	191 { `getpwuid_r exit: uid=UW `$HOOKENV, '64' {O4}`line=A4.4 rc=UW errno=EW`},		\
	200 { `getpwent_r: `$HOOKENV, '64' {O4}`line=A4.4 line_len=UW`}, \
	201 { `getpwent_r exit: `$HOOKENV, '64' {O4}`line=A4.4 rc=UW errno=EW`}, \
	210 { `getgrnam_r: `$HOOKENV, '64' {O4}`nam=A4.4 `$HOOKENV, '64' {O4}`line=A4.4 line_len=UW`},			\
	211 { `getgrnam_r exit: `$HOOKENV, '64' {O4}`nam=A4.4 `$HOOKENV, '64' {O4}`line=A4.4 rc=UW errno=EW`},	   	\
	220 { `getgrgid_r: gid=UW `$HOOKENV, '64' {O4}`line=A4.4 line_len=UW`},	\
	221 { `getgrgid_r exit: gid=UW `$HOOKENV, '64' {O4}`line=A4.4 rc=UW errno=EW`},		\
	230 { `getgrent_r: `$HOOKENV, '64' {O4}`line=A4.4 line_len=UW`},	\
	231 { `getgrent_r exit: `$HOOKENV, '64' {O4}`line=A4.4 rc=UW errno=EW`}, \
	244 { "pkim_query_versions: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },					\
	245 { "pkim_query_versions FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	246 { "pkim_query_versions succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },			\
	247 { "pkim_error_moduletext: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	248 { "pkim_error_moduletext FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	249 { "pkim_error_moduletext succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },			\
	250 { "pkim_list_build: appServiceList=" $HOOKENV, '32' { A4 }, '64' { A8 } },				\
	251 { "pkim_list_build FAIL: appServiceList=" $HOOKENV, '32' { A4 }, '64' { A8 } ` rc=DW`},	\
	252 { "pkim_list_build succ: appServiceList=" $HOOKENV, '32' { A4 }, '64' { A8 } },			\
	253 { "pkim_list_free: appServiceList=" $HOOKENV, '32' { A4 }, '64' { A8 } },					\
	255 { "pkim_list_free exit: appServiceList=" $HOOKENV, '32' { A4 }, '64' { A8 } },			\
	256 { "pkim_list_loadservice: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	257 { "pkim_list_loadservice FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},		\
	258 { "pkim_list_loadservice succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },			\
	260 { "pkim_cert_create: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },						\
	261 { "pkim_cert_create FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},		\
	262 { "pkim_cert_create succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	263 { "pkim_cert_revoke: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },						\
	264 { "pkim_cert_revoke FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},		\
	265 { "pkim_cert_revoke succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	266 { "pkim_cert_verify: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },						\
	267 { "pkim_cert_verify FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},		\
	268 { "pkim_cert_verify succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	269 { "pkim_keystore_chpasswd: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	270 { "pkim_keystore_chpasswd FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	271 { "pkim_keystore_chpasswd succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },		\
	272 { "pkim_keystore_passwdrules: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },			\
	273 { "pkim_keystore_passwdrules FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	274 { "pkim_keystore_passwdrules succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },	\
	275 { "pkim_keystore_vrfypasswd: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },			\
	276 { "pkim_keystore_vrfypasswd FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	277 { "pkim_keystore_vrfypasswd succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },		\
	278 { "pkim_keystore_cpobjects: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	279 { "pkim_keystore_cpobjects FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	280 { "pkim_keystore_cpobjects succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },		\
	281 { "pkim_keystore_lsobjects: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },			 	\
	282 { "pkim_keystore_lsobjects FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	283 { "pkim_keystore_lsobjects succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },		\
	284 { "pkim_keystore_rmobjects: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	285 { "pkim_keystore_rmobjects FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	286 { "pkim_keystore_rmobjects succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },		\
	287 { "pkim_user_create: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },						\
	288 { "pkim_user_create FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},		\
	289 { "pkim_user_create succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	290 { "pkim_user_disable: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },						\
	291 { "pkim_user_disable FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	292 { "pkim_user_disable succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	293 { "pkim_query_methods: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },					\
	294 { "pkim_query_methods FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	295 { "pkim_query_methods succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	296 { "pkim_ctrl_cleanup: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },						\
	297 { "pkim_ctrl_cleanup FAIL: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } ` rc=DW`},	\
	298 { "pkim_ctrl_cleanup succ: srvname=" $HOOKENV, '32' { A8 }, '64' { A16 } },				\
	300 { "pkit_trace_entry: function=" $HOOKENV, '32' { A8 }, '64' { A16 } ` line=DW`},		\
	301 { "pkit_trace_entry info:" ` a=DW b=DW c=DW d=DW`},												\
	302 { "pkit_trace_entry FAIL: function=" $HOOKENV, '32' { A8 }, '64' { A16 } ` line=DW errcode=DW`},	\
	303 { "pkit_trace_entry succ: function=" $HOOKENV, '32' { A8 }, '64' { A16 } ` line=DW`},	\
	304 { "pkil_trace_entry: function=" $HOOKENV, '32' { A8 }, '64' { A16 } ` line=DW`},		\
	305 { "pkil_trace_entry info:" ` rc=DW errno=DW`},														\
	306 { "pkil_trace_entry FAIL: function=" $HOOKENV, '32' { A8 }, '64' { A16 } ` line=DW errcode=DW`},	\
	307 { "pkil_trace_entry succ: function=" $HOOKENV, '32' { A8 }, '64' { A16 } ` line=DW`},	\
	320 { "certcommand_trace_entry: function=" $HOOKENV, '32' { A20 }, '64' { A40 } },				\
	321 { "certcommand_trace_exit succ: function=" $HOOKENV, '32' { A20 }, '64' { A40 } },		\
	322 { "certcommand_trace_exit FAIL: function=" $HOOKENV, '32' { A20 }, '64' { A40 } ` rc=DW`}, \
	10000 { `accessx entry: path=XW mode=UW who=UW`},			\
	10001 { `accessx exit: error=EW rc=D1`},		 		\
	10010 { `faccessx entry: fildes=UW mode=UW who=UW`},			\
	10011 { `faccessx exit:  error=EW rc=D1`},	 			\
	10020 { `audit entry: cmd=UW arg=UW`},					\
	10021 { `audit exit: error=EW rc=D1`},					\
	10030 { `auditbin entry: Cmd=UW CurrentFD=UW NextFD=UW thresh=UW`},	\
	10031 { `auditbin exit: Cmd=UW CurrentFD=UW NextFD=UW error=EW rc=D1`},	\
	10040 { `auditlog entry: Event=XW Status=UW Buffer=XW Length=UW`},	\
	10041 { `auditlog exit: error=EW rc=D1`},				\
	10050 { `auditevents entry: Cmd=UW Classes=XW NumClasses=UW`},		\
	10051 { `auditevents exit: error=EW rc=D1`},				\
	10060 { `auditproc entry: pid=UW cmd=UW arg=XW len=UW`},		\
	10061 { `auditproc exit: error=EW rc=D1`},				\
	10062 { `auditproc FAIL: error=EW rc=D1`},				\
	10070 { `chacl entry: path=XW aclbuf=XW aclsiz=UW`},			\
	10071 { `chacl exit: error=EW rc=D1`},					\
	10080 { `fchacl entry: fdes=UW aclbuf=XW aclsiz=UW`},			\
	10081 { `fchacl exit: error=EW rc=D1`},					\
	10090 { `chpriv entry: path=XW pclbuf=XW pclsiz=UW`},			\
	10091 { `chpriv exit: error=EW rc=D1`},					\
	10100 { `fchpriv entry: fdes=UW pclbuf=XW pclsiz=UW`},			\
	10101 { `fchpriv exit: error=EW rc=D1`},				\
	10110 { `privcheck entry: p=UW`},					\
	10111 { `privcheck exit: rc=D1`},					\
	10120 { `revoke entry: path=XW`},					\
	10121 { `revoke exit: error=EW rc=D1`},					\
	10130 { `frevoke entry: fd=UW`},					\
	10131 { `frevoke exit: error=EW rc=D1`},				\
	10140 { `statacl entry: path=XW cmd=UW buf=XW len=UW`},			\
	10141 { `statacl exit: error=EW rc=D1`},				\
	10150 { `fstatacl entry: fdes=UW cmd=UW buf=XW len=UW`},		\
	10151 { `fstatacl exit: error=EW rc=D1`},				\
	10160 { `statpriv entry: path=XW cmd=UW buf=XW len=UW`},		\
	10161 { `statpriv exit: error=EW rc=D1`},				\
	10170 { `fstatpriv entry: fdes=UW cmd=UW buf=XW len=UW`},		\
	10171 { `fstatpriv exit: error=EW rc=D1`},				\
	10172 { `__fstataclx entry: fd=UW cmd=UW aclbuf=XW aclsiz=UW type=XW`},	\
	10173 { `__fstataclx exit: error=EW rc=D1`},				\
	10174 { `__fchaclx entry: fd=UW cmd=UW aclbuf=XW aclsiz=UW type=XW`},	\
	10175 { `__fchaclx exit: error=EW rc=D1`},				\
	10176 { `__chaclx entry: path=XW aclbuf=XW aclsiz=UW type=XW`},		\
	10177 { `__chaclx exit: error=EW rc=D1`},				\
	10178 { `__stataclx entry: path=XW cmd=UW aclbuf=XW aclsiz=UW type=XW`},\
	10179 { `__stataclx exit: error=EW rc=D1`},				\
	10180 { `__fchxacl entry: fd=UW aclbuf=XW size=UW type=`$HOOKENV, '32' { A4 }, '64' { A8 } ` flag=UW`},	\
	10181 { `__fchxacl exit: error=EW rc=D1`},				\
	10182 { `__chxacl entry: path=XW buf=XW size=U4 type=`$HOOKENV, '32' { A4 }, '64' { A8 } ` flag=UW`},	\
	10183 { `__chxacl exit: error=EW rc=D1`},				\
	10184 { `__fstatxacl entry: fd=UW acl=UW size=UW type=UW ctl_flg=UW`},	\
	10185 { `__fstatxacl exit: error=EW rc=D1`},				\
	10186 { `__statxacl entry: path=XW acl=UW size=UW type=UW ctl_flg=UW`},	\
	10187 { `__statxacl exit: error=EW rc=D1`},				\
	10188 { `__aclxcntl entry: path=XW cmd=UW arg=UW size=UW`},		\
	10189 { `__aclxcntl exit: error=EW rc=D1`},				\
	10190 { `priv_refmon entry: priv=UW`},					\
	10191 { `priv_refmon exit: priv=UW priv_found=DW`},			\
	10192 { `refmon entry: callfrom=XW callfrom2=XW`},			\
	10193 { `refmon exit: rc=DW action=XW`},				\
	10400 { `sec_getuserkat entry: auth_buf=XW sizep=XW`},			\
	10401 { `sec_getuserkat exit: error=EW rc=DW`},				\
	10402 { `sec_getkat entry: auth_buf=XW sizep=XW`},			\
	10403 { `sec_getkat exit: error=EW rc=DW`},				\
	10404 { `sec_authidtoname entry: auth=UW buf=XW`},			\
	10405 { `sec_authidtoname exit: error=EW rc=DW`},			\
	10406 { `sec_authnametoid entry: authname=XW aidp=XW`},			\
	10407 { `sec_authnametoid exit: error=EW rc=DW`},			\
	10408 { `sec_checkauth entry: authname=XW`},				\
	10409 { `sec_checkauth exit: error=EW rc=DW`},				\
	10410 { `sec_checkauthid entry: auth=UW`},				\
	10411 { `sec_checkauthid exit: error=EW rc=DW`},			\
	10412 { `sec_getkatids entry: auth_buf=XW sizep=XW`},			\
	10413 { `sec_getkatids exit: error=EW rc=DW`},				\
	10416 { `_check_auths_any entry: authid=UW`},				\
	10417 { `_check_auths_any exit: rc=DW`},				\
	10418 { `_check_auths_bitmap entry: authid=UW`},			\
	10419 { `_check_auths_bitmap exit: bitmap=DW`},				\
	10422 { `sec_getkrt entry: role_buf=XW sizep=XW`},			\
	10423 { `sec_getkrt exit: error=EW rc=DW`},				\
	10424 { `sec_getrolebyid entry: role=UW role_buf=XW sizep=XW`},		\
	10425 { `sec_getrolebyid exit: error=EW rc=DW`},			\
	10426 { `sec_getrolebyname entry: role=XW role_buf=XW sizep=XW`},	\
	10427 { `sec_getrolebyname exit: error=EW rc=DW`},			\
	10428 { `sec_roleidtoname entry: role=UW rolename=XW sizep=XW`},	\
	10429 { `sec_roleidtoname exit: error=EW rc=DW`},			\
	10430 { `sec_rolenametoid entry: rolename=XW ridp=XW`},			\
	10431 { `sec_rolenametoid exit: error=EW rc=DW`},			\
	10440 { `sec_setwascid entry: cid=UW WAS=XW WAS_num=UW`},		\
	10441 { `sec_setwascid exit: error=EW rc=DW`},				\
	10442 { `sec_getwascid entry: cid=UW WAS_buf=XW sizep=XW`},		\
	10443 { `sec_getwascid exit: error=EW rc=DW`},				\
	10444 { `sec_getwas entry: WAS_buf=XW sizep=XW`},			\
	10445 { `sec_getwas exit: error=EW rc=DW`},				\
	10450 { `sec_setwpscid entry: cid=UW WPS=XW`},				\
	10451 { `sec_setwpscid exit: error=EW rc=DW`},				\
	10452 { `sec_getwpscid entry: cid=UW WPS=XW`},				\
	10453 { `sec_getwpscid exit: error=EW rc=DW`},				\
	10454 { `sec_getsysprivs entry: WPS=XW`},				\
	10455 { `sec_getsysprivs exit: error=EW rc=DW`},			\
        10456 { `sec_setkst entry: setkst_buf=XW setkst_siz=UW`},		\
	10457 { `sec_setkst exit: error=EW rc=DW`},				\
	10462 { `sec_getkpct entry: path_buf=XW num_entries=XW`},		\
	10463 { `sec_getkpct exit: error=EW rc=DW`},				\
	10464 { `sec_getcmdattrs entry: path=XW`},			        \
	10465 { `sec_getcmdattrs exit: error=EW rc=DW`},			\
	10472 { `sec_getkpdt entry: path=XW num_entries=XW`},			\
	10473 { `sec_getkpdt exit: error=EW rc=DW`},				\
	10474 { `sec_getdevattrs entry: path=XW`},		                \
	10475 { `sec_getdevattrs exit: error=EW rc=DW`},			\
	10476 { `sec_getauditrange entry: warp=XW`},				\
	10477 { `sec_getauditrange exit: error=EW rc=DW`},			\
	10478 { `sec_setauditrange entry: warp=XW flag=XW`},			\
	10479 { `sec_setauditrange exit: error=EW rc=DW`},			\
	\* { "UNKNOWN SUBHOOK ID:" $HD%UW }
3B8 1.0 L=APPL "SEC DATA:" 				\
	UW,						\
	10 { "getconfattr: sys=" },			\
	11 { "getconfattr: atnam=" },			\
	20 { "getgroupattr: atnam=" },			\
	30 { "putgroupattr: atnam=" },			\
	70 { "getuserattr: atnam=" },			\
	80 { "putuserattr: atnam=" },			\
	110 { "getgenricattr: file=" },			\
	111 { "getgenricattr: stanza=" },		\
	112 { "getgenricattr: atnam=" },		\
	120 { "putgenricattr: file=" },			\
	121 { "putgenricattr: stanza=" },		\
	122 { "putgenricattr: atnam=" },		\
	140 { "setpenv: cmd=" },			\
	170 { "authenticate: uname=" },			\
	171 { "authenticate: AUTHSTATE=" },		\
	172 { "authenticate: FNAME=" },			\
	173 { "authenticate: GRAMMAR=" },		\
	180 { "getpwnam_r: nam=" },			\
	181 { "getpwnam_r: line=" },			\
	190 { "getpwuid_r: line=" },			\
	200 { "getpwent_r: line=" },			\
	210 { "getgrnam_r: name=" },			\
	211 { "getgrnam_r: line=" },			\
	220 { "getgrgid_r: line=" },			\
	230 { "getgrent_r: line=" },			\
	231 { "_build_loadmodule_list: error in stanza=" },	\
	250 { "pkim_list_build: found srvname=" },			\
	257 { "pkim_list_loadservice: loading program=" },	\
	10000 { "accessx: path=" },			\
	10041 { "auditlog: Event=" },			\
	10042 { "auditlog: Buffer=" },			\
	10070 { "chacl: path=" },			\
	10091 { "chpriv: path=" },			\
	10121 { "revoke: path=" },			\
	10161 { "statpriv: path=" },			\
	10176 { "__chaclx: path=" },			\
	\* { "UNKNOWN SUBHOOK ID:" $D1%UW $BREAK }	\
	LOOP $HL {A1.1""}				\
	" len=" $HL%UW
3c5 1.0 L=SVC "@ IPCACCESS EVENT" \
{{ \
ipcflag(flag) \
	$flag \
	BITFLAGS $flag%o4, \
	0001000 "IPC_CREATE_OLD", \
	0002000 "IPC_EXCL", \
	0020000 "IPC_CREATE" \
}} \
{{ \
ipcmode(mode) \
	$mode \
	BITFLAGS $mode%o4, \
	0001000 "IPC_ALLOC" \
}} \
	"ipcaccess p->uid="$D1" p->mode="ipcmode($D2) \
	"p->seq="$D3" p->key="$D4 $D4, \
	 0 "IPC_PRIVATE_OLD", \
	-1 "IPC_PRIVATE" \
	"mode="ipcmode($D5)
3c6 1.0 L=SVC "@ IPCGET EVENT" \
	"ipcget key="$D1 $D1, \
	 0 "IPC_PRIVATE_OLD", \
	-1 "IPC_PRIVATE" \
	"flag="ipcflag($D2)" base="$D3" size="$D4" *mark="$D5
3c7 1.0 L=SVC "@ MSGCONV EVENT" \
	"msgconv msgid="$D1" seq="$D2" index="$D3" qp="$D4
3c8 1.0 L=SVC "@ MSGCTL SYSTEM CALL" \
	"msgctl msgid="$D1 \
	"cmd="$D2 $D2, \
	  0 "IPC_RMID", \
	  1 "IPC_SET_OLD", \
	  2 "IPC_STAT_OLD", \
	101 "IPC_SET", \
	102 "IPC_STAT" \
	" buf="$D3
3c9 1.0 L=SVC "@ MSGGET SYSTEM CALL" \
	"msgget key="$D1 $D1, \
	 0 "IPC_PRIVATE_OLD", \
	-1 "IPC_PRIVATE" \
	"msgflg="ipcflag($D2)" msgid="$D3
3ca 1.0 L=SVC "@ MSGRCV SYSTEM CALL" \
	"msgrcv msgid="$D1" msgp="$D2" msgsz="$D3" msgtyp="$D4 \
	"msgflg="$D5 BITFLAGS $D5%o4, \
	0010000 "MSG_NOERROR", \
	0004000 "IPC_NOWAIT"
3cb 1.0 L=SVC "@ MSGSELECT SYSTEM CALL" \
	"msgselect msgid="$D1" corl="$D2" reqevents="$D3" rtneventsp="$D4 \
	" rc="$D5
3cc 1.0 L=SVC "@ MSGSND SYSTEM CALL" \
	"msgsnd msgid="$D1" msgp="$D2" msgsz="$D3 \
	"msgflg="$D4 BITFLAGS $D4%o4, \
	0004000 "IPC_NOWAIT"
3cd 1.0 L=SVC "@ MSGXRCV SYSTEM CALL" \
	"msgxrcv msgid="$D1" msgp="$D2" msgsz="$D3" msgtyp="$D4 \
	"msgflg="$D5 BITFLAGS $D5%o4, \
	0004000 "IPC_NOWAIT"
3ce 1.0 L=SVC "@ SEMCONV EVENT" \
	"semconv semid="$D1" seq="$D2" index="$D3" sp="$D4
3cf 1.0 L=SVC "@ SEMCTL SYSTEM CALL" \
	"semctl semid="$D1" semnum="$D2 \
	"cmd="$D3 $D3, \
	  0 "IPC_RMID", \
	  1 "IPC_SET_OLD", \
	  2 "IPC_STAT_OLD", \
	  3 "GETNCNT", \
	  4 "GETPID", \
	  5 "GETVAL", \
	  6 "GETALL", \
	  7 "GETZCNT", \
	  8 "SETVAL", \
	  9 "SETALL", \
	101 "IPC_SET", \
	102 "IPC_STAT" \
	" arg="$D4
3d0 1.0 L=SVC "@ SEMGET SYSTEM CALL" \
	"semget key="$D1 $D1, \
	 0 "IPC_PRIVATE_OLD", \
	-1 "IPC_PRIVATE" \
	"nsems="$D2" semflg="ipcflag($D3)" sp="$D4
3d1 1.0 L=SVC "@ SEMOP SYSTEM CALL" \
	"semop semid="$D1" sops="$D2" nsops="$D3
3d2 1.0 L=SVC "@ SEM EVENT" \
	"sem op semid="$D1" semval="$D2" sem_num="$D3" sem_op="$D4 \
	"sem_flg="$D5 BITFLAGS $D5%o4, \
	0010000 "SEM_UNDO", \
	0004000 "IPC_NOWAIT"
3d3 1.0 L=SVC "@ SHMAT SYSTEM CALL" \
        W1 "shmat shmid="XW "addr="X8 \
        {{ $flg = XW }} \
        "flag="$flg BITFLAGS $flg%o4, \
        010000 "SHM_RDONLY", \
        020000 "SHM_RND", \
        004000 "SHM_MAP", \
        002000 "SHM_FMAP", \
        040000 "SHM_COPY"
3d4 1.0 L=SVC "@ SHMCONV EVENT" \
	"shmconv shmid="$D1" flg="$D2" seq="$D3" index="$D4" sp="$D5
3d5 1.0 L=SVC "@ SHMCTL SYSTEM CALL" \
	"shmctl shmid="$D1 \
	"cmd="$D2 $D2, \
	  0 "IPC_RMID", \
	  1 "IPC_SET_OLD", \
	  2 "IPC_STAT_OLD", \
	  6 "SHM_SIZE", \
	101 "IPC_SET", \
	102 "IPC_STAT" \
	" arg=" W3 X8
3d6 1.0 L=SVC "@ SHMDT SYSTEM CALL" \
        W1 "shmdt addr="X8
3d7 1.0 L=SVC "@ SHMGET SYSTEM CALL" \
	"shmget key="$D1 $D1, \
	 0 "IPC_PRIVATE_OLD", \
	-1 "IPC_PRIVATE" \
	"size=" W4 D8 " shmflg="ipcflag($D2)" sp="$D3
3d8 1.0 L=SVC "@ MADVISE SYSTEM CALL" \
{{ \
mmap_prot(prot) \
	$prot \
	BITFLAGS $prot%o4, \
	1 "PROT_READ", \
	2 "PROT_WRITE", \
	4 "PROT_EXEC" \
}} \
{{ \
mmap_flag(flag) \
	$flag \
	BITFLAGS $flag, \
	0x001 "MAP_SHARED", \
	0x002 "MAP_PRIVATE", \
	0x010 "MAP_ANONONYMOUS", \
	0x100 "MAP_FIXED" \
}} \
	"madvise addr="$D1" len="$D2" behav="$D3
3d9 1.0 L=SVC "@ MINCORE SYSTEM CALL" \
	"mincore addr="$D1" len="$D2" vec="$D3
3da 1.0 L=SVC "@ MMAP SYSTEM CALL" \
	"mmap addr="$D1" len="$D2 \
	"prot="mmap_prot($D3) \
	"flags="mmap_flag($D4) \
	"fd="$D5
3db 1.0 L=SVC "@ MPROTECT SYSTEM CALL" \
	"mprotect addr="$D1" len="$D2 \
	"prot="mmap_prot($D3)
3dc 1.0 L=SVC "@ MSYNC SYSTEM CALL" \
	"msync addr="$D1" len="$D2
3dd 1.0 L=SVC "@ MUNMAP SYSTEM CALL" \
	"munmap addr="$D1" len="$D2
3de 1.0 L=SVC "@ MVALID SYSTEM CALL" \
	"mvalid addr="$D1" len="$D2" prot="mmap_prot($D3)
3df 1.0 L=SVC "@ MSEM_INIT SYSTEM CALL" \
	"msem_init msem="$D1" msem_state="$D2" msem_wanted="$D3 \
	"initial_value="$D4
3e0 1.0 L=SVC "@ MSEM_LOCK SYSTEM CALL" \
	"msem_lock msem="$D1" msem_state="$D2" msem_wanted="$D3 \
	"condition="$D4
3e1 1.0 L=SVC "@ MSEM_REMOVE SYSTEM CALL" \
	"msem_remove msem="$D1" msem_state="$D2" msem_wanted="$D3
3e2 1.0 L=SVC "@ MSEM_UNLOCK SYSTEM CALL" \
	"msem_unlock msem="$D1" msem_state="$D2" msem_wanted="$D3 \
	"condition="$D4
3EC 1.1 "@LFS: vfs_vget / vnode cache" \
     $HD, \
     0xFF { `vfs_vget(vfsp = $D3, fid_ino = $D4, fid_gen = $D5) = $D1, *vpp = $D2` }, \
     0x0D { `vnode cache enter: vp = $D1, dev = $D2, ino = $D3, gen = $D4, hash = $D5` }, \
     0x0E { `vnode cache remove: vp = $D1, dev = $D2, ino = $D3, gen = $D4, hash = $D5` }, \
     0x0F { `vnode cache purge: dev = $D2, getcaller = $D3, getcaller2 = $D4: rc = $D1` }, \
     0x10 { `vnode cache hit: dev = $D2, ino = $D3, gen = $D4: *vpp = $D1, hash = $D5` }, \
     0x11 { `vnode cache miss: dev = $D2, ino = $D3, gen = $D4: *vpp = $D1, hash = $D5` }, \
     \*   { vfs_vget unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
3F7 1.1 L=KERN "@JFS2: vnode (deprecated, use 59B and vnops trace group)" \
        $HD, \
        0x01  { `JFS2 RDWR: (vp,ip)=($D1,$D2)` \
               pfsrdwrinstall1($D1,$D2) vnodetofilename($D1) $BREAK }, \
        0x02  { {{ $h = "READI" }} }, \
        0x03  { {{ $h = "WRITEI" }} }, \
        0x04  { `JFS2 CLOSE: (ip, gp)=($D1, $D2)` $BREAK }, \
        0x05  { `JFS2 OPEN: (ip, gp)=($D1, $D2)` $BREAK }, \
	0x06  { `JFS2 VFS: vfs_number=$D1, inode_number=$D2` $BREAK }, \
        \* { `JFS2 mode=$HD` } \
        `JFS2 $h: VA.S=$D3$D4.$D2 bcount=$D5 ip=$D1` \
        pfsrdwrinstall2($D4,$D5,$D2,$D1) \
        {{ $mspage = $D3 * 1048576 }} \
        {{ $lspage = $D4 / 4096 }} \
        {{ $vpage = $mspage + $lspage }} vpagetofilename($vpage,$D2)
3F8 1.1 L=KERN "@JFS2: pager (deprecated, use 59B)" \
	{{ $left }} {{ $trust }} {{ $fault }} {{ $prer }} {{ $decis }} \
        $HD, \
        0x01 { `JFS2 PAGEIN: segment=$D2%X4, offset=$D4%X8, length=$D5%X4` $BREAK }, \
        0x02    { `JFS2 PAGEOUT: segment=$D2%X4, offset=$D4%X8, length=$D5%X4` $BREAK }, \
        0x03    {  {{ $trust = $D4 & 0xFFFFFFFF }} {{ $trust = $trust / 16777216 }} \
                {{ $fault = $D4 & 0xFFFFFF }}   {{ $fault = $fault / 65536 }} \
                {{ $prer  = $D4 & 0xFFFF }}     {{ $prer  = $prer  / 256 }} \
                {{ $decis = $D4 & 0xFF }} \
                `JFS2 READAHEAD: segment=$D1%X4, offset=$D2%XW, length=$D3%XW, trust=$trust, fault=$fault, prer=$prer, decis=$decis` $BREAK }, \
        \*   { 'JFS2 PAGER: unknown hookid ' $HD }
400 1.0 "@STTY " \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} {{ $name }} \
        O1 {{ $how = B0.2 }} {{ $which = B0.6 }} \
        {{ $maj = $D1 / 65536 }} \
        {{ $min = $maj * 65536 }} {{ $min = $D1 - $min }} \
        "("$maj%X2","$min%X2")" $name \
        $which, \
        0001 "config ", \
        0002 "open ", \
        0003 "close ", \
        0004 "wput ", \
        0005 "rput ", \
        0006 "wsrv ", \
        0007 "rsrv ", \
        000A "proc ", \
        000B "service ", \
        000C "slih ", \
        000D "offlevel " \
        $how, \
        0000 { $which, \
            0001 { "cmd" $D3, \
		0x1 "CFG_INIT", \
		0x2 "CFG_TERM", \
		0x3 "CFG_QVPD", \
		0x4 "CFG_UCODE", \
		\* { $D3%XW } \
		}, \
            0002 { "ptr" $D2%XW "mode:" dopenflags($D3) \
                   "sflag:" $D4, \
                0000 "0", \
                0001 "MODOPEN", \
                0002 "CLONEOPEN", \
		\* { $D4 } }, \
            0003 { "ptr" $D2%XW "mode:" dopenflags($D3) }, \
            0004 { "ptr" $D2%XW "@msg" $D3%XW \
		   "msg_type" messagetype($D4) \
		 }, \
            0005 { "ptr" $D2%XW "@msg" $D3%XW \
		   "msg_type" messagetype($D4) \
		 }, \
            0006 { "ptr" $D2%XW "q_count" $D3 }, \
            0007 { "ptr" $D2%XW "q_count" $D3 }, \
            000A { "ptr" $D2%XW \
            	   $D3, \
                0000 "output" , \
                0001 "suspend" , \
                0002 "resume" , \
                0003 "block" , \
                0004 "unblock" , \
                0005 "rflush" , \
                0006 "wflush" }, \
            000B { "ptr" $D2%XW \
                   $D3, \
                0000 { "proc" $D4, \
                    0000 "output" , \
                    0001 "suspend" , \
                    0002 "resume" , \
                    0003 "block" , \
                    0004 "unblock" , \
                    0005 "rflush" , \
                    0006 "wflush" }, \
                0001 { "set control" BITFLAGS $D4, \
                        0x01 "TSDTR", \
                        0x02 "TSRTS", \
                        0x04 "TSCTS", \
                        0x08 "TSDSR", \
                        0x10 "TSRI ", \
                        0x20 "TSCD " }, \
                0002 { "get control" }, \
                0003 { "get status" }, \
                0004 { "sbaud" $D4%DW }, \
                0005 { "get baud" }, \
                0006 { "set input baud" $D4%DW }, \
                0007 { "get input baud" }, \
                0008 { "set bpc" {{ $dog = $D4 + 5 }} $dog%DW }, \
                0009 { "get bpc" }, \
                000A { "set parity" $D4, \
                    0000 "none", \
                    0001 "odd", \
                    0002 "mark", \
                    0003 "even", \
                    0004 "space" }, \
                000B { "get parity" }, \
                000C { "set stops" $D4, 0 "1", 1 "2" }, \
                000D { "get stops" }, \
                000E { "set break" }, \
                000F { "clear break" }, \
                0010 { "open" $D4, 0 "local", 1 "remote" }, \
                0011 { "dopace" $D4, \
                    0000 "again" , \
                    0001 "xon" , \
                    0002 "str" , \
                    0003 "dtr" , \
                    0004 "rts" }, \
                0012 { "softpace" $D4, \
                    0000 "remote off" , \
                    0001 "remote any" , \
                    0002 "remote on" , \
                    0003 "remote str" , \
                    0004 "local off" , \
                    0005 "local on" , \
                    0006 "local str" }, \
                0013 { "softrchar" $D4 }, \
                0014 { "softlchar" $D4 }, \
                0015 { "softrstr" $D4 }, \
                0016 { "softlstr" $D4 }, \
                0017 { "hardrbits" $D4 }, \
                0018 { "hardlbits" $D4 }, \
                0019 { "loop" $D4, 0 "enter", 1 "exit" } }, \
            000C { "rintr" $D2%XW "adap_type" $D3, \
		0000 "Native io", \
		0001 "8/16 Port" }, \
            000D { "rintr" $D2%XW } } \
{{ \
stty_ret(which) \
	$which, \
        0001 { "ret" $D3 "from line" $D4  }, \
        0002 { "ret" $D3 "from line" $D4  }, \
        0003 { "ret" $D3 "from line" $D4  }, \
        0004 { "ret" $D3 "from line" $D4  }, \
        0005 { "ret" $D3 "from line" $D4  }, \
        0006 { "ret" $D3 "from line" $D4  }, \
        0007 { "ret" $D3 "from line" $D4  }, \
        0008 { "ret" $D3 "from line" $D4  }, \
        0009 { "ret" $D3 "from line" $D4  }, \
        000A { "ret" $D3 "from line" $D4  }, \
        000B { "ret" $D3 "from line" $D4  }, \
        000C { "ret" $D3 "from line" $D4  }, \
        000D { "ret" $D3 "from line" $D4  }, \
        000E { "last "      "ret" $D3 "from line" $D4  }, \
	\* { "unknown subhook" $HD }    \
}}
401 1.0 "@STTY STRTTY" \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "sth" }} \
	$400 \
	$which, \
	0008 "revoke ", \
	0009 "ioctl " \
	$how, \
	0000 { $which, \
		0008 { "flag" $D3 }, \
		0009 { "osr" $D2%XW "cmd" ioctlname($D3) } }, \
	0002 { $which, \
		\* { stty_ret($which) } }
402 1.0 "@STTY LDTERM " \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "ldterm" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000e "gwinsz ", \
	000f "fastinput ", \
	0010 "backdone ", \
	0011 "readdata ", \
	0012 "ioctl_ack ", \
	0013 "need_flush ", \
	0014 "pend ", \
	0015 "input ", \
	0016 "flush_shead ", \
	0017 "flush ", \
	0018 "flush_mp ", \
	0019 "echo ", \
	001a "rub ", \
	001b "rubo ", \
	001c "putc ", \
	001d "output ", \
	001e "start ", \
	001f "retype ", \
	0020 "tblock ", \
	0021 "wakeup ", \
	0022 "intimeout ", \
	0023 "canputnext ", \
	0024 "write ", \
	0025 "sendcanon ", \
	0026 "sendraw ", \
	0027 "mnotify ", \
	0028 "break ", \
	0029 "mhangup ", \
	002a "mctl ", \
	002b "sendctl ", \
	002c "b_to_m ", \
	002d "stuffc ", \
	002e "unstuffc ", \
	002f "post_input ", \
	0030 "swinsz ", \
	0031 "sti ", \
	0032 "getoutbuf ", \
	0033 "putctl_later ", \
	0034 "putctl_timeout ", \
	0035 "recover " \
        $how, \
        0000  { $which, \
		0009 { "ptr" $D2%XW "cmd" ioctlname($D3) }, \
		000e { "q" $D3 "mp" $D4 }, \
		000f { "mp" $D3 }, \
		0010 { "q" $D3 "mp" $D4 }, \
		0011 { "mp" $D3 }, \
		0012 { "q" $D3 "mp" $D4 }, \
		0013 { "cmd" $D3 "new" $D4 }, \
		0014 { }, \
		0015 { "c" $D3 }, \
		0016 { "mp" $D3 }, \
		0017 { "mp" $D3 }, \
		0018 { "flags" $D3 "rmp" $D4 "wmp" $D5 }, \
		0019 { "c" $D3 }, \
		001a { "c" $D3 }, \
		001b { "ct" $D3 }, \
		001c { "c" $D3 }, \
		001d { "c" $D3 }, \
		001e { }, \
		001f { }, \
		0020 { }, \
		0021 { }, \
		0022 { }, \
		0023 { "mp" $D3 "q" $D4 }, \
		0024 { "mp" $D3 }, \
		0025 { }, \
		0026 { }, \
		0027 { "mp" $D3 }, \
		0028 { "mp" $D3 }, \
		0029 { "q" $D3 "mp" $D4 }, \
		002a { "q" $D3 "mp" $D4 }, \
		002b { "command" $D3 "size" $D4 }, \
		002c { "cp" $D3 "cc" $D4 }, \
		002d { "c" $D3 }, \
		002e {	}, \
		002f { "post_wakeup" $D3 }, \
		0030 { "mp" $D3 }, \
		0031 { "mp" $D3 }, \
		0032 { }, \
		0033 { "msg_needed" $D3 }, \
		0034 { }, \
		0035 { } \
		}, \
        0002 { $which, \
		0011 { "ret" $D3 "from line" $D4%DW }, \
		\* { "ret" $D3%DW "from line" $D4%DW } }, \
	0003 { $D3, \
		0000 { "break at line" $D4%DW }, \
		0001 { "continue at line" $D4%DW }, \
		0002 { "goto from line" $D4%DW } }
403 1.0 "@STTY SPTR " \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "sptr" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000E "sp_open_wakeup ", \
	000F "start_write ", \
	0010 "format_data ", \
	0011 "sptr_prnformat ", \
	0012 "addc ", \
	0013 "write_mread ", \
	0014 "read_mdata ", \
	0015 "write_timeout ", \
	0016 "read_miocack ", \
	0017 "read_miocnak ", \
	0018 "sptr_mctl ", \
	0019 "cts_handle ", \
	001A "write_req_ioctl ", \
	001B "write_mflush ", \
	001C "tioc_handle ", \
	001D "ioctl_reply ", \
	001E "send_xctl_tiocgeta ", \
	001F "allocb_recovery ", \
	0020 "continue_write ", \
	0021 "sptr_release " \
	$how, \
	0000 { $which, \
	    0009 { "ptr" $D2%XW "cmd" ioctlname($D3) "rwflag" $D4 "ext" $D5 }, \
	    000E { }, \
	    000F { "mp" $D3%XW }, \
	    0010 { "mp" $D3%XW "nmp" $D3%XW }, \
	    0011 { "nmp" $D3%XW "c" $D4 }, \
	    0012 { "nmp" $D3%XW "c" $D4 }, \
	    0013 { "mp" $D3%XW }, \
	    0014 { "mp" $D3%XW }, \
	    0015 { }, \
	    0016 { "mp" $D3%XW "cmd" ioctlname($D4) }, \
	    0017 { "mp" $D3%XW "cmd" ioctlname($D4) }, \
	    0018 { "mp" $D3%XW }, \
	    0019 { $D3, 0005 "cts_on ", 0006 "cts_off " $D4%XW }, \
	    001A { "mp" $D3%XW }, \
	    001B { "mp" $D3%XW }, \
	    001C { "mp" $D3%XW }, \
	    001D { "mp" $D3%XW "db_type" $D4 "ioc_error" $D5%EW }, \
	    001E { "mp" $D3%XW "cmd" ioctlname($D4) }, \
	    001F { "bid" $D3%XW "tid" $D4%XW "num" $D5%DW }, \
            0020 { }, \
	    0021 { } }, \
        0002 { $which, \
		\* { "ret" $D3%EW "from line" $D4%DW } }, \
	0003 { $D3, \
		0000 { "break at line" $D4%DW }, \
		0001 { "continue at line" $D4%DW }, \
		0002 { "goto from line" $D4%DW } }
404 1.0 "@STTY NLS " \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "nls" }} \
	$400 \
	$which, \
	0009 "ioctl " \
	$how, \
	0000 { $which, \
		0009 { "ptr" $D2%XW "cmd" ioctlname($D3) } }, \
	0002 { $which, \
		\* { stty_ret($which) } }
405 1.0 "@STTY PTY" \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "pty" }} \
	$400 \
	$which, \
	0009 "ioctl " \
	$how, \
	0000 { $which, \
		0009 { "ptr" $D2%XW "cmd" ioctlname($D3) } }, \
	0002 { $which, \
		\* { stty_ret($which) } }
406 1.0 "@STTY RS" \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "rs" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000E "flush ", \
	000F "ctl ", \
	0010 "termios_set ", \
	0011 "termios_get ", \
	0012 "termiox_set ", \
	0013 "termiox_get ", \
	0014 "break_set ", \
	0015 "break_clear ", \
	0016 "add ", \
	0017 "del ", \
	0018 "allocmsg ", \
	0019 "revover ", \
	001A "timeout ", \
	001B "allocmflush ", \
	001C "mflush_recover ", \
	001D "mflush_timeout " \
	$how, \
	0000 { $which, \
		0009 { "ptr" $D2%XW "cmd" ioctlname($D3) }, \
		000E { "rw" BITFLAGS $D3, 1 "read", 2 "write" }, \
		000F { "cmd" ioctlname($D3) }, \
		0010 { "cflag" $D3%XW "iflag" $D4%XW "start/stop" $D5%X2 }, \
		0011 { }, \
		0012 { "hflag" $D3%XW }, \
		0013 { }, \
		0014 { duration $D3%DW }, \
		0015 { }, \
		0016 { "dev" $D3%XW }, \
		0017 { "dev" $D3%XW }, \
		0018 { }, \
		0019 { }, \
		001A { }, \
		001B { }, \
		001C { }, \
		001D { } }, \
        0002 { $which, \
		0018 { "ret" $D3 "from line" $D4%DW }, \
		\* { "ret" $D3%DW "from line" $D4%DW } }, \
	0003 { $D3, \
		0000 { "break at line" $D4%DW }, \
		0001 { "continue at line" $D4%DW }, \
		0002 { "goto from line" $D4%DW } }
407 1.0 "@STTY LION" \
        {{ $maj }} {{ $min }} {{ $how }} {{ $which }} \
        {{ $name = "lion" }} \
	$400 \
	$which, \
	0009 "ioctl ", \
	000e "add ", \
	000f "del ", \
	0010 "cbreak ", \
	0011 "termios set ", \
	0012 "strttyinput ", \
	0013 "send ", \
	0014 "comm ", \
	0015 "recv ", \
	0016 "gcomm_tmr " \
	$how, \
	0000 { $which, \
		0009 { "ptr" $D2%XW "cmd" ioctlname($D3) }, \
		0011 { "cflag" $D2%XW "iflag" $D3%XW }, \
		0012 { "c" $D2 "status" $D3 }, \
		0013 { "ld" $D3 "busmem" $D4 }, \
		0014 { "comm" $D3 }, \
		0015 { "busmem" $D3 } }, \
	0001 { $which, \
		0002 { $D3, \
			0001 { "tp" $D4 "ld" $D5 } }, \
		000C { "dev" $D4 "chan" $D5 BITFLAGS $D3, \
			0x01 "RCMAIN", \
			0x02 "RCALT", \
			0x04 "TXMAIN", \
			0x08 "TXALT", \
			0x10 "TXPAR", \
			0x20 "DCD", \
			0x40 "HILINK", \
			0x80 "CTS" }, \
		000D { $D3, \
			0001 { "calling slion_recv at" $D4%DW } }, \
		0010 { "Had message" }, \
		0012 { "Hit point" $D3 }, \
		0013 { $D3, \
			0001 { "txcnt" $D4%DW "len" $D5%DW } }, \
		\*   { "Unknown Data hook" } }, \
	0002 { $which, \
		0010 { "ret" $D3 "from line" $D4%DW  }, \
		0011 { "ret" $D3 "from line" $D4%DW  }, \
		0012 { "ret" $D3 "from line" $D4%DW  }, \
		0013 { "ret" $D3 "from line" $D4%DW  }, \
		0014 { "ret" $D3 "from line" $D4%DW  }, \
		0015 { "ret" $D3 "from line" $D4%DW  }, \
		0016 { "ret" $D3 "from line" $D4%DW  }, \
		\* { stty_ret($which) } }, \
	0003 { $D3, \
		0000 { "break at line" $D4%DW }, \
		0001 { "continue at line" $D4%DW }, \
		0002 { "goto from line" $D4%DW } }
419 1.0 L=INT "Virtual CPU preemption/dispatch data" \
	$GENERIC,\
		1 { {{ $typ = XW }} {{ $alldata = 1 }} },\
		\* { {{ $typ = X2 }} \
		     $HOOKENV,\
			32 { {{ $alldata = 0 }} }, \
			64 { {{ $alldata = 1 }} } \
		   }\
	{{ $CPUID = $typ & 0xFFF }}\
	{{ $lost = $typ & 0x4000 }}\
	{{ $realloc = $typ & 0x8000 }}\
	{{ $dispatch_rc = X1 }}\
	{{ $preempt_rc = X1 }}\
	{{ $vrm = 0 }}\
        $lost,\
		0x4000 { "\nprior entries were lost" $BREAK }\
        $realloc,\
		0x8000 { "\npreemption buffer reallocated" $BREAK }\
		"\nPreempt:"\
	$preempt_rc,\
		1  { "FWEvents," },\
		2  { "CEDE," },\
		3  { "CONFER," },\
		4  { "Timeout," },\
		5  { "PMIG or HIBERNATE," {{ $vrm = 1}} },\
		6  { "VRM Fault," {{ $vrm = 1}} },\
		7  { "CONFER adjunct & run," }, \
		8  { "Hcall & adjunct run," },\
		9  { "Timeout & adjunct run," },\
		\* { "Unknown preempt reason code," }\
		"Dispatch:"\
	$dispatch_rc,\
		0  { "EI" },\
		1  { "LpEvent" },\
		2  { "LpProd" },\
		3  { "Timeout" },\
		4  { "IPL" },\
		5  { "Terminate" },\
		6  { "Unblocked" },\
		7  { "Timeslice" },\
		8  { "VRM Fault" },\
		9  { "Run Adjunct" },\
                \* { "Unknown dispatch reason code" }\
	"vProcIndex="X2\
	$GENERIC,\
		1 {\
			{{ $exdelta = X4 }} {{ $enqdelta = X4 }} {{ $rtrdelta = X4 }}\
			"\nrtrdelta="$rtrdelta%u4 "us enqdelta="$enqdelta%u4 "us exdelta="$exdelta%u4 "us"\
			{{ $startwait = X8 }} {{ $delta = $exdelta + $enqdelta }}\
			{{ $delta = $delta + $rtrdelta }} {{ $endwait = $startwait + $delta }}\
			"\nstart wait="$startwait%m8 "ms end wait="$endwait%m8 "ms"\
			$vrm,\
				1 { "logical_raddr="X8 }\
			$vrm,\
				0 { O8 }\
		}\
	$GENERIC,\
		0 {\
			$vrm,\
			1 {\
				{{ $rtrdelta = X4 }} {{ $addr = X8 }} {{ $startwait = X8 }}\
                                "\nrtrdelta="$rtrdelta%u4 "start wait="$startwait%m8 "logical_raddr="$addr }\
			$vrm,\
			0 {\
				{{ $exdelta = X4 }} {{ $enqdelta = X4 }} {{ $rtrdelta = X4 }}\
				"\nrtrdelta="$rtrdelta%u4 "us enqdelta="$enqdelta%u4 \
				"us exdelta="$exdelta%u4 "us"\
				{{ $startwait = X8 }} {{ $delta = $exdelta + $enqdelta }}\
				{{ $delta = $delta + $rtrdelta }} {{ $endwait = $startwait + $delta }}\
				"\nstart wait="$startwait%m8 "ms end wait="$endwait%m8 "ms" }\
		}\
	"\nSRR0="X8 " SRR1="X8\
	$GENERIC,\
		1 {\
			{{ $dist = B0.4 }} {{ $junk = B0.12 }}\
			{{ $srad = X2 }}\
			{{ $assoc = X4 }}\
			"\ndist: "\
			$dist,\
				0  { "unknown" },\
				1  { "local" },\
				2  { "near" },\
				3  { "far" },\
				\* { "invalid" }\
			" srad="$srad%D2 "assoc="$assoc%D4\
		}
460 1.0 L=KERN "@ASSERT WAIT"	\
   	$PLATFORMTYPE, \
   	0 { "e_assert_wait:   tid="prKernelTID($D1)  "anchor="$D2  "flag="$D3%D1  "lr="$D4 }, \
   	1 { "e_assert_wait:   tid="prKernelTID($D1)  "anchor="$D2  "flag="$D3%D1  "b0="$D4 }
461 1.0 L=KERN "@CLEAR WAIT"	\
  	$PLATFORMTYPE, \
  	0 { "e_clear_wait:   tid="prKernelTID($D1)  "anchor="$D2  "result="$D3%D1  "lr="$D4 }, \
  	1 { "e_clear_wait:   tid="prKernelTID($D1)  "anchor="$D2  "result="$D3%D1  "b0="$D4 }
462 1.0 L=KERN "@THREAD BLOCK"	\
  	$PLATFORMTYPE, \
	0 { "e_block_thread:   tid="prKernelTID($D1)  "anchor="$D2  "t_flags="$D3  "lr="$D4 }, \
	1 { "e_block_thread:   tid="prKernelTID($D1)  "anchor="$D2  "t_flags="$D3  "b0="$D4 }
463 1.0 L=KERN "@EMPSLEEP"	\
  	$PLATFORMTYPE, \
	0 { "e_mpsleep:   tid="prKernelTID($TID)  "anchor="$D1  "timeout="$D2%D1\
	"lock="$D3  "flags="$D4%D1  "lr="$D5%D1 }, \
	1 { "e_mpsleep:   tid="prKernelTID($TID)  "anchor="$D1  "timeout="$D2%D1\
	"lock="$D3  "flags="$D4%D1  "b0="$D5%D1 }
464 1.0 L=KERN "@EWAKEUPONE"	\
  	$PLATFORMTYPE, \
	0 { "e_wakeup_one:   tid="prKernelTID($D1)   "anchor="$D2  "lr="$D3 }, \
	1 { "e_wakeup_one:   tid="prKernelTID($D1)   "anchor="$D2  "b0="$D3 }
465 1.0 L=SVC "@THREAD_CREATE SYSTEM CALL" \
        $HD, \
        0x000 { `thread_create:   pid=$D1%D1  tid=$D2%D1  priority=$D3%D1`\n\
               `                 policy=$D4%D1` pidinstall($D1,0,$EXECPATH,$D2,0xff,0xff) }, \
	0x001 { "  - thread_create pid =" prpid($D1) "tid ="prpid($D2) "vtid="prpid($D5) "vpid="prpid($D4) "cid="$D3%D4 \
	   cidinstall($D2, $D3, $D4, $D5, 0, 0) }, \
        0x002 { `thread_create:   Kernel thread limit reached by uid=$D1%D4`\n\
                `                 pid=$D2%D1 kcid=$D3%D4 num=$D4%D4 lim=$D5%D8` }, \
        \*   { thread_create unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 }
466 1.0 L=KERN "@KTHREAD_START"	\
	"kthread_start:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "priority="$D3%D1  \
	"policy="$D4%D1  "func="$D5
467 1.0 L=SVC "@THREAD_TERMINATE SYSTEM CALL"	\
	"thread_terminate:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)
468 1.0 L=KERN "@KSUSPEND"	\
	"ksuspend:   tid="prKernelTID($D1)  "p_suspended="$D2%D1  "p_active="$D3%D1
469 1.0  L=SVC "@THREAD_SETSTATE" \
        "thread_setstate:   tid="prKernelTID($D)  "t_state="prstate($D2)  "t_flags="$D3  \
	"priority="$D4%D1  "policy="$D5%D1
46A 1.0 L=SVC "@THREAD_TERMINATE_ACK"	\
	"thread_terminate_ack:   current_tid="prKernelTID($D1)  "target_tid="prKernelTID($D2)
46B 1.0 L=SVC "@THREAD_SETSCHED"	\
	"thread_setsched:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "priority="$D3%D1 \
	"policy="$D4%D1
46C 1.0 L=SVC "@TIDSIG"	\
  	$PLATFORMTYPE, \
	0 { "tidsig:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "signal="prsignal($D3)  "lr="$D4 }, \
	1 { "tidsig:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "signal="prsignal($D3)  "b0="$D4 }
46D 1.0 L=SVC "@WAIT_ON_LOCK"	\
        $D5,                    \
        0 {"wait_on_lock:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "lockaddr="$D3 \n }, \
        1 {"wait_on_lock:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "lockaddr="$D3  "owner="$D4%D1 "boosted="$D5 \n }, \
        \* { "wait_on_lock:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "lockaddr="$D3 \n }
46E 1.0 L=SVC "@WAKEUP_LOCK"	\
        "wakeup_lock:   lockaddr="$D1 "threads_awoken="$D2%D1 \
	"waiters_exist="$D4%D1
476 1.0 L=SVC "@THREAD_LOCKBOOST"	\
	"thread_lockboost:   pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "owner-pri="$D3%D1 \
	"mutex-pri="$D4%D1
477 1.0 L=SVC "@WAIT_ON_LOCAL_LOCK"	\
        "wait_on_local_lock: pid="prKernelPID($D1)  "tid="prKernelTID($D2)  "owner="$D3%D1 "boosted="$D4 \n
478 1.0 L=APPL "ACL ENGINE:" O2.0									\
	 $HD%UW, 											\
	 1 { `set_acl entry: `$HOOKENV, '64' {O4}`type=A4 ctl_flg=UW obj_mode=UW mode=UW size=UW`},	\
	 2 { `set_acl exit: `$HOOKENV, '64' {O4}`type=A4 rc=UW obj_mode=UW size=UW cmd=UW`},		\
	 3 { `validate_acl: `$HOOKENV, '64' {O4}`type=A4 rc=UW ace_cnt=UW acl_len=UW size=UW`},		\
	 4 { `chk_access entry: `$HOOKENV, '64' {O4}`type=A4 obj_mode=UW size=UW ops=UW uid=UW`},	\
	 5 { `aixc_chk_access_self: `$HOOKENV, '64' {O4}`type=A4 mode=UW`},				\
	 6 { `rwx_privcheck: `$HOOKENV, '64' {O4}`type=A4 deny=UW mode=UW`},				\
	 7 { `nfs4_chk_access_self: `$HOOKENV, '64' {O4}`type=A4 aceN=UW aceCnt=UW req=UW deny=UW`},	\
	 8 { `nfs4_mask_privcheck: `$HOOKENV, '64' {O4}`type=A4 deny=UW priv=UW`},			\
	 9 { `nfs4_only_privcheck: `$HOOKENV, '64' {O4}`type=A4 deny=UW priv=UW`},			\
	 10 { `chk_access exit: `$HOOKENV, '64' {O4}`type=A4 rc=UW ops=UW priv=UW against=UW`},		\
	 11 { `get_acl entry: `$HOOKENV, '64' {O4}`type=A4 ctl_flg=UW uiosize=UW mode=UW size=UW`},	\
	 12 { `get_acl exit: `$HOOKENV, '64' {O4}`type=A4 rc=UW size=UW mode=UW`},			\
	 13 { `get_child_acl entry: `$HOOKENV, '64' {O4}`type=A4 size=UW type=UW`},			\
	 14 { `get_child_acl exit: `$HOOKENV, '64' {O4}`type=A4 rc=UW cmd=UW mode=UW size=UW`},		\
	 \* { "UNKNOWN SUBHOOK ID:" $HD%UW }
47B 1.0 L=SVC "MLOCK"\
	$HD,\
	0x01 { "MLOCKALL   "},\
	0x02 { "MUNLOCKALL " \
		$D1,\
		0x00000100 "MCL_CURRENT", \
		0x00000200 "MCL_FUTURE" },\
	0x03 { "MLOCK      " `W1 addr=$D1%X8 len=$D2%XW pid=`prKernelPID($D3)},\
	0x04 { "MUNLOCK    " `W1 addr=$D1%X8 len=$D2%XW pid=`prKernelPID($D3)},\
	0x05 { "MLOCK_FPGIN" `V.S=$D3.$D1 ppage=$D4` vmmsibits($D2)  },\
        \*   { "unknown subhook" }
47F 1.0 L=INT "@PHANTOM EXTINT" \
        "phantom interrupt cpuid="$CPUID
480 1.0 " VCM_MAIN 480" \
        $GENERIC, \
        1 { \
                $D1, \
                0x3a  { "vcm_localOpsBeginCreate_NAME: " W2 $HL%S1 }, \
                0x68  { "vcmi_peerCreateObject_NAME: " W2 $HL%S1 }, \
                \* { `VCM_MAIN genmode=$D1` } \
                $BREAK \
        } \
        $HD%D1, \
        1 { "vcm_clientRegister_ENTER " version=$D1 flags=$D2 revoke_fcn=$D3 },\
        2 { "vcm_clientRegister_ERROR " },\
        3 { "vcm_clientRegister_EXIT " rc=$D1 version=$D2 chandle=$D3 },\
        4 { "vcm_clientUnregister_ENTER " chandle=$D1 },\
        5 { "vcm_clientUnregister_EXIT " rc=$D1 chandle=$D2 },\
        6 { "vcm_openVFS_ENTER " ch=$D1 vfsp=$D2 useFlags=$D3 },\
        7 { "vcm_openVFS_ERROR "  },\
        8 { "vcm_openVFS_EXIT " rc=$D1 vfsFlags=$D2 vfsHandle=$D3 },\
        9 { "vcm_closeVFS_ENTER " vfsHandle=$D1 },\
       10 { "vcm_closeVFS_EXIT " rc=$D1 vfshandle=$D2 },\
       11 { "vcm_getOpRights_ENTER " vfsH=$D1 requestFlags=$D2  revoke_tag_H=$D3 revoke_tag_L=$D4 fid_ino=$D5 starttimer(0x480,$D5) },\
       12 { "vcm_getOpRights_ERROR1 " },\
       13 { "vcm_getOpRights_ENTER2 " rights=$D1 fid_gen=$D3 },\
       14 { "vcm_getOpRights_ERROR2 " rights=$D1},\
       15 { "vcm_getOpRights_EXIT1 " rc=$D1 rights=$D2 opHandle_H=$D3 opHandle_L=$D4 fid_ino=$D5 endtimer(0x480,$D5) },\
       16 { "vcm_returnOpRights_ENTER " fid_ino=$D1 fid_gen=$D2 rights=$D3 opH_H=$D4 opH_L=$D5 starttimer(0x480,$D1) },\
       17 { "vcm_returnOpRights_EXIT " rc=$D1  fid_ino=$D2 opH_H=$D3 opH_L=$D4 endtimer(0x480,$D2) },\
       18 { "vcm_beginCreate_ERROR " dirFidp=$D1 objName=$D2 openRights=$D3 },\
       19 { "vcm_beginCreate_ENTER " vfsH=$D1 fid_ino=$D2 openRights=$D3 requestFlags=$D4 },\
       20 { "vcm_beginCreate_EXIT2 " rc=$D1 ctag=$D2 },\
       21 { "vcm_endCreate_ENTER " vfsH=$D1 ctag=$D2 },\
       22 { "vcm_endCreate_ERROR " ohp=$D1 grantedRightsp=$D2 openStatusFlagsp=$D3 revokeTagp=$D4 },\
       23 { "vcm_endCreate_EXIT1 " revokeTag=$D1 grantedRights=$D2 openStatusFlags=$D3 },\
       24 { "vcm_endCreate_EXIT2 " oh_H=$D1 oh_L==$D2 },\
       25 { "allocLocalObj_EXIT1 " bytes_in_block=$D1 n_objs=$D2 objp=$D3 blockNo=$D4 },\
       26 { "getLocalObj_ENTER " vp=$D1 hlockp=$D2 hqp=$D3 objp=$D4 },\
       27 { "getLocalObj_ERROR1 " rc=$D1 vp=$D2 },\
       28 { "getLocalObj_ERROR2 " new_objp=$D1 },\
       29 { "getLocalObj_FINDLOCAL "  objp=$D1 hgen=$D2 hqp->gen=$D3 },\
       30 { "getLocalObj_EXIT " objp=$D1 refCount=$D2 },\
       31 { "localObjectRevoke_ENTER " oh_H=$D1 oh_L=$D2 rev_rights=$D3 rtag_H=$D4 rtag_L=$D5 },\
       32 { "localObjectRevoke_ERROR " objp=$D1 lobj_oph_H=$D2 lobj_oph_L=$D3 lcl_magic=$D4 refCount=$D5 },\
       33 { "localObjectRevoke_CONFLICT_OPEN " crights=$D1 readOpens=$D2 writeOpens=$D3 },\
       34 { "localObjectRevoke_CONFLICT_ACTIVE " crights=$D1 activeOps=$D2 },\
       35 { "localObjectRevode_EXIT " rc=$D1 heldRights=$D2 crights=$D3 },\
       36 { "vmci_localOpsInit_SIZES " lrecTable=$D1 localObjHash=$D2 hash_size=$D3 },\
       37 { "vmci_localOpsInit_CLIENTADD " rc=$D1 },\
       38 { "vcm_localOpsGet_ENTER " vp=$D1 rights=$D2 starttimer(0x480,$D1) },\
       39 { "vcm_localOpsGet_ERROR " rc=$D1 },\
       40 { "vcm_localOpsGet_EXIT1 " vp=$D1 rc=$D2 objp=$D3 heldRights=$D4 endtimer(0x480,$D1) },\
       41 { "vcm_localOpsGet_EXIT2 " vp=$D1 rc=$D2 endtimer(0x480,$D1) },\
       42 { "vcm_localOpsPut_ENTER " lclH=$D1 starttimer(0x480,$D1) },\
       43 { "vcm_localOpsPut_EXIT " lclH=$D1 endtimer(0x480,$D1) },\
       44 { "vcm_localOpsOpen_ENTER " vp=$D1 openRights=$D2 enforced_types=$D3 starttimer(0x480,$D1) },\
       45 { "vcm_localOpsOpen_ERROR1 " error=$D1 },\
       46 { "vcm_localOpsOpen_ERROR2 " rc=$D1 },\
       47 { "vcm_localOpsOpen_EXIT1 " vp=$D1 lclH=$D2 heldRights=$D3 endtimer(0x480,$D1) },\
       48 { "vcm_localOpsOpen_EXIT2 " vp=$D1 rc=$D2 endtimer(0x480,$D1) },\
       49 { "vcm_localOpsClose_ENTER " vp=$D1 openRights=$D2 starttimer(0x480,$D1) },\
       50 { "vcm_localOpsClose_ERROR1 " v_vflag2=$D1 },\
       51 { "vcm_localOpsClose_ERROR2 " vfs_flag=$D1 v_flag2=$D2 },\
       52 { "vcm_NOT_CURRENTLY_USED " },\
       53 { "vcm_localOpsClose_ERROR4 " readOpens=$D1 },\
       54 { "vcm_localOpsClose_ERROR5 " writeOpens=$D1 },\
       55 { "vcm_localOpsClose_ERROR6 " vp=$D1 openRights=$D2 heldRights=$D3 },\
       56 { "vcm_localOpsClose_EXIT " vp=$D1 openCount=$D2 rc=$D3 endtimer(0x480,$D1) },\
       57 { "vcm_localOpsBeginCreate_ENTER " dvp=$D1 rights=$D2 },\
       59 { "vcm_localOpsBeginCreate_EXIT1 " crTag=$D1 objp=$D2 },\
       60 { "vcm_localOpsBeginCreate_EXIT2 " rc=$D1 },\
       61 { "vcm_localOpsEndCreate_ENTER " vp=$D1 crTag=$D2 },\
       62 { "vcm_localOpsEndCreate_ERROR1 " lcl_magic=$D1 intFlags=$D2 },\
       63 { "vcm_localOpsEndCreate_ERROR2 " },\
       64 { "vcm_localOpsEndCreate_ERROR3 " rc=$D1 },\
       65 { "vcm_localOpsEndCreate_ERROR4 " rc=$D1 ctag=$D2 },\
       66 { "vcm_localOpsEndCreate_ERROR5 " },\
       67 { "vcm_localOpsEndCreate_EXIT1 " heldRights=$D1 },\
       68 { "vcm_localOpsEndCreate_EXIT2 " rc=$D1 },\
       69 { "vcm_init_EXIT_ERROR " rc=$D1 phase=$D2 },\
       70 { "vcm_vnop_create_ENTER " dvp=$D1 ch=$D2 ctag=$D3 flags=$D4 },\
       71 { "vcm_vnop_create_ERROR1 " rc=$D1 },\
       72 { "vcm_vnop_create_ERROR2 " rc=$D1 vp=$D2 },\
       73 { "vcm_vnop_create_ERROR3 " rc=$D1 },\
       74 { "vcm_vnop_create_EXIT " rc=$D1 vp=$D2 dvp=$D3 name=$D4 },\
       75 { "vcm_vnop_open_ERROR " rc=$D1 oph_H=$D2 oph_L=$D3 },\
       76 { "vcm_vnop_create_attr_ENTER " dvp=$D1 vcm_ch=$D2 ctag=$D3 },\
       77 { "vcm_vnop_create_attr_ERROR1 " rc=$D1 },\
       78 { "vcm_vnop_create_attr_ERROR2 " rc=$D1 },\
       79 { "vcm_vnop_create_attr_EXIT " rc=$D1 dvp=$D2 name=$D3 },\
       80 { "chandleToClientRec_ERROR1 " index=$D1 },\
       81 { "chandleToClientRec_ERROR2 " gen=$D1 index=$D2 intFlags=$D3 },\
       82 { "vcmi_clientDelete_ERROR1 " crp=$D1 vfsOpens=$D2 },\
       83 { "vcmi_clientRevokeRights_ENTER1 " oph_H=$D1 oph_L=$D2 },\
       84 { "vcmi_clientRevokeRights_ENTER2 " rights=$D1 revokeTag_H=$D2 revokeTag_L=$D3 revokeFlags=$D4 },\
       85 { "vcmi_clientRevokeRights_EXIT " rc=$D1 },\
       86 { "vmci_clientAddVFSOpen_ERROR1 " ch=$D1 },\
       87 { "vmci_clientAddVFSOpen_ERROR2 " intFlags=$D1 },\
       88 { "vmci_clientRemVFSOpen_ERROR1 " ch=$D1 },\
       89 { "addVFS_ENTER " vrp=$D1 vfsp=$D2 },\
       90 { "closeVFS_ENTER " vrp=$D1 objectRefs=$D2  },\
       91 { "vcmi_vfsEndCreate_ERROR1 " vfsH=$D1 ctag=$D2  },\
       92 { "vcmi_vfsEndCreate_ERROR2 " c_openp=$D1 },\
       93 { "vcmi_vfsAddObjRef_ERROR1 " vh=$D1 c_openp=$D2 },\
       94 { "vcmi_vfsAddObjRef_ERROR2 " vrp=$D1 c_intFlags=$D2 c_objectRefs=$D3 },\
       95 { "vcmi_vfsDelObjRef_ERROR1 " vh=$D1 c_openp=$D2 },\
       96 { "vmci_vfsDelObjRef_ERROR2 " c_objectRefs=$D1 },\
       97 { "vcmi_peerReturnObjHandle_ENTER" peerH=$D1 peerTag_H=$D2 peerTag_L=$D3 objHandle=$D4 },\
       98 { "vcmi_peerReturnObjHandle_EXIT" },\
       99 { "vcmi_peerGetRights_ENTER" peerTag_H=$D1 peerTag_L=$D2 objHandle=$D3 peer_reqFlags=$D4  rights=$D5 starttimer(0x480,$D2) },\
      100 { "vcmi_peerGetRights_EXIT1" rc=$D1 peerTag_L=$D2 endtimer(0x480,$D2) },\
      101 { "vcmi_peerGetRights_EXIT2" peerOpHandle_H=$D1 peerOpHandle_L=$D2 },\
      102 { "vcmi_peerReturnRights_ENTER" rtag_H=$D1 rtag_L=$D2 objHandle=$D3 retFlags=$D4 rights=$D5 },\
      103 { "vcmi_peerReturnRights_EXIT" rc=$D1 },\
      105 { "vcmi_peerCreateObject_ENTER" peerH=$D1 dvp=$D2 },\
      106 { "vcmi_peerCreateObject_EXIT" rc=$D1 },\
      107 { "vcmi_peerOpenObject_ENTER" objHandle=$D1 peerOpHandle_H=$D2 peerOpHandle_L=$D3 },\
      108 { "vcmi_peerOpenObject_EXIT" rc=$D1 },\
      109 { "vcm_peerRegister_ENTER " peerGFSP=$D1 peerFlags=$D2 },\
      110 { "vcm_peerRegister_ERROR1 " },\
      111 { "vcm_peerRegister_EXIT " pinfop=$D1 phandle=$D2 rc=$D3 },\
      112 { "vcm_peerUnregister_ENTER " phandle=$D1 },\
      113 { "vcm_peerUnregister_EXIT " rc=$D1 },\
      114 { "vcm_peerRevoke_ENTER " objHandle=$D1 rtag_H=$D2 rtag_L=$D3 rights=$D4 rflags=$D5 starttimer(0x480,$D3) },\
      115 { "vcm_peerRevoke_EXIT1 " rc=$D1 peerOpHandle_H=$D2 peerOpHandle_L=$D3 relHandles=$D4 objPeerRefs=$D5 },\
      116 { "removeRights_SUCCESS " objp=$D1 rights=$D2 intFlags=$D3 numObjs_woRights=$D4 },\
      117 { "removeRights_TOPEER " objp=$D1 peerRights=$D2 peerRights_not_neededd=$D4 },\
      118 { "checkRevokeResponse_ERROR1 " objp=$D1 chandle=$D2 rvkRights=$D3 },\
      119 { "checkRevokeResponse_ERROR2 " objp=$D1 chandle=$D2 rflags=$D3 rvkRights=$D4 },\
      120 { "checkRevokeResponse_ERROR3 " objp=$D1 chandle=$D2 rvkCode=$D3 rvkRights=$D4 },\
      121 { "checkRevokeResponse_ERROR4 " objp=$D1 chandle=$D2 rflags=$D3 },\
      122 { "checkRevokeResponse_SETSTALE " objp=$D1 chandle=$D2 holderFlags=$D3 heldRights=$D4 },\
      123 { "objectRecGC_RESULTS " goal=$D1 gcCount=$D2 revokeCount=$D3 },\
      124 { "vcm_NOT_CURRENTLY_USED " },\
      125 { "getHolder_NEW_HOLDER " holderp=$D1 holderGen=$D2 holderID=$D3 },\
      126 { "getHolder_IS_LOCAL " chandle=$D1 holderFlags=$D2 },\
      127 { "getObjRec_NEWOBJ " fid_ino=$D1 fid_gen=$D2 objp=$D3 vfsp=$D4 },\
      128 { "objRecFromOpHandle_ERROR1 " oph_H=$D1 oph_L=$D2 },\
      129 { "getPeerRights_ERROR1 " objp=$D1 peerH=$D2 rc=$D3 },\
      130 { "resolveConflicts_INCREATE " objp=$D1 holdp=$D2 rvkRights=$D3 heldRights=$D4 },\
      131 { "vcmi_rightsPeerRevoke_ERROR1" objHandle=$D1 peerOpHandle_H=$D2 peerOpHandle_L=$D3 rtag_H=$D4 rtag_L=$D5 },\
      132 { "vcmi_rightsPeerRevoke_ERROR2" },\
      133 { "vcmi_rightsPeerRevoke_INCREATE" chandle=$D1 rflags=$D2 },\
      134 { "vcmi_rightsFlushPeerState_ENTER" peerH=$D1 },\
      135 { "vcmi_rightsFlushPeerState_EXIT" peerH=$D1 },\
      136 { "vcmi_rightsGet_ESTALE" objp=$D1 holderp=$D2 holderFlags=$D3 },\
      137 { "vcmi_rightsPostCreate_ERROR" n_objp=$D1 fid_ino=$D2 fid_gen=$D3 },\
      138 { "vcmi_rightsFinishCreate_ERROR1" n_objp=$D1 vfsp=$D2 },\
      139 { "vcmi_rightsReturn_ERROR1" rc=$D1 },\
      140 { "vcmi_rightsReturn_ERROR2" objp=$D1 rights=$D2 heldRights=$D3 },\
      141 { "vcm_getOpRights_EXIT2" rc=$D1 },\
      142 { "vcm_peerRevoke_EXIT2" rtag_L=$D1 endtimer(0x480,$D1) },\
      143 { "vcm_beginCreate_EXIT1 " rc=$D1 dirFidp=$D2 name=$D3 rights=$D4 },\
      144 { "localObjectRevoke_ERROR2 " crights=$D1 },\
      145 { "vcm_localOpsClose_ERROR7 " heldRights=$D1 refCount=$D2 activeOps=$D3 },\
      146 { "objectRecGC_ENTER " goal=$D1 },\
      147 { "getHolder_OLD_RTAG " holderp_rtag_H=$D1 holderp_rtag_L=$D2 rip_rtag_H=$D3 rip_rtag_L=$D4 },\
      148 { "vcmi_rightsGet_ENTER " rip_rights=$D1  reqFlags=$D2 rip_rtag_H=$D3 rip_rtag_L=$D4 vfsp=$D5 },\
      149 { "vcmi_rightsGet_BAD_RTAG " holderp_rtag_H=$D1 holderp_rtag_L=$D2 rip_rtag_H=$D3 rip_rtag_L=$D4 },\
      150 { "vcmi_rightsGet_EXIT " rc=$D1 rip_oph_H=$D2 rip_oph_L=$D3 rip_rtag_H=$D4 rip_rtag_L=$D5 },\
      151 { "allocObj_ERROR_GCD " rc=$D1 },\
      152 { "vcmi_rightsPostCreate_XFER" objp=$D1 fid_ino=$D2 peerRights=$D3 },\
      153 { "vcmi_rightsPostCreate_XFER_ERROR1" objp=$D1 fid_ino=$D2 peerRights=$D3},\
      154 { "vcmi_rightsGet_RESTART" objp=$D1 upper_oph=$D2 lower_oph=$D3 upper_rtag=$D4 lower_rtag=$D5},\
      155 { "vcm_localOpsEnableObjRights_EXIT1" rc=$D1 handle=$D2 },\
      156 { "vcmi_disableObjectRights_ENTER" vfsp=$D1 fid_ino=$D2 fid_gen=$D3 reqFlags=$D4 disableHandlep=$D5},\
      157 { "vcmi_disableObjectRights_EXIT" rc=$D1 objp=$D2},\
      158 { "vcmi_enableObjectRights_ENTER " handle=$D1 },\
      159 { "vcmi_enableObjectRights_EXIT" rc=$D1 },\
        \* { `mode=$HD` unknown VCM id: D1=$D1 D2=$D2 D3=$D3 }
481 1.0 " VCM_DEBUG 481" \
        $HD%D1, \
        1 { "releaseLocalObj_RETURN1 " heldRights=$D1 },\
        2 { "releaseLocalObj_RETURN2 " heldRights=$D1 },\
        3 { "releaseLocalObj_EXIT1 " free_objp=$D1 readOpens=$D2 writeOpens=$D3 },\
        4 { "releaseLocalObj_EXIT2 " refCount=$D1 activOps=$D2 intFlags=$D3 },\
        5 { "getLocalRights_EXIT " objp=$D1 lobj_oph_H=$D2 lobj_oph_L=$D3 },\
        6 { "vcm_localOpsPut_ERROR " },\
        7 { "findVFS_EXIT " vrp=$D1 hq=$D2 },\
        8 { "remVFS_ENTER " vrp=$D1 },\
	9 { "vcmi_peerFind_RESULTS" peerH=$D1 vfsp=$D2 peerFlags=$D3 },\
       10 { "vcmi_peerGetObjHandle_ENTER" prp=$D1 vfsp=$D2 find_ino=$D3 },\
       11 { "vcmi_peerGetObjHandle_EXIT1" rc=$D1 objHandle=$D2 },\
       12 { "vcmi_peerGetObjHandle_EXIT2" peerH=$D1 vfsp=$D2 rc=$D3 },\
       13 { "allocObj_STATS " recIndex=$D1 blockNo=$D2 tot_bytesperblock=$D3 },\
       14 { "getLocalRights_ENTER " objp=$D1 vp=$D2 rights=$D3 },\
       15 { "getLocalRights_EXIT_ERROR " objp=$D1 rc=$D2 },\
       16 { "localObjectRevoke_INVALID_ERROR " },\
       17 { "objectRecGC_STATS " freeObjs=$D1 gc_short=$D2 },\
       18 { "vcmi_enableObjectRights_freeobj" freeObjs=$D1 },\
        \* { `mode=$HD` unknown VCM id: D1=$D1 D2=$D2 D3=$D3 }
48E 0.1 L=APPL "Pthread spinlock" \
          {{ $subhookid = $HD & 0xFFFF}} \
            $subhookid, \
              0x1 { "init address=0x"$D1%XW " lock word=0x"$D2%XW  \n }, \
              0x2 { "destroy address=0x"$D1%XW " lock word=0x"$D2%XW \n }, \
              0x3 { "lock address=0x"$D1%XW " lock word=0x"$D2%XW \n }, \
              0x4 { "trylock address=0x"$D1%XW " lock word=0x"$D2%XW\n }, \
              0x5 { "unlock address=0x"$D1%XW " lock word=0x"$D2%XW\n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
          "ptid: "$D3%DW \n \
          "Caller: 0x"$D4%XW \n \
          "Caller-Caller: 0x"$D5%XW \n
491 1.0 "@IOPATH TEMPLATE" \
        $D1, \
        0 { "VM_UIOMOVE READ BUFFER ("$HL%D2")" W2 LOOP $HL {X0} }, \
        1 { "VM_UIOMOVE WRITE BUFFER ("$HL%D2")" W2 LOOP $HL {X0} }, \
        \* { "DEFAULT BUFFER ("$HL%D2")" W2 LOOP $HL {X0} }
492 1.0 '@HCALL' \
	$HD, \
	1  { `h_call: start` }, \
	2  { `h_call: end` }, \
	\* { `h_call: (unknown subhook $HD)` } \
	$D1, \
	0x01C { `H_GET_TCE` }, \
	0x020 { `H_PUT_TCE` }, \
	0x03C { `H_LOGICAL_CI_LOAD` }, \
	0x040 { `H_LOGICAL_CI_STORE` }, \
	0x044 { `H_LOGICAL_CACHE_LOAD` }, \
	0x048 { `H_LOGICAL_CACHE_STORE` }, \
	0x04C { `H_LOGICAL_ICBI` }, \
	0x050 { `H_LOGICAL_DCBF` }, \
	0x054 { `H_GET_TERM_CHAR` }, \
	0x058 { `H_PUT_TERM_CHAR` }, \
	0x064 { `H_EOI` }, \
	0x068 { `H_CPPR` }, \
	0x06C { `H_IPI` }, \
	0x074 { `H_XIRR` }, \
	0x078 { `H_MIGRATE_DMA` }, \
	0x0E0 { `H_CEDE` }, \
	0x0E4 { `H_CONFER` }, \
	0x0E8 { `H_PROD` }, \
	0x0EC { `H_GET_PPP` }, \
	0x0F0 { `H_SET_PPP` }, \
	0x0F4 { `H_PURR` }, \
	0x0F8 { `H_PIC` }, \
	0x0FC { `H_REG_CRQ` }, \
	0x100 { `H_FREE_CRQ` }, \
	0x104 { `H_VIO_SIGNAL` }, \
	0x108 { `H_SEND_CRQ` }, \
	0x10C { `H_PUT_RTCE` }, \
	0x110 { `H_COPY_RDMA` }, \
	0x114 { `H_REGISTER_LOGICAL_LAN` }, \
	0x118 { `H_FREE_LOGICAL_LAN` }, \
	0x11C { `H_ADD_LOGICAL_LAN_BUFFER` }, \
	0x120 { `H_SEND_LOGICAL_LAN` }, \
	0x128 { `H_WRITE_RDMA` }, \
	0x12C { `H_READ_RDMA` }, \
	0x130 { `H_MULTICAST_CTRL` }, \
	0x14C { `H_CHANGE_LOGICAL_LAN_MAC` }, \
	0x1D4 { `H_FREE_LOGICAL_LAN_BUFFER` }, \
	\* { `(unknown hcall_id $D1)` } \
	$HD, \
	1  { `iar=$D2 p1=$D3 p2=$D4 p3=$D5` }, \
	2  { `iar=$D2 rc=$D3` }
496 1.0 L=APPL "Pthread Barrier" \
          {{ $subhookid = $HD & 0xFFFF}} \
            $subhookid, \
              0x1 { "init barrier address=0x"$D1%XW \n }, \
              0x2 { "destroy barrier address=0x"$D1%XW \n }, \
              0x3 { "wait barrier address=0x"$D1%XW \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
          "ptid: "$D3%DW \n \
          "Caller: 0x"$D4%XW \n \
          "Caller-Caller: 0x"$D5%XW \n
49A 1.0 "ADVANCED ACCOUNTING:" \
	$HD%D1,\
	1 { "dr_handler: DR Phase:" $D1%XW Bind CpuID: $D2 }, \
	2 { "interval_register: TRID:" $D1 cmds: $D2%XW handler: $D3%XW argp: $D4%XW }, \
	3 { "interval_register: TransName: " $D1%A16.16 }, \
	4 { "interval_unregister: handler: " $D1%XW }, \
	5 { "acct_int_walk: command: " $D1%XW TransID: $D2 }, \
	6 { "acct_int_walk: Transaction Interval, TransID: " $D1%XW }, \
	7 { "acct_int_walk: Transaction Enable, TransID: " $D1%XW }, \
	8 { "acct_int_walk: Transaction Disable, TransID: " $D1%XW }, \
	9 { "_acctctl: aacctctl Request:" $D1%XW }, \
	10 { "_acctctl: AACCT Started " }, \
	11 { "_acctctl: AACCT Stopped " }, \
	12 { "_acctctl: Add a new accounting file. File ID: " $D1 }, \
	13 { "_acctctl: Remove an accounting file. File ID: " $D1 }, \
	14 { "_acctctl: Switched to an accounting file. File ID: " $D1 }, \
	15 { "_acctctl: Acknowledged a FULL acct file, File ID: " $D1 tid: $D2 }, \
	16 { "_acctctl: Transaction Defined:" $D1%XW }, \
	17 { "_acctctl: Transaction Enabled:" $D1%XW }, \
	18 { "_acctctl: Transaction Disabled:" $D1%XW }, \
	19 { "close_active_file: Acct file is FULL, File ID:" $D1%XW }, \
	20 { "queue_special_file: Acct Termination, File ID:" $D1%XW }, \
	21 { "queue_special_file: out of Acct Buffers, File ID:" $D1%XW }, \
	22 { "queue_special_file: out of Acct Files, File ID:" $D1%XW }, \
	23 { "queue_special_file: Acct file almost FULL, File ID:" $D1%XW }, \
	24 { "_acctctl: System Interval Set: Time:" $D1 }, \
	25 { "_acctctl: System Interval Reset" }, \
	26 { "_acctctl: Process Interval Set: Time:" $D1 }, \
	27 { "_acctctl: Process Interval Reset" }, \
	28 { "_acctctl: Data Aggregation Set" }, \
	29 { "_acctctl: Data Aggregation Reset" }
49B 1.0 "ADVANCED ACCOUNTING ACCT PUT:" \
	$HD%D1,\
	1 { "_acct_put: Writing acct record, TRID:" $D1 acct flags: $D2%XW projID: $D3 subprojID: $D4 }, \
	2 { "_acct_put: Writing Process aggr record, Acct flags:" $D1%XW UID: $D2 projID: $D3 subprojID: $D4 }, \
	3 { "_acct_put: Writing Application aggr record, Acct flags:" $D1%XW UID: $D2 projID: $D3 subprojID: $D4 }, \
	4 { "_acct_put: Writing Kextension aggr record, Acct flags:" $D1%XW KEName: $D2%A12.12 projID: $D3 subprojID: $D4 }
49E 1.0 "Checkpoint/Restart" \
	$HD%D1, \
	1 { "hkwd_CHK_START" flags=$D1 id=$D2 }, \
	2 { "hkwd_ISSUE_CHKPT" pid=$D1 crid=$D2 }, \
	3 { "hkwd_INVOKE_HANDLER" crid=$D1 }, \
	4 { "hkwd_CALL_COMMIT" crid=$D1 flags=$D2 }, \
	5 { "hkwd_PROCESS_SUSP" crid=$D1 }, \
	6 { "hkwd_START_WRITE" crid=$D1 }, \
	7 { "hkwd_FINISH_WRITE" crid=$D1 }, \
	8 { "hkwd_EXIT_CHKPT" crid=$D1 }, \
	9 { "hkwd_CHK_FINISH" tid=$D1 crid=$D2 errno=$D3 }
4A5 1.0 "@VMM_LRU2" \
{{ \
lru_updcrit_unmunge(munge) \
        $munge & 0xC0000003, \
        \* { \
                " " \
                BITFLAGS $munge, \
                0x80000000 "starvation", \
                0x40000000 "file-only", \
                & 0x00000003 0x00000000 "lru_rev=0", \
                & 0x00000003 0x00000001 "lru_rev=1", \
                & 0x00000003 0x00000002 "lru_rev=2", \
                & 0x00000003 0x00000003 "lru_rev=3" \
        } \
}} \
        $HD, \
        0x0  { `VMM LRU: Clock hand cycles  memp=$D1 scans=$D2 cycles=$D3` }, \
        0x1  { `VMM LRU: No xmemok          memp=$D1 scans=$D2 numfrb=$D3 ncpus=$D4` }, \
        0x2  { `VMM LRU: Next LRUlist       memp=$D1 scans=$D2 ccb=$D3 listtype=$D4 eligible pages in ccb=$D5` }, \
        0x3  { `VMM LRU: Compute LRUlist    memp=$D1 scans=$D2 ccb=$D3 pass1pgs=$D4` }, \
        0x4  { `VMM LRU: Found new CCB      memp=$D1 scans=$D2 ccb=$D3` }, \
        0x5  { `VMM LRU: Update Criteria    memp=$D1 scans=$D2 `lru_updcrit_unmunge($D3)` steal_color=$D4` }, \
        0x6  { `VMM LRU: Move to new pass   memp=$D1 scans=$D2 new pass=$D3` }, \
        0x7  { `VMM LRU: Enter DLA mode     memp=$D1 psx=$D2 elapsed=$D3 thresh=$D4` }, \
        0x8  { `VMM LRU: DLA Timer wakeall  memp=$D1 psx=$D2 elapsed=$D3 thresh=$D4` }, \
        0x9  { `VMM LRU: Update Criteria (DLA)  memp=$D1 psx=$D2` }, \
	0xa  { `VMM LRU: Allow Klock Pages memp=$D1 psx=$D2 klk_unpin_pgs=$D3 pfavail_tgt=$D4`}, \
	0xb  { `VMM LRU: Update Criteria (use klk pgs) memp=$D1 psx=$D2` }, \
	0xc  { `VMM LRU: By Phys Hit Start (use klk pgs) memp=$D1 psx=$D2` }
4A7 1.0 "DLPI" \
{{ \
mode(mess) \
        $mess, \
                0x01 "DL_CODLS", \
                0x02 "DL_CLDLS", \
                0x04 "DL_ACLDLS", \
                \* { UNKNOWN MODE $mess } \
}}\
{{ \
msg_dlpillc(mess) \
        $mess%DW, \
                1 "bad LLC drop", \
                2 "codls mode drop", \
                3 "listen DM", \
                4 "listen drop", \
                \* { UNKNOWN MSG $mess } \
}}\
{{ \
msg_timer(mess) \
        $mess%DW, \
		0 "fired",\
                1 "started", \
                2 "stopped", \
                \* { invalid argument! $mess } \
}}\
{{ \
eventtype_ind_dlpi(mess) \
        $mess, \
                0x04 "DL_UNATTACHED", \
                0x05 "DL_ATTACH_PENDING", \
                0x06 "DL_DETACH_PENDING", \
                0x00 "DL_UNBOUND", \
                0x01 "DL_BIND_PENDIN", \
                0x02 "DL_UNBIND_PENDING", \
	        0x03 "DL_IDLE", \
	        0x07 "DL_UDQOS_PENDING", \
	        0x08 "DL_OUTCON_PENDING", \
	        0x09 "DL_INCON_PENDING", \
	        0x0a "DL_CONN_RES_PENDING", \
	        0x0b "DL_DATAXFER", \
	        0x0c "DL_USER_RESET_PENDING", \
	        0x0d "DL_PROV_RESET_PENDING", \
	        0x0e "DL_RESET_RES_PENDING", \
	        0x0f "DL_DISCON8_PENDING", \
	        0x10 "DL_DISCON9_PENDING", \
	        0x11 "DL_DISCON11_PENDING", \
	        0x12 "DL_DISCON12_PENDING", \
	        0x13 "DL_DISCON13_PENDING", \
	        0x14 "DL_SUBS_BIND_PND", \
                0x15 "DL_SUBS_UNBIND_PND", \
                \* { UNKNOWN EVENT TYPE IND $mess%DW } \
}}\
{{ \
event_prim(mess) \
        $mess, \
	0x00 "DL_INFO_REQ", \
	0x01 "DL_BIND_REQ", \
	0x02 "DL_UNBIND_REQ", \
	0x03 "DL_INFO_ACK", \
	0x04 "DL_BIND_ACK", \
	0x05 "DL_ERROR_ACK", \
	0x06 "DL_OK_ACK", \
	0x07 "DL_UNITDATA_REQ", \
	0x08 "DL_UNITDATA_IND", \
	0x09 "DL_UDERROR_IND", \
	0x0a "DL_UDQOS_REQ", \
	0x0b "DL_ATTACH_REQ", \
	0x0c "DL_DETACH_REQ", \
	0x0d "DL_CONNECT_REQ", \
	0x0e "DL_CONNECT_IND", \
	0x0f "DL_CONNECT_RES", \
	0x10 "DL_CONNECT_CON", \
	0x11 "DL_TOKEN_REQ", \
	0x12 "DL_TOKEN_ACK", \
	0x13 "DL_DISCONNECT_REQ", \
	0x14 "DL_DISCONNECT_IND", \
	0x15 "DL_SUBS_UNBIND_REQ", \
	0x17 "DL_RESET_REQ", \
	0x18 "DL_RESET_IND", \
	0x19 "DL_RESET_RES", \
	0x1a "DL_RESET_CON", \
	0x1b "DL_SUBS_BIND_REQ", \
	0x1c "DL_SUBS_BIND_ACK", \
	0x1d "DL_ENABMULTI_REQ", \
	0x1e "DL_DISABMULTI_REQ", \
	0x1f "DL_PROMISCON_REQ", \
	0x20 "DL_PROMISCOFF_REQ", \
	0x21 "DL_DATA_ACK_REQ", \
	0x22 "DL_DATA_ACK_IND", \
	0x23 "DL_DATA_ACK_STATUS_IND", \
	0x24 "DL_REPLY_REQ", \
	0x25 "DL_REPLY_IND", \
	0x26 "DL_REPLY_STATUS_IND", \
	0x27 "DL_REPLY_UPDATE_REQ", \
	0x28 "DL_REPLY_UPDATE_STATUS_IND", \
	0x29 "DL_XID_REQ", \
	0x2a "DL_XID_IND", \
	0x2b "DL_XID_RES", \
	0x2c "DL_XID_CON", \
	0x2d "DL_TEST_REQ", \
	0x2e "DL_TEST_IND", \
	0x2f "DL_TEST_RES", \
	0x30 "DL_TEST_CON", \
	0x31 "DL_PHYS_ADDR_REQ", \
	0x32 "DL_PHYS_ADDR_ACK", \
	0x33 "DL_SET_PHYS_ADDR_REQ", \
	0x34 "DL_GET_STATISTICS_REQ", \
	0x35 "DL_GET_STATISTICS_ACK", \
        \* { UNKNOWN EVENT TYPE IND $mess%DW } \
}}\
{{ \
message_type(mess) \
   $mess, \
           0x00 "M_DATA", \
           0x01 "M_PROTO", \
           0x83 "M_PCPROTO", \
	   0x84 "M_PCSIG", \
	   0x0d "M_CTL", \
           0x0e "M_IOCTL", \
           0x86 "M_FLUSH", \
	   0x88 "M_START", \
           \* { UNKNOWN type $mess }  \
}} \
   $GENERIC,\
   0 { {{ $gener = 0 }} },\
   1 { $HOOKENV, \
      32 { {{ $gener = 1 }} }, \
      64 { {{ $gener = 0 }} } \
    } \
   $gener, \
   0 { \
   $HD%D1, \
    001 { `dlpiopen entry - q=$D1 OTHERQ=$D2 devp=$D3 flag=$D4 sflag=$D5` }, \
    002 { `dlpiopen failed error=$D1%DW` }, \
    003 { `dlpiopen out - dlb=$D1 rq=$D2 wq=$D3` }, \
    004 { `dlpiclose entry - q=$D1 OTHERQ=$D2 dlb=$D3` }, \
    005 { `dlpiclose - state=`eventtype_ind_dlpi($D1) }, \
    006 { `dlpiclose - promiscoff err ($D1%DW)` }, \
    007 { `dlpiclose - delmulti $D1 err $D2%DW` }, \
    008 { `dlpiwput entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    009 { `dlpiwput: M_message type=`message_type($D1) }, \
    010 { `dlpirsrv entry - q=$D1 OTHERQ=$D2 dlb=$D3` }, \
    047 { `dlpirsrv: mp=$D1,M_message type=`message_type($D2)}, \
    011 { `dlpiwsrv entry - q=$D1 OTHERQ=$D2 dlb=$D3` }, \
    012 { `dlpiwsrv: mp=$D1,M_message type=`message_type($D2) }, \
    013 { `dlpiwsrv datareq deferred dlb=$D1` }, \
    014 { `dlpiwsrv - primitive=`event_prim($D1) }, \
    015 { W2 $HL%S1 }, \
    016 { `dl_attach dlb=$D1 ndd_addr too long ($D2%DW)` }, \
    017 { `dl_attach dlb=$D1 no address resolution routine` }, \
    018 { `dl_unbind dlb=$D1 dl_unbind: dl_del_filter err $D2%DW` }, \
    019 { `dl_add_filter dlb=$D1 ns_add_filter: ns_add err $D2%DW` }, \
    020 { `dl_del_filter dlb=$D1 ns_del_filter: ns_del err $D2%DW` }, \
    021 { `dl_bind sap $D1 mode=`mode($D2) ` conind $D3%DW` }, \
    022 { `dl_subs_bind class $D1` }, \
    023 { W2 $HL%S1 }, \
    024 { `dl_add_filter error mode: $D1` }, \
    025 { `dl_connind rx_sabme: rx_sabme: discard dup dlb=$D1` }, \
    026 { `dl_connind rx_sabme: discard pend table full dlb=$D1` }, \
    029 { `dl_datareq: state $D1%DW  drop` }, \
    030 { `dl_rexmit dlb=$D1 retransmitting I-frames` }, \
    031 { `dl_rexmit dlb=$D1 cannot dup` }, \
    032 { `dl_rexmit dlb=$D1no outstanding I-frames` }, \
    033 { `tx_i dlb=$D1 mkframe failed err=$D2%DW` }, \
    034 { `tx_i dlb=$D1 tx_frame failed err=$D2%DW` }, \
    035 { `tx_super dlb=$D1 tx_frame failed $D2%DW` }, \
    036 { `rx_i: dlb=$D1 reject drop (t = $D2%DW)` }, \
    037 { `rx_i: dlb=$D1 sent reject ended` }, \
    038 { `rx_i: dlb=$D1 mbuf convert drop` }, \
    039 { `chktimers: dlb=$D1 why is T1 still running` }, \
    040 { `chktimers: dlb=$D1 why is T2 still running` }, \
    041 { `expired_t1: dlb=$D1 retry $D2%DW` }, \
    042 { `expired_t1: dlb=$D1 retry exhausted` }, \
    043 { `expired_t2: dlb=$D1 retry $D2%DW` }, \
    044 { `expired_t2: dlb=$D1 retry exhausted` }, \
    045 { `expired_ti: dlb=$D1 retry $D2%DW` }, \
    046 { `expired_ti: dlb=$D1 busy retry exhausted` }, \
    050 { `rx_xtauto: dlb=$D1 unsolicited response drop` }, \
    051 { W2 $HL%S1 }, \
    052 { W2 $HL%S1 }, \
    057 { `rx_ua: p=$D1%DW f=$D2%DW, droppebos.sysmgt.trace.trc.Sd UA` }, \
    058 { `rx_ua: state $D1%DW dropped UA` }, \
    059 { `rx_dm: state $D1%DW dropped DM` }, \
    060 { `rx_disc: state $D1%DW dropped DISC` }, \
    061 { `rx_ui: flow control drop` }, \
    062 { `local_busy dlb=$D1` }, \
    063 { `local_okay dlb=$D1` }, \
    064 { `dlpillc: sap 0x$D1: no stream drop` }, \
    065 { `dlpillc: multi drop dlb=$D1` }, \
    066 { `dlpillc: ctl $D1 `msg_dlpillc($D2) }, \
    067 { W2 $HL%S1 }, \
    068 { `drd_bind: ndd 0x$D1 ppa $D2%DW sap 0x$D3` }, \
    069 { `drd_bind: cannot bind; ppa $D1%DW, err $D2%DW` }, \
    070 { `drd_unbind: ndd 0x$D1 ppa $D2%DW sap 0x$D3` }, \
    071 { `drd_unbind: cannot bind; ppa $D1%DW, err $D2%DW` }, \
    072 { W2 $HL%S1 }, \
    073 { `drd_timer:` msg_timer($D1%DW) }, \
    074 { W2 $HL%S1 }, \
    075 { `drd_timeout: no route dlb=$D1` }, \
    076 { `drd_intr: bogus interrupt` }, \
    077 { W2 $HL%S1 }, \
    078 { `drd_intr: unexpected LLC PDU 0x$D1` }, \
    079 { `drd_intr: unexpected XID CMD` }, \
    080 { `dlpiconfig - config init: drd sap 0x$D1` }, \
    081 { `dlpiconfig - config term: drd sap 0x$D1` }, \
    082 { `nddrele - p_ref underflow` }, \
    \* { `unknown subhook $HD%D1 error $ERROR` } \
  }, \
 1 { W2 $HL%S1 }
4A8 1.0 "XTI" \
{{ \
event_state_bit(mess) \
	$mess, \
		0x0001 SE_ERROR, \
		0x0002 SE_HAVEDATA, \
		0x0004 SE_HAVEOOB, \
		0x0008 SE_DATAFULL, \
		0x0010 SE_CONNOUT, \
		0x0020 SE_CONNIN, \
		0x0040 SE_SENDCONN, \
		0x0080 SE_RECVCONN, \
		0x4000 SE_POLL, \
		0x8000 SE_STATUS, \
		\* { UNKNOWN EVENT STATE BIT $mess } \
}} \
{{ \
eventtype_ind_T(mess) \
        $mess%DW, \
                20 "T_BIND_ACK", \
                21 "T_CONN_CON", \
                22 "T_CONN_IND", \
                23 "T_DATA_IND", \
                24 "T_DISCON_IND", \
                25 "T_ERROR_ACK", \
                26 "T_EXDATA_IND", \
                27 "T_INFO_ACK", \
                28 "T_OK_ACK", \
                29 "T_OPTMGMT_ACK", \
                30 "T_ORDREL_IND", \
                31 "T_UNITDATA_IND", \
                32 "T_UDERROR_IND", \
                33 "T_ADDR_ACK", \
                \* { UNKNOWN EVENT TYPE IND $mess%DW } \
}}\
{{ \
event_state_ts(mess) \
        $mess%DW, \
		0 "TS_UNINIT", \
		1 "TS_UNBND", \
		2 "TS_WACK_BREQ", \
		3 "TS_WACK_UREQ", \
		4 "TS_IDLE", \
		5 "TS_WACK_OPTREQ", \
		6 "TS_WACK_CREQ", \
		7 "TS_WCON_CREQ", \
		8 "TS_WRES_CIND", \
		9 "TS_WACK_CRES", \
		10 "TS_DATA_XFER", \
		11 "TS_WIND_ORDREL", \
		12 "TS_WREQ_ORDREL", \
		13 "TS_WACK_DREQ6", \
		14 "TS_WACK_DREQ7", \
		15 "TS_WACK_DREQ9", \
		16 "TS_WACK_DREQ10", \
		17 "TS_WACK_DREQ11", \
		18 "TS_WACK_ORDREL", \
		19 "TS_NOSTATES", \
                \* { UNKNOWN EVENT TS $mess%DW } \
}} \
{{ \
msgerr_put(error) \
        $error%D1, \
		1 "incorrect message size", \
                2 "unitdata_req on non-CLTS provider", \
		3 "ordrel_req on non-COTS_ORD provider", \
		4 "data_req on non-COTS provider", \
		\* { UNKNOWN EVENT $error%D1 } \
}} \
{{ \
msgerr_send(error) \
        $error%D1, \
		1 "splitmsg failed", \
                2 "mblk_to_mbuf failed", \
		\* { UNKNOWN EVENT $error%D1 } \
}} \
{{ \
msgerr_req(error) \
        $error%D1, \
		1 "failed to create socket", \
                2 "would place interface out of state",\
		3 "incorrect message size", \
                4 "incorrect address size", \
		5 "invalid address size", \
		6 "copy_to_mbuf failed", \
		7 "xti_snd_flushrw failed", \
		8 "options not supported", \
		9 "invalid options size", \
		10 "invalid flag specified", \
		11 "invalid option", \
		12 "qlen must be greater than zero", \
		13 "primitive not supported by provider", \
		14 "invalid dest address", \
		15 "invalid connection data size", \
		16 "option allocation failed", \
		17 "readonly option", \
		18 "incorrect option size", \
		19 "invalid sequence number", \
		20 "must respond to other rcvd conn indications first", \
		21 "invalid resfd", \
		22 "invalid transport provider", \
		23 "invalid resfd, no socket", \
		24 "would place resfd out of state", \
		25 "invalid discon data size", \
		26 "invalid sequence number:no conn ind", \
		27 "cannot send normal data", \
		28 "TSDU size exceeded", \
		29 "cannot send expedited data", \
		30 "ETSDU size exceeded", \
		31 "TSDU not supported", \
		32 "invalid connection indication count", \
		33 "failed to allocate qlen", \
		\* { UNKNOWN EVENT $error%D1 } \
}} \
{{ \
eventtype(mess) \
        $mess%DW, \
                1 "T_BIND_REQ", \
                2  "T_CONN_REQ", \
                3  "T_CONN_RES", \
                4  "T_DATA_REQ", \
                5  "T_DISCON_REQ", \
                6  "T_EXDATA_REQ", \
                7  "T_INFO_REQ", \
                8  "T_OPTMGMT_REQ", \
                9  "T_ORDREL_REQ", \
                10 "T_UNBIND_REQ", \
                11 "T_UNITDATA_REQ", \
                12 "T_ADDR_REQ", \
                19 "T_FEEDBACK_REQ", \
                \* { UNKNOWN EVENT $mess%DW } \
}}\
{{ \
eventtype_te(mess) \
        $mess%DW, \
                1 "TE_BIND_REQ",\
                2 "TE_UNBIND_REQ",\
                3 "TE_OPTMGMT_REQ", \
                4 "TE_BIND_ACK",\
                5 "TE_OPTMGMT_ACK",\
                6 "TE_CONN_REQ",\
                7 "TE_CONN_RES",\
                8 "TE_DISCON_REQ",\
                9 "TE_DATA_REQ ",\
                10 "TE_EXDATA_REQ",\
                11 "TE_ORDREL_REQ",\
                12 "TE_CONN_IND",\
                13 "TE_CONN_CON",\
                14 "TE_DATA_IND",\
                15 "TE_EXDATA_IND",\
                16 "TE_ORDREL_IND",\
                17 "TE_DISCON_IND1",\
                18 "TE_DISCON_IND2",\
                19 "TE_DISCON_IND3",\
                20 "TE_ERROR_ACK",\
                21 "TE_OK_ACK1",\
                22 "TE_OK_ACK2",\
                23 "TE_OK_ACK3",\
                24 "TE_OK_ACK4",\
                25 "TE_PASS_CONN",\
                26 "TE_UNITDATA_REQ",\
                27 "TE_UNITDATA_IND",\
                28 "TE_UDERROR_IND",\
                29 "TE_NOEVENTS",\
                \* { UNKNOWN TE_EVENT $mess%DW } \
}} \
   $GENERIC,\
   0 { {{ $gener = 0 }} },\
   1 { $HOOKENV, \
      32 { {{ $gener = 1 }} }, \
      64 { {{ $gener = 0 }} } \
    } \
   $gener, \
   0 { \
   $HD%D1, \
    001 { `xtiso_config` cmd=$D1%X1,\
                1 "CFG_INIT ",\
                2 "CFG_TERM ",\
                \* {"UNKNOWN CFG CMD ("$D1%X1")"} }, \
    002 { `return from xtiso_config rc=$D1%D1 error=$D2%D1` }, \
    003 { `xtiopen entry - q=$D1 OTHERQ=$D2 devp=$D3 flag=$D4 sflag=$D5` }, \
    004 { `xtiopen: this is a CLONEOPEN of $D1%DW` }, \
    005 { `xtiopen: this is a OPEN of major=$D1%DW minor=$D2%DW` }, \
    006 { `xtiopen: found xticb $D1 $D2%DW $D3%DW` }, \
    007 { `xtiopen: cdevsw_open_comm() failed $D1%DW` }, \
    008 { `xtiopen: xtip 0x$D1 minor $D2%DW` }, \
    009 { `xtiopen: failed to create socket error:$D1` }, \
    010 { `xtiwput entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    011 { `xtiwput: request type=`eventtype($D1) }, \
    012 { `xtiwput: M_message type=`$D1, \
           0x00 "M_DATA", \
           0x01 "M_PROTO", \
           0x83 "M_PCPROTO", \
           0x0e "M_IOCTL", \
           0x86 "M_FLUSH", \
           \* {"UNKNOWN type" } }, \
    013 { `xtiwput: minor:$D1%DW` msgerr_put($D2) }, \
    014 { `xtiwput: minor:$D1%DW bad TPI message type $D2%DW` }, \
    015 { `xtiwput: M_IOCNAK for cmd=$D1%DW` }, \
    016 { `xtiwput: Non understood msg type $D1%DW received mp= $D2` }, \
    017 { `xticlose entry - q=$D1 OTHERQ=$D2 so=$D3` }, \
    018 { `xtirsrv entry - q=$D1 OTHERQ=$D2` }, \
    020 { `xtiwsrv: entry - q=$D1 OTHERQ=$D2` }, \
    021 { `xtiwsrv-doing startup on xtip=$D1` }, \
    022 { `xtiwsrv-sending exdata` }, \
    023 { `xtiwsrv-getq() returned: mp=$D1` }, \
    024 { `xtiwsrv-early return flow=$D1%DW` }, \
    025 { `xtiso: event=`eventtype_te($D1) \
         ` original state=`event_state_ts($D2) \
         ` next state=`event_state_ts($D3) }, \
    026 { `xtiso: event=`eventtype_te($D1) \
        ` new state=`event_state_ts($D2) }, \
    030 { `xti_addr_req: q:$D1 OTHERQ=$D2 mp=$D3` }, \
    031 { `xti_addr_req: xtip:$D1` msgerr_req($D2) }, \
    035 { `xti_bind_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    036 { `xti_bind_req: xtip:$D1` msgerr_req($D2)}, \
    037 { `xti_bind_req : pp->tbindreq.ADDR_length=$D1%DW` }, \
    038 { `xti_bind_req: mp:$D1 error:$D2%DW` msgerr_req($D3)}, \
    039 { `xti_bind_req: sobind($D1, $D2)` }, \
    040 { `xti_bind_req: sobind error=$D1%DW` }, \
    041 { `xti_bind_req : tbindack fields:PRIM_type:$D1 ADDR_leng:$D2 ADDR_offs:$D3 CONIND_nu:$D4` }, \
    046 { `xti_unbind_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    047 { `xti_unbind_req: xti_snd_ok_ack(q=$D1 mp=$D2)`}, \
    048 { `xti_unbind_req: xtip:$D1` msgerr_req($D2) }, \
    049 { `xti_optmgmt_req: xtip:$D1 OTHERQ=$D2 mp=$D3`  }, \
    050 { `xti_optmgmt_req: xtip:$D1`msgerr_req($D2)  }, \
    051 { `xti_optmgmt_req: mp:$D1` msgerr_req($D2) }, \
    052 { `xti_listen_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    057 { `xti_listen_req: state:$D1%DW would place interface out of state` }, \
    058 { `xti_listen_req: xtip:$D1 qlen must be greater than zero` }, \
    059 { `xti_listen_req: solisten error status error:$D1%DW` }, \
    060 { `xti_conn_req: xtip:$D1` msgerr_req($D2) }, \
    061 { `xti_conn_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    062 { `xti_conn_res: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    063 { `xti_discon_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    064 { `xti_data_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    065 { `xti_exdata_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    066 { `xti_unitdata_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    067 { `xti_ordrel_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    068 { `xti_info_req: entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    069 { `xti_unitdata_req: msgdsize(mp=$D1) = $D2%DW\n` }, \
    071 { `xti_conn_req: soconnect so=$D1 nam=$D2 error=$D3` }, \
    072 { `xti_conn_res: xtip:$D1` msgerr_req($D2) }, \
    073 { `xti_disconn_req: xtip:$D1` msgerr_req($D2) }, \
    074 { `xti_datareq_req: xtip:$D1` msgerr_req($D2) }, \
    075 { `xti_exdatareq_req: xtip:$D1` msgerr_req($D2) }, \
    076 { `xti_unitdatareq_req: xtip:$D1` msgerr_req($D2) }, \
    077 { `xti_ordrelreq_req: xtip:$D1` msgerr_req($D2) }, \
    082 { `xti_startup: sobind($D1, $D2)` }, \
    083 { `xti_startup: sobind($D1, $D2) failed error=$D3%DW` }, \
    084 { `xti_startup: xtip=$D1 error=$D2%DW` msgerr_req($D3) }, \
    085 { `xti_startup: solisten(so=$D1 qlen=$D2%DW) failed=$D3%DW` }, \
    086 { `xti_discon_ind: xtip=$D1` msgerr_req($D2) }, \
    087 { `xti_data_ind: xtip=$D1` msgerr_req($D2) }, \
    088 { `xti_unitdata_ind: xtip=$D1` msgerr_req($D2) }, \
    089 { `xti_ordrelind_ind: xtip=$D1` msgerr_req($D2) }, \
    090 { `xti_listen_req: solisten(so=$D1 qlen=$D2%DW)` }, \
    091 { `xti_startup: solisten(so=$D1 qlen=$D2%DW)` }, \
    092 { `xti_ordrel_ind: soshutdown($D1, 0) = $D2%DW` }, \
    093 { `xti_send: entry so=$D1 type=$D2%DW` }, \
    095 { `xti_send: sosend(q=$D1 so=$D2)` }, \
    096 { `xti_send: xticb $D1 sosend error $D2%DW: data lost` }, \
    097 { `xti_rcv: xti_rcv(xtip=$D1 dp=$D2 type=$D3 anam=$D4)` }, \
    098 { `xti_send: xtip=$D1` msgerr_send($D2) }, \
    099 { `xti_finished: xtip=$D1 xti_entry_init failed` }, \
    100 { `xti_dumpso: type=$D1%DW state=$D2 pcb=$D3 iodne=$D4 ioarg=$D5` }, \
    101 { `xti_dumpproto_1: tsdulen=$D1%DW etsdulen=$D2%DW connectlen=$D3%DW disconlen=$D4%DW addrlen=$D5%DW` }, \
    102 { `xti_dumpiocblk: cmd=$D1%DW uid=$D2%DW count=$D3%DW error=$D4%DW rval=$D5%DW` }, \
    103 { `xti_dumpproto_2: optlen=$D1%DW tidulen=$D2%DW connectlen=$D3%DW servtype=$D4%DW` }, \
    104 { `xti_setopt: sosetopt failed = $D1%DW` }, \
    105 { `xti_rcv: previous soreceive read $D1%DW` }, \
    106 { `xti_rcv: mbufdsize($D1)=$D2%DW` }, \
    107 { `xti_rcv: size=$D1%DW, flags=$D2, msgdsize=$D3%DW more=$D4%DW` }, \
    110 { `xtiso:prec_insq - entry...q=$D1 OTHERQ=$D2 mp=$D3` }, \
    111 { `xtiso:prec_insq - xti_snd_ok_ack q=$D1 mp=$D2` }, \
    112 { `xti_output-entry...q=$D1 OTHERQ=$D2 mp=$D3` }, \
    113 { `xti_input - entry...xtip=$D1` }, \
    114 { `xti_input-indication=$D1%DW` }, \
    115 { `xti_new_tp_ind-entry xtip=$D1` }, \
    116 { `xti_conn_ind-entry xtip=$D1` }, \
    117 { `xti_conn_con-entry xtip=$D1` }, \
    118 { `xti_discon_ind-entry xtip=$D1` }, \
    119 { `xti_data_ind-entry xtip=$D1  indication=$D2%DW` }, \
    120 { `xti_ordrel_ind-entry xtip=$D1` }, \
    121 { `xti_unitdata_ind-entry xtip=$D1` }, \
    122 { `xti_uderror_ind-entry q=$D1 error=$D2%DW` }, \
    123 { `xti_cleanup-entry q=$D1 mp=$D2 error=$D3%DW` }, \
    124 { `xti_finished-entry q=$D1` }, \
    125 { `xti_snd_error_ack-entry q=$D1 dir=$D2%DW` }, \
    126 { `xti_snd_flushrw-entry q=$D1 dir=$D2%DW` }, \
    127 { `xti_snd_ok_ack-entry q=$D1 mp=$D2 tli_error=$D3%DW unix_error=$D4%DW` }, \
    128 { `xti_entry_init-socreate error = $D1%DW` }, \
    129 { `xti_entry_init-entry xtip=$D1 flags=$D2%DW` }, \
    130 { `xti_wqenable-entry q=$D1` }, \
    131 { `xti_rqenable-entry q=$D1` }, \
    132 { `xti_canput-entry q=$D1 need=$D2%DW` }, \
    133 { `xti_init_socket-entry so=$D1 q=$D2` }, \
    134 { `putnext-entry q=$D1 mp=$D2` }, \
    135 { `xti_discon_ind-discon_event=`eventtype_te($D1) }, \
    137 { `xti_canput-setting FLOW CONTROL, space=$D1%DW need=$D2%DW` }, \
    138 { `xti_canput-clearing FLOW CONTROL, space==$D1%DW need=$D2%DW` }, \
    140 { `xtiso:new_tp_ind lastState=$D1 state=$D2 xti_sostate=$D3` }, \
    141 { `xtiso:new_tp_ind `eventtype_ind_T($D1) }, \
    142 { `xtiso:new_tp_ind ` event_state_bit($D1) eventtype_ind_T($D2) }, \
    143 { `xtiso: new_tp_ind(xtip=$D1) - xti_state=`event_state_ts($D2) `indication=`eventtype_ind_T($D3) }, \
    146 { `xtiso: new_tp_ind(xtip=$D1) - xti_state=$D2%DW indication=$D3%DW` }, \
    147 { `xtiso: new_tp_ind(xtip=$D1) - xti_state=`event_state_ts($D2) ` state=SE_CONNIN sodequeue error=$D3%DW` }, \
    150 { `copy_to_mbuf-entry addr=$D1 len=$D2%DW type=$D3%DW nam=$D4` }, \
    151 { `copy_to_mbuf m_get returns $D1` }, \
    152 { W2 $HL%S1 }, \
    \* { `unknown subhook $HD%D1 error $ERROR` } \
  }, \
 1 { W2 $HL%S1 }
4A9 1.0 "TIMOD" \
{{ \
eventtype_timod(mess) \
        $mess%DW, \
                1 "TI_BIND", \
		2 "TI_GETINFO", \
		3 "TI_OPTMGMT", \
		4 "TI_UNBIND", \
		5 "TI_GETMYNAME", \
		6 "TI_GETPEERNAME", \
		7 "TI_ADDR", \
		8 "TI_XTI_HELLO", \
		9 "TI_XTI_GET_STATE", \
		10 "TI_XTI_CLEAR_EVENT", \
		11 "TI_XTI_MODE", \
		12 "TI_TLI_MODE", \
		13 "TI_XTI_GET_SEQUENCE", \
                \* { UNKNOWN EVENT TYPE $mess%DW } \
}}\
   $HD%D1, \
    001 { `timod_open entry - q=$D1 OTHERQ=$D2 devp=$D3 flag=$D4 sflag=$D5` }, \
    002 { `timod_open - mi_open_comm() failed error=$D1%DW` }, \
    003 { `timod_close entry - q=$D1 OTHERQ=$D2 timod=$D3` }, \
    004 { `timod_close - mi_close_comm() failed error=$D1%DW` }, \
    005 { `timod_rput entry - q=$D1 OTHERQ=$D2 mp=$D3 timod=$D4` }, \
    006 { `timod_rput: M_message type=`$D1, \
           0x00 "M_DATA", \
           0x01 "M_PROTO", \
           0x83 "M_PCPROTO", \
           0x0e "M_IOCTL", \
           0x86 "M_FLUSH", \
           \* {"UNKNOWN type" } }, \
    007 { `timod_rput - primitive=`eventtype_ind_T($D1) }, \
    008 { `timod_wput entry - q=$D1 OTHERQ=$D2 mp=$D3 timod=$D4` }, \
    009 { `timod_wput: M_message type=`$D1, \
           0x00 "M_DATA", \
           0x01 "M_PROTO", \
           0x83 "M_PCPROTO", \
           0x0e "M_IOCTL", \
           0x86 "M_FLUSH", \
           \* {"UNKNOWN type" } }, \
    010 { `timod_wput - primitive=`eventtype($D1) }, \
    011 { `timod_wput - primitive=`eventtype_timod($D1) }, \
    \* { `unknown subhook $HD%D1 error $ERROR` }
4AA 1.0 "TIRDWR" \
   $HD%D1, \
    001 { `tirdwr_open entry - q=$D1 OTHERQ=$D2 devp=$D3 flag=$D4 sflag=$D5` }, \
    002 { `tirdwr_open failed error=$D1%DW` }, \
    003 { `tirdwr_close entry - q=$D1 OTHERQ=$D2` }, \
    004 { `tirdwr_close - primitive=`eventtype($D1) }, \
    005 { `tirdwr_rput entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    006 { `tirdwr_rput: M_message type=`$D1, \
           0x00 "M_DATA", \
           0x01 "M_PROTO", \
           0x83 "M_PCPROTO", \
           0x0e "M_IOCTL", \
           0x86 "M_FLUSH", \
           \* {"UNKNOWN type" } }, \
    007 { `tirdwr_rput - primitive=`eventtype_ind_T($D1) }, \
    008 { `tirdwr_wput entry - q=$D1 OTHERQ=$D2 mp=$D3` }, \
    009 { `tirdwr_wput: M_message type=`$D1, \
           0x00 "M_DATA", \
           0x01 "M_PROTO", \
           0x83 "M_PCPROTO", \
           0x0e "M_IOCTL", \
           0x86 "M_FLUSH", \
           \* {"UNKNOWN type" } }, \
    \* { `unknown subhook $HD%D1 error $ERROR` }
4AE 1.0 L=KERN "@ras_errhook"	\
        "ras_errhook() service:   comp_data="$D1%XW  "errcode="$D2%XW \
	"caller1="$D3%XW "caller2="$D4%XW "caller3="$D5%XW
4AF 1.0 L=KERN "@EXCESSIVE INTERRUPT DISABLEMENT "	\
	$HD%D1,						\
	0 {						\
	"excessive disablement: ticks " $D1%DW		\
	"events " $D2%DW				\
	"IAR " $D3					\
	"LR " $D4					\
	"TRB callout " $D5				\
	},						\
	1 { "excessive disablement SUSPEND prev_ticks="$D1" LR="$D2 }, \
	2 { "excessive disablement RESUME  prev_enabled="$D1" LR="$D2 }, \
	3 { "excessive disablement FORGIVE LR="$D1 }
4B0 1.0 "@UNDISPATCH" \
	"undispatch: " \
	"old_tid="prKernelTID($TID) "CPUID="$D3%U1
4C1 1.0 "@VMM_PSIZE" \
	$HD, \
	0 { `VMM psize inc: psx=$D1 npgs_unpin=$D2 npgs_add=$D3 npgs_new=$D4` \
	                    "\n  " `new_pfavail=$D5` }, \
	1 { `VMM psize dec: psx=$D1 npgs_unpin=$D2 npgs_rem=$D3 npgs_new=$D4` \
	                    "\n  " `new_pfavail=$D5` }
4C2 1.0 "@VMM_PSM" \
	$HD, \
        0 { `VMM PSM promote:    mp=$D1 tgt=$D2 remain=$D3 rc=$D4 drunsafe=$D5` }, \
        1 { `VMM PSM prom scan:  fs=$D1 fcptr=$D2 fcbmap=$D3 flist=$D4 nfree=$D5` }, \
        2 { `VMM PSM chng psize: nfr=$D1 dfs=$D2 rfs=$D3 npgs_don=$D4 npgs_rcv=$D5` }, \
        3 { `VMM PSM lw promote: fs=$D1 nfr=$D2 bmap=$D3 rc=$D4` }, \
	4 { `VMM PSM lw migrate: V.S=$D2.$D1 nfr=$D3 n_nfr=$D4 rc=$D5` }, \
	5 { `VMM PSM hw promote: mp=$D1 nfr=$D2 dpsx=$D3 rpsx=$D4 rc=$D5` }, \
	6 { `VMM PSM demote:	 mp=$D1 dpsx=$D2 rpsx=$D3 dtgt=$D4 drem=$D5` }, \
	7 { `VMM PSM dem scan:	 mp=$D1 fs=$D2 nfr=$D3 nfree=$D4` }, \
        8 { `VMM PSM request:    mp=$D1 psx=$D2 pfavail=$D3 npages=$D4 rc=$D5` }, \
        9 { `VMM PSM fail limit: mp=$D1 npages=$D2 psx_don=$D3 psx_rcv=$D4` },\
        0xA { `VMM PSM abort pass: nfr=$D1 fs=$D2 pass=$D3 nskip=$D4 rc=$D5` }, \
        0xB { `VMM PSM start pin: mp=$D1 dpsx=$D2 rpsx=$D3 pfavail=$D4 npages=$D5` }, \
        0xC { `VMM PSM start fre0: mp=$D1 dpsx=$D2 rpsx=$D3 dfree=$D4 rfree=$D5` }, \
        0xD { `VMM PSM start fre1: mp=$D1 dnumperm=$D2 dnumclient=$D3` }, \
        0xE { `VMM PSM tgt npgs:   mp=$D1 dpsx=$D2 rpsx=$D3 tgt=$D4 dfree=$D5` }, \
        0xF { `VMM PSM tmr start:  mp=$D1 interval=$D2` }, \
        0x10 { `VMM PSM tmr tmout:  mp=$D1` }, \
        0x11 { `VMM PSM tmr stop:  mp=$D1` }, \
        0x12 { `VMM PSM start LRU:  mp=$D1 psx=$D2` }, \
        0x13 { `VMM PSM prog tmout: mp=$D1 rpsx=$D2 lastprog=$D3 oldreq=$D4` }, \
        0x14 { `VMM_PSM mk pin req: mp=$D1 psx=$D2 rc=$D3 psmd_waitl=$D4` }, \
        0x15 { `VMM PSM hw migchk: nfr=$D1 swbits=$D2 pftpvt=$D3 ssid=$D4` }, \
        0x16 { `VMM PSM lw migchk: nfr=$D1 krc=$D2 swbits=$D3 pftpvt=$D4 ssid=$D5` }, \
        0x17 { `VMM PSM prom scan2: rc=$D1` }
4C3 1.0 "@VMM_WRITE" \
        $HD, \
        0x00 { `VMM WRITE: sid=$D1 src=$D2 dest=$D3 bytes=$D4 basecopy_flags=$D5` }, \
	0x01 { `VMM WRITE Excp: sid=$D1 src=$D2 dest=$D3 bytes=$D4 rc=$D5` }
4C9 1.0 'WPAR' \
   $GENERIC, \
      1 { \
         $D1, \
         0x22 { "return kcorral_getrootpath= " W2 $HL%S1 }, \
         0x3a { "return kcorral_gethostname hostname= " W2 $HL%S1 }, \
         0x3c { `return kcorral_getname name=G16 $HL%S1` }, \
    	 0x3e { "return kcorral_getdomainname domainname= " W2 $HL%S1 }, \
         0x40 { "enter  kcorral_sethostname hostname= " W2 $HL%S1 }, \
    	 0x43 { "enter  kcorral_setdomainname domainname= " W2 $HL%S1 }, \
    	 0x49 { "wpar_cant_chkpnt  debug message= " W2 $HL%S1 }, \
         0x4b { "        corral_config kcid="W2 D4 "WPAR_name=" S2 "WPAR_root_path=" S2 }, \
         0x4c { "        corral_modify kcid="W2 D4 "newname WPAR_name=" $HL%S1 }, \
         0x91 { "       kwpar_mkKEexport   name=" W2 $HL%S1 }, \
         0x93 { "enter  kwpar_gethash name=" W2 $HL%S1 }, \
         0x94 { "       kwpar_gethash libpath=" W2 $HL%S1 }, \
           \* { `Unknown Generic hook id=$D1` } \
         $BREAK \
        } \
   $HD, \
    001 { `enter  corral_getpids kcid=$D1%D1 u_index=$D2` }, \
    002 { `return corral_getpids CQRY_FOUND` }, \
    003 { `return corral_getpids CQRY_NOTFOUND` }, \
    004 { `enter  corral_query kcid=$D1%D1 u_corral=$D2 u_size=$D3` }, \
    005 { `return corral_query rc=0` }, \
    006 { `return corral_query rc=$D1%D1` }, \
    007 { `enter  corral_getinfo kcid=$D1%D1 op=$D2%D1 u_buf=$D3 u_size=$D4` }, \
    008 { `return corral_getinfo rc=0` }, \
    009 { `return corral_getinfo rc=-1 error=$D1%D1` }, \
    00a { `enter  brand in=$D1` }, \
    00b { `return brand rc=-1 error=$D1%D1` }, \
    00c { `return brand rc=0 pid=`prKernelPID($D1) ` kcid=$D2%D4` }, \
    00d { `enter  kcorral_setinitpid pcorral=$D1 pid=`prKernelPID($D2) }, \
    00e { `return kcorral_setinitpid rc=EBUSY` }, \
    00f { `return kcorral_setinitpid rc=0` }, \
    010 { `enter  kcorral_init` }, \
    011 { `return kcorral_init fail    11` }, \
    012 { `return kcorral_init fail    12` }, \
    013 { `return kcorral_init fail    13` }, \
    014 { `return kcorral_init success 14` }, \
    015 { `enter  panel_init` }, \
    016 { `return panel_int rc=ENOMEM` }, \
    017 { `return panel_int rc=0` }, \
    018 { `enter  wlm_start_corral` }, \
    019 { `return wlm_start_corral rc=0` }, \
    01a { `enter  wlm_stop_corral` }, \
    01b { `return wlm_stop_corral rc=0` }, \
    01c { `enter  kcorral_lock_kcid kcid=$D1%D1` }, \
    01d { `return kcorral_lock_kcid rc=NULL` }, \
    01e { `return kcorral_lock_kcid pcorral=$D1` }, \
    01f { `enter  kcorral_getrootpath kcid=$D1%D1 plen=$D2 ppath=$D3` }, \
    020 { `return kcorral_getrootpath rc=ENOENT` }, \
    021 { `return kcorral_getrootpath rc=ENOSPC` }, \
    023 { `enter  kcorral_inuse prochr=$D1 reason=$D2%D1 id=$D3%D1 kcid=$D4%D1` }, \
    024 { `enter  kcorral_option_enabled kcid=$D1%D1 option=$D2%D1` }, \
    025 { `return kcorral_option_enabled rc=0` }, \
    026 { `enter  corral_delete kcid=$D1%D1` }, \
    027 { `return corral_delete rc=0` }, \
    028 { `return corral_delete rc=-1 error=$D1%D1` }, \
    029 { `enter  corral_config in=$D1` }, \
    02a { `return corral_config rc=0` }, \
    02b { `return corral_config rc=-1 error=$D1 completed=$D2` }, \
    02c { `enter  corral_modify in=$D1` }, \
    02d { `return corral_modify rc=0` }, \
    02e { `return corral_modify rc=$D1%D1 errlocal=$D2` }, \
    02f { `enter  remove_aliases target=$D1` }, \
    030 { `return remove_aliases rc=$D1%D1` }, \
    031 { `return remove_aliases rc=0` }, \
    032 { `enter  add_aliases target=$D1 in=$D2` }, \
    033 { `return add_aliases rc=$D1%D1` }, \
    034 { `enter  kcorral_loadmeta pkcorral=$D1` }, \
    035 { `return kcorral_loadmeta rc=$D1%D1` }, \
    036 { `enter  kcorral_unloadmeta pkcorral=$D1` }, \
    037 { `return kcorral_unloadmeta rc=$D1%D1` }, \
    038 { `enter  kcorral_gethostname kcid=$D1%D1 adspace=$D2` }, \
    039 { `return kcorral_gethostname rc=EINVAL` }, \
    03b { `enter  kcorral_getname kcid=$D1%D1 adspace=$D2` }, \
    03d { `enter  kcorral_getdomainname kcid=$D1%D1 adspace=$D2` }, \
    03f { `enter  kcorral_sethostname kcid=$D1%D1` }, \
    041 { `return kcorral_sethostname rc=0` }, \
    042 { `enter  kcorral_setdomainname kcid=$D1%D1` }, \
    044 { `return kcorral_setdomainname rc=0` }, \
    045 { `enter  kcorral_gethostid kcid=$D1%D1` }, \
    046 { `return kcorral_gethostid rc=0 hostid=$D1%D1` }, \
    047 { `enter  kcorral_sethostid kcid=$D1%D1` }, \
    048 { `return kcorral_sethostid rc=0 hostid=$D1%D1` }, \
    04a { `wpar_cant_chkpnt kcid=$D1%D1 cant_chkpnt=$D2%D1 caller=$D3 caller2=$D4` }, \
    04d { `enter  kwpar_devbranch_add kcid=$D1%D1` }, \
    04e { `return  kwpar_devbranch_add rc =$D1%D1` }, \
    04f { `enter  kwpar_devtrunk` }, \
    050 { `return  kwpar_devtrunk` }, \
    051 { `enter  kwpar_devleaf_add kcid=$D1%D1` }, \
    052 { `return  kwpar_devleaf_add rc =$D1%D1` }, \
    052 { `return  kwpar_devleaf_add rc =$D1%D1` }, \
    053 { `return  kwpar_devleaf_add rc =$D1%D1` }, \
    054 { `enter  kwpar_devbranch_delete kcid=$D1%D1` }, \
    055 { `return  kwpar_devbranch_delete rc =$D1%D1` }, \
    056 { `enter  kwpar_exp_add kcid=$D1%D1` }, \
    057 { `return  kwpar_exp_add rc=$D1%D1` }, \
    058 { `enter  kwpar_exp_delete kcid=$D1%D1` }, \
    059 { `return  kwpar_exp_delete rc=$D1%D1` }, \
    05a { `enter  kwpar_exp_getbyrdevno kcid=$D1%D1` }, \
    05b { `return  kwpar_exp_getbyrdevno rc=$D1%D1` }, \
    05c { `enter  wpar_mkdevexport kcid=$D1%D1` }, \
    05d { `return  wpar_mkdevexport rc=$D1%D1` }, \
    05e { `enter  wpar_rmdevexport kcid=$D1%D1` }, \
    05f { `return  wpar_rmdevexport rc=$D1%D1` }, \
    060 { `enter  wpar_mkdevimport impdev=$D1` }, \
    061 { `return  wpar_mkdevimport rc=$D1%D1` }, \
    062 { `enter  kwpar_getbyname kcid=$D1%D1` }, \
    063 { `return  kwpar_getbyname rc=$D1%D1` }, \
    064 { `return  wpar_rmdevimport inwimp=$D1%D1` }, \
    065 { `return  wpar_rmdevimport rc=$D1%D1` }, \
    066 { `return  wio_getdev kcid=$D1%D1` }, \
    067 { `return  wio_getdev rc=$D1%D1` }, \
    068 { `return  wio_getdev rc=$D1%D1` }, \
    069 { `return  wio_getdev rc=$D1%D1` }, \
    06a { `return  wio_getdev rc=$D1%D1` }, \
    06b { `return  wio_getdev rc=$D1%D1` }, \
    06c { `return  wio_getdev rc=$D1%D1` }, \
    06d { `return  kwio_devexpset kcid=$D1%D1` }, \
    06e { `return  kwio_devexpset rc=$D1%D1` }, \
    06f { `return  kwio_devexpset rc=$D1%D1` }, \
    070 { `return  kwio_devexpset rc=$D1%D1` }, \
    071 { `return  kwio_devexpset rc=$D1%D1` }, \
    072 { `return  kwio_devexpunset kcid=$D1%D1` }, \
    073 { `return  kwio_devexpunset rc=$D1%D1` }, \
    074 { `return  kwio_devexpunset rc=$D1%D1` }, \
    075 { `return  kwio_devexpunset rc=$D1%D1` }, \
    076 { `return  kwio_devexpunset rc=$D1%D1` }, \
    077 { `return  kwio_devexpget kcid=$D1%D1` }, \
    078 { `return  kwio_devexpget rc=$D1%D1` }, \
    079 { `return  kwio_devexpget rc=$D1%D1` }, \
    07a { `return  kwio_devexpget rc=$D1%D1` }, \
    07b { `return  wpar_getdevexp index=$D1%D1` }, \
    07c { `return  wpar_getdevexp rc=$D1%D1` }, \
    07d { `return  wpar_setdevexpname wimp=$D1%D1` }, \
    07e { `return  wpar_setdevexpname rc=$D1%D1` }, \
    07f { `return  wpar_setdevexpname rc=$D1%D1` }, \
    080 { `return  wpar_setdevexpname rc=$D1%D1` }, \
    081 { `return  kwpar_devV2Rname kcid=$D1%D1` }, \
    082 { `return  kwpar_devV2Rname rc=$D1%D1` }, \
    083 { `return  kwpar_devV2Rname rc=$D1%D1` }, \
    084 { `return  kwpar_devV2Rname rc=$D1%D1` }, \
    085 { `return  kwpar_ddioctl kcid=$D1%D1` }, \
    086 { `return  kwpar_ddioctl rc=$D1%D1` }, \
    087 { `return  kwpar_ddioctl rc=$D1%D1` }, \
    088 { `return kcorral_getrootpath rc=EINVAL` }, \
    089 { `enter  kcorral_lock_kcid_with_chk kcid=$D1%D1` }, \
    08a { `return kcorral_lock_kcid_with_chk rc=NULL` }, \
    08b { `return kcorral_lock_kcid_with_chk pcorral=$D1` }, \
    08c { `enter  kwpar_devV2Rname_CID kcid=$D1%D1` }, \
    08d { `return  kwpar_devV2Rname_CID rc=$D1%D1` }, \
    08e { `enter  wpar_KEexp cmd=$D1%D1 kcid=$D2%D1` }, \
    08f { `exit   wpar_KEexp cmd=$D1%D1 kcid=$D2%D1 rc=$D3%D1 errno=$D4%D1 code=$D5%D1` }, \
    090 { `enter  kwpar_mkKEexport - kcid=$D1%D1 KEexp=$D2 type=$D3%D1 major=$D4%D1 sig[0]=$D5%X1` }, \
    092 { `exit   kwpar_mkKEexport - rc=$D1%D1 code=$D2%D1` }, \
    095 { `exit   kwpar_gethash - rc=$D1%D1 sig[0]=$D2%X1 code=$D3%D1` }, \
    097 { `enter  kwpar_chk_kext cmd=$D1%D1` }, \
    098 { `         REG_KMID hndl=$D1 KEexpp=$D2 kmid=$D3` }, \
    099 { `         Found ALL match` }, \
    09a { `         Found PV_DEV_LOAD match` }, \
    09b { `exit  kwpar_chk_kext cmd=$D1%D1 rc=$D2%D1 errno=$D3%D1 match=$D4%D1 code=$D5%D1` }, \
    09c { `enter  find_file` }, \
    09d { `exit   find_file - fp=$D1 code=$D2%D1` }, \
    09e { `enter  kwpar_rmKEexport - kcid=$D1%D1 wdev=$D2 ` }, \
    09f { `exit   kwpar_rmKEexport - rc=$D1%D1 ` }, \
    100 { `enter  kwpar_rmKEexports - kcid=$D1%D1 need_lck=$D2%D1 ` }, \
    101 { `exit   kwpar_rmKEexports - rc=$D1%D1 ` }, \
    102 { `enter  kwpar_qryKEexport - kcid=$D1%D1 wdev=$D2 ` }, \
    103 { `exit   kwpar_qryKEexport - rc=$D1%D1 ` }, \
    104 { `enter  kwpar_qryKEexports - kcid=$D1%D1 wdev=$D2 size=$D3 ` }, \
    105 { `exit   kwpar_qryKEexports - rc=$D1%D1 size=$D2 ` }, \
    200 { `enter  kwpar_rel_all - line=$D1%D1  ` }, \
    201 { `exit   kwpar_rel_all - line=$D1%D1  ` }, \
    202 { `enter  kwpar_cfg_state - op=$D1%D1  ` }, \
    203 { `exit   kwpar_cfg_state - rc=$D1%D1 state=$D2  ` }, \
    204 { `enter  kwpar_find_maj - line=$D1%D1  ` }, \
    205 { `exit   kwpar_find_maj - line=$D1%D1 ` }, \
    206 { `enter  kwpar_alloc_maj - line=$D1%D1  ` }, \
    207 { `exit   kwpar_alloc_maj - rc=$D1%D1 line=$D2 ` }, \
    208 { `enter  kwpar_setmajor - line=$D1%D1  ` }, \
    209 { `exit   kwpar_setmajor - rc=$D1%D1 line=$D2 ` }, \
    20a { `enter  kwpar_chkmajor - line=$D1%D1  ` }, \
    20b { `exit   kwpar_chkmajor - rc=$D1%D1 line=$D2 ` }, \
    20c { `enter  wpar_kexpops - op=$D1%D1  ` }, \
    20d { `exit   wpar_kexpops - rc=$D1%D1 line=$D2 ` }, \
    20c { `enter  kwpar_setOnePrefMinor - major=$D1%D1  ` }, \
    20d { `exit   kwpar_setOnePrefMinor - line=$D1%D1 start1=$D2 ` }, \
    210 { `enter  kwpar_setOneMinor - major=$D1%D1  ` }, \
    211 { `exit   kwpar_setOneMinor - line=$D1%D1 start1=$D2 ` }, \
    212 { `enter  kwpar_MinorsFast - line=$D1%D1  ` }, \
    213 { `exit   kwpar_MinorsFast - line=$D1%D1 start1=$D2 ` }, \
    214 { `enter  kwpar_setminors - major=$D1%D1  ` }, \
    215 { `exit   kwpar_MinorsFast - line=$D1%D1 start1=$D2 ` }, \
    216 { `enter  kwpar_delminor - line=$D1%D1  ` }, \
    217 { `exit   kwpar_delminor - line=$D1%D1 start1=$D2 ` }, \
    900 { `enter wpar_errlog_init cid=$D1 line=$D2 ` }, \
    901 { `return wpar_errlog_init cid=$D1 rc=$D2 errno=$D3 line=$D4 ` }, \
    902 { `enter wpar_errlog_dealloc cid=$D1 line=$D2 ` }, \
    903 { `return wpar_errlog_dealloc cid=$D1 rc=$D2 errno=$D3 line=$D4 ` }, \
    904 { `enter kwpar_write_errbuf cid=$D1 input_buf=$D2 size=$D3 line=$D4 ` }, \
    905 { `return kwpar_write_errbuf cid=$D1 rc=$D2 errno=$D3 line=$D4 ` }, \
    906 { `enter wpar_log_err_buf cid=$D1 buf_size=$D2 line=$D3 ` }, \
    907 { `return wpar_log_err_buf cid=$D1 rc=$D2 errno=$D3 line=$D4 ` }, \
    90A { `enter copy_into_strpool arg=$D1 strpool_size=$D2 strpool_offset=$D3 line=$D4 ` }, \
    90B { `return copy_into_strpool rc=$D1 errno=$D2 line=$D3 ` }, \
    90C { `enter copy_into_payload arg=$D1 payload_size=$D2 payload_offset=$D3 line=$D4 ` }, \
    90D { `return copy_into_payload rc=$D1 errno=$D2 line=$D3 ` }, \
    90E { `enter kwpar_err cid=$D1 msg_set_no=$D2 msg_no=$D3 line=$D4 ` }, \
    90F { `return kwpar_err cid=$D1 rc=$D2 errno=$D3 line=$D4 ` }, \
    910 { `enter wpar_read_err_buf cid=$D1 size=$D2 line=$D3 ` }, \
    911 { `return wpar_read_err_buf cid=$D1 rc=$D2 errno=$D3 line=$D4 ` }, \
    \* { `unknown subhook id $HD` }
4CA 1.0 "@VMM_ERR" \
	$HD, \
	0 { `VMM ERR vmrelease: addr=$D1 nb=$D2 caller=$D5 sid=$D3` vmmsibits($D4) }, \
	1 { `VMM ERR vmprotect:	addr=$D1 nb=$D2 caller=$D5 sid=$D3` vmmsibits($D4) }
4CB 1.1 "@LFS: vnop_fid" \
     $HD, \
     0xFF { `vnop_fid(vp = $D2) = $D1, fid_ino = $D3, fid_gen = $D4` }, \
     \*   { vnop_fid unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4CC 1.1 "@LFS: vnop_getacl" \
     $HD, \
     0xFF { `vnop_getacl(vp = $D2) = $D1` }, \
     0xFE { `vnop_getaclx(vp = $D5) = $D1, acl_type = $D2, acl_sz = $D3, mode = $D4` }, \
     \*   { vnop_getacl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4CD 1.1 "@LFS: vnop_setacl" \
     $HD, \
     0xFF { `vnop_setacl(vp = $D2) = $D1` }, \
     0xFE { `vnop_setaclx(vp = $D2, acl_type = $D3, mode = $D4) = $D1` }, \
     \*   { vnop_setacl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4CE 1.1 "@LFS: vnop_getea" \
     $HD, \
     0xFF { `vnop_getea(vp = $D2) = $D1` }, \
     \*   { vnop_getea unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4CF 1.1 "@LFS: vnop_setea" \
     $HD, \
     0xFF { `vnop_setea(vp = $D2, flags = $D3) = $D1` }, \
     \*   { vnop_setea unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D0 1.1 "@LFS: vnop_listea" \
     $HD, \
     0xFF { `vnop_listea(vp = $D2) = $D1` }, \
     \*   { vnop_listea unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D1 1.1 "@LFS: vnop_removeea" \
     $HD, \
     0xFF { `vnop_removeea(vp = $D2) = $D1` }, \
     \*   { vnop_removeea unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D2 1.1 "@LFS: vnop_getpcl" \
     $HD, \
     0xFF { `vnop_getpcl(vp = $D2) = $D1` }, \
     \*   { vnop_getpcl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D3 1.1 "@LFS: vnop_setpcl" \
     $HD, \
     0xFF { `vnop_setpcl(vp = $D2) = $D1` }, \
     \*   { vnop_setpcl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D4 1.1 "@LFS: vnop_revoke" \
     $HD, \
     0xFF { `vnop_revoke(vp = $D2, cmd = $D3, flags = $D4) = $D1` }, \
     \*   { vnop_revoke unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D5 1.1 "@LFS: vnop_memcntl" \
     $HD, \
     0xFF { `vnop_memcntl(vp = $D2, cmd = $D3, arg = $D4) = $D1` }, \
     \*   { vnop_memcntl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D6 1.1 "@LFS: vfs_root" \
     $HD, \
     0xFF { `vfs_root(vfsp = $D3) = $D1, *vpp = $D2` }, \
     \*   { vfs_root unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D7 1.1 "@LFS: vfs_sync / vfs_syncvfs" \
     $HD, \
     0xFF { `vfs_sync(gfs_type = $D2, vfsp = $D3, cmd = $D4) = $D1` }, \
     \*   { vfs_sync unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D8 1.1 "@LFS: vfs_cntl" \
     $HD, \
     0xFF { `vfs_cntl(vfsp = $D2, cmd = $D3, arg = $D4, argsiz = $D5) = $D1` }, \
     \*   { vfs_cntl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4D9 1.1 "@LFS: vfs_quotactl" \
     $HD, \
     0xFF { `vfs_quotactl(vfsp = $D2, cmd = $D3, id = $D4, arg = $D5) = $D1` }, \
     \*   { vfs_quotactl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4DA 1.1 "@LFS: vfs_aclxcntl" \
     $HD, \
     0xFF { `vfs_aclxcntl(vfsp = $D2, vp = $D3, cmd = $D4) = $D1` }, \
     \*   { vfs_aclxcntl unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4DB 1.1 "@LFS: vnop_hold / vnop_rele" \
     $HD, \
     0xFF { `vnop_hold(vp = $D2, getcaller = $D3) = $D1` }, \
     0xFE { `vnop_rele(vp = $D1, getcaller = $D2)` }, \
     \*   { vnop_hold unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4DC 1.0 "@LFS: pile subsystem" \
     $HD, \
     0x01 { `pile_init: pflags = $D2, objsize = $D3, spages = $D4, getcaller = $D5: pile = $D1` }, \
     0x02 { `pile_destroy: pile = $D1, totalpages = $D2, spages = $D3, pflags = $D4, getcaller = $D5` }, \
     0x03 { `pile_alloc: pile = $D2, getcaller = $D5: obj = $D1, slab = $D3, refcount = $D4` }, \
     0x04 { `pile_free: obj = $D1, getcaller = $D5: pile = $D2, slab = $D3, refcount = $D4` }, \
     0x05 { `pile_config_max: pile = $D2, pflags = $D3, origmax = $D4, newmax = $D5: rc = $D1` }, \
     0x06 { `pile_config_min: pile = $D2, pflags = $D3, origmin = $D4, newmin = $D5: rc = $D1` }, \
     0x07 { `pile_slab_alloc: pile = $D3, pflags = $D4, flags = $D5: rc = $D1, slab = $D2` }, \
     0x08 { `pile_slab_destroy: pile = $D1, pflags = $D2, slab = $D3, sflags = $D4, spages = $D5` }, \
     0x09 { `pile_slab_squeeze: pile = $D1, pflags = $D2, slab = $D3, spages = $D4, refcount = $D5` }, \
     0x0A { `pile_slab_reclaim: pile = $D1, pflags = $D2, slab = $D3, spages = $D4, refcount = $D5` }, \
     \*   { pile unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4DD 1.0 "@LFS: name lookup cache" \
{{ nlcaction(act) `name cache $act: vfsp = $D1, dp = $D2, np = $D3, nid = $D4, hash = $D5` }} \
     $HD, \
     0x01 { `name cache purge: vfsp = $D1, halted = $D2, getcaller = $D3, getcaller2 = $D4` }, \
     0x02 { `name cache resume: halted = $D1, getcaller = $D2, getcaller2 = $D3` }, \
     0x03 { nlcaction('enter') }, \
     0x04 { nlcaction('delete') }, \
     0x11 { nlcaction('miss') }, \
     0x12 { nlcaction('negative hit') }, \
     0x13 { nlcaction('false hit') }, \
     0x14 { nlcaction('good hit') }, \
     \*   { name cache unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4DE 1.1 "@JFS2: metadata cache" \
{{ pxd(type) $HOOKENV, \
		64 { O8 R4 {{ $len = X3 }} {{ $high = X1 }} O8 R4 {{ $low = X4 }} }, \
	        32 { {{ $len = X3 }} {{ $high = X1 }} {{ $low = X4 }} }  \
	     {{ $high = $high * 0x100000000 }} {{ $high = $high + $low }} \
	     `blk = $high, len = $len` }} \
        $HD, \
	0x1  { `JFS2 metadata checkout: bp = $D1, vp = $D2, lv` W3 pxd()`, getcaller = $D5`}, \
	0x2  { `JFS2 metadata checkin: bp = $D1, vp = $D2, lv` W3 pxd()`, getcaller = $D5`}, \
	0x3  { `JFS2 metadata devstrat0: bp = $D1, vp = $D2, lv blk = $D3, bcount = $D4, getcaller = $D5`}, \
	0x4  { `JFS2 metadata iodone read: bp = $D1, vp = $D2, berror = $D3`}, \
	0x5  { `JFS2 metadata wait: bp = $D1, vp = $D2, pbflags = $D3`}, \
	0x6  { `JFS2 metadata devstrat1: bp = $D1, vp = $D2, lv blk = $D3, bcount = $D4, getcaller = $D5`}, \
	0x7  { `JFS2 metadata devstrat2: bp = $D1, vp = $D2, lv blk = $D3, bcount = $D4, getcaller = $D5`}, \
	0x8  { `JFS2 metadata iodone write: bp = $D1, vp = $D2, berror = $D3`}, \
	\*   { 4DE unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4DF 1.1 "@JFS2: inode cache" \
        $HD, \
	0x1  { `JFS2 iget: vp = $D1, count = $D2, ino = $D3, dev = $D4, getcaller = $D5`}, \
	0x2  { `JFS2 iput: vp = $D1, count = $D2, ino = $D3, nlink = $D4, getcaller = $D5`}, \
	\*   { 4DF unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4E0 1.1 "@JFS2: snapshot" \
{{ snaptrace(what) `JFS2 snapshot $what: bp = $D1, vfsp = $D2, snap dev = $D3, lv blk = $D4, bcount = $D5` }} \
{{ exttrace(what) `JFS2 snapshot $what: bp = $D1, vfsp = $D2, fs blk = $D3, bcount = $D4` }} \
{{ snapexttrace(what) `JFS2 snapshot $what: xaddr = $D1, xlen = $D2` }} \
{{ snapfifo(what) `JFS2 snapshot $what: ipSMap = $D1, tblk = $D2, list = $D3, level = $D4` }} \
        $HD, \
	0x01 { exttrace('cow fs ext') }, \
	0x02 { snaptrace('cow snap ext') }, \
	0x03 { snaptrace('cow bfs ext') }, \
	0x04 { exttrace('read fs ext') }, \
	0x05 { snaptrace('read snap ext') }, \
	0x06 { snapexttrace('iod fs ext') }, \
	0x07 { `JFS2 snapshot ron fs ext: xaddr = $D1, xlen = $D2, ip = $D3` }, \
	0x08 { `JFS2 snapshot fifo in: ipSMap = $D1, tblk = $D2, tlckList = $D3, tail = $D4` }, \
	0x09 { snapfifo('fifo out') }, \
	0x0a { snapfifo('fifo wakeup') }, \
	0x0b { snapfifo('fifo wait') }, \
	0x0c { `JFS2 snapshot iod free: xaddr = $D1, xlen = $D2, fFlag = $D3, mapType = $D4, tblk = $D5` }, \
	0x0d { `JFS2 snapshot COW Queue: ssd = $D1, siod = $D2, sfd = $D3, W4 O6 pirh/t = X1/X1,W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` }, \
        0x0e { `JFS2 snapshot COW IOWait: ssd = $D1, mysiod = $D2, xfdList = $D3, W4 O6 pirh/t = X1/X1, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x0f { `JFS2 snapshot PIIOD: ssd = $D1, sfd = $D2, LINE # = $D3%DW, W4 O6 pirh/t = X1/X1, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x10 { `JFS2 snapshot Wakeup: ssd = $D1, sfd = $D2, ioWait = $D3, LINE# = $D4%DW, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x11 { `JFS2 snapshot POIOD: ssd = $D1, eosPageOut= $D2, W3 O6 pirh/t = X1/X1, W4 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x12 { `JFS2 snapshot COWEOS : ssd = $D1, ssdnxt = $D2, flag = $D3, W4 O6 pirh/t = X1/X1, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x13 { `JFS2 snapshot COWPOR: ssd = $D1, sfd = $D2, flag = $D3, W4 O6 pirh/t = X1/X1, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x14 { `JFS2 snapshot PageIn IODone: ssd = $D1, b_forw = $D2, error = $D3, W4 O6 pirh/t = X1/X1, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x15 { `JFS2 snapshot PageOut IODone: ssd = $D1, b_forw = $D2, error = $D3, W4 O6 pirh/t = X1/X1, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
        0x16 { `JFS2 snapshot COD : bp = $D1, vfs = $D2, blkno = $D3, bcount = $D4 `},\
        0x17 { `JFS2 snapshot Awake: ssd = $D1, sfd = $D2, siod = $D3, LINE# = $D4%DW, W5 piiph/t = X1/X1 pixoh/t = X1/X1, porh/t = X1/X1 poiph/t = X1/X1` },\
	\*   { 4E0 unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4E1 1.1 "@JFS2: block map" \
{{ pxd(type) $HOOKENV, \
		64 { O8 R4 {{ $len = X3 }} {{ $high = X1 }} O8 R4 {{ $low = X4 }} }, \
	        32 { {{ $len = X3 }} {{ $high = X1 }} {{ $low = X4 }} }  \
	     {{ $high = $high * 0x100000000 }} {{ $high = $high + $low }} \
	     `blk = $high, len = $len` }} \
{{ pmap(type) `JFS2 block pmap $type: vp = $D1, fs blk = $D2, len = $D3, getcaller = $D4` }} \
        $HD, \
	0x01 { `JFS2 block map alloc: vp = $D1, fs` W2 pxd()`, free = $D4, getcaller = $D5` }, \
	0x02 { `JFS2 block map free: vp = $D1, fs` W2 pxd()`, free = $D4, getcaller = $D5` }, \
	0x03 { pmap('alloc') }, \
	0x04 { pmap('free') }, \
	0x05 { `JFS2 block map allocbits: ip = $D1, dp = $D2, blkno = $D3, nblocks = $D4, getcaller = $D5` }, \
	0x06 { `JFS2 block map freebits: ip = $D1, dp = $D2, blkno = $D3, nblocks = $D4, getcaller = $D5` }, \
	\*   { 4E1 unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4E2 1.1 "@JFS2: global events" \
        $HD, \
	0x01 { `JFS2 mount: vfsp = $D2, fs dev = $D3, log dev = $D4, rc = $D1` }, \
	0x02 { `JFS2 unmount: vfsp = $D2, fs dev = $D3, log dev = $D4, flags = $D5, rc = $D1` }, \
	0x03 { `JFS2 log open: logx = $D1, log dev = $D2, rc = $D3` }, \
	0x04 { `JFS2 log shutdown: logx = $D1, log dev = $D2, rc = $D3` }, \
	0x05 { `JFS2 reconfig: memory size = $D1, inode cache size = $D2, metadata cache size = $D3` }, \
	0x06 { `JFS2 quotas enabled: vfsp = $D1, qvp = $D2, type = $D3` }, \
	0x07 { `JFS2 quotas disabled: vfsp = $D1, qvp = $D2, type = $D3` }, \
	0x08 { `JFS2 freeze: vfsp = $D2, timeout = $D3, rc = $D1` }, \
	0x09 { `JFS2 thaw: vfsp = $D2, rc = $D1` }, \
	0x0A { `JFS2 refreeze: vfsp = $D2, timeout = $D3, rc = $D1` }, \
	0x0B { `JFS2 snapshot create: vfsp = $D2, snap dev = $D3, rc = $D1` }, \
	0x0C { `JFS2 snapshot delete: vfsp = $D2, snap dev = $D3, rc = $D1` }, \
	0x0D { `JFS2 shrink fs: vfsp = $D1, fs size = $D2 fsblks, log size = $D3 fsblks, lv size = $D4 fsblks, mapsize = $D5` }, \
	0x0E { `JFS2 extend fs: vfsp = $D1, fs size = $D2 fsblks, log size = $D3 fsblks, lv size = $D4 fsblks, mapsize = $D5` }, \
	0x0F { `JFS2 defrag fs: vp = $D2, file offset = fsblk $D3, new fs address = fsblk $D4, length = $D5 fsblks, rc = $D1` }, \
	0x10 { `JFS2 generic: D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5` }, \
	0x11 { `JFS2 remount: vfsp = $D2, fs dev = $D3, flags = $D4, rc = $D1` }, \
	\*   { 4E2 unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4E3 1.1 "@JFS2: log manager" \
        $HD, \
	0x01 { `JFS2 log wrap start: logx = $D1, log dev = $D2, wrap count = $D3` }, \
	0x02 { `JFS2 log wrap stop: logx = $D1, log dev = $D2, wrap count = $D3` }, \
	0x03 { `JFS2 log open: logx = $D1, log dev = $D2, fs dev = $D3` }, \
	0x04 { `JFS2 log close: logx = $D1, log dev = $D2, fs dev = $D3` }, \
	0x05 { `JFS2 log sync: logx = $D1, orig sync pt = $D2, sync pt = $D3, sync = $D4` }, \
	0x06 { `JFS2 log exception: logx = $D1, log dev = $D2, fs dev = $D3, rc = $D4, state = $D5` }, \
	0x07 { `JFS2 log devstrat: bp = $D1, logx = $D2, lv blk = $D3, bcount = $D4` }, \
	0x08 { `JFS2 log iodone: bp = $D1, logx = $D2` }, \
	\*   { 4E3 unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4E4 1.1 "@JFS2: transaction manager" \
        $HD, \
	0x01 { `JFS2 transaction begin: tid = $D1, vfsp = $D2, getcaller = $D3` }, \
	0x02 { `JFS2 transaction end: tid = $D1, vfsp = $D2, getcaller = $D3` }, \
	0x03 { `JFS2 transaction lock: tid = $D1, vp = $D2, type = $D3, getcaller = $D4` }, \
	0x04 { `JFS2 transaction commit: tid = $D1, vp = $D2, flag = $D3, getcaller = $D4` }, \
	0x05 { `JFS2 transaction abort: tid = $D1, vfsp = $D2, dirty = $D3, rc = $D4` }, \
	0x06 { `JFS2 transaction nohomeok: vp = $D1, bp = $D2, nohomeok = $D3, getcaller = $D4` }, \
	\*   { 4E4 unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4E5 1.1 "@KDM: Kernel DMAPI module" \
{{ int64(x) $HOOKENV, 64 { O4 {{ $high = X4 }} {{ $high = $high * 0x100000000 }} O4 {{ $low = X4 }} {{ $high = $high + $low  }} $high%X8 }, 32 { X8 } }} \
        $HD, \
	0x01 { `kdm_fsetcachemount(kvp = $D3, ops = $D4, fsid = $D5) = $D1, fcp = $D2` }, \
	0x02 { `kdm_fsetcacheumount(fcp = $D2, kvp = $D3, ops = $D4, fsid = $D5) = $D1` }, \
	0x03 { `kdm_fset_active(fcp = $D2, origactive = $D3, curactive = $D4) = $D1` }, \
	0x04 { `kdm_fset_inactive(fcp = $D2, origactive = $D3, curactive = $D4) = $D1` }, \
	0x05 { `kdm_fset_handletoip(fcp = $D3, fsid = $D4, ino = $D5) = $D1, *kvpp = $D2` }, \
	0x06 { `kdm_fset_getbulkattr(fcp = $D2, loc = $D3, nelem = $D4, mask = $D5) = $D1` }, \
	0x07 { `kdm_fset_getbulkall(fcp = $D2, loc = $D3, len = $D4, mask = $D5) = $D1` }, \
	0x08 { `kdm_fset_do_setondestroy(fcp = $D2, flag = $D3) = $D1` }, \
	0x09 { `kdm_fset_do_seteventlist(fcp = $D2, eventmask = $D3) = $D1` }, \
	0x0A { `kdm_fset_getconfig(fcp = $D2) = $D1` }, \
	0x0B { `kdm_vn_iptohandle(kvp = $D1) = void, fsid = $D2, ino = $D3, gen = $D4, type = $D5` }, \
	0x0C { `kdm_vn_kvptovp(kvp = $D3) = $D1, *vpp = $D2` }, \
	0x0D { `kdm_vn_vrele(kvp = $D1) = void` }, \
	0x0E { `kdm_vn_rwlock(kvp = $D1, mode = $D2) = void` }, \
	0x0F { `kdm_vn_rwunlock(kvp = $D1) = void` }, \
	0x10 { `kdm_vn_rwlock_try(kvp = $D2, mode = $D3) = $D1` }, \
	0x11 { `kdm_vn_probe_hole(kvp = $D2, offset = $D3, length = $D4) = $D1` }, \
	0x12 { `kdm_vn_get_allocinfo(kvp = $D2, offset = $D3, nextents = $D4) = $D1` }, \
	0x13 { `kdm_vn_get_fileattr(kvp = $D2, mask = $D3) = $D1` }, \
	0x14 { `kdm_vn_get_dirattr(kvp = $D2, loc = $D3, buflen = $D4, mask = $D5) = $D1` }, \
	0x15 { `kdm_vn_get_dmattr(kvp = $D2, len = $D3) = $D1` }, \
	0x16 { `kdm_vn_attrtomr(kvp = $D2, right = $D3) = $D1` }, \
	0x17 { `kdm_vn_do_readinvis(kvp = $D2, offset = ` W3 int64()`, length = $D5) = $D1` }, \
	0x18 { `kdm_vn_do_writeinvis(kvp = $D2, offset = ` W3 int64()`, length = $D5) = $D1` }, \
	0x19 { `kdm_vn_do_punch_hole(kvp = $D2, offset = $D3, length = $D4) = $D1` }, \
	0x1A { `kdm_vn_do_setfileattr(kvp = $D2, fa_size = $D3, fa_mode = $D4) = $D1` }, \
	0x1B { `kdm_vn_do_set_dmattr(kvp = $D2, len = $D3, dmtime = $D4) = $D1` }, \
	0x1C { `kdm_vn_do_set_resident(kvp = $D2, res = $D3) = $D1` }, \
	0x1D { `kdm_vn_do_sync(kvp = $D2, flags = $D3) = $D1` }, \
	0x1E { `kdm_vn_do_creatbyhan(kvp = $D2, fsid = $D3, ino = $D4) = $D1` }, \
	0x1F { `kdm_vn_do_set_region(kvp = $D2, nregions = $D3) = $D1` }, \
	0x20 { `kdm_vn_do_set_eventlist(kvp = $D2, eventmask = $D3) = $D1` }, \
	\*   { 4E5 unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4EF 1.1 "@LFS: vnop_map" \
     $HD, \
     0xFF { `vnop_map(vp = $D2, flags = $D3, offset = $D4, length = $D5) = $D1` }, \
     0xEF { `vnop_map(vp = $D2, flags = $D3, ...) = $D1` }, \
     0xEE { `vnop_map(vp = $D1, offset = ` W2 X8`, length = ` W4 X8`) = ...` }, \
     \*   { vnop_map unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4F0 1.1 "@LFS: vnop_unmap" \
     $HD, \
     0xFF { `vnop_unmap(vp = $D1, flags = $D2)` }, \
     \*   { vnop_unmap unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4F1 1.1 "@LFS: vnop_finfo" \
     $HD, \
     0xFF { `vnop_finfo(vp = $D2, cmd = $D3) = $D1` }, \
     \*   { vnop_finfo unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4F2 1.1 "@LFS: vnop_statea" \
     $HD, \
     0xFF { `vnop_statea(vp = $D2) = $D1` }, \
     \*   { vnop_statea unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
4F9 1.0 "@VMM_RESERVATION" \
	$HD, \
	0 { `VMM RESRV: frs_id=$D1 vmpool=$D2 need=$D3 ppda_reservation=$D4 caller=$D5` }, \
	1 { `VMM RESRV: frs_id=$D1 frs_numfrb=$D2 frs_nfreelist=$D3` }, \
	2 { `VMM RESRV: frs_id=$D1 vmpool=$D2 psx=$D3 ppda_reservation=$D4 caller=$D5` }, \
	3 { `VMM RESRV: frs_id=$D1 frs_numfrb=$D2 frs_nfreelist=$D3` }, \
	4 { `VMM RESRV: frs_id=$D1 vmpool=$D2 psx=$D3 numrsvd=$D4 caller=$D5` }, \
	5 { `VMM RESRV: frs_id=$D1 frs_numfrb=$D2 frs_nfreelist=$D2` }, \
	6 { `VMM RESRV: frs_id=$D1 frs_numfrb=$D2 frs_nfreelist=$D3 nfr=$D4` }, \
	7 { `VMM RESRV: frs_id=$D1 freefwd=$D2 freebwd=$D3 rsvdfwd=$D4 rsvdbwd=$D5` }, \
	8 { `VMM RESRV: frs_id=$D1 freefwd=$D2 freebwd=$D3 rsvdfwd=$D4 rsvdbwd=$D5` }, \
	9 { `VMM RESRV: frs_id=$D1 freefwd=$D2 freebwd=$D3 rsvdfwd=$D4 rsvdbwd=$D5` }, \
	10 { `VMM RESRV: frs_id=$D1 ppda_frs_id=$D2 ppds_frs_freefwd=$D3 ppda_frs_rsvdfwd=$D4 caller=$D5` }
4FC 1.0 "WPARCR" \
    $HD, \
    0x001  { "mcr_handler_setup enter " pid=$D1 tid=$D2 }, \
    0x002  { "mcr_handler_setup ENTERHANDLER return " pid=$D1 tid=$D2 rc=$D3 }, \
    0x003  { "mcr_handler_setup exit " pid=$D1 tid=$D2 rc=$D3 }, \
    0x004  { "mcr_handler_undo enter " pid=$D1 tid=$D2 }, \
    0x005  { "mcr_handler_undo EXITHANDLER return " pid=$D1 tid=$D2 rc=$D3 }, \
    0x006  { "mcr_handler_undo exit " pid=$D1 tid=$D2 rc=$D3 }, \
    0x007  { "mcr_chkpnt_handler enter " pid=$D1 tid=$D2 }, \
    0x008  { "kmcr_chkpnt_kill enter " pid=$D1 size=$D2 }, \
    0x009  { "kmcr_chkpnt_kill checkpoint " pid=$D1 tid=$D2 t_flags=$D3 t_flags2=$D4 }, \
    0x00A  { "kmcr_chkpnt_kill exit " pid=$D1 rc=$D2 }, \
    0x00B  { "mcr_thread_rvous enter " pid=$D1 tid=$D2 }, \
    0x00C  { "mcr_thread_rvous exit " pid=$D1 tid=$D2 primary=$D3 flag=$D4 }, \
    0x00D  { "smcr_signal_enter enter " pid=$D1 tid=$D2 }, \
    0x00E  { "smcr_signal_enter stack alloc " pid=$D1 tid=$D2 }, \
    0x010  { "smcr_signal_enter exit " pid=$D1 tid=$D2 rc=$D3 }, \
    0x011  { "smcr_signal_exit enter " pid=$D1 tid=$D2 }, \
    0x012  { "smcr_signal_exit exit " pid=$D1 tid=$D2 }, \
    0x013  { "mcr_exec_checkpoint exit " rc=$D1 code=$D2 len=$D3 }, \
    0x014  { "mcr_get_shlib_info exit " rc=$D1 code=$D2 len=$D3 }, \
    0x015  { "smcr_exec_info exit " flags=0x$D1%X4 fd=$D2 fderr=$D3 rc=$D4 code=$D5 }, \
    0x016  { "entr mcr_exec_pre_asyncheckpoint" flags=$D1 fd=$D2%D1 fderr=$D3%D1 buf=$D4 len=$D5%D1 }, \
    0x017  { "exit mcr_exec_pre_asyncheckpoint" rc=$D1%D1 code=$D2%D1 len=$D3%D1 }, \
    0x018  { "entr mcr_exec_asyncheckpoint" flags=$D1 fd=$D2%D1 fderr=$D3%D1 buf=$D4 len=$D5%D1 }, \
    0x019  { "exit mcr_exec_asyncheckpoint" rc=$D1%D1 code=$D2%D1 len=$D3%D1 }, \
    0x01A  { "entr mcr_get_shlib_asyncinfo" flags=$D1 fd=$D2%D1 fderr=$D3%D1 buf=$D4 len=$D5%D1 }, \
    0x01B  { "exit mcr_get_shlib_asyncinfo" rc=$D1%D1 code=$D2%D1 len=$D3%D1 }, \
    0x01C  { "entr smcr_exec_asyncinfo" flags=$D1 fd=$D2%D1 fderr=$D3%D1 buf=$D4 len=$D5%D1 }, \
    0x01D  { "exit smcr_exec_asyncinfo" rc=$D1%D1 code=$D2%D1 len=$D3%D1 }, \
    0x01E  { "entr mcr_exec_restart_async" fd=$D1%D1 fderr=$D2%D1 buf=$D3 len=$D4%D1 }, \
    0x01F  { "exit mcr_exec_restart_async" rc=$D1%D1 len=$D2%D1 }, \
    0x020  { "entr mcr_restart_shlib_asyncinfo" flags=$D1 fd=$D2%D1 fderr=$D3%D1 buf=$D4 len=$D5%D1 }, \
    0x021  { "exit mcr_restart_shlib_asyncinfo" rc=$D1%D1 code=$D2%D1 }, \
    0x022  { "entr smcr_async_xfer_oper" cmd=$D1%D1 cid=$D2%D1 bufp=$D3 size=$D4%D1 }, \
    0x023  { "exit smcr_async_xfer_oper" rc=$D1%D1 code=$D2%D1 }, \
    0x101  { "kwpar_sock_cr enter " cmd=$D1 arg=$D2 }, \
    0x102  { "kwpar_sock_cr exit " cmd=$D1 rc=$D2 }, \
    0x103  { "wpar_sock_cr enter " cmd=$D1 arg=$D2 }, \
    0x104  { "wpar_sock_cr param " cmd=$D1 fd=$D2 fdout=$D3 }, \
    0x105  { "wpar_sock_cr param " cmd=$D1 so=$D2 }, \
    0x106  { "wpar_sock_cr exit " cmd=$D1 rc=$D2 }, \
    0x107  { "sock_cr_get enter " so=$D1 }, \
    0x108  { "sock_cr_get exit " so=$D1 rc=$D2 }, \
    0x109  { "do_sock_get enter " so=$D1 }, \
    0x10A  { "do_sock_get exit " so=$D1 rc=$D2 }, \
    0x10B  { "do_mbuf_get enter " so=$D1 }, \
    0x10C  { "do_mbuf_get exit " so=$D1 rc=$D2 }, \
    0x10D  { "sock_cr_put enter " so=$D1 }, \
    0x10E  { "sock_cr_put queue " so=$D1 qlen=$D2 q0len=$D3 }, \
    0x110  { "do_sock_put enter " so=$D1 }, \
    0x111  { "do_sock_put exit " so=$D1 rc=$D2 }, \
    0x112  { "do_mbuf_put enter " so=$D1 }, \
    0x113  { "do_mbuf_put exit " so=$D1 rc=$D2 }, \
    0x114  { "do_unix_get enter " so=$D1 }, \
    0x115  { "do_unix_get exit " so=$D1 rc=$D2 }, \
    0x116  { "do_unix_put enter " so=$D1 }, \
    0x117  { "do_unix_put exit " so=$D1 rc=$D2 }, \
    0x118  { "usock_connect enter " so=$D1 }, \
    0x119  { "usock_connect exit " so=$D1 so2=$D2 rc=$D3 }, \
    0x11A  { "do_usock_inflt enter " get=$D1 so=$D2 }, \
    0x11B  { "do_usock_inflt exit " get=$D1 so=$D2 rc=$D3 }, \
    0x11C  { "usock_inflt_get enter " so=$D1 }, \
    0x11D  { "usock_inflt_get exit " so=$D1 rc=$D2 }, \
    0x11E  { "usock_inflt_put enter " so=$D1 }, \
    0x120  { "usock_inflt_put exit " so=$D1 rc=$D2 }, \
    0x121  { "do_sock_del enter " so=$D1 }, \
    0x122  { "do_sock_del exit " so=$D1 rc=$D2 }, \
    0x123  { "unref_sock_get enter " cid=$D1 }, \
    0x124  { "unref_sock_get exit " cid=$D1 rc=$D2 }, \
    0x125  { "unref_sock_put enter " cid=$D1 }, \
    0x126  { "unref_sock_put exit " cid=$D1 rc=$D2 }, \
    0x127  { "socket data out " len=$D1 }, \
    0x128  { "socket data in " len=$D1 }, \
    0x129  { "sock_cr_put exit " so=$D1 rc=$D2 }, \
    0x131  { "mcr_net_oper enter " cid=$D1 cmd=$D2 }, \
    0x132  { "mcr_net_oper exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x133  { "sock_freeze enter " cid=$D1 cmd=$D2 }, \
    0x134  { "sock_freeze specific " cid=$D1 cmd=$D2 so=$D3 }, \
    0x135  { "sock_freeze all " cid=$D1 cmd=$D2 so=$D3 }, \
    0x136  { "sock_freeze exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x137  { "sock_unblock enter " cid=$D1 cmd=$D2 }, \
    0x138  { "sock_unblock exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x139  { "sock_reblock enter " cid=$D1 cmd=$D2 }, \
    0x13A  { "sock_reblock exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x13B  { "filt_unblock enter " cid=$D1 cmd=$D2 }, \
    0x13C  { "filt_unblock exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x13D  { "filt_reblock enter " cid=$D1 cmd=$D2 }, \
    0x13E  { "filt_reblock exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x140  { "net_block enter " cid=$D1 cmd=$D2 }, \
    0x141  { "net_block exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x142  { "net_unblock enter " cid=$D1 cmd=$D2 }, \
    0x143  { "net_unblock exit " cid=$D1 cmd=$D2 rc=$D3 }, \
    0x144  { "chkpnt_filter allow " op=$D1 saddr=$D2 sport=$D3 daddr=$D4 dport=$D5 }, \
    0x145  { "chkpnt_filter drop " op=$D1 saddr=$D2 sport=$D3 daddr=$D4 dport=$D5 }, \
    0x151  { "do_inet_cr enter " cmd=$D1 so=$D2 }, \
    0x152  { "do_inet_cr exit " cmd=$D1 so=$D2 rc=$D3 }, \
    0x153  { "do_inet_get enter " so=$D1 }, \
    0x154  { "do_inet_get exit " so=$D1 rc=$D2 }, \
    0x155  { "do_inpcb_get enter " so=$D1 }, \
    0x156  { "do_inpcb_get exit " so=$D1 rc=$D2 }, \
    0x157  { "do_tcpcb_get enter " so=$D1 }, \
    0x158  { "do_tcpcb_get exit " so=$D1 rc=$D2 }, \
    0x159  { "do_inet_put enter " so=$D1 }, \
    0x15A  { "do_inet_put exit " so=$D1 rc=$D2 }, \
    0x15B  { "do_inpcb_put enter " so=$D1 }, \
    0x15C  { "do_inpcb_put exit " so=$D1 rc=$D2 }, \
    0x15D  { "do_tcpcb_put enter " so=$D1 }, \
    0x15E  { "do_tcpcb_put exit " so=$D1 rc=$D2 }, \
    0x160  { "do_inet_del enter " so=$D1 }, \
    0x161  { "do_inet_del exit " so=$D1 rc=$D2 }, \
    0x162  { "get_unref_sock enter " so=$D1 }, \
    0x163  { "get_unref_sock exit " so=$D1 rc=$D2 }, \
    0x190  { "mcr_save_secinfo exit " }, \
    0x191  { "mcr_restore_secinfo exit " rc=$D1 code=$D2 }, \
    0x192  { "smcr_secinfo exit " oper=0x$D1%X4 bufp=0x$D2%XW sizep=0x$D3%XW rc=$D4 needed=$D5 }, \
    0x201  { "smcr_mapinfo enter " oper=$D1 range=$D2 outbuf=$D3 *outsize=$D4 inarg=$D5 }, \
    0x202  { "smcr_mapinfo exit " oper=$D1 rc=$D2 }, \
    0x203  { "vm_query_memmaps enter " cargs=$D1 }, \
    0x204  { "vm_query_memmaps exit " rc=$D1 }, \
    0x205  { "vm_query_regions enter " map=$D1 }, \
    0x206  { "vm_query_regions exit " rc=$D1 }, \
    0x207  { "vm_query_all_user enter " map=$D1 }, \
    0x208  { "vm_query_all_user exit " rc=$D1 }, \
    0x209  { "vm_query_data enter " map=$D1 }, \
    0x20A  { "vm_query_data exit " rc=$D1 }, \
    0x20B  { "vm_query_stack enter " map=$D1 }, \
    0x20C  { "vm_query_stack exit " rc=$D1 }, \
    0x20D  { "vm_query_all_mmap enter " map=$D1 }, \
    0x20E  { "vm_query_all_mmap exit " rc=$D1 }, \
    0x20F  { "vm_query_all_shared enter " map=$D1 }, \
    0x210  { "vm_query_all_shared exit " rc=$D1 }, \
    0x211  { "vm_query_nosup enter " ssp=$D1 esid=$D2 map=$D3 }, \
    0x212  { "vm_query_nosup exit " rc=$D1 }, \
    0x213  { "vm_get_shmid enter " shmp=$D1 oshmid=$D2 }, \
    0x214  { "vm_get_shmid exit " rc=$D1 *oshmid=$D2 }, \
    0x215  { "vm_cp_shm_info enter " shmp=$D1 mapi=$D2 ssp=$D3 }, \
    0x216  { "vm_cp_shm_info exit " rc=$D1 }, \
    0x217  { "vm_query_shared enter " ssp=$D1 esid=$D2 map=$D3 }, \
    0x218  { "vm_query_shared exit " rc=$D1 }, \
    0x219  { "vm_query_mapped enter " ssp=$D1 esid=$D2 map=$D3 }, \
    0x21A  { "vm_query_mapped exit " rc=$D1 }, \
    0x21B  { "vm_query_mmap enter " vmep=$D1 map=$D2 }, \
    0x21C  { "vm_query_mmap exit " rc=$D1 }, \
    0x21D  { "vm_output_mapinfo enter " map=$D1 }, \
    0x21E  { "vm_output_mapinfo exit " rc=$D1 }, \
    0x21F  { "vm_fixup_range enter " rp=$D1 start=$D2 end=$D3 }, \
    0x220  { "vm_fixup_range exit " rc=$D1 start=$D2 end=$D3 }, \
    0x221  { "vm_get_stack_range enter " rp=$D1 }, \
    0x222  { "vm_get_stack_range exit " rc=$D1 start=$D2 end=$D3 }, \
    0x223  { "vm_copyout_data enter " src=$D1 srclen=$D2 *outbp=$D3 *rlenp=$D4 }, \
    0x224  { "vm_copyout_data exit " rc=$D1 *outbp=$D2 *rlenp=$D3 }, \
    0x225  { "vm_init_mapstate enter " masp=$D1 }, \
    0x226  { "vm_init_mapstate exit " rc=$D1 }, \
    0x227  { "vm_init_mapactive enter " maap=$D1 }, \
    0x228  { "vm_init_mapactive exit " rc=$D1 }, \
    0x229  { "vm_get_state enter " cargs=$D1 }, \
    0x22A  { "vm_get_state exit " rc=$D1 }, \
    0x22B  { "vm_get_state_wstg enter " masp=$D1 }, \
    0x22C  { "vm_get_state_wstg exit " rc=$D1 }, \
    0x22D  { "vm_find_vme enter " addr=$D1 len=$D2 exact=$D3 }, \
    0x22E  { "vm_find_vme exit " vmepo=$D1 }, \
    0x22F  { "vm_get_state_mmap enter " masp=$D1 }, \
    0x230  { "vm_get_state_mmap exit " rc=$D1 }, \
    0x231  { "vm_get_state_all_shm enter " masp=$D1 }, \
    0x232  { "vm_get_state_all_shm exit " rc=$D1 }, \
    0x233  { "vm_get_state_shared enter " ssp=$D1 esid=$D2 masp=$D3 }, \
    0x234  { "vm_get_state_shared exit " rc=$D1 }, \
    0x235  { "vm_get_state_mapped enter " ssp=$D1 esid=$D2 masp=$D3 }, \
    0x236  { "vm_get_state_mapped exit " rc=$D1 }, \
    0x237  { "vm_get_sidx enter " vaddr=$D1 }, \
    0x238  { "vm_get_sidx exit " sidx=$D1 }, \
    0x239  { "v_get_prot_page enter " msp=$D1 }, \
    0x23A  { "v_get_prot_page exit " rc=$D1 }, \
    0x23B  { "v_get_prot_wseg enter " msp=$D1 isidx=$D2 }, \
    0x23C  { "v_get_prot_wseg exit " rc=$D1 }, \
    0x23D  { "v_get_prot_pseg enter " msp=$D1 sidx=$D2 }, \
    0x23E  { "v_get_prot_pseg exit " }, \
    0x23F  { "v_get_prot_mseg enter " msp=$D1 sidx=$D2 }, \
    0x240  { "v_get_prot_mseg exit " }, \
    0x241  { "vm_get_active enter " cargs=$D1 }, \
    0x242  { "vm_get_active exit " rc=$D1 }, \
    0x243  { "vm_get_active_data enter " maap=$D1 sidx=$D2 }, \
    0x244  { "vm_get_active_data exit " rc=$D1 }, \
    0x245  { "vm_get_active_shm enter " maap=$D1 sidx=$D2 }, \
    0x246  { "vm_get_active_shm exit " rc=$D1 }, \
    0x247  { "vm_get_active_mmap enter " maap=$D1 }, \
    0x248  { "vm_get_active_mmap exit " rc=$D1 }, \
    0x249  { "v_bld_bitmap_seg enter " maap=$D1 sidx=$D2 pnof=$D3 pnol=$D4 }, \
    0x24A  { "v_bld_bitmap_seg exit " pcnt=$D1 }, \
    0x24B  { "v_bld_bitmap_xpts enter " maap=$D1 isidx=$D2 offset=$D3 ancestors=$D4 }, \
    0x24C  { "v_bld_bitmap_xpts exit " rc=$D1 }, \
    0x24D  { "vm_put_protect enter " cargs=$D1 }, \
    0x24E  { "vm_put_protect exit " rc=$D1 }, \
    0x24F  { "vm_put_protect_data enter " mapp=$D1 }, \
    0x250  { "vm_put_protect_data exit " rc=$D1 }, \
    0x251  { "vm_put_protect_shm enter " mapp=$D1 }, \
    0x252  { "vm_put_protect_shm exit " rc=$D1 }, \
    0x253  { "vm_put_protect_mmap enter " mapp=$D1 }, \
    0x254  { "vm_put_protect_mmap exit " rc=$D1 }, \
    0x255  { "vm_protect_range enter " msp=$D1 pnof=$D2 pnol=$D3 key=$D4 }, \
    0x256  { "vm_protect_range exit " rc=$D1 }, \
    0x257  { "vm_protect_pages enter " msp=$D1 pnof=$D2 pnol=$D3 key=$D4 }, \
    0x258  { "vm_protect_pages exit " rc=$D1 }, \
    0x259  { "vm_protect_region enter " msp=$D1 }, \
    0x25A  { "vm_protect_region exit " rc=$D1 }, \
    0x25B  { "vm_get_segnode enter " }, \
    0x25C  { "vm_get_segnode exit " snp=$D1 }, \
    0x25D  { "vm_get_fileinfo enter " fd=$D1 }, \
    0x25E  { "vm_get_fileinfo exit " rc=$D1 *fpr=$D2 *size=$D3 }, \
    0x25F  { "vm_get_shmsize enter " shmptr=$D1 }, \
    0x260  { "vm_get_shmsize exit " size=$D1 }, \
    0x261  { "v_get_prot_wseg " pageno=$D1 key=$D2 }, \
    0x262  { "v_get_prot_mseg " pageno=$D1 key=$D2 }, \
    0x263  { "v_get_prot_pseg " pageno=$D1 key=$D2 }, \
    0x264  { "v_bld_bitmap_seg " bitc=$D1 index=$D2 bits=$D3 }, \
    0x265  { "vm_inherit_map enter " cargs=$D1 }, \
    0x266  { "vm_inherit_map exit " rc=$D1 }, \
    0x267  { "vm_inherit_map_clone enter " cargs=$D1 mvmep=$D2 }, \
    0x268  { "vm_inherit_map_clone exit " rc=$D1 }, \
    0x269  { "vm_inherit_map_msid enter " vmep=$D1 }, \
    0x26A  { "vm_inherit_map_msid exit " rc=$D1 }, \
    0x26B  { "vm_get_mlocks enter " cargs=$D1 }, \
    0x26C  { "vm_get_mlocks exit " rc=$D1 }, \
    0x26D  { "vm_rst_mlocks enter " cargs=$D1 }, \
    0x26E  { "vm_rst_mlocks exit " rc=$D1 }, \
    0x26F  { "vm_mlinfo_proc enter " unlockf=$D1 mlip=$D2 size=$D3 stopp=$D4 badp=$D5 }, \
    0x270  { "vm_mlinfo_proc exit " rc=$D1 }, \
    0x271  { "vm_shm_rdonly enter " segtype=$D1 addr=$D2 }, \
    0x272  { "vm_shm_rdonly exit " rc=$D1 }, \
    0x273  { "vm_is_shm_rdonly enter " msp=$D1 }, \
    0x274  { "vm_is_shm_rdonly exit " rc=$D1 }, \
    0x275  { "vm_mapi_adsplock enter " adslock=$D1 }, \
    0x276  { "vm_mapi_adsplock exit " }, \
    0x277  { "vm_mapi_adspunlock enter " adslock=$D1 }, \
    0x278  { "vm_mapi_adspunlock exit " }, \
    0x279  { "vm_mapi_getkeys enter " msp=$D1 gotlock=$D2 }, \
    0x27A  { "vm_mapi_getkeys exit " rc=$D1 }, \
    0x27B  { "vm_mapi_setkey enter " uaddr=$D1 usize=$D2 hkey=$D3 gotlock=$D4 }, \
    0x27C  { "vm_mapi_setkey exit " rc=$D1 }, \
    0x27D  { "vm_mapi_setkeys enter " map=$D1 gotlock=$D2 }, \
    0x27E  { "vm_mapi_setkeys exit " rc=$D1 }, \
    0x27F  { "v_get_xpt enter " sidx=$D1 pno=$D2 isancestor=$D3 }, \
    0x280  { "v_get_xpt exit " xpt=$D1 }, \
    0x281  { "v_get_xpt_parent enter " sidx=$D1 pno=$D2 }, \
    0x282  { "v_get_xpt_parent exit " xpt=$D1 }, \
    0x283  { "vm_get_segstate enter " sspp=$D1 snpp=$D2 snidxp=$D3 idxp=$D4 esidp=$D5 }, \
    0x284  { "vm_get_segstate exit " rc=$D1 }, \
    0x285  { "vm_get_segstate_in_sgn enter " sspp=$D1 snp=$D2 snidxp=$D3 idxp=$D4 }, \
    0x286  { "vm_get_segstate_in_sgn exit " rc=$D1 }, \
    0x287  { "vm_get_esid_in_sgn enter " ssp=$D1 snp=$D2 esidp=$D3 nesidp=$D4 }, \
    0x288  { "vm_get_esid_in_sgn exit " }, \
    0x289  { "vm_get_rtfd enter " rtshm=$D1 }, \
    0x28A  { "vm_get_rtfd exit " rc=$D1 }, \
    0x28B  { "vm_mapi_setprot enter " uaddr=$D1 usize=$D2 prot=$D3 gotlock=$D4 }, \
    0x28C  { "vm_mapi_setprot exit " rc=$D1 }, \
    0x28D  { "vm_mapi_setprots enter " map=$D1 gotlock=$D2 }, \
    0x28E  { "vm_mapi_setprots exit " rc=$D1 }, \
    0x501  { "fdinfo enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x502  { "fdinfo exit " rc=$D1 }, \
    0x503  { "get_fdtype " fdtype=$D1 }, \
    0x504  { "get_fdusage enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x505  { "get_fdusage loop " fd=$D1 fp=$D2 flags=$D3 }, \
    0x506  { "get_fdusage exit " rc=$D1 }, \
    0x507  { "get_fdpath enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x508  { "get_fdpath exit " rc=$D1 }, \
    0x509  { "get_flocks enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x50A  { "get_flocks loop " gp=$D1 offset=$D2 lock count=$D3 rc=$D4 }, \
    0x50B  { "get_flocks exit " rc=$D1 }, \
    0x50C  { "set_flocks enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x50D  { "set_flocks loop " fp=$D1 lock count=$D2 rc=$D3 }, \
    0x50E  { "set_flocks exit " rc=$D1 }, \
    0x50F  { "get_queued_aio enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x510  { "get_queued_aio exit " rc=$D1 }, \
    0x511  { "put_queued_aio enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x512  { "put_queued_aio exit " rc=$D1 }, \
    0x513  { "get_pending_io enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x514  { "get_pending_io exit " rc=$D1 }, \
    0x515  { "put_pending_io enter " pid=$D1 cmd=$D2 arg=$D3 }, \
    0x516  { "put_pending_io exit " rc=$D1 }, \
    0x601  { "aio_suspend_io enter" }, \
    0x602  { "aio_suspend_io exit " rc=$D1 }, \
    0x603  { "posix aio_suspend_io enter" }, \
    0x604  { "posix aio_suspend_io exit " rc=$D1 }, \
    0x605  { "suspend_aio enter" }, \
    0x606  { "suspend_aio sleep" }, \
    0x607  { "suspend_aio suspend" }, \
    0x608  { "suspend_aio exit " rc=$D1 }, \
    0x609  { "for_each_file " func=$D1 fd=$D2 fp=$D3 rc=$D4 }, \
    0x60A  { "wait_fastpath_io enter" }, \
    0x60B  { "wait_fastpath_io exit " rc=$D1 }, \
    0x60C  { "wait_list_io enter" }, \
    0x60D  { "wait_list_io exit " rc=$D1 }, \
    0x60E  { "aio_resume_io enter" }, \
    0x60F  { "aio_resume_io exit " rc=$D1 }, \
    0x610  { "posix aio_resume_io enter" }, \
    0x611  { "posix aio_resume_io exit " rc=$D1 }, \
    0x612  { "resume_aio enter" }, \
    0x613  { "resume_aio sleep" }, \
    0x614  { "resume_aio resume" }, \
    0x615  { "resume_aio exit " rc=$D1 }, \
    0x616  { "aio_put_queued_io enter " pid=$D1 fd=$D2 fp=$D3 }, \
    0x617  { "aio_put_queued_io loop " req count=$D1 rc=$D2 }, \
    0x618  { "aio_put_queued_io exit " rc=$D1 }, \
    0x619  { "posix aio_put_queued_io enter " pid=$D1 fd=$D2 fp=$D3 }, \
    0x61A  { "posix aio_put_queued_io loop " req count=$D1 rc=$D2 }, \
    0x61B  { "posix aio_put_queued_io exit " rc=$D1 }, \
    0x61C  { "aio_get_queued_io enter " pid=$D1 fd=$D2 fp=$D3 }, \
    0x61D  { "aio_get_queued_io exit " rc=$D1 }, \
    0x61E  { "posix aio_get_queued_io enter " pid=$D1 fd=$D2 fp=$D3 }, \
    0x61F  { "posix aio_get_queued_io exit " rc=$D1 }, \
    0x620  { "get_queued_io_tab enter " tab=$D1 pid=$D2 fd=$D3 fp=$D4 }, \
    0x621  { "get_queued_io_tab loop " skip=$D1 req count=$D2 }, \
    0x622  { "get_queued_io_tab exit " rc=$D1 }, \
    0x623  { "ipcinfo enter " op=$D1 inwhere=$D2 fd=$D3 insize=$D4 inarg=$D5 }, \
    0x624  { "ipcinfo exit " u_error=$D1 rc=$D2 }, \
    0x625  { "read_from_fd enter " fd=$D1 buf=$D2 nbytes=$D3 }, \
    0x626  { "read_from_fd exit " rc=$D1 }, \
    0x627  { "write_from_fd enter " fd=$D1 buf=$D2 nbytes=$D3 }, \
    0x628  { "write_from_fd exit" rc=$D1 }, \
    0x629  { "ipcinfo_copyout enter" src=$D1 dest=$D2 fd=$D3 size=$D4 }, \
    0x630  { "ipcinfo_copyout exit" rc=$D1 }, \
    0x631  { "ipcinfo_copyin enter" src=$D1 fd=$D2 dest=$D3 size=$D4 }, \
    0x632  { "ipcinfo_copyin exit" rc=$D1 }, \
    0x633  { "check_ipcinfo_permissions enter" cmd=$D1 }, \
    0x634  { "check_ipcinfo_permissions exit" rc=$D1 }, \
    0x635  { "ipcinfo_msg enter" op=$D1 where=$D2 fd=$D3 acopysize=$D4 inarg=$D5 aneeded=$D6 }, \
    0x636  { "ipcinfo_msg exit" rc=$D1 }, \
    0x637  { "ipcinfo_msg_copyin enter" index=$D1 rcvbuff=$D2 fd=$D3 acopysize=$D4 aneeded=$D5 }, \
    0x638  { "ipcinfo_msg_copyin exit" rc=$D1 }, \
    0x639  { "ipcinfo_msg_copyout enter" index=$D1 rcvbuff=$D2 fd=$D3 acopysize=$D4 aneeded=$D5 }, \
    0x640  { "ipcinfo_msg_copyout exit" rc=$D1 }, \
    0x641  { "ipcinfo_msgid_copyin enter" from=$D1 fd=$D2 mykcid=$D3 }, \
    0x642  { "ipcinfo_msgid_copyin exit" rc=$D1 }, \
    0x643  { "ipcinfo_msgid_copyout enter" qp=$D1 iqp=$D2 fd=$D3 msgid=$D4 mykcid=$D5 }, \
    0x644  { "ipcinfo_msgid_copyout exit" rc=$D1 }, \
    0x645  { "ipcinfo_rtmsg enter" op=$D1 where=$D2 fd=$D3 acopysize=$D4 inarg=$D5 aneeded=$D6 }, \
    0x646  { "ipcinfo_rtmsg exit" rc=$D1 }, \
    0x647  { "ipcinfo_rtmsg_copyin enter" where=$D1 fd=$D2 mykcid=$D3 }, \
    0x648  { "ipcinfo_rtmsg_copyin exit" rc=$D1 }, \
    0x649  { "ipcinfo_rtmsg_copyout enter" qp=$D1 iqp=$D2 fd=$D3 mqid=$D4 mykcid=$D5 }, \
    0x650  { "ipcinfo_rtmsg_copyout exit" rc=$D1 }, \
    0x651  { "ipcinfo_rtsem enter" op=$D1 where=$D2 fd=$D3 acopysize=$D4 inarg=$D5 aneeded=$D6 }, \
    0x652  { "ipcinfo_rtsem exit" rc=$D1 }, \
    0x653  { "ipcinfo_rtsem_copyin enter" where=$D1 fd=$D2 mykcid=$D3 }, \
    0x654  { "ipcinfo_rtsem_copyin exit" rc=$D1 }, \
    0x655  { "ipcinfo_rtsem_copyout enter" qp=$D1 iqp=$D2 fd=$D3 semid=$D4 mykcid=$D5 }, \
    0x656  { "ipcinfo_rtsem_copyout exit" rc=$D1 }, \
    0x657  { "ipcinfo_rtshm enter" op=$D1 where=$D2 fd=$D3 acopysize=$D4 inarg=$D5 aneeded=$D6 }, \
    0x658  { "ipcinfo_rtshm exit" rc=$D1 }, \
    0x659  { "ipcinfo_rtshm_copyin enter" where=$D1 fd=$D2 mykcid=$D3 }, \
    0x660  { "ipcinfo_rtshm_copyin exit" rc=$D1 }, \
    0x661  { "ipcinfo_rtsem_copyout enter" qp=$D1 iqp=$D2 fd=$D3 shmid=$D4 mykcid=$D5 }, \
    0x662  { "ipcinfo_rtsem_copyout exit" rc=$D1 }, \
    0x663  { "ipcinfo_sem enter" op=$D1 where=$D2 fd=$D3 acopysize=$D4 inarg=$D5 aneeded=$D6 }, \
    0x664  { "ipcinfo_sem exit" rc=$D1 }, \
    0x665  { "ipcinfo_semundo_copyout enter" src=$D1 dest=$D2 fd=$D3 }, \
    0x666  { "ipcinfo_sem_copyin enter" from=$D1 fd=$D2 mykcid=$D3 }, \
    0x667  { "ipcinfo_sem_copyin exit" rc=$D1 }, \
    0x668  { "ipcinfo_sem_copyout enter" qp=$D1 iqp=$D2 fd=$D3 semid=$D4 mykcid=$D5 }, \
    0x669  { "ipcinfo_sem_copyout exit" rc=$D1 }, \
    0x670  { "ipcinfo_shm enter" op=$D1 where=$D2 fd=$D3 acopysize=$D4 inarg=$D5 aneeded=$D6 }, \
    0x671  { "ipcinfo_shm exit" rc=$D1 }, \
    0x672  { "ipcinfo_shm_copyin enter" where=$D1 fd=$D2 mykcid=$D3 }, \
    0x673  { "ipcinfo_shm_copyin exit" rc=$D1 }, \
    0x674  { "ipcinfo_shm_copyout enter" qp=$D1 iqp=$D2 fd=$D3 shmid=$D4 mykcid=$D5 }, \
    0x675  { "ipcinfo_shm_copyout exit" rc=$D1 }, \
    0x800  { "entr trans_exists" tp=$D1 vsid=$D2 pno=$D3 }, \
    0x801  { "exit trans_exists" rc=$D1%D1 code=$D2%D1 }, \
    0x802  { "entr create_trans_node_list"  }, \
    0x803  { "exit create_trans_node_list" tmp=$D1 code=$D2%D1 }, \
    0x804  { "entr create_trans_table_list_node" kcid=$D1%D1 }, \
    0x805  { "exit create_trans_table_list_node" ptr=$D1 code=$D2%D1 }, \
    0x806  { "entr pmemfs_trans_tbl_add" kcid=$D1 vsid=$D2 pno=$D3 psize=$D4%D1 no4kp=$D5%D1 }, \
    0x807  { "exit pmemfs_trans_tbl_add" rc=$D1 code=$D2%D1 }, \
    0x808  { "entr pmemfs_trans_tbl_del" kcid=$D1 }, \
    0x809  { "exit pmemfs_trans_tbl_del" rc=$D1%D1 code=$D2%D1 }, \
    0x80a  { "entr locate_trans_node" kcid=$D1 offset=$D2}, \
    0x80b  { "exit locate_trans_node" tp=$D1 code=$D2%D1 }, \
    0x80c  { "entr pmemfs_set_sig_hdlr" kcid=$D1 pid=$D2%D1 }, \
    0x80d  { "exit pmemfs_set_sig_hdlr" rc=$D1%D1 code=$D2%D1 }, \
    0x80e  { "entr pmemfs_get_sig_hdlr" kcid=$D1%D1 }, \
    0x80f  { "exit pmemfs_get_sig_hdlr" rc=$D1%D1 code=$D2%D1 pid=$D3%D1 }, \
    0x810  { "entr dep_put_shlib_chkpt_data" kcid=$D1%D1 data=$D2 len=$D3%D1 }, \
    0x811  { "exit dep_put_shlib_chkpt_data" rc=$D1%D1 code=$D2%D1 }, \
    0x812  { "entr dep_get_shlib_chkpt_data" kcid=$D1%D1 len=$D2%D1 }, \
    0x813  { "exit dep_get_shlib_chkpt_data" rc=$D1%D1 code=$D2%D1 data=$D3 len=$D4%D1 }, \
    0x814  { "entr dep_put_exec_chkpt_data" kcid=$D1%D1 p=$D2 data=$D3 len=$D4%D1 }, \
    0x815  { "exit dep_put_exec_chkpt_data" rc=$D1%D1 code=$D2%D1 }, \
    0x816  { "entr dep_get_exec_chkpt_data" kcid=$D1%D1 p=$D2 len=$D3%D1 }, \
    0x817  { "exit dep_get_exec_chkpt_data" rc=$D1%D1 code=$D2%D1 data=$D3 len=$D4 }, \
    0x818  { "entr pmemfs_set_vnode" cid=$D1%D1 vp=$D2 }, \
    0x819  { "exit pmemfs_set_vnode" rc=$D1%D1 code=$D2%D1 }, \
    0x81a  { "entr pmemfs_rootinit" getcaller=$D1 getcaller2=$D2 rc=EINVAL }, \
    0x81b  { "exit pmemfs_init" gfsp=$D1 rc=0}, \
    0x81c  { "entr pmemfs_config" }, \
    0x81d  { "exit pmemfs_config" error=$D1%D1 code=$D2%D1 }, \
    0x81e  { "entr pmemfs_mount" vfsp=$D1 crp=$D2 }, \
    0x81f  { "exit pmemfs_mount" rc=$D1%D1 code=$D2%D1 }, \
    0x820  { "entr pmemfs_unmount" vfsp=$D1 flags=$D2%D1 crp=$D3 }, \
    0x821  { "exit pmemfs_unmount" rc=$D1%D1 code=$D2%D1 }, \
    0x822  { "entr pmemfs_root" vfsp=$D1 vpp=$D2 crp=$D3 rc=0 }, \
    0x823  { "entr pmemfs_statfs" vfsp=$D1 sfsp=$D2 crp=$D3 rc=0}, \
    0x824  { "entr pmemfs_vget" vfsp=$D1 fidp=$D2 crp=$D3 }, \
    0x825  { "exit pmemfs_vget" rc=$D1%D1 vpp=$D2 }, \
    0x826  { "entr pmemfs_sync" gfsp=$D1 rc=ENOSYS }, \
    0x827  { "entr pmemfs_cntl" vfsp=$D1 cmd=$D2%D1 arg=$D3 argsize=$D4%D1 rc=ENOSYS }, \
    0x828  { "entr pmemfs_quotactl" vfsp=$D1 cmd=$D2%D1 uid=$D3 arg=$D4 rc=ENOSYS }, \
    0x829  { "entr pmemfs_nosys" getcaller=$D1 getcaller2=$D2 rc=ENOSYS }, \
    0x82a  { "entr pmemfs_hold" getcaller=$D1 getcaller2=$D2 vp=$D3 v_count=$D4%D1 }, \
    0x82b  { "entr pmemfs_rele" getcaller=$D1 getcaller2=$D2 vp=$D3 v_count=$D4%D1 }, \
    0x82c  { "exit pmemfs_rele" rc=$D1%D1 code=$D2%D1 }, \
    0x82d  { "entr pmemfs_lookup" dvp=$D1 name=$D2 flag=$D3 vattrp=$D4 crp=$D5 }, \
    0x82e  { "exit pmemfs_lookup" rc=$D1%D1 code=$D2%D1 vp=$D3 }, \
    0x82f  { "entr pmemfsaccess" np=$D1 acc=$D2 lock=$D3%D1 cr=$D4 }, \
    0x830  { "exit pmemfsaccess" rc=$D1%D1 code=$D2%D1 }, \
    0x831  { "entr pmemfs_access" vp=$D1 mode=$D2 who=$D3 crp=$D5 }, \
    0x832  { "exit pmemfs_access" rc=$D1%D1 code=$D2%D1 }, \
    0x833  { "entr pmemfs_getattr" vp=$D1 vattrp=$D2 crp=$D3 rc=0 }, \
    0x834  { "entr pmemfs_setattr" vp=$D1 arg1=$D2 arg2=$D2 arg3=$D3 crp=$D4 }, \
    0x835  { "exit pmemfs_setattr" rc=$D1%D1 code=$D2%D1 }, \
    0x836  { "entr exists" dvp=$D1 name=$D2}, \
    0x837  { "exit exists" np=$D1 code=$D2%D1 }, \
    0x838  { "entr pmemfs_create" dvp=$D1 flag=$D2 name=$D3 mode=$D4 vinfop=$D5 }, \
    0x839  { "exit pmemfs_create" rc=$D1%D1 code=$D2%D1 vp=$D3 }, \
    0x83a  { "entr pmemfs_remove" vp=$D1 dvp=$D2 name=$D3 crp=$D4 }, \
    0x83b  { "exit pmemfs_remove" rc=$D1%D1 code=$D2%D1 }, \
    0x83c  { "entr pmemfs_open" vp=$D1 flag=$D2 ext=$D3 vinfop=$D4 crp=$D5 }, \
    0x83d  { "exit pmemfs_open" rc=$D1%D1 code=$D2%D1 }, \
    0x83e  { "entr pmemfs_close" vp=$D1 flag=$D2 vinfop=$D3%D1 crp=$D4 }, \
    0x83f  { "exit pmemfs_close" rc=$D1%D1 code=$D2%D1 }, \
    0x840  { "entr pmemfs_ftrunc" vp=$D1 flag=$D2 length=$D3%D1 vinfo=$D4%D1 crp=$D5 }, \
    0x841  { "exit pmemfs_ftrunc" rc=$D1%D1}, \
    0x842  { "entr pmemfs_rdwr" vp=$D1 op=$D2 flags=$D3 uiop=$D4 }, \
    0x843  { "exit pmemfs_rdwr " rc=$D1%D1 code=$D2%D1 }, \
    0x844  { "entr pmemfs_read" vp=$D1 flags=$D2 uiop=$D3 offset=$D4%D1 resid=$D5 }, \
    0x845  { "exit pmemfs_read" rc=$D1%D1 code=$D2%D1 }, \
    0x846  { "entr pmemfs_fsync" vp=$D1 flag=$D2 flag2=$D3 crp=$D4 rc=0 }, \
    0x847  { "entr pmemfs_fid" vp=$D1 fidp=$D2 crp=$D3 rc=0}, \
    0x848  { "entr pmemfs_finfo" vp=$D1 cmd=$D2 bufp=$D3 length=$D4 crp=$D5 }, \
    0x849  { "exit pmemfs_finfo" rc=$D1%D1 code=$D2%D1 }, \
    0x84a  { "entr pmemfs_readdir" dvp=$D1 uiop=$D2 cr=$D3 }, \
    0x84b  { "exit pmemfs_readdir" rc=$D1%D1 code=$D2%D1 }, \
    0x84c  { "entr pmemfs_ioctl" vp=$D1 cmd=$D2 arg=$D3 flags=$D4 crp=$D5 }, \
    0x84d  { "exit pmemfs_ioctl" rc=$D1%D1 code=$D2%D1 }, \
    0x84e  { "entr pmemfs_mkdir" dvp=$D1 name=$D2 mode=$D3 crp=$D4 }, \
    0x84f  { "exit pmemfs_mkdir" rc=$D1%D1 code=$D2%D1 }, \
    0x850  { "entr pmemfs_rmdir" vp=$D1 dvp=$D2 name=$D3 crp=$D4 }, \
    0x851  { "exit pmemfs_rmdir" rc=$D1%D1 code=$D2%D1 }, \
    0x852  { "entr v_mapi_getkeys_range" sidx=$D1 pstart=$D2 pend=$D3 pno=$D4 }, \
    0x853  { "exit v_mapi_getkeys_range" numpages=$D1 }, \
    0x854  { "entr pollset_putcache" ibuf=$D1 len=$D2%D1 }, \
    0x855  { "exit pollset_putcache" rc=$D1%D1 size=$D2%D1 loc=$D3%D1 }, \
    0x856  { "     pollset_putcache" ps_id=$D1%D1 rc=$D2%D1 loc=$D3%D1 }, \
    0x857  { "     pollset_putcache" ps_id=$D1%D1 max_fd=$D2%D1 fd_cnt=$D3%D1 isize=$D4%D1 }, \
    0x858  { "entr pollset_getcache" ibuf=$D1 len=$D2%D1 }, \
    0x859  { "     pollset_getcache" ps_id=$D1%D1 fd_cnt=$D2%D1 len=$D3%D1 }, \
    0x85a  { "exit pollset_getcache" len=$D1%D1 rc=$D2%D1 }, \
    \* { `unknown subhook id $HD` }
502 1.0 L=SVC "GSC " \
	$D1,                                                       \
		9101 "   enter: request_device_access           ", \
		9102 "          context not on queue            ", \
		9103 "          put context on queue            ", \
		9104 "          inlink priority                 ", \
		9105 "          fault/no access, do not queue   ", \
		9106 "          context already on queue        ", \
		9107 "          upgrade intrpt ctx thrd/fault   ", \
		9108 "          move ctx to front of queue      ", \
		9109 "          no environment upgrade needed   ", \
		910a "          sleep/block/intrpt return       ", \
		910b "          do not wait for access          ", \
		9141 "   exit:  request_device_access           ", \
		9181 "   enter: release_device_access           ", \
		91c1 "   exit:  release_device_access           ", \
		9201 "   enter: dispatch_device                 ", \
		9202 "          queue is empty                  ", \
		9203 "          switching, do not dispatch      ", \
		9204 "          look at first queue entry       ", \
		9205 "          locked by other thrd, no disp   ", \
		9206 "          lck\'d, == tid, ~disp intr req  ", \
		9207 "          cur ctx anti-thrsh ts, no disp  ", \
		9208 "          fdl, intrpt req diff tid, ~disp ", \
		9209 "          commit to dispatch the context  ", \
		920a "          access (lock) context           ", \
		920b "          wake up waiting thread          ", \
		920c "          ownership of device changing    ", \
		920d "          revoke user space access        ", \
		920e "          context switch for same thread  ", \
		920f "          grant user space access         ", \
		9210 "          unblock thread                  ", \
		9211 "          wake up thread                  ", \
		9212 "          remove old context              ", \
		9213 "          revoke user space access        ", \
		9214 "          context activity time           ", \
		9215 "          next device activity time       ", \
		9216 "          remaining unused timeslice      ", \
		9217 "          incr device lock for the switch ", \
		9241 "   exit:  dispatch_device                 ", \
		9301 "   enter: end_dispatch_device             ", \
		9302 "          grant user space access         ", \
		9303 "          unblock thread                  ", \
		9304 "          decr device lock after switch   ", \
		9305 "          wake up thread                  ", \
		9341 "   exit:  end_dispatch_device             ", \
		9781 "enter: timer_expired                      ", \
		9782 "       BUG: timer should not have been on ", \
		9783 "       decr device lock for timer         ", \
		97c1 "exit:  timer_expired                      ", \
		9401 "   enter: enable_user_access              ", \
		9402 "          grant user space access         ", \
		9441 "   exit:  enable_user_access              ", \
		9481 "   enter: disable_user_space              ", \
		9482 "          disable user space access       ", \
		9483 "          revoke user space access        ", \
		94c1 "   exit:  disable_user_space              ", \
		9501 "   enter: read_user_lock                  ", \
		9541 "   exit:  read_user_lock                  ", \
		9581 "   enter: write_user_request              ", \
		95c1 "   exit:  write_user_request              ", \
		9582 "   enter: clear_user_lock                 ", \
		95c2 "   exit:  clear_user_lock                 ", \
		9a01 "          inlink                          ", \
		9a11 "          inlink                          ", \
		9a02 "          queue trace:1                   ", \
		9a12 "          queue trace:2                   ", \
		9a03 "          queue trace:3                   ", \
		9a04 "          device queue entry - tid        ", \
		9a05 "          device queue entry - flags      ", \
		9601 "   enter: start HSC                       ", \
		9641 "   exit:  start HSC                       ", \
		9681 "   enter: stop HSC                        ", \
		9682 "          pend HSC stoppage               ", \
		96c1 "   exit:  stop HSC                        ", \
		9701 "   begin: HSC transaction                 ", \
		9801 "          enqueue to HSC                  ", \
		9901 "   enter: pfrm_switch                     ", \
		9902 "          start_switch completed          ", \
		9903 "<tagss>   start_switch time               ", \
		9904 "          enqueue to HSC                  ", \
		9906 "          perform switch in-line          ", \
		9905 "<tages>   end_switch time                 ", \
		9b01 "   enter: compute_timeslice               ", \
		9b02 "          use fixed timeslice             ", \
		9b03 "          use zero timeslice              ", \
		9b04 "          use fixed leader timeslice      ", \
		9b05 "          swapping context activity       ", \
		9b06 "          nonswapping context activity    ", \
		9b07 "          summing the top swapping values ", \
		9b10 "          total of top swapping values    ", \
		9b11 "          average of top swapping values  ", \
		9b08 "          new expanded bounded timeslice  ", \
		9b09 "          inadequate swap data, fixed ts  ", \
		9b41 "   exit:  compute_timeslice               ", \
		9c01 "   enter: start_timer                     ", \
		9c02 "          zero time slice                 ", \
		9c03 "<tagts>   incr lock and show timeslice    ", \
		9c41 "   exit:  start_timer                     ", \
		9c81 "   enter: kill_timer                      ", \
		9c82 "          decr device lock                ", \
		9cc1 "   exit:  kill_timer                      ", \
		\*   { $D1%XW } \
	$D1%XW $D2%XW $D3%XW $D4%XW $D5%XW
503 1.0 L=SVC "GSC " \
	$D1,                                                       \
		 800 "enter: command_list_service               ", \
		 801 "exit:  command_list_service               ", \
		 810 "enter: do_cmd                             ", \
		a000 "gsctrace                                  ", \
		 799 "enter: dma_free                           ", \
		 749 "enter: dma_end_master                     ", \
		 729 "enter: dma_end_slave                      ", \
		 700 "enter: dma_service                        ", \
		 901 "exit:  gsc_make_gp                        ", \
		 900 "       process structure                  ", \
		 910 "enter: rcm_unmake_gp                      ", \
		 911 "exit:  rcm_unmake_gp                      ", \
		 902 "enter: gp_make_kpproc                     ", \
		 903 "enter: gp_unmake_kpproc                   ", \
		 920 "enter: gp_state_change                    ", \
		 921 "       found graphics proc                ", \
		 603 "dev_init: domain_acc_authority_init rc    ", \
		 280 "enter: gsc_lock_hw                        ", \
		 289 "exit:  gsc_lock_hw                        ", \
		 290 "enter: gsc_unlock_hw                      ", \
		 299 "exit:  gsc_unlock_hw                      ", \
		 240 "enter: gsc_lock_domain                    ", \
		 241 "enter: gsc_unlock_domain                  ", \
		 261 "enter: gsc_give_up_timeslice              ", \
		 220 "enter: rcm_lock_hw                        ", \
		 229 "exit:  rcm_lock_hw                        ", \
		 230 "enter: rcm_unlock_hw                      ", \
		 239 "exit:  rcm_unlock_hw                      ", \
		 300 "gsc_create_rcx: prcx                      ", \
		 310 "gsc_delete_rcx: rcx and flags             ", \
		 320 "gsc_bind_window: rcx and wg               ", \
		 330 "gsc_set_rcx: prcx                         ", \
		 350 "gsc_create_rcxp or make_cur_and_guard_dom ", \
		 340 "enter: rcm_delete_rcx                     ", \
		 360 "enter: rcm_delete_rcxp                    ", \
		 100 "gp_fault: tid, pdom, pproc                ", \
		 101 "gp_fault: except [0], [1], [3]            ", \
		 180 "enter: gp_block_gp                        ", \
		 190 "enter: gp_unblock_gp                      ", \
		 400 "gsc_create_win_geom: pwg                  ", \
		 410 "gsc_delete_win_geom: pwg                  ", \
		 420 "gsc_update_win_geom: pwg                  ", \
		 430 "gsc_create_win_attr: pwa                  ", \
		 440 "gsc_delete_win_attr: pwa                  ", \
		 450 "gsc_update_win_attr: pwa                  ", \
		 600 "domain_acc_authority_init: key, pcproc    ", \
		 601 "put_busmem_keys: key, pdev                ", \
		 602 "put_busmem_keys: release database         ", \
		 c00 "rcmioctl: GRAPHICS_INIT_ENDS              ", \
		 c01 "          server not registered           ", \
		 c02 "          init complete                   ", \
		 c03 "          wake up sleepers                ", \
		 c04 "          done                            ", \
		 c05 "rcmioctl: GRAPHICS_DATA_SAVED             ", \
		 c06 "          pm_status flags                 ", \
		 c07 "          turn off watchdog               ", \
		 c08 "          done, returning                 ", \
		 c09 "rcmioctl: GRAPHICS_SAVE_FAILED            ", \
		 c0a "          pm_status flags                 ", \
		 c0b "          done                            ", \
		 c0c "rcmioctl: GRAPHICS_QUERY_PM_STATUS        ", \
		 c0d "          rcm_copyout rc                  ", \
		 c0e "          done                            ", \
		 a00 "enter: quiesce_graphics_IO                ", \
		 a01 "       no servers initializing            ", \
		 a02 "       server(s) initializing, sleep      ", \
		 a03 "quiesce_graphics_IO: woken up             ", \
		 a0a "       signal X to quiesce failed         ", \
		 a80 "exit:  quiesce_graphics_IO                ", \
		 a04 "enter: signal_X_to_quiesce_dsp_devices    ", \
		 a05 "       sent signal, sleeping              ", \
		 a06 "signal_X: woken up                        ", \
		 a07 "       killing X, then sleeping           ", \
		 a08 "signal_X: woken up                        ", \
		 a09 "exit:  signal_X_to_quiesce_dsp_devices    ", \
		 b00 "enter: unblock_graphics_IO                ", \
		 b01 "       wakeup server                      ", \
		 b80 "exit:  signal_X_to_quiesce_dsp_devices    ", \
		 d00 "enter: rcm_pm_handler                     ", \
		 d01 "exit:  rcm_pm_handler                     ", \
		9001 "enter: rcmker_create_rcm                  ", \
		9041 "exit:  rcmker_create_rcm                  ", \
		9081 "enter: rcmker_delete_rcm                  ", \
		90c1 "exit:  rcmker_delete_rcm                  ", \
		9002 "enter: rcmker_create_device               ", \
		9042 "exit:  rcmker_create_device               ", \
		9082 "enter: rcmker_delete_device               ", \
		90c2 "exit:  rcmker_delete_device               ", \
		9003 "enter: rcmker_create_client               ", \
		9043 "exit:  rcmker_create_client               ", \
		9083 "enter: rcmker_delete_client               ", \
		90c3 "exit:  rcmker_delete_client               ", \
		9004 "enter: rcmker_create_context              ", \
		9044 "exit:  rcmker_create_context              ", \
		9084 "enter: rcmker_delete_context              ", \
		90c4 "exit:  rcmker_delete_context              ", \
		9005 "enter: rcmker_set_context_priority        ", \
		9045 "exit:  rcmker_set_context_priority        ", \
		9006 "enter: rcmker_activate_context            ", \
		9046 "exit:  rcmker_activate_context            ", \
		9007 "enter: rcmker_enable_user_access          ", \
		9047 "exit:  rcmker_enable_user_access          ", \
		9087 "enter: rcmker_disable_user_access         ", \
		90c7 "exit:  rcmker_disable_user_access         ", \
		9008 "enter: rcmker_enable_device_dispatching   ", \
		9048 "exit:  rcmker_enable_device_dispatching   ", \
		9088 "enter: rcmker_disable_device_dispatching  ", \
		90c8 "exit:  rcmker_disable_device_dispatching  ", \
		9009 "enter: rcmker_control_timeslice           ", \
		9049 "exit:  rcmker_control_timeslice           ", \
		900d "enter: rcmker_resume_dispatching          ", \
		904d "exit:  rcmker_resume_dispatching          ", \
		900a "enter: rcmker_query_device_context        ", \
		904a "exit:  rcmker_query_device_context        ", \
		900b "enter: rcmker_query_current_user_lock     ", \
		904b "exit:  rcmker_query_current_user_lock     ", \
		9010 "enter: rcmker_query_domain_lock           ", \
		9050 "exit:  rcmker_query_domain_lock           ", \
		900c "enter: rcmker_set_timeslice               ", \
		904c "exit:  rcmker_set_timeslice               ", \
		900e "enter: rcmker_set_min_activity            ", \
		904e "exit:  rcmker_set_min_activity            ", \
		900f "enter: rcmker_force_heavy_switch          ", \
		904f "exit:  rcmker_force_heavy_switch          ", \
		\*   { $D1%XW } \
	$D1%XW $D2%XW $D3%XW $D4%XW $D5%XW
526 1.0 L=KERN "@ POLLCACHE SERVICES" "POLLCACHE " \
	$HD, \
	0x01 {  PC_PENDING: pcache:$D1 pccb:$D2 rtnevents:$D3 }, \
	0x02 {  PC_REMOVE_PEND: pcache:$D1 pccb:$D2 state:$D3 }, \
	0x03 {  PC_PUSH_PEND: pcache:$D1 in:$D2 out:$D3 }, \
	0x04 {  `PC_TIME_OUT: pcache:$D1 trb:$D2 tid:`prKernelTID($D3) }, \
	0x05 {  PC_WAIT_START: pcache:$D1 }, \
	0x06 {  PC_WAIT_STOP: pcache:$D1 sleep_rc:$D2 }, \
	0x07 {  PC_CLEANUP_FD: pcache:$D1 fd:$D2 cmd:$D3 }, \
	0x08 {  PC_POLL: pcache:$D1 timeout:$D2  }, \
	0x09 {  PC_CLOSE: fd:$D1 }, \
	0x0a {  PC_REGISTER: pcache:$D1 }, \
	0x0b {  PC_UNREGISTER: pcache:$D1 }, \
	0x0c {  PC_INIT: pcache:$D1 id:$D2 }, \
	0x0d {  PC_RELEASE: pcache:$D1 count:$D2 }, \
	0x0e {  PC_CACHE_ADD: pcache:$D1 fd:$D2 reqevents:$D3 }, \
	0x0f {  PC_CLEANUP: pcache:$D1 }, \
	0x10 {  PC_DEQUEUE_PEND: pcache:$D1 out:$D2 }, \
	0x11 {  PC_ENQUEUE_PEND: pcache:$D1 out:$D2 in:$D3 }, \
	0x12 {  PC_WAIT2_START: pcache:$D1 timeout:$D2 }, \
	0x13 {  PC_WAIT2_STOP: pcache:$D1 sleep_rc:$D2 }, \
	\*  { `unknown subhook` }
527 1.0 " UDI MANAGEMENT AGENT"  \
     G8.0 $HL%S1
528 1.0 " UDI SCSI MAPPER"  \
     G8.0 $HL%S1
529 1.0 " UDI BRIDGE MAPPER"  \
     G8.0 $HL%S1
52A 1.0 " UDI NETMAPPER ("$HD"): " W2 A4.4 W1 A4.4 W3 XW XW
52B 1.0 " UDI GIO MAPPER"  \
     G8.0 $HL%S1
52C 1.0 " UDI NETWORK DRIVER"  \
     G8.0 $HL%S1
52D 1.0 " UDI SCSI DRIVER"  \
     G8.0 $HL%S1
52F 1.0 L=APPL "SEC CRED:" \
	$HD%D1, \
	10300 { `crget  callfrom=$D1%XW callfrom2=$D2%XW pid=$D3%D1 ($D3%PW)` }, \
	10301 { `crfree  callfrom=$D1%XW callfrom2=$D2%XW pid=$D3%D1 ($D3%PW)` }, \
	10302 { `crdup  callfrom=$D1%XW callfrom2=$D2%XW pid=$D3%D1 ($D3%PW)` }, \
	10303 { `crhold  callfrom=$D1%XW callfrom2=$D2%XW pid=$D3%D1 ($D3%PW)` }, \
	10304 { `crref  callfrom=$D1%XW callfrom2=$D2%XW pid=$D3%D1 ($D3%PW)` }, \
	10305 { `crcopy  callfrom=$D1%XW callfrom2=$D2%XW pid=$D3%D1 ($D3%PW)` }, \
	\* {  unknown subhook $HD $ERROR }
535 1.0 'TCP' \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
	1   { `isprivport port=$D1%XW return value = $D2%DW` }, \
	2   { `reroute inp=$D1%XW newrt=$D2%XW` }, \
	3   { `splice_forward tp1=$D1%XW datarcvd=$D2%XW` }, \
	4   { `return from splice_forward tp1=$D1%XW error=$D2%DW` }, \
	5   { `tcp_SACKFastRecovery tp=$D1%XW` }, \
	6   { `tcp_UpSACKInfo tp=$D1%XW HolesBlocks=$D2%XW` }, \
	7   { `return from tcp_UpSACKInfo tp=$D1%XW return value=$D2%DW` }, \
	8   { `tcp_achalloc ach=$D1%XW` }, \
	9   { `tcp_achfree ach=$D1%XW ach->refs=$D2%XW` }, \
	10   { `return from tcp_achref port=$D1%XW ach=$D2%XW ach->refs=$D3%XW` }, \
	11   { `return from tcp_achset port=$D1%XW ach=$D2%XW tmp=$D3%XW` }, \
	12   { `tcp_acladd tcpdac=$D1%XW tcpdac->port=$D2%XW` }, \
	13   { `return from tcp_acladd tcpdac=$D1%XW rc=$D2%XW` }, \
	14   { `tcp_aclbind port=$D1%XW inp=$D2%XW` }, \
	15   { `tcp_aclclear_nolock port=$D1%XW` }, \
	16   { `tcp_acldel dac=$D1%XW dac->port=$D2%XW` }, \
	17   { `return from tcp_acldel dac=$D1%XW rc=$D2%XW` }, \
	18   { `tcp_aclflush` }, \
	19   { `tcp_aclls port=$D1%XW m=$D2%XW` }, \
	20   { `return from tcp_aclls rc=$D1%XW` }, \
	21   { `tcp_adjust_buffers tp=$D1%XW` }, \
	22   { `return from tcp_adjust_buffers` }, \
	23   { `tcp_attach so=$D1%XW` }, \
	24   { `return from tcp_attach so=$D1%XW error=$D2%XW` }, \
	25   { `tcp_auth0 flags=$D1%XW uid=$D2%XW gid=$D3%XW inp=$D4%XW` }, \
	26   { `return from tcp_auth0_out1 ach=$D1%XW lport=$D2%XW` }, \
	27   { `return from tcp_auth0_out2 lport=$D1%XW rc=$D2%XW` }, \
	28   { `tcp_auth tcp_opts=$D1%XW inp=$D2%XW found=$D3%XW` }, \
	29   { `return from tcp_auth_out1 tcp_opts=$D1%XW flags=$D2%XW uid=$D3%XW gid=$D4%XW` }, \
	30   { `return from tcp_auth_out2 flags=$D1%XW uid=$D2%XW gid=$D3%XW lport=$D4%XW` }, \
	31   { `tcp_build_sacks_err error=$D1%XW` }, \
	32   { `tcp_build_sacks tp=$D1%XW ti=$D2%XW` }, \
	33   { `return from tcp_build_sacks` }, \
	34   { `tcp_canceltimers` }, \
	35   { `tcp_close tp=$D1%XW tp->t_state=$D2%XW inp=$D3%XW so=$D4%XW` }, \
	36   { `tcp_close` }, \
	37   { `tcp_ctlinput cmd=$D1%XW sa=$D2%XW ip=$D3%XW` }, \
	38   { `return from tcp_ctlinput` }, \
	39   { `tcp_ctloutput op=$D1%XW so=$D2%XW level=$D3%XW optname=$D4%XW` }, \
	40   { `return from tcp_ctloutput so=$D1%XW error=$D2%DW` }, \
	41   { `tcp_delayack_set value=$D1%XW nop=$D2%XW` }, \
	42   { `return from tcp_delayack_set return value=$D1%XW` }, \
	43   { `tcp_disconnect tp=$D1%XW so=$D2%XW tp->t_state=$D3%XW` }, \
	44   { `return from tcp_disconnect tp=$D1%XW` }, \
	45   { `tcp_dooptions tp=$D1%XW om=$D2%XW ti=$D3%XW tcp_opts=$D4%XW` }, \
	46   { `return from tcp_dooptions tp=$D1%XW opt=$D2%XW` }, \
	47   { `tcp_drop tp=$D1%XW tp->t_state=$D2%XW errno=$D3%XW` }, \
	48   { `tcp_ephemeral_high_change newvalp=$D1%XW nop=$D2%XW value=$D3%XW` }, \
	49   { `return from tcp_ephemeral_high_change tcp_ephemeral_low=$D1%XW value=$D2%XW error=$D3%XW` }, \
	50   { `tcp_ephemeral_low_change newvalp=$D1%XW nop=$D2%XW value=$D3%XW` }, \
	51   { `return from tcp_ephemeral_low_change tcp_ephemeral_high=$D1%XW value=$D2%XW error=$D3%XW` }, \
	52   { `tcp_fasttimo` }, \
	53   { `return from tcp_fasttimo` }, \
	54   { `tcp_init` }, \
	55   { `return from tcp_init` }, \
	56   { `tcp_input0 *mp=$D1%XW *opts=$D2%XW llhdr=$D3%XW *ipsecgoo=$D4%XW` }, \
	57   { `return from tcp_input0_out1 *mp=$D1%XW return value=$D2%XW` }, \
	58   { `return from tcp_input0_out2 *mp=$D1%XW return value=$D2%XW` }, \
	59   { `return from tcp_input0_out3 *mp=$D1%XW return value=$D2%XW` }, \
	60   { `return from tcp_input0_out4 *mp=$D1%XW return value=$D2%XW` }, \
	61   { `return from tcp_input0_out5 *mp=$D1%XW return value=$D2%XW` }, \
	62   { `return from tcp_input0_out6 *mp=$D1%XW return value=$D2%XW` }, \
	63   { `return from tcp_input0_out7 *mp=$D1%XW return value=$D2%XW` }, \
	64   { `return from tcp_input0_out8 *mp=$D1%XW return value=$D2%XW` }, \
	65   { `return from tcp_input0_out9 *mp=$D1%XW return value=$D2%XW` }, \
	66   { `tcp_input m=$D1%XW iphlen=$D2%XW` }, \
	67   { `return from tcp_input m=$D1%XW opts=$D2%XW ipsecgoo=$D3%XW` }, \
	68   { `tcp_lspriv m=$D1%XW` }, \
	69   { `return from tcp_lspriv m=$D1%XW error=$D2%XW` }, \
	70   { `tcp_map_pseg m=$D1%XW` }, \
	71   { `return from tcp_map_pseg return value=$D1%XW` }, \
	72   { `tcp_mss tp=$D1%XW offer=$D2%XW` }, \
	73   { `return from tcp_mss tp=$D1%XW mss=$D2%XW` }, \
	74   { `tcp_newtcpcb inp=$D1%XW` }, \
	75   { `return from tcp_newtcpcb inp=$D1%XW return value=$D2%XW` }, \
	76   { `tcp_notify inp=$D1%XW tp=$D2%XW so=$D3%XW error=$D4%XW` }, \
	77   { `return from tcp_notify inp=$D1%XW tp=$D2%XW tp->t_state=$D3%XW error=$D4%XW` }, \
	78   { `tcp_output tp=$D1%XW so=$D2%XW` }, \
	79   { `return from tcp_output tp=$D1%XW so=$D2%XW error=$D3%XW` }, \
	80   { `tcp_pmtuchange inp=$D1%XW tp=$D2%XW` }, \
	81   { `tcp_process_sackopt tp=$D1%XW cp=$D2%XW ti=$D3%XW` }, \
	82   { `return from tcp_process_sackopt_out1 tp=$D1%XW Count=$D2%XW` }, \
	83   { `return from tcp_process_sackopt_out2 tp=$D1%XW` }, \
	84   { `tcp_pulloutofband so=$D1%XW ti=$D2%XW m=$D3%XW` }, \
	85   { `return from tcp_pulloutofband so=$D1%XW tp=$D2%XW` }, \
	86   { `tcp_quench inp=$D1%XW tp=$D2%XW` }, \
	87   { `tcp_reass tp=$D1%XW` }, \
	88   { `return from tcp_reass_out1 tp=$D1%XW` }, \
	89   { `return from tcp_reass_out2 tp=$D1%XW` }, \
	90   { `return from tcp_reass_out3 tp=$D1%XW` }, \
	91   { `return from tcp_reass_out4 tp=$D1%XW` }, \
	92   { `return from tcp_reass_out5 tp=$D1%XW flags=$D2%XW` }, \
	93   { `tcp_resend inp=$D1%XW tp=$D2%XW` }, \
	94   { `return from tcp_resend inp=$D1%XW tp=$D2%XW` }, \
	95   { `return from tcp_resprst_err tp=$D1%XW` }, \
	96   { `tcp_resprst tp=$D1%XW ti=$D2%XW m=$D3%XW seq=$D4%XW` }, \
	97   { `return from tcp_resprst tp=$D1%XW` }, \
	98   { `return from tcp_send_and_disconnect_err so=$D1%XW tp=$D2%XW *errorp=$D3%XW` }, \
	99   { `tcp_send_and_disconnect so=$D1%XW tp=$D2%XW tp->t_state=$D3%XW m=$D4%XW` }, \
	100   { `return from tcp_send_and_disconnect so=$D1%XW tp=$D2%XW` }, \
	101   { `return from tcp_send_and_kern_disconnect_err so=$D1%XW tp=$D2%XW *errorp=$D3%XW` }, \
	102   { `tcp_send_and_kern_disconnect so=$D1%XW tp=$D2%XW tp->t_state=$D3%XW m=$D4%XW` }, \
	103   { `return from tcp_send_and_kern_disconnect so=$D1%XW tp=$D2%XW` }, \
	104   { `tcp_sendkeep_err tp=$D1%XW` }, \
	105   { `tcp_sendkeep tp=$D1%XW ack=$D2%XW seq=$D3%XW` }, \
	106   { `return from tcp_sendkeep tp=$D1%XW` }, \
	107   { `tcp_setmss tp=$D1%XW` }, \
	108   { `return from tcp_setmss tp=$D1%XW rt=$D2%XW` }, \
	109   { `tcp_setpersist tp=$D1%XW` }, \
	110   { `return from tcp_setpersist tp=$D1%XW` }, \
	111   { `tcp_setpriv port=$D1%XW` }, \
	112   { `return from tcp_setpriv port=$D1%XW error=$D2%XW` }, \
	113   { `tcp_slowtimo` }, \
	114   { `return from tcp_slowtimo` }, \
	115   { `tcp_splice so1=$D1%XW so2=$D2%XW flags=$D3%XW` }, \
	116   { `return from tcp_splice error=$D1%XW` }, \
	117   { `tcp_template tp=$D1%XW inp=$D2%XW` }, \
	118   { `tcp_time_wait_timer first=$D1%XW last=$D2%XW` }, \
	119   { `return from tcp_time_wait_timer first=$D1%XW last=$D2%XW` }, \
	120   { `tcp_timer_init` }, \
	121   { `tcp_timers tp=$D1%XW timer=$D2%XW` }, \
	122   { `return from tcp_timers tp=$D1%XW` }, \
	123   { `tcp_unsetpriv port=$D1%XW` }, \
	124   { `return from tcp_unsetpriv port=$D1%XW error=$D2%XW` }, \
	125   { `tcp_update_sacks tp=$D1%XW` }, \
	126   { `return from tcp_update_sacks tp=$D1%XW` }, \
	127   { `tcp_usrclosed tp=$D1%XW tp->t_state=$D2%XW` }, \
	128   { `return from tcp_usrclosed tp=$D1%XW` }, \
	129   { `tcp_usrreq_err so=$D1%XW error=$D2%XW` }, \
	130   { `tcp_usrreq so=$D1%XW req=$D2%XW m=$D3%XW nam=$D4%XW` }, \
	131   { `return from tcp_usrreq so=$D1%XW req=$D2%XW` }, \
	132   { `tcp_xmit_timer tp=$D1%XW rtt=$D2%XW` }, \
	133   { `return from tcp_xmit_timer tp=$D1%XW srtt=$D2%XW` }, \
	134   { `tcp_UpSACKInfo out1 tp=$D1%XW return=$D2%DW` }, \
	136   { `tcp_build_sacks out1` }, \
	137   { `tcp_build_sacks out2` }, \
	138   { `tcp_build_sacks out3` }, \
	139   { `tcp_build_sacks out4` }, \
	140   { `tcp_input0_out10 tp=$D1%XW` }, \
	141   { `tcp_input0_out11 tp=$D1%XW` }, \
	142   { `tcp_input0_out12 tp=$D1%XW` }, \
	143   { `tcp_input0_out13 tp=$D1%XW` }, \
	144   { `tcp_input0_out14 m=$D1%XW` }, \
	145   { `tcp_input0_out15 m=$D1%XW` }, \
	146   { `tcp_input0_out16 m=$D1%XW` }, \
	147   { `tcp_input0_out17 m=$D1%XW` }, \
	148   { `tcp_input0_out18 tp=$D1%XW` }, \
	149   { `tcp_input0_out19 tp=$D1%XW` }, \
	150   { `tcp_input0_out20 tp=$D1%XW` }, \
	151   { `tcp_input0_out21 tp=$D1%XW` }, \
	152   { `tcp_input0_out22 tp=$D1%XW` }, \
	153   { `tcp_input0_out23 tp=$D1%XW` }, \
	154   { `tcp_input0_out24 tp=$D1%XW` }, \
	155   { `tcp_input0_out25 tp=$D1%XW` }, \
	156   { `tcp_input0_out26 tp=$D1%XW` }, \
	157   { `tcp_input0_out27 tp=$D1%XW` }, \
	158   { `tcp_input0_out28 so=$D1%XW` }, \
	159   { `tcp_input0_out29 tp=$D1%XW` }, \
	160   { `tcp_input0_out30 tp=$D1%XW` }, \
	161   { `tcp_input0_out31 tp=$D1%XW` }, \
	162   { `tcp_input0_out32 tp=$D1%XW` }, \
	163   { `tcp_input0_out33 tp=$D1%XW` }, \
	164   { `tcp_input0_out34 tp=$D1%XW` }, \
	165   { `tcp_input0_out35 tp=$D1%XW` }, \
	166   { `tcp_input0_out36 tp=$D1%XW` }, \
	167   { `tcp_input0_out37 tp=$D1%XW` }, \
	168   { `tcp_input0_out38 tp=$D1%XW` }, \
	169   { `tcp_input0_out39 tp=$D1%XW` }, \
	170   { `tcp_input0_out40 tp=$D1%XW` }, \
	171   { `tcp_input0_out41 tp=$D1%XW` }, \
	172   { `tcp_input0_out42 tp=$D1%XW` }, \
	173   { `tcp_input0_out43 tp=$D1%XW` }, \
	174   { `tcp_input0_out44 tp=$D1%XW` }, \
	175   { `tcp_input0_out45 tp=$D1%XW` }, \
	176   { `tcp_input0_out46 tp=$D1%XW` }, \
	177   { `tcp_input0_out47 tp=$D1%XW` }, \
	178   { `tcp_input0_out48 tp=$D1%XW` }, \
	179   { `tcp_input0_out49 tp=$D1%XW` }, \
	180   { `tcp_input0_out50 tp=$D1%XW` }, \
	181   { `tcp_input0_out51 tp=$D1%XW` }, \
	182   { `tcp_input0_out52 tp=$D1%XW` }, \
	183   { `tcp_input0_out53 tp=$D1%XW` }, \
	184   { `tcp_input0_out54 tp=$D1%XW` }, \
	185   { `tcp_input0_out55 tp=$D1%XW` }, \
	186   { `tcp_input0_out56 tp=$D1%XW` }, \
	187   { `tcp_input0_out57 tp=$D1%XW` }, \
	188   { `tcp_input0_win1 tp=$D1%XW rcv_wnd=$D2%DW` }, \
	191   { `tcp_process_sackopt_out3 tp=$D1%XW count=$D2%DW` }, \
	192   { `tcp_process_sackopt_out4 tp=$D1%XW count=$D2%DW` }, \
	193   { `tcp_auth out3 flags=$D1%XW uid=$D2%DW gid=$D3%DW lport=$D4%DW rc=$D5%DW` }, \
	194   { `tcp_mss out1 tp=$D1%XW tcp_mssdflt=$D2%DW` }, \
	195   { `tcp_setmss out1 tp=$D1%XW rt=$D2%XW` }, \
	197   { `tcp_map_pseg out1 return=$D1%DW` }, \
	198   { `tcp_output_sack_enabled1 tp=$D1%XW` }, \
	199   { `tcp_output_sack_enabled2 tp=$D1%XW` }, \
	203   { `tcp_output_update_lowat tp=$D1%XW so=$D2%XW hiwat=$D3%DW lowat=$D4%DW` }, \
	204   { `tcp_output out1 tp=$D1%XW so=$D2%XW return=$D3%DW` }, \
	205   { `tcp_output out2 tp=$D1%XW error=$D2%DW` }, \
	206   { `tcp_output out3 tp=$D1%XW so=$D2%XW error=$D3%DW` }, \
	207   { `tcp_output out4 tp=$D1%XW` }, \
	208   { `tcp_output out5 tp=$D1%XW error=$D2%DW` }, \
	209   { `tcp_output out6 tp=$D1%XW error=$D2%DW` }, \
	210   { `tcp_output out7 tp=$D1%XW error=$D2%DW` }, \
	211   { `tcp_output out8 tp=$D1%XW error=$D2%DW` }, \
	212   { `tcp_output out9 tp=$D1%XW error=$D2%DW` }, \
	213   { `tcp_output out10 tp=$D1%XW so=$D2%XW error=$D3%DW` }, \
	214   { `tcp_output out11 tp=$D1%XW so=$D2%XW error=$D3%DW` }, \
	215   { `tcp_output out12 tp=$D1%XW` }, \
	217   { `tcp_newtcpcb out1 inp=$D1%XW ret=$D2%DW` }, \
	218   { `tcp_notify out1 inp=$D1%XW tp=$D2%XW tp_state=$D3%XW error=$D4%DW` }, \
	220   { `tcp_ctlinput out1` }, \
	221   { `tcp_ctlinput out2` }, \
	222   { `tcp_ctlinput out3` }, \
	223   { `tcp_delayack_set out1 ret=$D1%DW` }, \
	224   { `tcp_delayack_set out2 error=$D1%DW` }, \
	225   { `tcp_delayack_set out3 error=$D1%DW` }, \
	226   { `tcp_delayack_set out4 error=$D1%DW` }, \
	227   { `tcp_timers out1 tp=$D1%XW` }, \
	228   { `tcp_usrreq error1 so=$D1%XW error=$D2%DW` }, \
	229   { `tcp_usrreq error2 so=$D1%XW error=$D2%DW` }, \
	230   { `tcp_usrreq error3 so=$D1%XW error=$D2%DW` }, \
	231   { `tcp_usrreq error4 so=$D1%XW error=$D2%DW` }, \
	232   { `tcp_usrreq error5 so=$D1%XW error=$D2%DW` }, \
	233   { `tcp_usrreq out1 so=$D1%XW req=$D2%DW` }, \
	234   { `tcp_usrreq out2 so=$D1%XW error=$D2%DW` }, \
	235   { `tcp_usrreq out3 so=$D1%XW error=$D2%DW` }, \
	236   { `tcp_usrreq out4 so=$D1%XW error=$D2%DW` }, \
	237   { `tcp_usrreq out5 so=$D1%XW error=$D2%DW` }, \
	238   { `tcp_usrreq out6 so=$D1%XW req=$D2%DW` }, \
	239   { `tcp_usrreq out7 so=$D1%XW error=$D2%DW` }, \
	240   { `tcp_usrreq out8 so=$D1%XW error=$D2%DW` }, \
	241   { `tcp_usrreq out9 so=$D1%XW error=$D2%DW` }, \
	242   { `tcp_usrreq out10 so=$D1%XW error=$D2%DW` }, \
	243   { `tcp_usrreq error6 so=$D1%XW error=$D2%DW` }, \
	244   { `tcp_acladd out1 tcpdac=$D1%XW rc=$D2%DW` }, \
	245   { `tcp_acladd out2 tcpdac=$D1%XW rc=$D2%DW` }, \
	246   { `tcp_acladd out3 tcpdac=$D1%XW rc=$D2%DW` }, \
	247   { `tcp_acladd out4 tcpdac=$D1%XW rc=$D2%DW` }, \
	248   { `tcp_acldel out1 dac=$D1%XW rc=$D2%DW` }, \
	249   { `tcp_acldel out2 dac=$D1%XW rc=$D2%DW` }, \
	250   { `tcp_acldel out3 dac=$D1%XW rc=$D2%DW` }, \
	251   { `tcp_aclls out1 m=$D1%XW port=$D2%DW rc=$D3%DW` }, \
	252   { `tcp_aclls out2 m=$D1%XW port=$D2%DW rc=$D3%DW` }, \
	253   { `tcp_aclls out3 m=$D1%XW port=$D2%DW rc=$D3%DW` }, \
	254   { `tcp_lspriv out1 m=$D1%XW error=$D1%DW` }, \
	255   { `tcp_ctloutput error op=$D1%DW optname=$D2%XW so=$D3%XW error=$D4%DW error=$D5%DW` }, \
	256   { `tcp_attach out1 so=$D1%XW error=$D2%DW` }, \
	257   { `tcp_attach out2 so=$D1%XW error=$D2%DW` }, \
	258   { `tcp_attach out3 so=$D1%XW error=$D2%DW` }, \
	259   { `tcp_splice out1 error=$D1%DW` }, \
	260   { `tcp_splice out2 error=$D1%DW` }, \
	261   { `tcp_reroute out inp=$D1%XW` }, \
	262   { `tcp_UpSACKInfo out2 tp=$D1%XW rc=$D2%DW` }, \
	263   { `tcp_reass out m=$D1%XW` }, \
	264   { `tcp_input0 out58 tp=$D1%XW` }, \
	265   { `tcp_output out13 tp=$D1%XW so=$D2%XW rc=$D3%DW` }, \
	266   { `tcp_output out14 tp=$D1%XW so=$D2%XW error=$D3%DW` }, \
	267   { `tcp_output out15 tp=$D1%XW so=$D2%XW error=$D3%DW` }, \
	268   { `tcp_output pmtu_alloc_fail tp=$D1%XW so=$D2%XW error=$D3%DW` }, \
	269   { `tcp_output error7 so=$D1%XW error=$D2%DW` }, \
	270   { `tcp_output error8 so=$D1%XW error=$D2%DW` }, \
	271   { `tcp_output error9 so=$D1%XW error=$D2%DW` }, \
	272   { `tcp_output error10 so=$D1%XW error=$D2%DW` }, \
	273   { `tcp_output error11 so=$D1%XW error=$D2%DW` }, \
	274   { `tcp_output error12 so=$D1%XW error=$D2%DW` }, \
	275   { `tcp_output error13 so=$D1%XW error=$D2%DW` }, \
	276   { `tcp_output error14 so=$D1%XW error=$D2%DW` }, \
	277   { `tcp_output error15 so=$D1%XW error=$D2%DW` }, \
	278   { `tcp_output error16 so=$D1%XW error=$D2%DW` }, \
	279   { `tcp_output error17 so=$D1%XW error=$D2%DW` }, \
	280   { `tcp_output pru abort so=$D1%XW tp=$D2%XW` }, \
	297   { `tcp_disconnect_out error=$D1%XW` }, \
	298   { `fastlo waitconn add so=$D1%XW` }, \
	299   { `fastlo waitconn rem so=$D1%XW` }, \
	300   { `fastlo waitconn drop so=$D1%XW` }, \
	301   { `fastlo lookup so=$D1%XW so2=$D2%XW` }, \
	302   { `fastlo setup so=$D1%XW so2=$D2%XW lport=$D3%DW fport=$D4%DW`},\
	303   { `fastlo setup out1 so=$D1%XW so2=$D2%XW` }, \
	304   { `fastlo setup out2 so=$D1%XW so2=$D2%XW` }, \
	305   { `fastlo setup out3 so=$D1%XW so2=$D2%XW` }, \
	306   { `fastlo setup out4 so=$D1%XW so2=$D2%XW` }, \
	307   { `fastlo setup out5 so=$D1%XW so2=$D2%XW error=$D3%DW` }, \
	308   { `fastlo send so=$D1%XW so2=$D2%XW` }, \
	309   { `fastlo rcvd so=$D1%XW so2=$D2%XW` }, \
	311   { `fastlo trace so=$D1%XW so2=$D2%XW output=$D3%DW if=$D4%DW input=$D5%DW` }, \
	312   { `fastlo terminate so=$D1%XW so2=$D2%XW` }, \
	313   { `fastlo iseligible so=$D1%XW rc=$D2%DW` }, \
	314   { `fastlo controlflow so=$D1%XW so2=$D2%XW op=$D3%DW hiwat=$D4%XW mbmax=$D5%XW` }, \
 	\* { unknown subhook $HD $ERROR }
536 1.0 'UDP' \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
	1   { `delay_sbdroprecord sb=$D1%XW freehead=$D2%XW` }, \
	2   { `udp_cksum_and_move m=$D1%XW uio=$D2%XW hdrsum=$D3%XW so=$D4%XW` }, \
	3   { `udp_cksum_and_move m=$D1%XW sum=$D2%XW error=$D3%XW` }, \
	4   { `udp_ctlinput cmd=$D1%XW sa=$D2%XW ip=$D3%XW` }, \
	5   { `udp_ctlinput cmd=$D1%XW` }, \
	6   { `udp_ephemeral_high_change newvalp=$D1%XW nop=$D2%XW value=$D3%XW` }, \
	7   { `udp_ephemeral_low_change newvalp=$D1%XW nop=$D2%XW value=$D3%XW` }, \
	8   { `udp_findmac m=$D1%XW ip=$D2%XW llhdr=$D3%XW` }, \
	9   { `udp_findmac_out1 llhdr=$D1%XW` }, \
	10   { `udp_findmac_out2 hdrp=$D1%XW` }, \
	11   { `udp_init` }, \
	12   { `udp_init` }, \
	13   { `udp_input0 mp=$D1%XW inopts=$D2%XW llhdr=$D3%XW ipsecgoo=$D4%XW` }, \
	14   { `udp_input0_out1 mp=$D1%XW return value=$D2%XW` }, \
	15   { `udp_input0_out2 mp=$D1%XW return value=$D2%XW` }, \
	16   { `udp_input0_out3 mp=$D1%XW return value=$D2%XW` }, \
	17   { `udp_input0_out4 mp=$D1%XW return value=$D2%XW` }, \
	18   { `udp_input0_out5 mp=$D1%XW return value=$D2%XW` }, \
	19   { `udp_input1 m=$D1%XW iphlen=$D2%XW llhdr=$D3%XW` }, \
	20   { `udp_input1 m=$D1%XW ipsecgoo=$D2%XW` }, \
	21   { `udp_input m=$D1%XW iphlen=$D2%XW` }, \
	22   { `udp_input m=$D1%XW ipsecgoo=$D2%XW` }, \
	23   { `udp_output inp=$D1%XW m=$D2%XW addr=$D3%XW control=$D4%XW` }, \
	24   { `udp_output inp=$D1%XW m=$D2%XW error=$D3%XW` }, \
	25   { `udp_receive so=$D1%XW paddr=$D2%XW uio=$D3%XW mp0=$D4%XW flagsp=$D5%XW` }, \
	26   { `return from udp_receive so=$D1%XW error=$D2%DW` }, \
	27   { `udp_saveopt p=$D1%XW m=$D2%XW size=$D3%XW type=$D4%XW` }, \
	28   { `udp_saveopt_out1 m=$D1%XW type=$D2%XW` }, \
	29   { `udp_saveopt_out2 m=$D1%XW type=$D2%XW len=$D3%XW` }, \
	30   { `udp_saveopt_out3 m=$D1%XW type=$D2%XW len=$D3%XW` }, \
	31   { `udp_saveopt_out4 m=$D1%XW type=$D2%XW len=$D3%XW` }, \
	32   { `udp_usrreq so=$D1%XW req=$D2%XW m=$D3%XW addr=$D4%XW control=$D5%XW` }, \
	33   { `return from udp_usrreq so=$D1%XW req=$D2%XW return value=$D3%DW` }, \
	34   { `udpsend so=$D1%XW addr=$D2%XW uio=$D3%XW top=$D4%XW control=$D5%XW` }, \
	35   { `return from udpsend so=$D1%XW flags=$D2%XW error=$D3%DW` }, \
	36   { `udp_ephemeral_low_change error1 value=$D1%DW error=$D2%DW` }, \
	37   { `udp_ephemeral_high_change error1 value=$D1%DW error=$D2%DW` }, \
	38   { `udp_input0 error1 mp=$D1%DW len=$D2%DW ipdlen=$D3%DW hdrsize=$D4%DW` }, \
	39   { `udp_input0 error2 m=$D1%DW len=$D2%DW` }, \
	40   { `udp_input0 error3 m=$D1%DW len=$D2%DW` }, \
	41   { `udp_input0 error4` }, \
	42   { `udp_input0 error5 m=$D1%DW len=$D2%DW` }, \
	43   { `udp_input0 error6 port_sent=$D1%DW port_limit=$D2%DW` }, \
	44   { `udp_input0 error7 m=$D1%DW len=$D2%DW` }, \
	45   { `udp_input0 error8 m=$D1%DW len=$D2%DW` }, \
	46   { `udp_input0 error9 so=$D1%XW` }, \
	47   { `udp_input0 error10 so=$D1%XW` }, \
	48   { `udp_ctlinput error1 cmd=$D1%DW` }, \
	49   { `udp_output error1 len=$D1%DW error=$D2%DW` }, \
	50   { `udp_output error2 inp=$D1%DW error=$D2%DW` }, \
	51   { `udp_output error3 error=$D1%DW` }, \
	52   { `udp_output error4 error=$D1%DW` }, \
	53   { `udp_output error5 error=$D1%DW` }, \
	54   { `udp_output error6 error=$D1%DW` }, \
	55   { `udp_output error7 error=$D1%DW` }, \
	56   { `udp_output error8 error=$D1%DW` }, \
	57   { `udp_output error9 error=$D1%DW` }, \
	58   { `udp_output error10 error=$D1%DW` }, \
	59   { `udp_usrreq error1 so=$D1%XW control=$D2%XW error=$D1%DW` }, \
	60   { `udp_usrreq error2 so=$D1%XW req=$D2%DW error=$D1%DW` }, \
	61   { `udp_usrreq error3 so=$D1%XW error=$D2%DW snd_space=$D3%DW rcv_space=$D4%DW` }, \
	62   { `udp_usrreq error4 so=$D1%XW error=$D2%DW` }, \
	63   { `udp_usrreq error5 so=$D1%XW req=$D2%DW error=$D1%DW` }, \
	64   { `udp_send error1 so=$D1%XW error=$D2%DW` }, \
	65   { `udp_send error2 so=$D1%XW flags=$D2%XW error=$D3%DW` }, \
	66   { `udp_send error3 so=$D1%XW flags=$D2%XW error=$D3%DW` }, \
	67   { `udp_send error4 so=$D1%XW flags=$D2%XW error=$D3%DW` }, \
	68   { `udp_send error5 so=$D1%XW flags=$D2%XW error=$D3%DW` }, \
	69   { `udp_send error6 so=$D1%XW error=$D2%DW` }, \
	70   { `udp_send error7 so=$D1%XW error=$D2%DW` }, \
	71   { `udp_send error8 so=$D1%XW error=$D2%DW` }, \
	72   { `udp_send error9 so=$D1%XW error=$D2%DW` }, \
	73   { `udp_send error10 so=$D1%XW error=$D2%DW resid=$D3%DW` }, \
	74   { `udp_send error11 so=$D1%XW error=$D2%DW` }, \
	75   { `udp_send error12 so=$D1%XW error=$D2%DW` }, \
	76   { `udp_send error13 so=$D1%XW error=$D2%DW` }, \
	77   { `udp_send error14 so=$D1%XW error=$D2%DW` }, \
	78   { `udp_send error15 so=$D1%XW error=$D2%DW` }, \
	79   { `udp_send error16 so=$D1%XW error=$D2%DW` }, \
	80   { `udp_send error17 so=$D1%XW error=$D2%DW` }, \
	81   { `udp_send error18 so=$D1%XW error=$D2%DW` }, \
	82   { `udp_send error19 so=$D1%XW error=$D2%DW` }, \
	83   { `udp_receive error1 so=$D1%XW error=$D2%DW` }, \
	84   { `udp_receive error2 so=$D1%XW error=$D2%DW` }, \
	85   { `udp_receive error3 so=$D1%XW error=$D2%DW` }, \
	86   { `udp_receive error4 so=$D1%XW error=$D2%DW` }, \
	87   { `udp_receive error5 so=$D1%XW error=$D2%DW` }, \
	88   { `udp_receive error6 so=$D1%XW error=$D2%DW` }, \
	89   { `udp_receive error7 so=$D1%XW error=$D2%DW` }, \
	90   { `udp_receive error8 so=$D1%XW error=$D2%DW` }, \
	91   { `udp_receive error9 so=$D1%XW` }, \
	92   { `udp_receive error10 so=$D1%XW error=$D2%DW` }, \
	93   { `udp_receive error11 so=$D1%XW error=$D2%DW` }, \
	94   { `udp_usrreq abort so=$D1%XW` }, \
	95   { `udp_notify inp=$D1%XW error=$D2%DW` }, \
	96   { `udp_output_ip_output m=$D1%XW inp_op=$D2%XW imo=$D3%XW gid=$D4%XW` }, \
	97   { `udp_send_ip_output top=$D1%XW inp_op=$D2%XW imo=$D3%XW so=$D4%XW gid=$D5%XW` }, \
	98   { `udp_usrreq error6 so=$D1%XW error=$D2%XW` }, \
 	\* { unknown subhook $HD $ERROR }
537 1.0 'IP' \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
	1   { `add_mfc mfccp=$D1%XW` }, \
	2   { `return from add_mfc mfccp=$D1%XW error=$D2%DW` }, \
	3   { `add_vif vifcp=$D1%XW` }, \
	4   { `return from add_vif vifcp=$D1%XW error=$D2%DW` }, \
	5   { `del_mfc mfccp=$D1%XW` }, \
	6   { `return from del_mfc mfccp=$D1%XW error=$D2%DW` }, \
	7   { `del_vif vifip=$D1%XW` }, \
	8   { `return from del_vif vifip=$D1%XW error=$D2%DW` }, \
	9   { `dequeue_pfctlinput` }, \
	10   { `return from dequeue_pfctlinput` }, \
	11   { `doghash m=$D1%XW` }, \
	12   { `return from doghash_out1 m=$D1%XW cp->hv=$D2%DW` }, \
	13   { `return from doghash_out2 m=$D1%XW rv=$D2%XW dogrod->ndogs=$D3%XW return value=$D4%XW` }, \
	14   { `doginit` }, \
	15   { `return from doginit_out1` }, \
	16   { `return from doginit_out2` }, \
	17   { `return from doginit_out3` }, \
	18   { `return from doginit_out4` }, \
	19   { `dogisr nddp=$D1%XW m=$D2%XW macp=$D3%XW` }, \
	20   { `return from dogisr nddp=$D1%XW m=$D2%XW` }, \
	21   { `dogproc flags=$D1%XW ip=$D2%XW len=$D3%XW` }, \
	22   { `return from dogproc flags=$D1%XW ip=$D2%XW len=$D3%XW` }, \
	23   { `dogthread ip=$D1%XW` }, \
	24   { `return from dogthread ip=$D1%XW p=$D2%XW` }, \
	25   { `encap_send ip=$D1%XW vifp=$D2%XW m=$D3%XW` }, \
	26   { `return from encap_send ip=$D1%XW mb_copy=$D2%XW` }, \
	27   { `expire_upcalls` }, \
	28   { `return from expire_upcalls` }, \
	29   { `get_sg_cnt req=$D1%XW` }, \
	30   { `return from get_sg_cnt req=$D1%XW` }, \
	31   { `get_vif_cnt req=$D1%XW` }, \
	32   { `return from get_vif_cnt req=$D1%XW` }, \
	33   { `gids_ok dstgid=$D1%XW cached_dstgid=$D2%XW` }, \
	34   { `return from gids_ok return value=$D1%XW` }, \
	35   { `icmp_error n=$D1%XW type=$D2%XW code=$D3%XW dest=$D4%XW` }, \
	36   { `return from icmp_error` }, \
	37   { `icmp_input m=$D1%XW len=$D2%XW` }, \
	38   { `return from icmp_input` }, \
	39   { `icmp_reflect m=$D1%XW optlen=$D2%XW` }, \
	40   { `return from icmp_reflect m=$D1%XW` }, \
	41   { `icmp_send m=$D1%XW opts=$D2%XW` }, \
	42   { `return from icmp_send m=$D1%XW` }, \
	43   { `in_flip_and_run nddp=$D1%XW m=$D2%XW macp=$D3%XW` }, \
	44   { `return from in_flip_and_run nddp=$D1%XW m=$D2%XW macp=$D3%XW` }, \
	45   { `inbound_fw_free_args args=$D1%XW` }, \
	46   { `inbound_fw_save_args args=$D1%XW` }, \
	47   { `return form inbound_fw_save_args return value=$D1%XW` }, \
	48   { `ip_changeversion pf=$D1%XW so=$D2%XW inp=$D3%XW` }, \
	49   { `return from ip_changeversion so=$D1%XW EADDRNOTAVAIL=$D2%XW` }, \
	50   { `ip_ctloutput op=$D1%XW so=$D2%XW level=$D3%XW optname=$D4%XW` }, \
	51   { `return from ip_ctloutput op=$D1%XW error=$D2%XW` }, \
	52   { `ip_dootions m=$D1%XW` }, \
	53   { `ip_drain` }, \
	54   { `ip_flush_packet m=$D1%XW` }, \
	55   { `return from ip_flush_packet m=$D1%XW` }, \
	56   { `ip_forward m=$D1%XW srcrt=$D2%XW` }, \
	57   { `return from ip_forward_out1 m=$D1%XW` }, \
	58   { `return from ip_forward_out2 m=$D1%XW` }, \
	59   { `return from ip_forward_out3 m=$D1%XW` }, \
	60   { `return from ip_forward_out4 m=$D1%XW error=$D2%XW` }, \
	61   { `return from ip_forward_out5 m=$D1%XW error=$D2%XW type=$D3%XW code=$D4%XW` }, \
	62   { `ip_freef fp=$D1%XW` }, \
	63   { `ip_freemoptions mopts=$D1%XW` }, \
	64   { `return from ip_freemoptions mopts=$D1%XW` }, \
	65   { `ip_getmoptions optname=$D1%XW mopts=$D2%XW m=$D3%XW` }, \
	66   { `return from ip_getmoptions optname=$D1%XW *m=$D2%XW error=$D3%XW` }, \
	67   { `ip_init` }, \
	68   { `return from ip_init` }, \
	69   { `ip_initr` }, \
	70   { `return from ip_initr` }, \
	71   { `ip_insertoptions m=$D1%XW opt=$D2%XW phlen=$D3%XW` }, \
	72   { `return from ip_insertoptions m=$D1%XW` }, \
	73   { `ip_mdq m=$D1%XW ifp=$D2%XW rt=$D3%XW` }, \
	74   { `return from ip_mdq m=$D1%XW return value=$D2%XW` }, \
	75   { `ip_mforward ip=$D1%XW ifp=$D2%XW m=$D3%XW` }, \
	76   { `return from ip_mforward ip=$D1%XW return value=$D2%XW` }, \
	77   { `ip_mloopback ifp=$D1%XW m=$D2%XW dst=$D3%XW` }, \
	78   { `return from ip_mloopback` }, \
	79   { `ip_mrouter_done` }, \
	80   { `return from ip_mrouter_done` }, \
	81   { `ip_mrouter_get cmd=$D1%XW so=$D2%XW m=$D3%XW` }, \
	82   { `ip_mrouter_init so=$D1%XW m=$D2%XW` }, \
	83   { `return from ip_mrouter_init so=$D1%XW error=$D2%XW` }, \
	84   { `ip_mrouter_set cmd=$D1%XW so=$D2%XW m=$D3%XW` }, \
	85   { `ip_output m0=$D1%XW opt=$D2%XW ro=$D3%XW flags=$D4%XW` }, \
	86   { `ip_output_post_fw ifp_arg=$D1%XW m0=$D2%XW args=$D3%XW` }, \
	87   { `return from ip_output_post_fw args=$D1%XW error=$D2%XW` }, \
	88   { `ip_pcbopts pcbopt=$D1%XW m=$D2%XW` }, \
	89   { `return from ip_pcbopts_out1 m=$D1%XW m->m_len=$D2%XW` }, \
	90   { `return from ip_pcbopts_out2 m=$D1%XW error=$D2%XW` }, \
	91   { `ip_pmtu_start rt=$D1%XW type=$D2%XW` }, \
	92   { `return from ip_pmtu_start` }, \
	93   { `ip_pmtu_stopt rt=$D1%XW mtu=$D2%XW` }, \
	94   { `return from ip_pmtu_stopt` }, \
	95   { `ip_pmtu_timeout rn=$D1%XW notused=$D2%XW` }, \
	96   { `return from ip_pmtu_timeout` }, \
	97   { `ip_reass m=$D1%XW` }, \
	98   { `return from ip_reass_out1 m=$D1%XW error=$D2%XW` }, \
	99   { `return from ip_reass_out2 m=$D1%XW` }, \
	100   { `ip_rsvp_force_done so=$D1%XW` }, \
	101   { `return from ip_rsvp_force_done so=$D1%XW` }, \
	102   { `ip_rsvp_vif_done so=$D1%XW m=$D2%XW` }, \
	103   { `return from ip_rsvp_vif_done so=$D1%XW error=$D2%XW` }, \
	104   { `ip_rsvp_vif_init so=$D1%XW m=$D2%XW` }, \
	105   { `return from ip_rsvp_vif_init so=$D1%XW error=$D2%XW` }, \
	106   { `ip_rtaddr dst=$D1%XW gidlist=$D2%XW` }, \
	107   { `return from ip_rtaddr dst=$D1%XW ifa=$D2%XW` }, \
	108   { `ip_setdupmtu rn=$D1%XW val=$D2%XW` }, \
	109   { `return from ip_setdupmtu` }, \
	110   { `ip_setmoptions so=$D1%XW optname=$D2%XW mopts=$D3%XW m=$D4%XW` }, \
	111   { `return from ip_setmoptions so=$D1%XW error=$D2%XW` }, \
	112   { `ip_slowtimo` }, \
	113   { `ip_srcroute ip_nhops=$D1%XW` }, \
	114   { `return from ip_srcroute m=$D1%XW` }, \
	115   { `ip_stripoptions m=$D1%XW strip_cksum=$D2%XW` }, \
	116   { `return from ip_stripoptions m=$D1%XW olen=$D2%XW` }, \
	117   { `ipintr_noqueue nddp=$D1%XW m=$D2%XW macp=$D3%XW` }, \
	118   { `return from ipintr_noqueue nddp=$D1%XW` }, \
	119   { `ipintr_noqueue_post_fw ifp=$D1%XW m=$D2%XW args=$D3%XW` }, \
	120   { `return from ipintr_noqueue_post_fw ifp=$D1%XW m=$D2%XW` }, \
	121   { `ipip_input ip=$D1%XW m=$D2%XW hlen=$D3%XW` }, \
	122   { `return from ipip_input ip=$D1%XW` }, \
	123   { `localaddr_notcast in=$D1%XW` }, \
	124   { `return from localaddr_notcast in=$D1%XW error=$D2%XW` }, \
	125   { `mroute_init` }, \
	126   { `mrt_ioctl cmd=$D1%XW data=$D2%XW` }, \
	127   { `outbound_fw_free_args args=$D1%XW` }, \
	128   { `return from outbound_fw_free_args` }, \
	129   { `outbound_fw_save_args args=$D1%XW` }, \
	130   { `return from outbound_fw_save_args args=$D1%XW error=$D2%XW` }, \
	131   { `phyint_send ip=$D1%XW vifp=$D2%XW m=$D3%XW` }, \
	132   { `return from phyint_send ip=$D1%XW mb_copy=$D2%XW` }, \
	133   { `pmtu_default_age_init *newval=$D1%XW nop=$D2%XW` }, \
	134   { `pmtu_default_age_upd rn=$D1%XW val=$D2%XW` }, \
	135   { `return from pmtu_default_age_upd` }, \
	136   { `pmtu_redis_intrvl_init *newval=$D1%XW nop=$D2%XW` }, \
	137   { `pmtu_rtrequest cmd=$D1%XW rt=$D2%XW sa=$D3%XW` }, \
	138   { `return from pmtu_rtrequest` }, \
	139   { `priority vifp=$D1%XW ip=$D2%XW` }, \
	140   { `return from priority vifp=$D1%XW prio=$D2%XW` }, \
	141   { `queue_pfctlinput cmd=$D1%XW sin=$D2%XW` }, \
	142   { `return from queue_pfctlinput m=$D1%XW` }, \
	143   { `raw_saveif index=$D1%XW` }, \
	144   { `return from raw_saveif m=$D1%XW` }, \
	145   { `rip_ctloutput op=$D1%XW so=$D2%XW level=$D3%XW optname=$D4%XW` }, \
	146   { `return from rip_ctloutput so=$D1%XW error=$D2%XW` }, \
	147   { `rip_init` }, \
	148   { `return from rip_init` }, \
	149   { `rip_input m=$D1%XW hlen=$D2%XW` }, \
	150   { `rip_output m=$D1%XW so=$D2%XW dst=$D3%XW` }, \
	151   { `return from rip_output m=$D1%XW error=$D2%XW` }, \
	152   { `rip_usrreq so=$D1%XW req=$D2%XW m=$D3%XW nam=$D4%XW` }, \
	153   { `return from rip_usrreq so=$D1%XW error=$D2%XW` }, \
	154   { `rsvp_input m=$D1%XW ifp=$D2%XW` }, \
	155   { `return from rsvp_input m=$D1%XW` }, \
	156   { `save_rte option=$D1%XW dst=$D2%XW olen=$D3%XW` }, \
	157   { `return from save_rte` }, \
	158   { `socket_send s=$D1%XW mm=$D2%XW src=$D3%XW` }, \
	159   { `return from socket_send s=$D1%XW error=$D2%XW` }, \
	160   { `tbf_control vifp=$D1%XW m=$D2%XW ip=$D3%XW p_len=$D4%XW` }, \
	161   { `return from tbf_control` }, \
	162   { `tbf_dq_sel vifp=$D1%XW ip=$D2%XW` }, \
	163   { `return from tbf_dq_sel vifp=$D1%XW p=$D2%XW` }, \
	164   { `tbf_process_q vifp=$D1%XW` }, \
	165   { `return from tbf_process_q` }, \
	166   { `tbf_reprocess_q vifp=$D1%XW` }, \
	167   { `return from tbf_reprocess_q vifp=$D1%XW ip_mrouter=$D2%XW` }, \
	168   { `tbf_send_packet vifp=$D1%XW m=$D2%XW` }, \
	169   { `return from tbf_send_packet m=$D1%XW error=$D2%XW` }, \
	170   { `tcp_pmtu_discover_init newval=$D1%XW nop=$D2%XW` }, \
	171   { `return from tcp_pmtu_discover_init *newval=$D1%XW error=$D2%XW` }, \
	172   { `tcp_pmtu_discover_upd rn=$D1%XW val=$D2%XW` }, \
	173   { `return from tcp_pmtu_discover_upd` }, \
	174   { `udp_pmtu_discover_init newval=$D1%XW nop=$D2%XW` }, \
	175   { `return from udp_pmtu_discover_init *newval=$D1%XW error=$D2%XW` }, \
	176   { `udp_pmtu_discover_upd rn=$D1%XW val=$D2%XW` }, \
	177   { `return from udp_pmtu_discover_upd` }, \
	178   { `outbound_fw_save_args out1 args=$D1%XW newargs=$D2%XW` }, \
	179   { `outbound_fw_save_args out2 args=$D1%XW newargs=$D2%XW` }, \
	180   { `outbound_fw_save_args out3 args=$D1%XW newargs=$D2%XW` }, \
	181   { `ip_output_post_fw error1 args=$D1%XW error=$D2%DW` }, \
	182   { `ip_output_post_fw error2 addr=$D1%XW error=$D2%DW` }, \
	183   { `ip_output_post_fw error3 rt=$D1%XW ro_rt=$D2%XW error=$D3%DW` }, \
	184   { `ip_output_post_fw error4 key=$D1%XW rt=$D2%XW error=$D3%DW` }, \
	185   { `ip_output_post_fw error5 newrt=$D1%XW rt=$D2%XW error=$D3%DW` }, \
	186   { `ip_output_post_fw error6 ifp=$D1%XW error=$D2%DW` }, \
	187   { `ip_output_post_fw error7 error=$D1%DW` }, \
	188   { `ip_output_post_fw error8 error=$D1%DW` }, \
	189   { `ip_output_post_fw error9 ifp=$D1%XW error=$D2%DW` }, \
	190   { `ip_output_post_fw error10 error=$D1%DW` }, \
	191   { `ip_output_post_fw error11 len=$D1%DW ifp_mtu=$D2%DW error=$D3%DW` }, \
	192   { `ip_output_post_fw error12 len=$D1%DW ifp_mtu=$D2%DW error=$D3%DW` }, \
	193   { `ip_output_post_fw error13 len=$D1%DW ifp_mtu=$D2%DW error=$D3%DW` }, \
	194   { `ip_output_post_fw error14 error=$D1%DW` }, \
	195   { `ip_output_post_fw error15 len=$D1%DW error=$D2%DW` }, \
	196   { `ip_output_post_fw error16 error=$D1%DW` }, \
	197   { `ip_output_post_fw error17 error=$D1%DW` }, \
	198   { `ip_output_post_fw error18 error=$D1%DW` }, \
	199   { `ip_output_post_fw error19 error=$D1%DW` }, \
	200   { `ip_insertoptions out1 m=$D1%XW` }, \
	201   { `ip_ctloutput error1 op=$D1%XW error=$D2%DW` }, \
	202   { `ip_ctloutput error2 op=$D1%XW error=$D2%DW` }, \
	203   { `ip_ctloutput error3 op=$D1%XW error=$D2%DW` }, \
	204   { `ip_changeversion error1 so=$D1%XW pf=$D2%DW proto=$D3%DW type=$D4%DW error=$D5%DW` }, \
	205   { `ip_changeversion error2 so=$D1%XW error=$D2%DW` }, \
	206   { `ip_changeversion error3 so=$D1%XW error=$D2%DW` }, \
	207   { `ip_changeversion error4 so=$D1%XW error=$D2%DW` }, \
	208   { `localaddr_notcast out1 addr=$D1%DW ret=$D2%DW` }, \
	209   { `localaddr_notcast out2 addr=$D1%DW ret=$D2%DW` }, \
	210   { `localaddr_notcast out3 addr=$D1%DW ret=$D2%DW` }, \
	211   { `localaddr_notcast out4 addr=$D1%DW ret=$D2%DW` }, \
	212   { `ip_setmoptions error1 so=$D1%XW error=$D2%DW optname=$D3%DW` }, \
	213   { `ip_setmoptions error2 so=$D1%XW error=$D2%DW optname=$D3%DW` }, \
	214   { `ip_setmoptions error3 so=$D1%XW error=$D2%DW optname=$D3%DW` }, \
	215   { `ip_setmoptions error4 so=$D1%XW error=$D2%DW optname=$D3%DW` }, \
	216   { `ip_setmoptions error5 so=$D1%XW error=$D2%DW optname=$D3%DW` }, \
	217   { `ip_getmoptions error1 optname=$D1%XW m=$D2%XW error=$D3%DW` }, \
	218   { `ip_getmoptions error2 optname=$D1%XW m=$D2%XW error=$D3%DW` }, \
	219   { `ip_getmoptions out1 optname=$D1%XW m=$D2%XW error=$D3%DW` }, \
	220   { `ip_getmoptions out2 optname=$D1%XW m=$D2%XW error=$D3%DW` }, \
	221   { `ip_getmoptions out3 optname=$D1%XW m=$D2%XW error=$D3%DW` }, \
	222   { `ip_pcbopts error1 m=$D1%XW m_len=$D2%DW` }, \
	223   { `ip_pcbopts error2 optlen=$D1%DW cnt=$D2%DW` }, \
	224   { `ip_pcbopts error3` }, \
	225   { `ip_pcbopts error4 optlen=$D1%DW` }, \
	226   { `ip_pcbopts error5 m=$D1%XW m_len=$D2%DW` }, \
	227   { `ip_intr out1` }, \
	228   { `ip_intr out2` }, \
	229   { `inbound_fw_save_args out1 ret=$D1%DW` }, \
	230   { `ip_dooptions out m=$D1%XW ret=$D2%DW opt=$D3%XW optlen=$D4%DW` }, \
	231   { `ip_dooptions out1 m=$D1%XW ret=$D2%DW` }, \
	232   { `ip_dooptions out2 m=$D1%XW ret=$D2%DW` }, \
	233   { `ip_rtaddr out1 dst=$D1%XW ifa=$D2%DW` }, \
	234   { `ip_rtaddr out2 dst=$D1%XW ifa=$D2%DW` }, \
	235   { `gids_ok out1 ret=$D1%DW` }, \
	236   { `gids_ok out2 ret=$D1%DW` }, \
	237   { `gids_ok out3 ret=$D1%DW` }, \
	238   { `save_rte out1` }, \
	239   { `ip_srcroute out1 m=$D1%XW` }, \
	240   { `ip_srcroute out2 m=$D1%XW` }, \
	241   { `ip_forward out6 m=$D1%XW error=$D2%DW` }, \
	242   { `dogisr out1 nddp=$D1%XW m=$D2%XW` }, \
	243   { `dogisr out2 nddp=$D1%XW m=$D2%XW` }, \
	244   { `doghash out3 m=$D1%XW rv=$D2%DW ndogs=$D3%DW hash=$D4%DW` }, \
	245   { `doghash out4 m=$D1%XW hash=$D2%DW` }, \
	246   { `doghash out5 m=$D1%XW hash=$D2%DW` }, \
	247   { `doghash out6 m=$D1%XW hash=$D2%DW` }, \
	248   { `doghash out7 m=$D1%XW hash=$D2%DW` }, \
	249   { `doghash out8 m=$D1%XW hash=$D2%DW` }, \
	250   { `doghash out9 m=$D1%XW hash=$D2%DW` }, \
	251   { `doghash out10 m=$D1%XW hash=$D2%DW` }, \
	252   { `doghash out11 m=$D1%XW hash=$D2%DW` }, \
	253   { `doghash out12 m=$D1%XW hash=$D2%DW` }, \
	254   { `doghash out13 m=$D1%XW hash=$D2%DW` }, \
	255   { `doghash out14 m=$D1%XW hash=$D2%DW` }, \
	256   { `doghash out15 m=$D1%XW hash=$D2%DW` }, \
	257   { `doghash out16 m=$D1%XW hash=$D2%DW` }, \
	258   { `ip_reass error1 error=$D1%DW` }, \
	259   { `ip_reass out3 m=$D1%XW` }, \
	260   { `ip_reass out4 m=$D1%XW ret=$D2%DW` }, \
	261   { `ip_insertoptions out2 m=$D1%XW` }, \
	262   { `udp_pmtu_discover_init out1 newval=$D1%DW ret=$D2%DW` }, \
	263   { `tcp_pmtu_discover_init out1 newval=$D1%DW ret=$D2%DW` }, \
	264   { `pmtu_delete_not_found pt=$D1%XW id=$D2%DW` }, \
	265   { `pmtu_delete pt=$D1%XW` }, \
	266   { `return from pmtu_delete pt=$D1%XW id=$D2%DW` }, \
	267   { `pmtu_expire newval=$D1%DW` }, \
	268   { `return from pmtu_expire` }, \
	269   { `ip_pmtu_timeout out1 rt=$D1%XW` }, \
	270   { `ip_pmtu_timeout out2 rt=$D1%XW` }, \
	271   { `ip_pmtu_timeout out3` }, \
	272   { `ip_pmtu_timeout out4` }, \
	273   { `pmtu_equalifmtu ifp=$D1%XW` }, \
	274   { `pmtu_setmtu sa=$D1%XW rt=$D2%XW mtu=$D3%DW` }, \
	275   { `pmtu_del_request_usr dst=$D1%XW gw=$D2%XW v6=$D3%DW` }, \
	276   { `pmtu_del_request_route rt=$D1%XW` }, \
	277   { `pmtu_rediscover_v4 pt_mtu=$D1%DW if_mtu=$D2%DW` }, \
	278   { `pmtu_rediscover_v6 pt_mtu=$D1%DW rtif_mtu=$D2%DW` }, \
	279   { `pmtu_expire_upd newval=$D1%DW` }, \
	280   { `return from pmtu_expire_upd` }, \
	281   { `pmtu_alloc sa=$D1%XW rt=$D2%XW index=$D3%DW` }, \
	282   { `return from pmtu_alloc pt=$D1%XW` }, \
	283   { `pmtu_alloc out1 rt=$D1%XW` }, \
	284   { `pmtu_alloc out2 pt=$D1%XW` }, \
	285   { `pmtu_alloc out3 pt=$D1%XW` }, \
	286   { `pmtu_alloc out4 pt=$D1%XW` }, \
	311   { `set_add_membership so=$D1%XW, mopts=$D2%XW, imo=$D3%XW, mreq=$D4%XW, ifp=$D5%XW` }, \
	312   { `return from set_add_membership so=$D1%XW, error=$D2%XW` }, \
	313   { `set_add_source_membership so=$D1%XW, mopts=$D2%XW, imo=$D3%XW, mreq_source=$D4%XW, ifp=$D5%XW` }, \
	314   { `return from set_add_source_membership so=$D1%XW, error=$D2%XW` }, \
	315   { `set_source_filter so=$D1%XW, mopts=$D2%XW, imo=$D3%XW, sfilter=$D4%XW, ifp=$D5%XW` }, \
	316   { `return from set_source_filter so=$D1%XW, error=$D2%XW` }, \
	317   { `ip_setmoptions error6 so=$D1%XW error=$D2%DW optname=$D3%DW` }, \
	318   { `ip_ctloutput error4 op=$D1%XW error=$D2%DW` }, \
 	\* { unknown subhook $HD $ERROR }
538 1.0 'IP6' \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
	1   { `dopt6_input mp=$D1%XW opts=$D2%XW llhdr=$D3%XW ipsecgoo=$D4%XW` }, \
	2   { `return from dopt6_input *mp=$D1%XW return value=$D2%XW` }, \
	3   { `end6_input *mp=$D1%XW *optsp=$D2%XW` }, \
	4   { `frg6_drain` }, \
	5   { `frg6_freef fp=$D1%XW` }, \
	6   { `frg6_input mp=$D1%XW opts=$D2%XW llhdr=$D3%XW ipsecgoo=$D4%XW` }, \
	7   { `return from frg6_input` }, \
	8   { `frg6_slowtimo` }, \
	9   { `hd6_inoptions m=$D1%XW opts=$D2%XW alert=$D3%XW` }, \
	10   { `return from hd6_inoptions return value=$D1%XW` }, \
	11   { `hd6_outoptions m=$D1%XW opts=$D2%XW` }, \
	12   { `hop6_input mp=$D1%XW opts=$D2%XW llhdr=$D3%XW ipsecgoo=$D4%XW` }, \
	13   { `return from hop6_input *mp=$D1%XW return value=$D2%XW` }, \
	14   { `icmp6_error n=$D1%XW type=$D2%XW code=$D3%XW arg=$D4%XW` }, \
	15   { `return from icmp6_error_out1 n=$D1%XW` }, \
	16   { `return from icmp6_error_out2` }, \
	17   { `icmp6_errparam m=$D1%XW opts=$D2%XW len=$D3%XW` }, \
	18   { `icmp6_fasttimo` }, \
	19   { `icmp6_init` }, \
	20   { `icmp6_input mp=$D1%XW optsp=$D2%XW llhdr=$D3%XW ipsecgoo=$D4%XW` }, \
	21   { `return from icmp6_input` }, \
	22   { `icmp6_joingroup inm=$D1%XW` }, \
	23   { `icmp6_leavegroup inm=$D1%XW` }, \
	24   { `icmp6_reflect m=$D1%XW opts=$D2%XW` }, \
	25   { `return from icmp6_reflect m=$D1%XW` }, \
	26   { `icmp6_send m=$D1%XW opts=$D2%XW imo=$D3%XW` }, \
	27   { `return from icmp6_send m=$D1%XW` }, \
	28   { `icmp6_sendmld inm=$D1%XW type=$D2%XW addr=$D3%XW` }, \
	29   { `return from icmp6_sendmld_out1 inm=$D1%XW m=$D2%XW` }, \
	30   { `return from icmp6_sendmld_out2 inm=$D1%XW m=$D2%XW imo=$D3%XW` }, \
	31   { `return from icmp6_sendmld_out3 inm=$D1%XW ia=$D2%XW` }, \
	32   { `return from icmp6_sendmld_out4 inm=$D1%XW` }, \
	33   { `ip6_copyoptions ip=$D1%XW opts=$D2%XW canshare=$D3%XW reverse=$D4%XW` }, \
	34   { `return from ip6_copyoptions ip=$D1%XW top=$D2%XW` }, \
	35   { `ip6_ctloutput op=$D1%XW so=$D2%XW level=$D3%XW optname=$D4%XW` }, \
	36   { `return from ip6_ctloutput so=$D1%XW error=$D2%XW` }, \
	37   { `ip6_deloption m0=$D1%XW len=$D2%XW` }, \
	38   { `ip6_dropoption opts=$D1%XW which=$D2%XW` }, \
	39   { `ip6_forward m=$D1%XW srcrt=$D2%XW` }, \
	40   { `return from ip6_forward m=$D1%XW` }, \
	41   { `ip6_freemoptions imo=$D1%XW` }, \
	42   { `ip6_getmoptions optname=$D1%XW imo=$D2%XW mp=$D3%XW` }, \
	43   { `return from ip6_getmoptions error=$D1%XW` }, \
	44   { `ip6_getoptions pcbopts=$D1%XW mp=$D2%XW control=$D3%XW` }, \
	45   { `return from ip6_getoptions error=$D1%XW` }, \
	46   { `ip6_init` }, \
	47   { `return from ip6_init` }, \
	48   { `ip6_input m=$D1%XW macp=$D2%XW` }, \
	49   { `return from ip6_input` }, \
	50   { `ip6_insertoption m=$D1%XW opt=$D2%XW iso=$D3%XW flags=$D4%XW` }, \
	51   { `return from ip6_insertoption m=$D1%XW` }, \
	52   { `ip6_mforward m=$D1%XW ifp=$D2%XW` }, \
	53   { `return from ip6_mforward m=$D1%XW rc=$D2%XW` }, \
	54   { `ip6_mloopback ifp=$D1%XW m=$D2%XW opts=$D3%XW dst=$D4%XW` }, \
	55   { `return from ip6_mloopback` }, \
	56   { `ip6_output m0=$D1%XW opts=$D2%XW ro=$D3%XW flags=$D4%XW` }, \
	57   { `return from ip6_output m0=$D1%XW opts=$D2%XW error=$D3%XW` }, \
	58   { `ip6_reass ip=$D1%XW fp=$D2%XW where=$D3%XW` }, \
	59   { `return from ip6_reass error=$D1%XW` }, \
	60   { `ip6_saveoption m0=$D1%XW opts=$D2%XW len=$D3%XW type=$D4%XW` }, \
	61   { `return from ip6_saveoption m0=$D1%XW opts=$D2%XW` }, \
	62   { `ip6_setcontrol inp=$D1%XW control=$D2%XW` }, \
	63   { `return from ip6_setcontrol inp=$D1%XW error=$D2%XW` }, \
	64   { `ip6_setmoptions inp=$D1%XW optname=$D2%XW m=$D3%XW` }, \
	65   { `return from ip6_setmoptions error=$D1%XW` }, \
	66   { `ip6_setoptions pcbopts=$D1%XW m0=$D2%XW inp=$D3%XW` }, \
	67   { `return from ip6_setoptions error=$D1%XW` }, \
	68   { `ip6rttimeout rn=$D1%XW arg=$D2%XW` }, \
	69   { `return from ip6rttimeout` }, \
	70   { `ip6rttimer` }, \
	71   { `ip6rttimer_sched` }, \
	72   { `mfc_addqueue m=$D1%XW mfc=$D2%XW` }, \
	73   { `return from mfc_addqueue m=$D1%XW error=$D2%XW` }, \
	74   { `mfc_requeue fam=$D1%XW ifq=$D2%XW mfc=$D3%XW` }, \
	75   { `return from mfc_requeue` }, \
	76   { `mfctimer` }, \
	77   { `return from mfctimer` }, \
	78   { `mroute6_init` }, \
	79   { `multicast_send m=$D1%XW ifp=$D2%XW` }, \
	80   { `return from multicast_send` }, \
	81   { `opt6_ctlinput cmd=$D1%XW sa=$D2%XW ip0=$D3%XW m0=$D4%XW` }, \
	82   { `return from opt6_ctlinput` }, \
	83   { `opt6_ferr_input op=$D1%XW m=$D2%XW opts=$D3%XW alert=$D4%XW` }, \
	84   { `opt6_haddr_input op=$D1%XW m=$D2%XW opts=$D3%XW alert=$D4%XW` }, \
	85   { `opt6_haddr_output op=$D1%XW m=$D2%XW opts=$D3%XW` }, \
	86   { `opt6_init` }, \
	87   { `opt6_oerr_input op=$D1%XW m=$D2%XW opts=$D3%XW alert=$D4%XW` }, \
	88   { `opt6_reverse ip=$D1%XW opts=$D2%XW` }, \
	89   { `opt6_rtalert_input op=$D1%XW m=$D2%XW opts=$D3%XW alert=$D4%XW` }, \
	90   { `real_ip6_output m0=$D1%XW opts=$D2%XW ro=$D3%XW flags=$D4%XW` }, \
	91   { `return from real_ip6_output m0=$D1%XW opts=$D2%XW error=$D3%XW` }, \
	92   { `rt6_input mp=$D1%XW opts=$D2%XW llhdr=$D3%XW ipsecgoo=$D4%XW` }, \
	93   { `return from rt6_input *mp=$D1%XW return value=$D2%XW` }, \
	94   { `rt6_reverse ip=$D1%XW opts=$D2%XW` }, \
	95   { `return from rt6_reverse ip=$D1%XW opts=$D2%XW` }, \
	96   { `ip6_output_cachedroute ro->ro_rt=$D1%XW` }, \
        97   { `ip6_output_cachedroute_free ro->ro_rt=$D1%XW` }, \
        98   { `ip6_output_routetoif flags=$D1%XW` }, \
        99   { `ip6_output_netunreach error=$D1%XW` }, \
        100  { `ip6_output_hostunreach error=$D1%XW` }, \
        101  { `ip6_output_route_gwroute ro->ro_rt=$D1%XW` }, \
        102  { `ip6_output_mcast ro=$D1%XW` }, \
        103  { `ip6_output_mcast_noxface ifp=$D1%XW ifp->if_flags=$D2%XW` }, \
        104  { `ip6_output_mcast_hoplimit ifp=$D1%XW ifp->if_flags=$D2%XW` }, \
        105  { `ip6_output_sendit ifp=$D1%XW len=$D2%XW mtu=$D3%XW` }, \
        106  { `ip6_output_nofrag_sent error=$D1%XW` }, \
        107  { `ip6_output_frag_sent error=$D1%XW` }, \
        108  { `ip6_output_bad error=$D1%XW` }, \
        109  { `llink_resolve m=$D1%XW dst=$D2%XW rt=$D3%XW` }, \
        110  { `return from llink_resolve m=$D1%XW` }, \
        111  { `ndp6_rtrequest req=$D1%XW rt=$D2%XW sa=$D3%XW` }, \
        112  { `return from ndp6_rtrequest rt=$D1%XW` }, \
        113  { `ndp6_resolve ifp=$D1%XW rt=$D2%XW m=$D3%XW dst=$D4%XW desten=$D5%XW` }, \
        114  { `return from ndp6_resolve dst=$D1%XW ret=$D2%XW` }, \
        115  { `ndsol6_output ifp=$D1%XW hold=$D2%XW dst=$D3%XW target=$D4%XW` }, \
        116  { `return from ndsol6_output dst=$D1%XW` }, \
        117  { `ndadv6_output ifp=$D1%XW dst=$D2%XW target=$D3%XW flags=$D4%XW` }, \
        118  { `return from ndadv6_output dst=$D1%XW` }, \
        119  { `redirect6_output m0=$D1%XW rt=$D2%XW` }, \
        120  { `return from redirect6_output m0=$D1%XW` }, \
        121  { `ndsol6_input m0=$D1%XW llhdr=$D2%XW` }, \
        122  { `return from ndsol6_input m0=$D1%XW ret=$D2%XW` }, \
        123  { `ndadv6_input m0=$D1%XW llhdr=$D2%XW` }, \
        124  { `return from ndadv6_input m0=$D1%XW ret=$D2%XW` }, \
        125  { `rtsol6_input m0=$D1%XW llhdr=$D2%XW` }, \
        126  { `return from rtsol6_input m0=$D1%XW ret=$D2%XW` }, \
        127  { `rtadv6_input m0=$D1%XW llhdr=$D2%XW` }, \
        128  { `return from rtadv6_input m0=$D1%XW ret=$D2%XW` }, \
        129  { `redirect6_input m0=$D1%XW llhdr=$D2%XW` }, \
        130  { `return from redirect6_input m0=$D1%XW ret=$D2%XW` }, \
	131  { `ip6_reachhint inp=$D1%XW` }, \
        132  { `return from ip6_reachhint inp=$D1%XW` }, \
        133  { `ndplookup addr=$D1%XW create=$D2%XW` }, \
        134  { `return from ndplookup addr=$D1%XW rt=$D2%XW` }, \
        135  { `ndp6_ifinit ifp=$D1%XW ifa=$D2%XW` }, \
        136  { `return from ndp6_ifinit ifp=$D1%XW` }, \
        137  { `ndp6_rtlost rt=$D1%XW dead=$D2%XW` }, \
        138  { `return from ndp6_rtlost rt=$D1%XW` }, \
        139  { `rip6_input mp=$D1%XW opts=$D2%XW llhdr=$D3%XW ipsecgoo=$D4%XW` }, \
        140  { `return from rip6_input ret=$D1%XW` }, \
        141  { `raw6_saverecv m0=$D1%XW flags=$D2%XW` }, \
        142  { `return from raw6_saverecv m=$D1%XW` }, \
        143  { `rip6_output m=$D1%XW so=$D2%XW dst=$D3%XW` }, \
        144  { `return from rip6_output error=$D1%XW` }, \
        145  { `rip6_ctloutput op=$D1%XW so=$D2%XW level=$D3%XW optname=$D4%XW m=$D5%XW` }, \
	146  { `return from rip6_ctloutput error=$D1%XW` }, \
        147  { `rip6_usrreq so=$D1%XW req=$D2%XW m=$D3%XW nam=$D4%XW control=$D5%XW` }, \
        148  { `return from rip6_usrreq error=$D1%XW` }, \
        149  { `rip6_ctlinput cmd=$D1%XW sa=$D2%XW ip=$D3%XW m=$D4%XW ` }, \
        150  { `rip6_ctlinput_out1 `}, \
        151  { `rip6_ctlinput_out2 `}, \
        152  { `rip6_ctlinput_out3 `}, \
        153  { `rip6_ctlinput_out4 `}, \
        154  { `ip6_getctrlinfo inp=$D1%XW control=$D2%XW opdata=$D3%XW` }, \
        155  { `return from ip6_getctrlinfo error=$D1%XW` }, \
        156  { `source_address_select address=$D1%XW$D2%XW$D3%XW$D4%XW ifp=$D5%XW` }, \
        157  { `return from source_address_select ret=$D1%XW` }, \
        158  { `rip6_output_ancillary m=$D1%XW so=$D2%XW dst=$D3%XW` }, \
        159  { `return from rip6_output_ancillary error=$D1%XW` }, \
	160  { `llink_resolve_nolock m=$D1%XW dst=$D2%XW rt=$D3%XW` }, \
	161  { `return from llink_resolve_nolock m=$D1%XW` }, \
	162  { `ip6_rtexpire_timeout_setup rt=$D1%XW` }, \
	163  { `return from ip6_rtexpire_timeout_setup` }, \
	164  { `ip6_rtexpire_netisr ` }, \
	165  { `return from ip6_rtexpire_netisr ` }, \
	166  { `ip6_ndsol_netisr `}, \
        167  { `return from ip6_ndsol_netisr pointer null`}, \
        168  { `return from ip6_ndsol_netisr success`}, \
	169  { `in6_recvpathmtu inp=$D1%XW pathmtu=$D2%XW sin6=$D3%XW` }, \
        170  { `return from in6_recvpathmtu with error ` }, \
        171  { `return from in6_recvpathmtu with success ` }, \
        172  { `in6_pcbnotifymtu head=$D1%XW pathmtu=$D2%XW sin6=$D3%XW notify=$D4%XW ` }, \
        173  { `return from in6_pcbnotifymtu ` }, \
        174  { `ip6_setexthdroption pcbopts=$D1%XW m0=$D2%XW inp=$D3%XW type=$D4%XW ` }, \
        175  { `return from ip6_setexthdroption with error=$D1%XW` }, \
        176  { `ip6_getexthdroption optname=$D1%XW opts=$D2%XW mp=$D3%XW` }, \
        177  { `return from ip6_getexthdroption with error=$D1%XW` }, \
        178  { `raw6_saveopt p=$D1%XW m=$D2%XW size=$D3%XW type=$D4%XW level=$D5%XW ` }, \
        179  { `return from raw6_saveopt with error ` }, \
        180  { `return from raw6_saveopt with success ` }, \
        181  { `mh6_input` }, \
        182  { `return from mh6_input *mp=$D1%XW return value=$D2%XW` }, \
	183  { `ip6_reroute ro=$D1%XW ip=$D2%XW ifp=$D3%XW mtu=$D4%XW` }, \
	184  { `return from ip6_reroute error=$D1%XW` }, \
	185  { `set_source_filter6 so=$D1%XW imo=$D2%XW imop=$D3%XW sfilter=$D4%XW ifp=$D5%XW` }, \
	186  { `return from set_source_filter6 so=$D1%XW rc=$D2%XW error=$D3%XW` }, \
        200 { `send_hash_len greater than digest hashlen=$D1%XW` }, \
        201 { `send_clic_context rc=$D1%XW`}, \
        202 { `send_clic_shainit rc=$D1%XW`}, \
        203 { `send_hashit_sha   rc=$D1%XW`}, \
        204 { `send_config_inet_clic_init cmd=$D1%XW`}, \
        210 { `cga_param_validation_in cga_param=$D1%XW cga_param_len=$D2%XW ifaddr=$D3%XW`}, \
        211 { `cga_param_validation_collision collision_count=$D1%XW`}, \
        212 { `cga_param_validation_prefix prefix0=$D1%XW prefix1=$D2%XW ifaddr0=$D3%XW ifaddr1=$D4%XW`}, \
        213 { `cga_param_validation_local_cga cga_param_len=$D1%XW`}, \
        214 { `cga_param_validation_hash1 cga_param=$D1%XW cga_param_len=$D2%XW hash0=$D3%XW hash1=$D4%XW`}, \
        215 { `cga_param_validation_hash1_ifid hash0=$D1%XW hash1=$D2%XW ifid0=$D3%XW ifid1=$D4%XW`}, \
        216 { `cga_param_validation_hash2 cga_param_local=$D1%XW cga_param_len=$D2%XW hash0=$D3%XW hash1=$D4%XW`}, \
        217 { `cga_param_validation_hash2_mask2 hash0=$D1%XW hash1=$D2%XW mask0=$D3%XW mask1=$D4%XW`}, \
        218 { `cga_param_validation_out rc=$D1%XW`}, \
        219 { `rsa_sig_generation_in msg=$D1%XW msg_len=$D2%XW max_sig_op_len=$D3%XW private_key=$D4%XW`}, \
        221 { `rsa_sig_generation_keyobj rc=$D1%XW`}, \
        222 { `rsa_sig_generation_local msg_len=$D1%XW`}, \
        223 { `rsa_sig_generation_signed msg_local=$D1%XW msg_len=$D2%XW sig=$D3%XW rsa_sig_len=$D4%XW`}, \
        224 { `rsa_sig_generation_max_len rsa_op_len=$D1%XW max_sig_op_len=$D2%XW`}, \
        225 { `rsa_sig_generation_out rc=$D1%XW`}, \
        226 { `rsa_sig_validation_in msg=$D1%XW msg_len=$D2%XW rsa_sig=$D3%XW public_key=$D4%XW`}, \
        227 { `send_validate_options_failed option=$D1%XW msg_type=$D2%XW`}, \
        228 { `rsa_sig_validation_keyobj key=$D1%XW key_len=$D2%XW rc=$D3%XW `}, \
        229 { `rsa_sig_validation_malloc msglen=$D1%XW`}, \
        230 { `rsa_sig_validation_signature msg=$D1%XW msglen=$D2%XW sig=$D3%XW sig_len=$D4%XW`}, \
        231 { `rsa_sig_validation_signature_out rc=$D1%XW`}, \
        232 { `key_hash_validate_in rsa_sig=$D1%XW keyobj=$D2%XW`}, \
        233 { `key_hash_validate_hash key=$D1%XW key_len=$D2%XW key_hash=$D3%XW`}, \
        234 { `key_hash_validate_out rc=$D1%XW`}, \
        235 { `key_hash_generate_in rsa_sig=$D1%XW keyobj=$D2%XW`}, \
        236 { `key_hash_generate_hash key=$D1%XW key_len=$D2%XW key_hash=$D3%XW`}, \
        237 { `key_hash_generate_out rc=$D1%XW`}, \
        238 { `nonce_validate_in saved_nonce_len=$D1%XW rx_nonce_len=$D2%XW`}, \
        239 { `nonce_validate_failed saved_nonce=$D1%XW saved_len=$D2%XW rx_nonce=$D3%XW rx_len=$D4%XW`}, \
        240 { `nonce_validate_out rc=$D1%XW`}, \
        241 { `nonce_genereate_in nonce=$D1%XW`}, \
        242 { `nonce_genereate_out nonce1=$D1%XW nonce2=$D2%XW`}, \
        243 { `timestamp_validate_in send_option=$D1%XW update_nce=$D2%XW`}, \
        244 { `timestamp_validate_fail TSnew=$D1%XW RDnew=$D2%XW TSlast=$D3%XW RDlast=$D4%XW`}, \
        245 { `timestamp_validate_out rc=$D1%XW`}, \
        246 { `timestamp_generate_in  tx_timestamp=$D1%XW`}, \
        247 { `timestamp_generate_out tx_timestamp1=$D1%XW tx_timestamp2=$D2%XW`}, \
        248 { `send_validate_options_in ip=$D1%XW send_option=$D2%XW update_record=$D3%XW`}, \
        249 { `send_validate_options_invalid_msgtype icmp6_type=$D1%XW`}, \
        250 { `send_validate_options_req option_num=$D1%XW icmp6_type=$D2%XW `}, \
        251 { `send_validate_options_not_allowed option_num=$D1%XW icmp6_type=$D2%XW`}, \
        252 { `send_validate_options_err option_num=$D1%XW icmp6_type=$D2%XW`}, \
        253 { `send_validate_options_opt_undef option_num=$D1%XW`}, \
        254 { `send_validate_options_out rc=$D1%XW update_record=$D2%XW icmp6_type=$D3%XW`}, \
        255 { `send_generate_options_in ip=$D1%XW icmplen=$D2%XW send_option=$D3%XW`}, \
        256 { `send_generate_options_invalid_msgtype icmp6_type=$D1%XW`}, \
        257 { `send_generate_options_opt_undef option_num=$D1%XW`}, \
        258 { `send_generate_options_out rc=$D1%XW icmp6_type=$D2%XW`}, \
        259 { `rx_cga_in op_reqs=$D1%XW ip=$D2%XW send_option=$D3%XW`}, \
        260 { `rx_cga_rs_unsolicited_unspec_address `}, \
        261 { `rx_cga_failed icmp6_type=$D1%XW`}, \
        262 { `rx_cga_out rc=$D1%XW icmp6_type=$D2%XW`}, \
        263 { `rx_rsa_sig_keyobj key_len=$D1%XW`}, \
        264 { `rx_rsa_sig_keylen key_len=$D1%XW`}, \
        265 { `send_extractoptions_trunc icmp6_type=$D1%XW`}, \
        266 { `send_extractoptions_unknown_opt exttype=$D1%XW`}, \
        267 { `send_extractoptions_extlen_icmplen optlen=$D1%XW icmplen=$D2%XW`}, \
        268 { `send_extractoptions_dup_opt option_num=$D1%XW`}, \
        280 { `ip6_ctloutput_sec_send_clic error=$D1%XW`}, \
        281 { `ip6_ctloutput_sec_send_len slen=$D1%XW mlen=$D2%XW error=$D3%XW`}, \
        282 { `ip6_ctloutput_sec_send_no_addr ia=$D1%XW sin=$D2%XW optname=$D3%XW error=$D4%XW`}, \
        283 { `ip6_ctloutput_sec_send_sic_malloc optname=$D1%XW error=$D2%XW`}, \
        284 { `ip6_ctloutput_sec_send_pub_key key_len=$D1%XW error=$D2%XW`}, \
        285 { `ip6_ctloutput_sec_send_priv_key key_len=$D1%XW error=$D2%XW`}, \
        286 { `ip6_ctloutput_sec_send_cga cga_len=$D1%XW error=$D2%XW`}, \
        287 { `ip6_ctloutput_sec_send_no_sic ia=$D1%XW lladdr=$D2%XW error=$D3%XW`}, \
        288 { `ip6_ctloutput_sec_m error=$D1%XW`}, \
        289 { `ip6_ctloutput_sec_mcl error=$D1%XW`}, \
	300 { `if6zone_init`}, \
	301 { `if6zone_attach_in ifp=$D1%XW`}, \
	302 { `if6zone_attach_err rc=$D1%XW`}, \
	303 { `if6zone_attach_out`}, \
	304 { `if6zone_detach_in ifp=$D1%XW`}, \
	305 { `if6zone_detach_err rc=$D1%XW`}, \
	306 { `if6zone_detach_out`}, \
	307 { `if6zone_getzone_in ifp=$D1%XW scope=$D2%XW`}, \
	308 { `if6zone_getzone_err rc=$D1%XW`}, \
	309 { `if6zone_getzone_out`}, \
	310 { `if6zone_setzone_in ifp=$D1%XW scope=$D2%XW zoneid=$D3%XW`}, \
	311 { `if6zone_setzone_err rc=$D1%XW`}, \
	312 { `if6zone_setzone_out`}, \
	313 { `if6zone_lookup_in ifp=$D1%XW addr=$D2%XW`}, \
	314 { `if6zone_lookup_err rc=$D1%XW`}, \
	315 { `if6zone_lookup_out`}, \
	316 { `if6zone_join_zone ifp=$D1%XW scope=$D2%XW zoneid=$D3%XW recursive=$D4%XW`}, \
 	\* { unknown subhook $HD $ERROR }
539 1.0 'PCB' \
 	$HD%D1, \
	0   { `(`G8.0 A8.8`) d1=$D2%XW d2=$D3%XW d3=$D4%XW d4=$D5%XW` }, \
	1   { `add_gateway gateway=$D1%XW` }, \
	2   { `return from add_gateway` }, \
	3   { `clear_ping_flags` }, \
	4   { `return from clear_ping_flags` }, \
	5   { `config_inet cmd=$D1%XW uio=$D2%XW` }, \
	6   { `return from config_inet cmd=$D1%XW error=$D2%XW` }, \
	7   { `del_gateway gateway=$D1%XW` }, \
	8   { `del_gateway_nolock gateway=$D1%XW dec=$D2%XW` }, \
	9   { `return from del_gateway_nolock` }, \
	10   { `return from del_gateway gateway=$D1%XW` }, \
	11   { `dgd_init` }, \
	12   { `return from dgd_init` }, \
	13   { `dgd_input6 m=$D1%XW` }, \
	14   { `return from dgd_input6` }, \
	15   { `dgd_input` }, \
	16   { `return from dgd_input` }, \
	17   { `dgdretry` }, \
	18   { `return from dgdretry` }, \
	19   { `dgdretrysched` }, \
	20   { `return from dgdretrysched` }, \
	21   { `dgdsched` }, \
	22   { `return from dgdsched` }, \
	23   { `in6_addmulti addr=$D1%XW ifp=$D2%XW` }, \
	24   { `return from in6_addmulti return value=$D1%XW` }, \
	25   { `in6_control so=$D1%XW cmd=$D2%XW data=$D3%XW ifp=$D4%XW` }, \
	26   { `return from in6_control so=$D1%XW error=$D2%XW` }, \
	27   { `in6_delete_addrs ifp=$D1%XW` }, \
	28   { `return from in6_delete_addrs ifp=$D1%XW` }, \
	29   { `in6_delmulti inm=$D1%XW` }, \
	30   { `return from in6_delmulti inm=$D1%XW` }, \
	31   { `in6_ifattach ifp=$D1%XW` }, \
	32   { `return from in6_ifattach ifp=$D1%XW error=$D2%XW` }, \
	33   { `in6_ifinit ifp=$D1%XW ia=$D2%XW sin=$D3%XW scrub=$D4%XW` }, \
	34   { `return from in6_ifinit ifp=$D1%XW error=$D2%XW` }, \
	35   { `in6_ifscrub ifp=$D1%XW ia=$D2%XW` }, \
	36   { `return from in6_ifscrub` }, \
	37   { `in6_pcbbind_dyn inp=$D1%XW nam=$D2%XW dyn=$D3%XW` }, \
	38   { `return from in6_pcbbind_dyn error=$D1%XW` }, \
	39   { `in6_pcbbind inp=$D1%XW nam=$D2%XW` }, \
	40   { `in6_pcbbind_nolock_dyn inp=$D1%XW nam=$D2%XW dyn=$D3%XW` }, \
	41   { `return from in6_pcbbind_nolock_dyn inp=$D1%XW error=$D2%XW` }, \
	42   { `in6_pcbbind_nolock inp=$D1%XW nam=$D2%XW` }, \
	43   { `return from in6_pcbbind error=$D1%XW` }, \
	44   { `in6_pcbconnect inp=$D1%XW nam=$D2%XW` }, \
	45   { `in6_pcbconnect_nolock inp=$D1%XW nam=$D2%XW` }, \
	46   { `return from in6_pcbconnect_nolock error=$D1%XW` }, \
	47   { `return from in6_pcbconnect error=$D1%XW` }, \
	48   { `in6_pcblookup head=$D1%XW faddr=$D2%XW fport_arg=$D3%XW laddr=$D4%XW` }, \
	49   { `in6_pcblookup_nolock head=$D1%XW faddr=$D2%XW fport=$D3%XW laddr=$D4%XW` }, \
	50   { `return from in6_pcblookup_nolock match=$D1%XW` }, \
	51   { `return from in6_pcblookup inp=$D1%XW` }, \
	52   { `in6_pcbmatch tablep=$D1%XW faddr=$D2%XW fport=$D3%XW laddr=$D4%XW` }, \
	53   { `return from in6_pcbmatch match=$D1%XW` }, \
	54   { `in6_pcbnotify head=$D1%XW dst=$D2%XW fport_arg=$D3%XW laddr=$D4%XW` }, \
	55   { `return from in6_pcbnotify` }, \
	56   { `in6_pcbrebind inp=$D1%XW af=$D2%XW` }, \
	57   { `return from in6_pcbrebind inp=$D1%XW error=$D2%XW` }, \
	58   { `in6_rtalloc ro=$D1%XW ifa=$D2%XW gidlist=$D3%XW` }, \
	59   { `return from in6_rtalloc` }, \
	60   { `in6_rthost dst=$D1%XW gidlist=$D2%XW` }, \
	61   { `return from in6_rthost rt=$D1%XW` }, \
	62   { `in6_setifa inp=$D1%XW ifa=$D2%XW` }, \
	63   { `return from in6_setifa inp=$D1%XW error=$D2%XW` }, \
	64   { `in_addmulti addr=$D1%XW ifp=$D2%XW` }, \
	65   { `return from in_addmulti addr=$D1%XW return value=$D2%XW` }, \
	66   { `in_allpcbs head=$D1%XW notify=$D2%XW` }, \
	67   { `return from in_allpcbs` }, \
	68   { `in_arpintr nddp=$D1%XW m=$D2%XW hp=$D3%XW` }, \
	69   { `return from in_arpintr nddp=$D1%XW` }, \
	70   { `in_arpresolve ac=$D1%XW m=$D2%XW destip=$D3%XW daddr=$D4%XW` }, \
	71   { `in_control so=$D1%XW cmd=$D2%XW data=$D3%XW ifp=$D4%XW` }, \
	72   { `return from in_control so=$D1%XW cmd=$D2%XW error=$D3%XW` }, \
	73   { `in_delete_addrs ifp=$D1%XW` }, \
	74   { `return from in_delete_addrs ifp=$D1%XW` }, \
	75   { `in_delmulti inm=$D1%XW` }, \
	76   { `return from in_delmulti inm=$D1%XW error=$D2%XW` }, \
	77   { `in_hash_add addr=$D1%XW ifp=$D2%XW broadcast=$D3%XW` }, \
	78   { `return from in_hash_add addr=$D1%XW` }, \
	79   { `in_hash_remove addr=$D1%XW ifp=$D2%XW broadcast=$D3%XW` }, \
	80   { `in_ifattach ifp=$D1%XW` }, \
	81   { `return from in_ifattach ifp=$D1%XW error=$D2%XW` }, \
	82   { `in_ifdetach ifp=$D1%XW` }, \
	83   { `return from in_ifdetach ifp=$D1%XW` }, \
	84   { `in_ifinit ifp=$D1%XW ia=$D2%XW sin=$D3%XW scrub=$D4%XW` }, \
	85   { `return from in_ifinit ifp=$D1%XW error=$D2%XW` }, \
	86   { `in_ifscrub ifp=$D1%XW ia=$D2%XW` }, \
	87   { `in_losing inp=$D1%XW` }, \
	88   { `in_losing_lock inp=$D1%XW` }, \
	89   { `return from in_losing_lock inp=$D1%XW` }, \
	90   { `return from in_losing inp=$D1%XW` }, \
	91   { `in_pcb_hash_del inp=$D1%XW` }, \
	92   { `return from in_pcb_hash_del inp=$D1%XW` }, \
	93   { `in_pcb_hash_ins inp=$D1%XW` }, \
	94   { `return from in_pcb_hash_ins inp=$D1%XW` }, \
	95   { `in_pcb_tcp_hash_del inp=$D1%XW` }, \
	96   { `return from in_pcb_tcp_hash_del inp=$D1%XW` }, \
	97   { `in_pcb_tcp_lport_hash_ins inp=$D1%XW` }, \
	98   { `return from in_pcb_tcp_lport_hash_ins inp=$D1%XW` }, \
	99   { `in_pcballoc so=$D1%XW head=$D2%XW` }, \
	100   { `return from in_pcballoc so=$D1%XW error=$D2%XW` }, \
	101   { `in_pcbbind inp=$D1%XW nam=$D2%XW` }, \
	102   { `in_pcbbind_nolock inp=$D1%XW nam=$D2%XW` }, \
	103   { `return from in_pcbbind_nolock inp=$D1%XW error=$D2%XW` }, \
	104   { `return from in_pcbbind inp=$D1%XW error=$D2%XW` }, \
	105   { `in_pcbconnect inp=$D1%XW nam=$D2%XW` }, \
	106   { `in_pcbconnect_nolock inp=$D1%XW nam=$D2%XW` }, \
	107   { `return from in_pcbconnect_nolock inp=$D1%XW error=$D2%XW` }, \
	108   { `return from in_pcbconnect inp=$D1%XW error=$D2%XW` }, \
	109   { `in_pcbdetach inp=$D1%XW` }, \
	110   { `in_pcbdetach_nolock inp=$D1%XW` }, \
	111   { `return from in_pcbdetach_nolock inp=$D1%XW` }, \
	112   { `return from in_pcbdetach inp=$D1%XW` }, \
	113   { `in_pcbdisconnect inp=$D1%XW` }, \
	114   { `in_pcbdisconnect_nolock inp=$D1%XW` }, \
	115   { `return from in_pcbdisconnect_nolock inp=$D1%XW` }, \
	116   { `return from in_pcbdisconnect inp=$D1%XW` }, \
	117   { `in_pcbfree inp=$D1%XW hv=$D2%XW` }, \
	118   { `in_pcbfree_nolock inp=$D1%XW inp->inp_socket=$D2%XW` }, \
	119   { `return from in_pcbfree_nolock inp=$D1%XW` }, \
	120   { `return from in_pcbfree inp=$D1%XW` }, \
	121   { `in_pcbhashlookup2 tablep=$D1%XW _faddr=$D2%XW fport=$D3%XW _laddr=$D4%XW` }, \
	122   { `return from in_pcbhashlookup2 _faddr=$D1%XW fport=$D2%XW _laddr=$D3%XW lport=$D4%XW` }, \
	123   { `in_pcbhashlookup tablep=$D1%XW faddr=$D2%XW fport=$D3%XW laddr=$D4%XW` }, \
	124   { `in_pcbinit` }, \
	125   { `return from in_pcbinit` }, \
	126   { `in_pcblookup head=$D1%XW faddr=$D2%XW fport=$D3%XW laddr=$D4%XW` }, \
	127   { `in_pcblookup_nolock head=$D1%XW faddr=$D2%XW fport=$D3%XW laddr=$D4%XW` }, \
	128   { `return from in_pcblookup_nolock faddr=$D1%XW fport=$D2%XW laddr=$D3%XW lport=$D4%XW` }, \
	129   { `return from in_pcblookup faddr=$D1%XW fport=$D2%XW laddr=$D3%XW lport=$D4%XW` }, \
	130   { `in_pcbmatch tablep=$D1%XW faddr=$D2%XW fport=$D3%XW laddr=$D4%XW` }, \
	131   { `return from in_pcbmatch faddr=$D1%XW fport=$D2%XW laddr=$D3%XW lport=$D4%XW` }, \
	132   { `in_pcbmovetotimewait inp=$D1%XW` }, \
	133   { `return from in_pcbmovetotimewait inp=$D1%XW` }, \
	134   { `in_pcbnotify head=$D1%XW dst=$D2%XW fport=$D3%XW p_laddr=$D4%XW` }, \
	135   { `return from in_pcbnotify` }, \
	136   { `in_pcbnotifyall head=$D1%XW dst=$D2%XW errno=$D3%XW notify=$D4%XW` }, \
	137   { `return from in_pcbnotifyall` }, \
	138   { `in_rawpcbs` }, \
	139   { `return from in_rawpcbs` }, \
	140   { `in_rtchange inp=$D1%XW i=$D2%XW` }, \
	141   { `return from in_rtchange` }, \
	142   { `in_rtinvalidate` }, \
	143   { `return from in_rtinvalidate` }, \
	144   { `in_setpeeraddr inp=$D1%XW nam=$D2%XW af=$D3%XW` }, \
	145   { `in_setsockaddr inp=$D1%XW nam=$D2%XW af=$D3%XW` }, \
	146   { `init_common_mtus` }, \
	147   { `mark_gateway_down` }, \
	148   { `return from mark_gateway_down` }, \
	149   { `ping_gateways` }, \
	150   { `return from ping_gateways` }, \
	151   { `ping_one_gateway gw=$D1%XW` }, \
	152   { `return from ping_one_gateway error=$D1%XW` }, \
	153   { `set_ping_flag` }, \
	154   { `return from set_ping_flag` }, \
	155   { `tcp_bad_port_limit_init *newvalp=$D1%XW nop=$D2%XW` }, \
	156   { `tcp_sendspace_change value=$D1%XW nop=$D2%XW` }, \
	157   { `udp_bad_port_limit_init *newvalp=$D1%XW nop=$D2%XW` }, \
	158   { `udp_sendspace_change value=$D1%XW nop=$D2%XW` }, \
	159   { `in_pcbbind_nolock len=$D1%XW family=$D2%XW port=$D3%XW addr=$D4%XW` }, \
	160   { `in6_pcbbind_nolock_dyn len=$D1%XW family=$D2%XW port=$D3%XW flowinfo=$D4%XW scope_id=$D5%XW` }, \
	161   { `in6_pcbbind_nolock_dyn addr[0]=$D1%XW addr[1]=$D2%XW addr[2]=$D3%XW addr[3]=$D4%XW` }, \
	162   { `in_pcb_pseudoconnect inp=$D1%XW nam=$D2%XW info=$D3%XW` }, \
	163   { `return from in_pcb_pseudoconnect inp=$D1%XW error=$D2%XW` }, \
	164   { `in_pcb_pseudobind inp=$D1%XW nam=$D2%XW info=$D3%XW` }, \
	165   { `return from in_pcb_pseudobind inp=$D1%XW error=$D2%XW` }, \
	166   { `in_pcb_pseudobind len=$D1%XW family=$D2%XW port=$D3%XW addr=$D4%XW` }, \
	167   { `in6_pcb_pseudoconnect inp=$D1%XW nam=$D2%XW info=$D3%XW` }, \
	168   { `return from in6_pcb_pseudoconnect inp=$D1%XW error=$D2%XW` }, \
	169   { `in6_pcb_pseudobind inp=$D1%XW nam=$D2%XW info=$D3%XW` }, \
	170   { `return from in6_pcb_pseudobind inp=$D1%XW error=$D2%XW` }, \
	171   { `in6_pcb_pseudobind len=$D1%XW family=$D2%XW port=$D3%XW flowinfo=$D4%XW scope_id=$D5%XW` }, \
	172   { `in6_pcb_pseudobind addr[0]=$D1%XW addr[1]=$D2%XW addr[2]=$D3%XW addr[3]=$D4%XW` }, \
	173   { `in6_pcb_pseudorebind inp=$D1%XW nam=$D2%XW info=$D3%XW` }, \
	174   { `return from in6_pcb_pseudorebind inp=$D1%XW error=$D2%XW` }, \
        176   { `in6_pcbnotifyall head=$D1%XW src=$D2%XW dst=$D3%XW errno=$D4%XW notify=$D5%XW` }, \
        177   { `return successfully from in6_pcbnotifyall ` }, \
        178   { `return with error from in6_pcbnotifyall ` }, \
        179   { `in6_setmss inp=$D1%XW ` }, \
        180   { `return from in6_setmss ` }, \
        181   { `in6_pmtuclone inp=$D1%XW ` }, \
        182   { `return from in6_pmtuclone ` }, \
	183   { `in_pcblocalipnotify head=$D1%XW dst=$D2%XW errno=$D3%XW notify=$D4%XW` }, \
        184   { `return from in_pcblocalipnotify` }, \
	185   { `inet_dr_cpu_add cpu=$D1%DW` }, \
	186   { `return from inet_dr_cpu_add cpu=$D1%DW` }, \
	187   { `inet_dr_cpu_add error1 error=$D1%DW` }, \
	188   { `in_arpresolve_out1` }, \
	189   { `in_arpresolve_out2` }, \
	190   { `config_inet erro1 cmd=$D1%DW error=$D2%DW` }, \
	191   { `in_pcbdetach_soputonfreelist so=$D1%XW` }, \
	192   { `pmignet_hd_in32 event=$D1%XW action=$D2%DW$D3%DW dri=$D4%XW` }, \
	193   { `pmignet_hd_in64 event=$D1%XW action=$D2%DW dri=$D3%XW` }, \
	194   { `pmignet_hd_out32 event=$D1%XW action=$D2%DW$D3%DW dri=$D4%XW` }, \
	195   { `pmignet_hd_out64 event=$D1%XW action=$D2%DW dri=$D3%XW` }, \
	196   { `pmignet_tx_in trb=$D1%XW` }, \
	197   { `pmignet_tx_sa_family family=$D1%DW` }, \
	198   { `pmignet_tx_out selfarp_count=$D1%DW` }, \
	199   { `pmignet_hd_enomen` }, \
	200   { `pmignet_register_ext rc=$D1%DW` }, \
	201   { `in_addmulti_sources ifp=$D1%DW inm=$D2%DW, sinfo=$D3%DW, mode=$D4%DW, mcastaddr=$D5%DW` }, \
	202   { `return from in_addmulti_sources inm=$D1%DW, sinfo=$D2%DW` }, \
	203   { `in_changemulti_sources_nolock inm=$D1%DW, sinfo=$D2%DW, mode=$D3%DW, numsrc=$D4%DW, srclist=$D5%DW` }, \
	204   { `return from in_changemulti_sources_nolock rp=$D1%DW` }, \
	205   { `in6_addmulti_sources ifp=$D1%DW inm=$D2%DW, sinfo=$D3%DW, mode=$D4%DW` }, \
	206   { `return from in6_addmulti_sources inm=$D1%DW, sinfo=$D2%DW` }, \
	207   { `in6_changemulti_sources_nolock inm=$D1%DW, sinfo=$D2%DW, mode=$D3%DW, numsrc=$D4%DW, srclist=$D5%DW` }, \
	208   { `return from in6_changemulti_sources_nolock rp=$D1%DW` }, \
        212   { `in_pcbbind error9 inp=$D1%XW error=$D2%DW` }, \
 	\* { unknown subhook $HD $ERROR }
59B 1.1 "@JFS2: userdata" \
{{ buftrace(what, bufword, blkdesc) `JFS2 IO $what: $bufword = $D1, vp = $D2, sid = $D3, $blkdesc blk = $D4, bcount = $D5` }} \
{{ vpsid(what) `JFS2 IO $what: vp = $D1, sid = $D2` }} \
{{ int64(x) $HOOKENV, 64 { O4 {{ $high = X4 }} {{ $high = $high * 0x100000000 }} O4 {{ $low = X4 }} {{ $high = $high + $low  }} $high%X8 }, 32 { X8 } }} \
        $HD, \
        0x01 { `JFS2 IO READ: pagerCopyOut_rc=$D1` $BREAK }, \
        0x02 { `JFS2 IO WRITE: pagerCopyIn_rc=$D1` $BREAK }, \
        0x03 { `JFS2 DIO DEMOTED: direct_mode=$D1, bad_alignment=$D2, vm_uiomove_rc=$D3, vm_flushp_rc=$D4` $BREAK }, \
        0x04 { `JFS2 DEVSTRAT: bufptr=$D1, call_flags=$D2, io_type=$D3` $BREAK }, \
	0x05 { `JFS2 IO read: vp = $D1, sid = $D2, offset = ` W3 int64()`, length = $D5` }, \
	0x06 { `JFS2 IO write: vp = $D1, sid = $D2, offset = ` W3 int64()`, length = $D5` }, \
	0x07 { buftrace('gather', 'bp', 'file') }, \
	0x08 { buftrace('pageOut', 'bplist', 'file') }, \
	0x09 { buftrace('pageIn', 'bplist', 'file') }, \
	0x0A { buftrace('pageProtect', 'bplist', 'file') }, \
	0x0B { buftrace('devstrat (pager strategy)', 'bplist', 'lv') }, \
	0x0C { buftrace('devstrat (pager service)', 'bplist', 'lv') }, \
	0x0D { buftrace('io not done', 'bplist', 'file') }, \
	0x0E { vpsid('exception') }, \
	0x0F { `JFS2 IO dio move: vp = $D1, sid = $D2, offset = ` W3 int64()`, length = $D5` }, \
	0x10 { `JFS2 IO dio demoted: vp = $D1, mode = $D2, bad = $D3, rc = $D4, rc2 = $D5` }, \
	0x11 { buftrace('dio devstrat', 'bplist', 'lv') }, \
	0x12 { `JFS2 IO dio iodone: bp = $D1, vp = $D2, sid = $D3` }, \
	0x13 { `JFS2 IO dio error: bp = $D1, b_error = $D2, b_resid = $D3, request offset = $D4, error offset= $D5` }, \
	0x14 { `JFS2 IO pagerBind: vp = $D1, sid = $D2, rc = $D3` }, \
	0x15 { `JFS2 IO readahead: vp = $D1, sid = $D2, offset = $D3, length = $D4, trust = ` W6 R4 X1` fault = ` X1` prer = ` X1` decision = `X1 }, \
	0x16 { vpsid('dio flag cleared (j2_open)') }, \
	0x17 { vpsid('dio flag set (j2_open)') }, \
	0x18 { vpsid('dio flag cleared (j2_close)') }, \
	0x19 { vpsid('dio flag set (j2_close)') }, \
	0x1A { vpsid('dio flag cleared (j2_map)') }, \
	0x1B { vpsid('dio flag set (j2_map)') }, \
	0x1C { `JFS2 IO encrypt : gatherHead = $D1, vp = $D2, memoryObject = $D3, b_blkno = $D4, b_bcount = $D5` }, \
	0x1D { `JFS2 IO decrypt : bp = $D1, vp = $D2, memoryObject = $D3, b_blkno = $D4, b_bcount = $D5` }, \
	0x1E { `JFS2 IO EFS iodone : bpList = $D1, vp = $D2, memoryObject = $D3, b_blkno = $D4, b_bcount = $D5` }, \
	0x1F { `JFS2 IO PGTHREAD : where = $D1, rc = $D2` }, \
	0x20 { `JFS2 IO ISYNC : where = $D1, vp = $D2, memoryObject = $D3, jCacheClassLow = $D4, po_nPageLock = $D5` }, \
	\*   { 59B unknown subhook: subhook=$HD D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
59C 1.1 L=KERN "@JFS2: direct IO (deprecated, use 59B)" \
        $HD, \
        0x01 { `JFS2 DIO CLEAR: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x02 { `JFS2 DIO SET: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x03 { `JFS2 DIO READ: diomove_rc=$D1` $BREAK }, \
        0x04 { `JFS2 DIO WRITE: diomove_rc=$D1` $BREAK }, \
        0x05 { `JFS2 DIO MOVE: inodeptr=$D1, segment=$D2, uio_offset_shift32=$D3, uio_offset=$D4, length=$D5` $BREAK }, \
        0x06 { `JFS2 DIO DONE: dev=$D1, blkno=$D2, bcount=$D3, options=$D4` $BREAK }, \
        0x07 { `JFS2 DIO DONE ERROR: error=$D1, words_not_transfer=$D2, dio_offset=$D3, error_offset=$D4` $BREAK }, \
	0x1001 { `JFS2 CLOSE DIO CLEAR: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x1002 { `JFS2 CLOSE DIO SET: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x2001 { `JFS2 OPEN DIO CLEAR: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x2002 { `JFS2 OPEN DIO SET: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x3001 { `JFS2 MAP DIO CLEAR: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x3002 { `JFS2 MAP DIO SET: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x4001 { `JFS2 UNMAP DIO CLEAR: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        0x4002 { `JFS2 UNMAP DIO SET: inodeptr=$D1, segment=$D2%X4` $BREAK }, \
        \*  { `unknown subhook` }
5A0 1.0 "@sysldr/mods   " \
	W2 \
	$D1, \
	0x01	{ "ld_loadmodule: file="prargs($HL) }, \
	0x02	{ "               libpath="prargs($HL) }, \
	0x03	{ "               le="$D2%XW "loadcount="$D3%XW "usecount="$D4%XW }, \
	0x20	{ "unload_module: "prargs($HL) "shared library PURGE"}, \
	0x30	{ "unload_module: le="$D2%XW "loadcount="$D3%XW "usecount="$D4%XW }, \
	0x50	{ "libraries: pre_libpath="prargs($HL) }, \
	0x51	{ "libraries: libpath="prargs($HL) }, \
	0x52	{ "libraries: file="prargs($HL) }, \
	0x70	{ "ld_get_domain: ld->ld_name="prargs($HL) }, \
	0x71	{ "ld_clean_domain: de->de_fullname="prargs($HL) }, \
	0x72	{ "ld_unload_domain: ld->ld_name="prargs($HL) }, \
	0x80	{ "ld_unload_le: file="prargs($HL) }, \
	0x81	{ "ld_unload_le: le="$D2%XW  "le->le_file="$D3%XW }, \
	0x150	{ "                             le_filename="prargs($HL) }, \
	0x151	{ "ld_shlap(updating loadlist): le="$D2%XW }, \
	0x152	{ "                                  le_filename="prargs($HL) }, \
	0x153	{ "ld_libgettext(updating loadlist): le="$D2%XW }, \
	0x154	{ "                             le_filename="prargs($HL) }, \
	0x155	{ "ld_libld(updating loadlist): le="$D2%XW }, \
	0x156	{ "                               le_filename="prargs($HL) }, \
	0x157	{ "ld_sroinst(updating loadlist): le="$D2%XW }, \
	0x158	{ "                                le_filename="prargs($HL) }, \
	0x159	{ "ld_instance(updating loadlist): le="$D2%XW }, \
	\*	{ "unknown subhookid="$D1%D1 }
5A1 1.0 "@load/kxent" \
        W2 \
	$D1, \
        0x01	{ "kmod_load: file="prargs($HL) }, \
        0x02	{ "kmod_load: libpath="prargs($HL) }, \
        0x03    { "kmod_unload: file="prargs($HL) }, \
        0x04	{ "kmod_load: le"=$D2%XW  "loadcount="$D3%D1  "usecount="$D4%D1 }, \
	0x05	{ "kmod_unload: le"=$D2%XW  "loadcount="$D3%D1  "usecount="$D4%D1 }, \
	0x90	{ "kmod_load(test_hook): Enter kmod_load flags="$D2%XW }, \
	\*      { "unknown subhookid="$D1%D1 }
5A2 1.0 "@sysldr/execld" \
	W2 \
	$D1, \
	0x01	{ "ld_execload: file="prargs($HL) }, \
	0x02	{ "             pid"=prKernelPID($D2) }, \
	0x03	{ "             la_lib_text_sid"=$D2%XW "la_lib_data_sid="$D3%XW "la_lib_le_sid="$D4%XW}, \
	\*      { "unknown subhookid="$D1%D1 }
5A3 1.0 "sysldr/errs: " \
	W2 \
	$D1, \
	0x01	{ "loadmodule: rc"=$D2%D1 "reason="$D3%D1 }, \
	0x02	{ "kmod_load: reason="$D2%D1 }, \
	0x03	{ "kmod_unload: rc="$D2%D1 }, \
	0x04	{ "execload: pid="$D2%D1  "rc="$D3%D1  "reason"=$D4%D1}, \
	0x05	{ "ld_get_domain: FAILED! path_buf="prargs($HL) }, \
	0x06	{ "ld_resolve_error: symbol number="prargs($HL) }, \
	0x07	{ "                  reason"=$D2%D1 }, \
	0x08	{ "relocate_error: LDREL["$D2%D4"].l_vaddr="$D3%XW }, \
	0x0b	{ "    member: "prargs($HL) }, \
	0x0c	{ "    file:   "prargs($HL) }, \
	0x0d	{ "    import file:   "prargs($HL) }, \
	0x0e	{ "    export symbol: "prargs($HL) }, \
	0x0f	{ "    symbol: "prargs($HL) }, \
	0x10	{ "ld_hashfind: line "$D2%DW": too many errors" }, \
	0x11	{ "ld_hashfind: line "$D2%DW }, \
	0x12	{ "ld_rtl_buildSearchlist: line "$D2%DW": le = 0x"$D3%XW": failed to allocate "$D4 element list }, \
	0x13	{ "ld_rtl_initLE: line "$D2%DW }, \
	0x14	{ "ld_rtl_initLE: line "$D2%DW": ld_rtl_allocDynlist returned "$D3%DW }, \
	0x15	{ "ld_rtl_initLE: line "$D2%DW": ld_rtl_buildSearchlist returned "$D3%DW }, \
	0x16	{ "ld_rtl_initLE: line "$D2%DW": ld_rtl_addLEtoDynlist returned "$D3%DW }, \
	0x17	{ "ld_rtl_initLE: line "$D2%DW": ld_rtl_allocSearchlist returned "$D3%DW }, \
	0x18	{ "ld_search_hashfind: line "$D2%DW": le = 0x"$D3%XW": unresolved deferred" }, \
	0x19	{ "ld_search_hashfind: line "$D2%DW": le = 0x"$D3%XW": typecheck error" }, \
	0x1a	{ "ld_postpass_hashfind: line "$D2%DW": unresolved" }, \
	0x1b	{ "ld_postpass_resolve: line "$D2%DW": ignored RTL" }, \
	0x1c	{ "ld_postpass_resolve: line "$D2%DW": unexpected TLS" }, \
	0x1d	{ "ld_postpass_resolve: line "$D2%DW": no match for XO" }, \
	0x1e	{ "ld_postpass_resolve: line "$D2%DW": unresolved dotdot" }, \
	0x1f	{ "ld_postpass_resolve: line "$D2%DW": unresolved preload" }, \
	0x20	{ "ld_postpass: line "$D2%DW": le = 0x"$D3%XW": failed to allocate "$D4%DW new deltas }, \
	0x21	{ "ld_postpass: line "$D2%DW": le = 0x"$D3%XW": ld_postpass_resolve returned "$D4%DW }, \
	0x22	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": failed to allocate deltas for "$D4%DW symbols }, \
	0x23	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": l_offset = 0x"$D4%XW", l_stlen = 0x"$D5%XW }, \
	0x24	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": l_parm = 0x"$D4%XW", l_stlen = 0x"$D5%XW }, \
	0x25	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": ifile = "$D4", lexp->nimpid = "$D5%DW }, \
	0x26	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": deferred symbol in kernel" }, \
	0x27	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": ld_deferred failed" }, \
	0x28	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": TLS symbol in kernel" }, \
	0x29	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": too many resolution errors" }, \
	0x2a	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": error resolving TLS" }, \
	0x2b	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": error resolving SVC" }, \
	0x2c	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": XO symbol does not match" }, \
	0x2d	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": unresolved" }, \
	0x2e	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": bad section l_scnum = "$D4%DW }, \
	0x2f	{ "ld_resolve1: line "$D2%DW": le = 0x"$D3%XW": no exports" }, \
	0x30	{ "ld_resolve: line "$D2%DW": le = 0x"$D3%XW": ld_rtl_initLE failed" }, \
	0x31	{ "ld_resolve: line "$D2%DW": le = 0x"$D3%XW": deferred import/export" }, \
	0x32	{ "ld_resolve: line "$D2%DW": le = 0x"$D3%XW": resolve error" }, \
	0x33	{ "ld_resolve: line "$D2%DW": le = 0x"$D3%XW": ld_postpass failed" }, \
	0x34	{ "ld_resolve: line "$D2%DW": le = 0x"$D3%XW": RTL error" }, \
	0x35	{ "ld_resolve: line "$D2%DW": le = 0x"$D3%XW": AIX-style-linking error" }, \
	0x36	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": l_rsecnm = "$D4%DW }, \
	0x37	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": l_vaddr = 0x"$D4%XW }, \
	0x38	{ "ld_relocate1: line "$D2%DW": rtype = "$D3", rv = 0x"$D4%XW", tls_ref = 0x"$D5%XW }, \
	0x39	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": rtype = "$D4%DW }, \
	0x3a	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": sect_offset = 0x"$D4%XW", sect_size = 0x"$D5%XW }, \
	0x3b	{ "ld_relocate1: line "$D2%DW": sect_offset = 0x"$D3%XW", rsize = 0x"$D4%XW", sect_size = 0x"$D5%XW }, \
	0x3c	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": reference to local TLS symbol" }, \
	0x3d	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": local TLS symbol imported from" }, \
	0x3e	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": reference to TLS symbol exported by" }, \
	0x3f	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": reference to TLS imported symbol" }, \
	0x40	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW" - unexpected TLS relocation type "$D4%DW }, \
	0x41	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW" - bad relocation type "$D4%DW }, \
	0x42	{ "ld_relocate1: line "$D2%DW": le = 0x"$D3%XW": tls_rld = "$D4%DW", tls_ref = "$D5%DW }, \
	0x43	{ "ld_relocate: line "$D2%DW": le = 0x"$D3%XW": ld_relocate1 returned = "$D4%DW }, \
	0x44	{ "ld_resolveredo: line "$D2%DW": le = 0x"$D3%XW": failed to allocate deltas for "$D4%DW symbols }, \
	0x45	{ "ld_resolveredo: line "$D2%DW": le = 0x"$D3%XW": l_offset = 0x"$D4%XW", l_stlen = 0x"$D5%XW }, \
	0x46	{ "ld_resolveredo: line "$D2%DW": le = 0x"$D3%XW": l_parm = 0x"$D4%XW", l_stlen = 0x"$D5%XW }, \
	0x47	{ "ld_resolveredo: line "$D2%DW": le = 0x"$D3%XW": l_smclas = 0x"$D4%XW", tls_sym = "$D5%DW }, \
	0x48	{ "ld_resolveredo: line "$D2%DW": le = 0x"$D3%XW": hashfindrc = "$D4%DW }, \
	0x49	{ "ld_redo1: line "$D2%DW": le = 0x"$D3%XW": ld_resolveredo returned "$D4%DW }, \
	0x4a	{ "ld_redo1: line "$D2%DW": le = 0x"$D3%XW": ld_relocate1 returned "$D4%DW }, \
	0x4b	{ "ld_redo: line "$D2%DW": le = 0x"$D3%XW": ld_redo1 returned "$D4%DW }, \
	0x4c	{ "ld_bind: line "$D2%DW": le = 0x"$D3%XW": ld_redo1 returned "$D4%DW }, \
	0x4d	{ "ld_kbuildhash: line "$D2%DW": numexports = "$D3%DW }, \
	0x60	{ "Failed to allocate "$D3%DW" bytes at location "$D2%DW }, \
	0x61	{ "ld_libraries0: line "$D2%DW": get_libpath returned "$D3%DW }, \
	0x62	{ "ld_libraries0: line "$D2%DW": execle = 0x"$D3%XW }, \
	0x63	{ "ld_getmod0: line "$D2%DW": ld_read returned 0" }, \
	0x64	{ "ld_getkext0: line "$D2%DW": ld_pathopen returned 0" }, \
	0x65 	{ "ld_getkext0: line "$D2%DW": ld_kernelld returned 0" }, \
	0x66	{ "ld_getkext0: line "$D2%DW": le = 0x"$D3%XW": ld_get_depends returned "$D4%DW }, \
	0x67	{ "ld_libgettext: line "$D2%DW": ld_textread returned "$D3%DW }, \
	0x68	{ "ld_privgettext: line "$D2%DW": ld_textread returned "$D3%DW }, \
	0x69	{ "ld_lib_getsvcfd: line "$D2%DW": ld_svcfdcreate returned "$D3%DW }, \
	0x6a	{ "ld_lib_getsvcfd: line "$D2%DW": shlap_rr returned "$D3%DW }, \
	0x6b	{ "ld_priv_getsvcfd: line "$D2%DW": ld_svcfdcreate returned "$D3%DW }, \
	0x6c	{ "ld_getsvcfd: line "$D2%DW": ld_lib_getsvcfd failed because of reason = "$D3%DW }, \
	0x6d	{ "ld_getlibread: line "$D2%DW": ld_privgettext returned NULL" }, \
	0x6e	{ "ld_getlibread: line "$D2%DW": le = 0x"$D3%XW": ld_dinstance returned NULL" }, \
	0x6f	{ "ld_kernelld: line "$D2%DW": ld_ktextread returned "$D3%DW }, \
	0x70	{ "ld_privinstance: line "$D2%DW": ld_getsvcfd returned NULL" }, \
	0x71	{ "ld_instance: line "$D2%DW": ld_getsvcfd returned NULL" }, \
	0x72	{ "ld_instance: line "$D2%DW": ld_dup_libdeferred returned "$D3%DW }, \
	0x73	{ "ld_instance: line "$D2%DW": ld_domain_add returned NULL" }, \
	0x74	{ "ld_getlib: line "$D2%DW": ld_pathopen returned NULL" }, \
	0x75	{ "ld_getlib: line "$D2%DW": depends on the main executable" }, \
	0x76	{ "ld_getlib: line "$D2%DW": le = 0x"$D3%XW": ld_get_depends returned "$D4%DW }, \
	0x77	{ "ld_get_depends_from_impids: line "$D2%DW": le = 0x"$D3%XW": truncated impids" }, \
	0x78	{ "ld_get_depends_from_impids: line "$D2%DW": le = 0x"$D3%XW": dotdot symbol" }, \
	0x79	{ "ld_get_depends_from_impids: line "$D2%DW": le = 0x"$D3%XW": import from main" }, \
	0x7a	{ "ld_get_depends: line "$D2%DW": le = 0x"$D3%XW": truncated impids" }, \
	0x7b	{ "ld_get_depends: line "$D2%DW": le = 0x"$D3%XW": ld_get_depends_from_impids returned "$D4%D1 }, \
	0x7c	{ "ld_read: line "$D2%DW": ld_getlib returned NULL" }, \
	0x7d	{ "ld_read: line "$D2%DW": le = 0x"$D3%XW": ld_get_depends returned "$D4%DW }, \
	0x7e	{ "ld_read: line "$D2%DW": le = 0x"$D3%XW": ld_libld_scc returned "$D4%DW }, \
	0x7f	{ "ld_read: line "$D2%DW": le = 0x"$D3%XW": ld_priv_instances returned "$D4%DW }, \
	0x80	{ "ld_read: line "$D2%DW": le = 0x"$D3%XW": ld_getsvcfd returned "$D4%DW }, \
	0x81	{ "ld_priv_instances: line "$D2%DW": le = 0x"$D3%XW": ld_privinstance returned NULL" }, \
	0x82	{ "process_scc: line "$D2%DW": make_prereloc returned "$D3%DW }, \
	0x83	{ "process_scc: line "$D2%DW": ld_instance returned "$D3%DW }, \
	0x84	{ "search: line "$D2%DW": process_scc returned "$D3%DW }, \
	0x85	{ "ld_libld_scc: line "$D2%DW": le = 0x"$D3%XW": search returned "$D4%DW }, \
	0x86	{ "make_prereloc: line "$D2%DW": le = 0x"$D3%XW": ld_lib_getsvcfd returned NULL" }, \
	0x87	{ "make_prereloc: line "$D2%DW": le = 0x"$D3%XW": ld_libinstance returned NULL" }, \
	0x88	{ "make_prereloc: line "$D2%DW": le = 0x"$D3%XW": ld_resolve returned "$D4%DW }, \
	0x89	{ "make_prereloc: line "$D2%DW": le = 0x"$D3%XW": ld_relocate returned "$D4%DW }, \
	0x8a	{ "make_prereloc: line "$D2%DW": shlap died" }, \
	0x8b	{ "make_prereloc: line "$D2%DW": shlap_rr returned "$D3%DW }, \
	0x8c	{ "ld_textorg_newsid: line "$D2%DW": vms_createx_attach returned "$D3%DW }, \
	0x8d	{ "ld_retext_sid: line "$D2%DW": len = "$D3%DW }, \
	0x8e	{ "ld_retext_sid: line "$D2%DW": read "$D3%DW out of $D4%DW bytes }, \
	0x8f	{ "ld_retext_sid: line "$D2%DW": fp_pread returned "$D3%DW }, \
	0x90	{ "ld_retext: line "$D2%DW": fp_fstat returned "$D3%DW }, \
	0x91	{ "ld_retext: line "$D2%DW": ld_sanity64 returned "$D3%DW }, \
	0x92	{ "ld_retext: line "$D2%DW": ld_sanity32 returned "$D3%DW }, \
	0x93	{ "ld_retext: line "$D2%DW": no entry point" }, \
	0x94	{ "ld_retext: line "$D2%DW": file size 0x"$D3%XW too large }, \
	0x95	{ "ld_retext: line "$D2%DW": ld_textorg_newsid returned "$D3%DW", flag64 = "$D4%DW }, \
	0x96	{ "ld_retext: line "$D2%DW": ld_retext_sid returned "$D3%DW", flag64 = "$D4%DW }, \
	0x97	{ "ld_untext: line "$D2%DW": invalid operand - "$D3%DW }, \
	0xb0	{ "ld_allocd: line "$D2%DW": found no fit" }, \
	0xb1	{ "ld_allocd: line "$D2%DW": lgp_sbrk32 returned SBRK_FAILED" }, \
	0xb2	{ "gettext: line "$D2%DW": ld_sanity32 returned "$D3%DW }, \
	0xb3	{ "ld_textread: line "$D2%DW": ld_mapfile returned "$D3%DW }, \
	0xb4	{ "ld_textread: line "$D2%DW": archive member not found" }, \
	0xb5	{ "ld_textread: line "$D2%DW": ld_sanity32 returned "$D3%DW }, \
	0xb6	{ "ld_textread: line "$D2%DW": ld_textalloc32(asize = 0x"$D3%XW", flags = "$D4%DW") returned NULL" }, \
	0xb7	{ "ld_textread: line "$D2%DW": address 0x"$D3%XW is not aligned properly }, \
	0xb8	{ "ld_textread: line "$D2%DW": read_file_private(flag = "$D3%DW", filesize = 0x"$D4%XW") returned "$D5%DW }, \
	0xb9	{ "ld_textread: line "$D2%DW": read_file_shared32(filesize = 0x"$D3%XW") returned "$D4%DW }, \
	0xba	{ "slow_map_big_exec: line "$D2%DW": ld_create_exec_seg(ne_psize = 0x"$D3%XW") returned "$D4%DW }, \
	0xbb	{ "slow_map_big_exec: line "$D2%DW": map_file_exec(len = 0x"$D3%XW") returned "$D4%DW }, \
	0xbc	{ "slow_map_big_exec: line "$D2%DW": read_file_exec(len = 0x"$D3%XW") returned "$D4%DW }, \
	0xbd	{ "slow_map_big_exec: line "$D2%DW": map_file_exec(offset_in_file = 0x"$D3%XW", len = 0x"$D4%XW") returned "$D5%DW }, \
	0xbe	{ "slow_map_big_exec: line "$D2%DW": read_file_exec(offset_in_file = 0x"$D3%XW", len = 0x"$D4%XW") returned "$D5%DW }, \
	0xbf	{ "slow_map_big_exec: line "$D2%DW": I/O error rc = "$D3%DW }, \
	0xc0	{ "slow_map_huge_exec: line "$D2%DW": ld_create_exec_seg(ne_psize = 0x"$D3%XW") returned "$D4%DW }, \
	0xc1	{ "slow_map_huge_exec: line "$D2%DW": map_file_exec(len = 0x"$D3%XW") returned "$D4%DW }, \
	0xc2	{ "slow_map_huge_exec: line "$D2%DW": read_file_exec(len = 0x"$D3%XW") returned "$D4%DW }, \
	0xc3	{ "slow_map_huge_exec: line "$D2%DW": map_file_exec(offset_in_file = 0x"$D3%XW", len = 0x"$D4%XW") returned "$D5%DW }, \
	0xc4	{ "slow_map_huge_exec: line "$D2%DW": read_file_exec(offset_in_file = 0x"$D3%XW", len = 0x"$D4%XW") returned "$D5%DW }, \
	0xc5	{ "slow_map_huge_exec: line "$D2%DW": I/O error rc = "$D3%DW }, \
	0xd0	{ "gettext64: line "$D2%DW": ld_mapfile returned "$D3%DW }, \
	0xd1	{ "gettext64: line "$D2%DW": ld_sanity64 returned "$D3%DW }, \
	0xd2	{ "gettext64: line "$D2%DW": file size 0x"$D3%XW is too big }, \
	0xd3	{ "ld_textread64: line "$D2%DW": ld_mapfile returned "$D3%DW }, \
	0xd4	{ "ld_textread64: line "$D2%DW": archive member not found" }, \
	0xd5	{ "ld_textread64: line "$D2%DW": file is not an archive" }, \
	0xd6	{ "ld_textread64: line "$D2%DW": ld_sanity64 returned "$D3%DW }, \
	0xd7	{ "ld_textread64: line "$D2%DW": ld_textalloc64(asize = 0x"$D3%XW", flags = "$D4%DW") returned "$D5%DW }, \
	0xd8	{ "ld_textread64: line "$D2%DW": map_file(v = 0x"$D3%XW", asize = 0x"$D4%XW") returned "$D5%DW }, \
	0xd9	{ "ld_textread64: line "$D2%DW": map_file_shared64(v = 0x"$D3%XW", asize = 0x"$D4%XW") returned "$D5%DW }, \
	0xda	{ "ld_textread64: line "$D2%DW": read_file_private(v + page_offset = 0x"$D3%XW", ufilesize = 0x"$D4%XW") returned "$D5%DW }, \
	0xdb	{ "ld_textread64: line "$D2%DW": read_file_shared64(v + page_offset = 0x"$D3%XW", ufilesize = 0x"$D4%XW") returned "$D5%DW }, \
	0xdc	{ "slow_map_npt_exec64: line "$D2%DW": ld_create_exec_seg(ne_psize = 0x"$D3%XW") returned "$D4%DW }, \
	0xdd	{ "slow_map_npt_exec64: line "$D2%DW": map_file_exec(len = 0x"$D3%XW") returned "$D4%DW }, \
	0xde	{ "slow_map_npt_exec64: line "$D2%DW": read_file_exec(len = 0x"$D3%XW") returned "$D4%DW }, \
	0xf0	{ "ld_syscall: line "$D2%DW": ld_kbuildhash(oldexports = "$D3%DW") returned NULL" }, \
	0xf1	{ "ld_syscall: line "$D2%DW": allocate_deltas_k(nsyms = "$D3%DW") returned NULL" }, \
	0xf2	{ "ld_syscall: line "$D2%DW": ld_kbuildhash(newexports = "$D3%DW") returned NULL" }, \
	0xf3	{ "ld_svcfdcreate: line "$D2%DW": ld_textalloc(size = 0x"$D3%XW") returned NULL" }, \
	0xf4	{ "ld_svcfdcreate: line "$D2%DW": copy_to_private(v = 0x"$D3%XW", size = 0x"$D4%XW") returned "$D5%DW }, \
	0xf5	{ "ld_svcfdcreate: line "$D2%DW": copy_to_shared64(v = 0x"$D3%XW", size = 0x"$D4%XW") returned "$D5%DW }, \
	0xf6	{ "ld_svcfdcreate: line "$D2%DW": copy_to_shared32(v = 0x"$D3%XW", size = 0x"$D4%XW") returned "$D5%DW }, \
	0xf7	{ "ld_base_svcs: line "$D2%DW": there is no syscall loader entry" }, \
	0xf8	{ "ld_base_svcs: line "$D2%DW": num32svcs = "$D3%DW", num64svcs = "$D4%DW }, \
	\*      { "unknown subhookid="$D1%D1 }
5A4 1.0 "@sysldr/chkpt: " \
        W2 \
        $D1, \
	0x01    { "ld_cr_adspace32: lib_text_sid"=$D2%XW "lib_data_sid="$D3%XW "lib_le_sid="$D4%XW }, \
        0x02    { "enlarge_sh_cr_textheap: lib64->shlib_text_sid["$D2%D1"] =" $D3%XW }, \
        0x03    { "enlarge_sh_cr_dataheap: lib64->shlib_data_sid["$D2%D1"] =" $D3%XW }, \
        0x04    { "ld_restart: le_addr =" $D2%XW }, \
        \*      { "unknown subhookid="$D1%D1 }
5AA 1.0 L=SVC "POSIX RT CLOCK " \
	$HD, \
	0x01 { "clock_getres       : " `clock_id=$D1` }, \
	0x02 { "clock_gettime      : " `clock_id=$D1` }, \
	0x03 { "clock_settime      : " `clock_id=$D1` }, \
	0x04 { "clock_getcpuclockid: " `pid=`prKernelPID($D1) }, \
	0x05 { "clock_nanosleep    : " `clock_id=$D1` }, \
	0x06 { "clock_nanosleep_end: " `trb=$D1` }, \
	\*  { `unknown subhook` }
5AB 1.0 L=SVC "POSIX RT TIMER " \
	$HD, \
	0x01 { "timer_create       : " `clock_id=$D1%X8` }, \
	0x02 { "timer_delete       : " `timer_id=$D1` }, \
	0x03 { "timer_gettime      : " `timer_id=$D1` }, \
	0x04 { "timer_getoverrun   : " `timer_id=$D1` }, \
	0x05 { "timer_settime      : " `timer_id=$D1` }, \
	0x06 { "trb_interval_end   : " `trb=$D1` }, \
	0x07 { "cputmr_interval_end: " `tmr=$D1` }, \
	\*  { `unknown subhook` }
5AC 1.0 L=SVC "@_PRIO_REQUEUE SYSTEM CALL" \
	_prio_requeue tid=prKernelTID($D1) tv_pri=$D2 run_pri=$D3
5AD 1.0 L=SVC "PRIO_SCHED " \
	$HD, \
	0x01 { "GET_PRIORITY_MIN " `policy=$D1` }, \
        0x02 { "GET_PRIORITY_MAX " `policy=$D1` }, \
        0x03 { "RR_GET_INTERVAL  " `pid=`prKernelPID($D1) }, \
        0x04 { "SETPARAM         " `pid=`prKernelPID($D1) ` param.sched_priority=$D2` }, \
        0x05 { "SETSCHEDULER     " `pid=`prKernelPID($D1) ` policy=$D2 param.sched_priority=$D3` }, \
        0x06 { "GETPARAM         " `pid=`prKernelPID($D1) }, \
	0x07 { "GETSCHEDULER     " `pid=`prKernelPID($D1) }, \
        \*   { "unknown subhook" }
5B5 1.0 L=SVC "RTSEM " \
        $HD, \
        0x01 { "OPEN     " `semp64=$D1%X4_$D2%X4` }, \
        0x02 { "CLOSE    " `usemid=$D1%X4_$D2%X4 semx=$D3%X4 semd=$D4%XW` }, \
        0x03 { "UNLINK   " `semx=$D1%X4` }, \
        0x04 { "INIT     " `semp64=$D1%X4_$D2%X4` \
                            $D3, 0 "non-shared", \* "shared" }, \
        0x05 { "DESTROY  " `semp64=$D1%X4_$D2%X4 semx=$D3%X4` }, \
        0x06 { "GETVALUE " `usemid=$D1%X4_$D2%X4 semx=$D3%X4` \
                            $D4, -1 "unnamed", \* { "semd="$D4%XW } }, \
        0x07 { "POST     " `usemid=$D1%X4_$D2%X4 semx=$D3%X4` \
                            $D4, -1 "unnamed", \* { "semd="$D4%XW } }, \
        0x08 { "WAIT     " `usemid=$D1%X4_$D2%X4 semx=$D3%X4` \
                            $D4, -1 "unnamed", \* { "semd="$D4%XW } }, \
        0x09 { "CREATE   " `usemid=$D1%X4_$D2%X4 semx=$D3%X4 semd=$D4%XW` }, \
        0x0A { "GET      " `usemid=$D1%X4_$D2%X4 semx=$D3%X4 semd=$D4%XW` }, \
        0x0B { "REMOVE   " `semx=$D1%X4` \
                            $D2, 0 "named", \* "unnamed" \
                            $D3, 0 "", \* "keepslot" }, \
        0x0C { "CLOSEDES " `semd=$D1%XW semx=$D2%X4` }, \
        \*   { "unknown subhook" }
5B6 1.0 L=SVC "RTMQ  " \
        $HD, \
        0x01 { "OPEN     " }, \
        0x02 { "CLOSE    " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` }, \
        0x03 { "UNLINK   " `mqx=$D1%X4` }, \
        0x04 { "GETATTR  " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` }, \
        0x05 { "SETATTR  " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` \
                            $D4, 0 "!non-block", \* "non-block" }, \
        0x06 { "NOTIFY   " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` \
                           $D4, 0 "CANCEL", \
                                1 "SIGEV_NONE", \
                                2 "SIGEV_SIGNAL", \
                                3 "SIGEV_THREAD tid=$D5%X4" }, \
        0x07 { "SEND     " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` \
                           `len=$D4%X4 prio=$D5%X4` }, \
        0x08 { "RECEIVE  " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` \
                           `len=$D4%X4` }, \
        0x09 { "CREATE   " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` }, \
        0x0A { "GET      " `umqid=$D1%X4 mqx=$D2%X4 mqd=$D3%XW` }, \
        0x0B { "REMOVE   " `mqx=$D1%X4` }, \
        0x0C { "CLOSEDES " `mqd=$D1%XW mqx=$D2%X4` }, \
        \*   { "unknown subhook" }
5B7 1.0 L=SVC "RTSHM " \
        $HD, \
        0x01 { "OPEN     " }, \
        0x02 { "UNLINK   " `shmx=$D1%X4` }, \
        0x03 { "CREATE   " `fd=$D1%X4 shmx=$D2%X4 fp=$D3%XW` }, \
        0x04 { "GET      " `fd=$D1%X4 shmx=$D2%X4 fp=$D3%XW` }, \
        0x05 { "REMOVE   " `shmx=$D1%X4` }, \
        0x06 { "CLOSEDES " `fp=$D1%XW shmx=$D2%X4` }, \
        \*   { "unknown subhook" }
5B8 1.0 L=KERN "RTIPC NAME " W2 $HL%S1
5B9 1.0 'NETWLM' \
        $HD%D1, \
        1   { `netwlm_connect` }, \
        2   { `return from netwlm_connect valid_handle=$D1%D1` }, \
        3   { `return from netwlm_connect_not_auth` }, \
        4   { `return from netwlm_connect_limit1_conn ` }, \
        5   { `return from netwlm_connect_bad_version ` }, \
        6   { `netwlm_disconnect` }, \
        7   { `return from netwlm_disconnect` }, \
        8   { `return from netwlm_disconnect_bad_version` }, \
        9   { `return from netwlm_disconnect_buffer_small` }, \
        10   { `netwlm_query request_type=$D1%XW` }, \
        11   { `return from netwlm_query request_type=$D1%XW` }, \
        12   { `return from netwlm_query_bad_request request_type=$D1%XW` }, \
        13   { `netwlm_set_ipaddrports` }, \
        14   { `return from netwlm_set_ipaddrports` }, \
        15   { `return from netwlm_set_ipaddrports_bad_version` }, \
        16   { `netwlm_get_ipaddrportsPID` }, \
        17   { `return from netwlm_get_ipaddrportsPID` }, \
        18   { `netwlm_proc_table_lookup` }, \
        19   { `return from netwlm_proc_table_lookup` }, \
        20   { `netwlm_fd_lookup` }, \
        21   { `return from netwlm_fd_lookup` }, \
        22   { `netwlm_get_proc_table_lookup` }, \
        23   { `return from netwlm_get_proc_table_lookup` }, \
        24   { `netwlm_get_verify_pid` }, \
        25   { `return from netwlm_get_verify_pid` }, \
        26   { `netwlm_get_fd_lookup` }, \
        27   { `return from netwlm_get_fd_lookup_out1 so=$D1%XW so_opt=$D2%XW so_port=$D3%DW so_addr=$D4%XW` }, \
        28   { `return from netwlm_get_fd_lookup_out2` }, \
        29   { `return from netwlm_get_fd_lookup_out3` }, \
        30   { `netwlm_postbind_save_pid port=$D1%XW proto=$D1%XW family= $D1%XW ` }, \
        31   { `return from netwlm_postbind_save_pid` }, \
        32   { `netwlm_add_pid` }, \
        33   { `return from netwlm_add_pid` }, \
        34   { `netwlm_del_pid` }, \
        35   { `return from netwlm_del_pid` }, \
        36   { `netwlm_get_fd_lookup_out1 so=$D1%XW so_opt=$D2%XW so_port=$D3%DW so_addr=$D4%XW` }, \
        \*  { `unknown subhook` }
5BA 1.0 'HKWD_DSM' \
   $HD%D1, \
    001 { "Entering dset_releaseProvider " provider=$D1 }, \
    002 { "Leaving dset_releaseProvider " provider=$D1 }, \
    003 { "Entering dset_findProvider " vfsp=$D1 }, \
    004 { "Leaving dset_findProvider " foundp=$D1 }, \
    005 { "Entering getLocations " \
	$D1, \
	1 { uuidp=$D2 locpp=$D3 clientaddrp=$D4 }, \
	2 { why=$D2 globalpathp=$D3 localpathp=$D4 } \
	}, \
    006 { "Leaving getLocations " rc=$D1 }, \
    007 { "getLocations error " rc=$D1 }, \
    008 { "UUID - " f1=$D1 f2=$D2 f3=$D3 f4=$D4 }, \
    009 { "Entering freeLocations " locp=$D1 }, \
    010 { "Leaving freeLocations " locp=$D1 }, \
    011 { "Entering dset_Init " }, \
    012 { "Leaving dset_Init " enabled=$D1 rc=$D2 }, \
    013 { "Entering dset_Shutdown "}, \
    014 { "dset_Shutdown - busy " rc=$D1 count=$D2 flags=$D3 }, \
    015 { "Leaving dset_Shutdown " rc=$D1 }, \
    016 { "Entering dset_gsvcsRegister " gsvcsInfop=$D1 }, \
    017 { "Leaving dset_gsvcsRegister " at=$D1 rc=$D2 }, \
    018 { "dset_gsvcsRegister " \
	$D1, \
	1 { gsvcsInfop=$D2 rc=$D3 }, \
	2 { tag=$D2 attrs=$D3 locs=$D4 free=$D5 }, \
	3 { infop=$D2 flags=$D3 rc=$D4 } \
	}, \
    019 { "Entering dset_gsvcsUnregister " tag=$D1 }, \
    020 { "Leaving dset_gsvcsUnregister " where=$D1 rc=$D2 }, \
    021 { "dset_gsvcsUnregister " \
	$D1, \
	1 { tag=$D2 count=$D3 rc=$D4 }, \
	2 { tag=$D2 flags=$D3 rc=$D4 } \
	}, \
    022 { "Entering dset_piRegister " vfsp=$D1 prInfop=$D2 }, \
    023 { "Leaving dset_piRegister " \
	$D1, \
	1 { where=$D1 rc=$D2 }, \
	2 { where=$D1 rc=$D2 }, \
	3 { where=$D1 vfsp=$D2 Infop=$D3 vfsnum=$D4 }, \
	4 { where=$D1 rc=$D2 }, \
	5 { where=$D1 rc=$D2 } \
	}, \
    024 { "dset_piRegister " \
	$D1, \
	1 { where=$D1 vfsp=$D2 Infop=$D3 find=$D4 byint=$D5 }, \
	2 { where=$D1 byuuid=$D2 create=$D3 dirto=$D4 list=$D5 }, \
	3 { where=$D1 vfsp=$D2 Infop=$D3 rc=$D4 }, \
	4 { where=$D1 vfsp=$D2 Infop=$D3 rc=$D4 } \
	}, \
    025 { "Entering dset_piUnregister " vfsp=$D1 tag=$D2 }, \
    026 { "Leaving dset_piUnregister " where=$D1 rc=$D2 }, \
    027 { "dset_piUnregister " \
	$D1, \
	1 { where=$D1 vfs=$D2 tag=$D3 count=$D4 rc=$D5 }, \
	2 { where=$D1 vfs=$D2 tag=$D3 rc=$D4 } \
	}, \
    028 { " Entering dset_allocMem " size=$D1 }, \
    029 { " dset_allocMem failed " size=$D1 res=$D2 }, \
    030 { " Leaving dset_allocMem " res=$D1 }, \
    031 { " Entering dset_freeMem " addr=$D1 }, \
    032 { " Leaving dset_freeMem " addr=$D2 }, \
    033 { " Entering dset_eventNotify " vfs=$D1 intid=$D2 event1=$D3 event2=$D4 }, \
    034 { " Leaving dset_eventNotify " where=$D1 rc=$D2 }, \
    035 { " dset_eventNotify error " where=$D1 vfs=$D2 event1=$D3 event2=$D4 rc=$D5 }, \
    036 { " calling notify function " func=$D1 arg=$D2 }, \
    037 { " notify function returned " rc=$D1 }, \
    038 { " Entering dset_ciFindProvider " vp=$D1 }, \
    039 { " dset_ciFindProvider error " where=$D1 vp=$D2 handle=$D3 flags=$D4 rc=$D5 }, \
    040 { " Leaving dset_ciFindProvider " rc=$D1 }, \
    041 { " Entering dset_ciReleaseProviderHandle " handle=$D1 }, \
    042 { " dset_ciReleaseProviderHandle error " pp=$D1 magic=$D2 count=$D3 rc=$D4 }, \
    043 { " Leaving dset_ciReleaseProviderHandle " rc=$D1 }, \
    044 { " Entering dset_ciIsDsetRef " vp=$D1 }, \
    045 { " Leaving dset_ciIsDsetRef " rc=$D1 isref=$D2 }, \
    046 { " dset_ciIsDsetRef error " rc=$D1 vp=$D2 isref=$D3 }, \
    047 { " Entering dset_ciGetDsetReferenceLocations " dvp=$D1 locpp=$D2 }, \
    048 { " dset_ciGetDsetReferenceLocations error " where=$D1 dvp=$D2 locpp=$D3 rc=$D4 }, \
    049 { " Leaving dset_ciGetDsetReferenceLocations " rc=$D1 }, \
    050 { " Entering dset_ciGetDsetLocations " vp=$D1 }, \
    051 { " dset_ciGetDsetLocations error " where=$D1 vp=$D2 locpp=$D3 rc=$D4 }, \
    052 { " Leaving dset_ciGetDsetLocations " rc=$D1 }, \
    053 { " Entering dset_ciGetDsetLocationsByUuid " uuidp=$D1 }, \
    054 { " Leaving dset_ciGetDsetLocationsByUuid " where=$D1 uuidp=$D2 locpp=$D3 rc=$D4 }, \
    055 { " Entering dset_ciRegisterNotifyHook " func=$D1 mask=$D2 }, \
    056 { " Leaving dset_ciRegisterNotifyHook " where=$D1 rc=$D2 }, \
    057 { " dset_ciRegisterNotifyHook error " where=$D1 func=$D2 mask=$D3 rc=$D4 }, \
    058 { " Leaving dset_ciRegisterNotifyHook " where=$D1 rc=$D2 }, \
    059 { " Entering dset_ciRemoveNotifyHook " func=$D1 mask=$D2 }, \
    060 { " Leaving dset_ciRemoveNotifyHook " rc=$D1 }, \
    061 { " Entering dset_ciFreeLocations " locp=$D1 }, \
    062 { " Leaving dset_ciFreeLocations " locp=$D1 }, \
    063 { " Entering dset_prOpFindDset " handle=$D1 vp=$D2 flags=$D3 dsnpp=$D4 objflags=$D5 }, \
    064 { " Leaving dset_prOpFindDset " rc=$D1 }, \
    065 { " dset_prOpFindDset error " handle=$D1 vp=$D2 rc=$D3 }, \
    066 { " Entering dset_prOpFindDsetByIntId " handle=$D1 id=$D2 }, \
    067 { " dset_prOpFindDsetByIntId error " where=$D1 handle=$D2 id=$D3 rc=$D4 }, \
    068 { " Leaving dset_prOpFindDsetByIntId " rc=$D1 }, \
    069 { " Entering dset_findDsetByUuid " handle=$D1 uuidp=$D2 }, \
    070 { " findDsetByUuid error " where=$D1 handle=$D2 uuidp=$D3 rc=$D4 }, \
    071 { " Leaving dset_findDsetByUuid " rc=$D1 }, \
    072 { " Entering dset_prOpFindDsetByUuid " handle=$D1 uuidp=$D2 }, \
    073 { " Leaving dset_prOpFindDsetByUuid " intId=$D1 rc=$D2 }, \
    074 { " dset_prOpFindDsetByUuid error " handle=$D1 uuidp=$D2 rc=$D3 intId=$D4 }, \
    075 { " uuid is " b1=$D1 b2=$D2 b3=$D3 b4=$D4 }, \
    076 { " Entering dset_prOpCreateDset " handle=$D1 target=$D2 uuidp=$D3 }, \
    077 { " dset_prOpCreateDset error " where=$D1 handle=$D2 target=$D3 uuidp=$D4 rc=$D5}, \
    078 { " Leaving dset_prOpCreateDset " rc=$D1 intId=$D2 }, \
    079 { " Entering dset_prOpDirToDset " handle=$D1 dvp=$D2 uuidp=$D3 }, \
    080 { " dset_prOpDirToDset error " where=$D1 rc=$D2 handle=$D3 dvp=$D4 uuidp=$D5 }, \
    081 { " Leaving dset_prOpDirToDset " rc=$D1 intId=$D2 }, \
    082 { " Entering dset_prOpListDsets " handle=$D1 cookie=$D2 iseof=$D3 }, \
    083 { " dset_prOpListDsets error " where=$D1 handle=$D2 cookie=$D3 iseof=$D4 rc=$D5 }, \
    084 { " Leaving dset_prOpListDsets " rc=$D1 isEof=$D2 }, \
    085 { " Entering dset_prOpIsDsetReference " handle=$D1 vp=$D2 }, \
    086 { " dset_prOpIsDsetReference error " where=$D1 handle=$D2 vp=$D3 rc=$D4 isRef=$D5 }, \
    087 { " Leaving dset_prOpIsDsetReference " rc=$D1 isRef=$D2 }, \
    088 { " Entering dset_prOpGetDsetGenById " handle=$D1 vp=$D2 id=$D3 }, \
    089 { " dset_prOpGetDsetGenById error " where=$D1 handle=$D2 vp=$D3 id=$D4 rc=$D5 }, \
    090 { " Leaving dset_prOpGetDsetGenById " rc=$D1 gen=$D2 }, \
    091 { " Entering dset_dsOpHold " dsnp=$D1 }, \
    092 { " dset_dsOpHold error " where=$D1 dsnp=$D2 rc=$D3 }, \
    093 { " Leaving dset_dsOpHold " rc=$D1 }, \
    094 { " Entering dset_dsOpRele " dsnp=$D1 }, \
    095 { " dset_dsOpRele error " where=$D1 dsnp=$D2 rc=$D3 }, \
    096 { " Leaving dset_dsOpRele " rc=$D1 }, \
    097 { " Entering dset_dsOpDsetRoot " dsnp=$D1 }, \
    098 { " dset_dsOpDsetRoot error " where=$D1 dsnp=$D2 rc=$D3 }, \
    099 { " Leaving dset_dsOpDsetRoot " rc=$D1 vpp=$D2 }, \
    100 { " Entering dset_dsOpCreateDsetRef " dnsp=$D1 dvp=$D2 uuidp=$D3 }, \
    101 { " dset_dsOpCreateDsetRef error " where=$D1 dnsp=$D2 dvp=$D3 uuidp=$D4 rc=$D5 }, \
    102 { " Leaving dset_dsOpCreateDsetRef " rc=$D1 }, \
    103 { " Entering dset_dsOpDeleteDset " dsnp=$D1 }, \
    104 { " dset_dsOpDeleteDset error " where=$D1 dsnp=$D2 rc=$D3 }, \
    105 { " Leaving dset_dsOpDeleteDset " rc=$D1 }, \
    106 { " Entering dset_dsOpDeleteDsetRef " dsnp=$D1 vp=$D2 }, \
    107 { " dset_dsOpDeleteDsetRef error " where=$D1 dsnp=$D2 vp=$D3 rc=$D4 }, \
    108 { " Leaving dset_dsOpDeleteDsetRef " rc=$D1 }, \
    109 { " Entering dset_dsOpGetDsetGen " dsnp=$D1 }, \
    110 { " dset_dsOpGetDsetGen error " where=$D1 dsnp=$D2 rc=$D3 }, \
    111 { " Leaving dset_dsOpDeleteDsetRef " rc=$D1 gen=$D2 }, \
    112 { " Entering dset_dsOpDsetToDir " dnsp=$D1}, \
    113 { " dset_dsOpDsetToDir error " where=$D1 dsnp=$D2 rc=$D3 }, \
    114 { " Leaving dset_dsOpDsetToDir " rc=$D1 }, \
    115 { " Entering dset_dsOpGetDsetAttrs " dsnp=$D1 }, \
    116 { " dset_dsOpGetDsetAttrs error " where=$D1 dsnp=$D2 rc=$D3 }, \
    117 { " Leaving dset_dsOpGetDsetAttrs " rc=$D1 }
5BC 1.0 L=KERN "@PAL: RTAS call" \
       {{ $WDS = $HL / $WORDSIZE }} \
       {{ $WW = $HD & 0x8000 }} \
       {{ $R = $WW / 0x8000 }} \
       {{ $RHD = $HD & 0x7FFF }} \
	   {{ printtimeofday(date) \
			{{ $date }} \
            {{ $year = $date%W56.63 }} \
            {{ $month = $date%W48.55 }} \
            {{ $day = $date%W40.47 }} \
            {{ $hour = $date%W32.39 }} \
            {{ $minutes = $date%W24.31 }} \
            {{ $seconds = $date%W16.23 }} \
            {{ $ms      = $date%W8.15 }} \
            setdelim(0) \
            $year"/"$month"/"$day $hour":"$minutes":"$seconds"."$ms \
            setdelim(1) \
	   }} \
	  {{ prtcntstate(state) \
			$state%D1 ,\
			0   COMPLETE ,\
			1	NEXT_SIB ,\
			2 	NEXT_CHILD , \
			3	NEXT_PROPERTY , \
			4	PREV_PARENT	, \
			5   MORE_AREA , \
			-1  RTAS_HERROR ,\
			-2  BUSY ,\
			-9001 NOT_THIS_SYSTEM ,\
			-9002 NOT_THIS_SLOT ,\
			-9003 ERR_CFG_USE ,\
			\*  { $state%D1 } \
	  }} \
	  {{ sensorname(token) \
			$token%D2, \
			1	"Key Switch" , \
			3	"Thermal" , \
			9   "ENV & EPOW state" , \
		    	9000 "Surveillance"	,\
			9001 "Fan Speed" , \
			9002 "Voltage" ,\
			9003 "DR-entity-sense" ,\
			9004 "Power Supply" ,\
			9005 "Global INT Queue Control" ,\
			9006 "System Info or FRU Fault" ,\
			9007 "Identify" ,\
			9009 "Comp Reset State" ,\
			\* { $token%D2 } \
	  }} \
	  {{ event_rc(rc) \
			$rc%D1 , \
				1 "No Errors Found" ,\
				0 "New Error Log returned" ,\
				-1 "Hardware Error" ,\
				\* { $rc%D2 } \
	  }} \
	  {{ cpustopstate(state) \
			$state%D1 , \
			0 "Processor Thread STOPPED" ,\
			1 "stop-self in Progress" ,\
			2 "Processor Thread RUNNING" ,\
			\* { $state%D2 } \
	  }} \
	  {{ prnt_cb_token(token) \
			$token%X1, \
			0x26 "ibm,open-errinjct" ,\
			0x27 "ibm,errinjct" ,\
			0x28 "ibm,close-errinjct" ,\
			0x2B "ibm,set-eeh-option" ,\
			0x2C "ibm,set-slot-reset" ,\
			0x36 "ibm,slot-error-detail" ,\
			0x38 "ibm,configure-bridge" ,\
			0x52 "ibm,configure-pe" ,\
			0x4D "ibm,get-config-addr-info2" ,\
			0x48 "ibm,read-slot-reset-state2" ,\
			0x47 "ibm,get-dynamic-sensor-state" ,\
			0x46 "ibm,set-dynamic-indicator" ,\
			0x4F "ibm,update-nodes" ,\
			0x50 "ibm,update-properties" ,\
			\* { $token%X2 } \
	  }} \
	"cpuid="$CPUID \
	$RHD , \
	0x00 { $WDS, \
		0x00 { `freeze timebase start:` starttimer(0x5BC,$RHD) }, \
		0x01 { `freeze timebase   end: rc=$D1%D2`  endtimer(0x5BC,$RHD) } \
	     }, \
	0x01 { $WDS, \
		0x00 { `thaw timebase start:` starttimer(0x5BC,$RHD) }, \
		0x01 { `thaw timebase   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x02 { $WDS, \
		0x00 { `system reboot start:` starttimer(0x5BC,$RHD) }, \
		0x01 { `system reboot   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x03 { $R , \
		0x00 { `get sensor state start:  sensor: name="`sensorname($D1)`", token=$D1, index=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `get sensor state   end:  rc=$D1%D2  state=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x04 { $R, \
		0x00 { `get time of day start: tm=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `get time of day   end: rc=$D1%D2` \n\t\t `TIME OF DAY` printtimeofday($D2) endtimer(0x5BC,$RHD) } \
	     }, \
	0x05 { $R, \
		0x00 { `set time of day start: TIME OF DAY` printtimeofday($D1) starttimer(0x5BC,$RHD) }, \
		0x01 { `set time of day   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x06 { $R, \
		0x00 { `set indicator start: indicator=$D1 index=$D2 value=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `set indicator   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x07 { $R, \
		0x00 { $D1 , \
				0xA { `display character start: value=$D1%A8 LF(New Line)` starttimer(0x5BC,$RHD) } ,\
				0xC { `display character start: value=$D1%A8 FF(New Page)` starttimer(0x5BC,$RHD) } ,\
				0xD { `display character start: value=$D1%A8 CR(Carriage Return)` starttimer(0x5BC,$RHD) } ,\
				\*     { `display character start: value=$D1%A8` O9 `(` A2.2 `)` starttimer(0x5BC,$RHD) } \
		     } , \
		0x01 { `display character   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x08 { $R, \
		0x00 { `power off start: power_on_hi=$D1 power_on_lo=$D2` starttimer(0x5BC,$RHD)  }, \
		0x01 { `power off   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x09 { $R, \
		0x00 { `set time for power on start: time=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `set time for power on   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x0A { $R, \
		0x00 { `config read start: size=$D1 address=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `config read   end: rc= $D1 trace_data=$D2%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x0B { $R, \
		0x00 { `config write start: size=$D1 config address=$D2 value=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `config write   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x0C { $R, \
		0x00 { `nvram fetch start: index=$D1 len=$D2 buffer=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `nvram fetch   end: rc=$D1%D2 num=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x0D { $R, \
		0x00 { `nvram store start: index=$D1 len=$D2 buffer=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `nvram store   end: rc=$D1%D2 num=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x0E { $R, \
		0x00 { `check exception start: vector=$D1 info=$D2 event mask=$D3 critical=$D4` starttimer(0x5BC,$RHD) },\
		0x01 { `check exception   end: "`event_rc($D1)`" ,rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x0F { $R, \
		0x00 { `event scan start: event mask=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `event scan   end: "`event_rc($D1)`" ,rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x10 { $R, \
		0x00 { `stop self start: physid=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `stop self   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x11 { $R, \
		0x00 { `os term start: string=` O2 A8.8 starttimer(0x5BC,$RHD) }, \
		0x01 { `os term   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x12 { $R, \
		0x00 { `scan log dump start: buffer=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `scan log dump   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x13 { $R, \
		0x00 { `get xive start: src number=$D1` starttimer(0x5BC,$RHD) }, \
	 	0x01 { `get xive   end: rc=$D1%D2 server=$D2 priority=$D3` endtimer(0x5BC,$RHD) } \
	     }, \
	0x14 { $R, \
		0x00 { `set xive start: src number=$D1 server=$D2 priority=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `set xive   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x15 { $R, \
		0x00 { `int off start: source num=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `int off   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x16 { $R, \
		0x00 { `int on start: source num=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `int on   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x17 { $R, \
		0x00 { `close errinject start: open token=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `close errinject   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x18 {  $R, \
		0x00 { `errinject start: errinject token=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `errinject   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x19 { $R, \
		0x00 { `open errinject start:` starttimer(0x5BC,$RHD) }, \
		0x01 { `open errinject   end: rc=$D1%D2, open token=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x1A { $R, \
		0x00 { `last error start: error buffer=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `last error   end: "`event_rc($D1)`" rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x1B { $R, \
		0x00 { `update flash reboot start: block list=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `update flash reboot   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x1C { $R, \
		0x00 { `update flash64 reboot start: block list=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `update flash64 reboot   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x1D { $R, \
		0x00 { `set power level start: power domain=$D1 level=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `set power level   end: rc=$D1%D2 setlevel=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x1E { $R, \
		0x00 { `get power level start: power domain=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `get power level   end: rc=$D1%D2 level=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x1F { $WDS, \
		0x00 { `callback   end: return` endtimer(0x5BC,$RHD) }, \
		0x01 { `callback start: token(`$D1%X2`) RTAS FUNCTION: "`prnt_cb_token($D1) `"` starttimer(0x5BC, $RHD) } \
	     }, \
	0x20 { $R, \
		0x00 { `config connector start: work area=$D1 extent=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `config connector   end: rc=`prtcntstate($D1) endtimer(0x5BC,$RHD) } \
	     }, \
	0x21 { $R, \
		0x00 { `read slot reset state start: config address=$D1 PHB_Unit_ID=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `read slot reset state   end: rc=$D1%D2 reset state=$D2 capability=$D3` endtimer(0x5BC,$RHD) } \
	     }, \
	0x22 { $R, \
		0x00 { `set eeh option start: config address=$D1 PHB_Unit_ID=$D2 function=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `set eeh option   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x23 { $R, \
		0x00 { `set slot reset start: config address=$D1 PHB_Unit_ID=$D2 function=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `set slot reset   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x25 { `old errinject: index or rc=$D1` }, \
	0x27 { $R, \
		0x00 { `extended config read start: config address=$D1 PHB_Unit_ID=$D2 size=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `extended config read   end: rc=$D1%D2 trace data=$D2%X8` endtimer(0x5BC,$RHD) } \
	     }, \
	0x28 { $R, \
		0x00 { `extended config write start: config address=$D1 PHB_Unit_ID=$D2 size=$D3 value=$D4` starttimer(0x5BC,$RHD) }, \
		0x01 { `extended config write   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x29 { $WDS, \
		0x00 { `nmi register start` starttimer(0x5BC,$RHD) }, \
		0x01 { `nmi register   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x30 { $R, \
		0x00 { `set slot reset perm start: config address=$D1 PHB_Unit_ID=$D2 function=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `set slot reset perm   end: rc=$D1%D2 error type=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x31 { $R, \
		0x00 { `get sysparm start: parameter token=$D1%X2 data length=$D2%X4` starttimer(0x5BC,$RHD) }, \
		0x01 {  $D1, \
			0x0 { `get sysparm   end: rc=$D1%X4 NO RETURN DATA` endtimer(0x5BC,$RHD) }, \
			\*  { $D2%D2, \
			    -1 { `get sysparm   end: rc=$D1%D2 `  endtimer(0x5BC,$RHD)  }, \
			    \* { `get sysparm   end: length=$D1%X4 `\n\t`raw:$D2%X8$D3%X8$D4%X8$D5%X8` O10 \n\t`PARAMETER="`A32.32`..."` endtimer(0x5BC,$RHD) } \
			    } \
		     } \
	     }, \
	0x32 { $R, \
		0x00 { `start cpu start: cpu=$D1 real address=$D2%X8 gr3=$D3%X8` starttimer(0x5BC,$RHD)  }, \
		0x01 { `start cpu end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x33 { $R, \
		0x00 { `query cpu state start: cpu=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `query cpu state   end: rc=$D1%D2 cpuid=$D2  status:$D3 "`cpustopstate($D3)`"` endtimer(0x5BC,$RHD) } \
	     }, \
	0x34 { $R, \
		0x00 { `set sysparm start: ` O2 `parameter=` D4 `length=` D4  \n\t\t\t `PARAMETER="` A32.32 `..."`  starttimer(0x5BC,$RHD) }, \
		0x01 { `set sysparm   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x35 { $R, \
		0x00 { `get indices start: indicator=$D1 type=$D2 start number=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `get indices   end: rc=$D1%D2 next start number=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x36 { $R, \
		0x00 { `configure bridge start: config address=$D1 PHB_Unit_ID=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `configure bridge   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x37 { $R, \
		0x00 { `os det cpu fault start: phycpuid=$D1 reason=$D2 persistent=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `os det cpu fault   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	      }, \
	0x38 { $R, \
		0x00 { `platform dump start: tag=$D1 seq=$D2 buffer=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `platform dump   end: rc=$D1%D2 count=$D2 tag=$D3 seq=$D4 length=$D5` endtimer(0x5BC,$RHD) } \
	     }, \
	0x39 { $R, \
		0x00 { `get vpd start: location code=$D1 seq=$D2 buffer=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `get vpd   end: rc=$D1%D2 count=$D2 next seq=$D3` endtimer(0x5BC,$RHD) } \
	     }, \
	0x3A { $R, \
		0x00 { `manage flash start: commit flag=$D1` starttimer(0x5BC,$RHD)  }, \
		0x01 { `manage flash   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x3B { $R, \
		0x00 { `validate flash start: buffer=$D1 size=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `validate flash   end: rc=$D1%D2 result token=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x3C { $R, \
		0x00 { `active firmware start: start` starttimer(0x5BC,$RHD) }, \
		0x01 { `active firmware   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x3D { $R, \
		0x00 { `slot error detail start: config address=$D1 PHB_Unit_ID=$D2 function=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `slot error detail   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x3E { $R, \
		0x00 { `get dyn sensor state start: sensor=$D1 loc_code=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `get dyn sensor state   end: rc=$D1%D2 state=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x3F { $R, \
		0x00 { `set dyn indicator start: indicator=$D1 loc_code=$D2 new value=$D3` starttimer(0x5BC,$RHD)  }, \
		0x01 { `set dyn indicator   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x40 { $R, \
		0x00 { `power off ups start: ` starttimer(0x5BC,$RHD) }, \
		0x01 { `power off ups   end: rc=$D1%D2` endtimer(0x5BC,$RHD)  } \
	     }, \
	0x41 { $R, \
		0x00 { `suspend me start: `  starttimer(0x5BC,$RHD) }, \
		0x01 { `suspend me   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x42 { $R, \
		0x00 { `update nodes start: scope=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `update nodes   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x43 { $R, \
		0x00 { `update properties start: scope=$D1` starttimer(0x5BC,$RHD) }, \
		0x01 { `update properties   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x44 { $R, \
		0x00 { `change msi start: config address=$D1 PHB_Unit_ID=$D2 function=$D3 seq=$D4 req_msis=$D5` starttimer(0x5BC,$RHD) }, \
		0x01 { `change msi   end: rc=$D1%D2 final msis=$D2 next seq number=$D3` endtimer(0x5BC,$RHD) } \
	     }, \
	0x45 { $R, \
		0x00 { `query intr start: config address=$D1 rel_intr_num=$D2 PHB_Unit_ID=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 { `query intr   end: rc=$D1%D2 source=$D2 trigger=$D3` endtimer(0x5BC,$RHD) } \
	     }, \
	0x46 { $R, \
		0x00 { `read slot reset state2 start: config address=$D1 PHB_Unit_ID=$D2` starttimer(0x5BC,$RHD) }, \
		0x01 { `read slot reset state2   end: rc=$D1%D2 reset_state=$D2 slot_capabilities=$D3 retry_delay=$D4` endtimer(0x5BC,$RHD) } \
	     }, \
	0x47 { $R, \
		0x00 {	`get config address info2 start: config address=$D1 PHB_Unit_ID=$D2 function=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 {  `get config address info2   end: rc=$D1%D2 info=$D2` endtimer(0x5BC,$RHD) } \
	     }, \
	0x48 { $R, \
		0x00 {  `configure kernel dump start: command=$D1 bufp=$D2 length=$D3` starttimer(0x5BC,$RHD) }, \
		0x01 {  `configure kernel dump   end: rc=$D1%D2` endtimer(0x5BC,$RHD) } \
	     }, \
        \*  { `unknown subhook` }
5BD 1.0 "SISSAS" \
        $DD1
5BE 1.0 "[EFS] " W1 \
    $HD, \
	0001 { "efs_init: EFS kernext is initializing" }, \
	0002 { "efs_init: pincode failed with rc=" D8 }, \
	0003 { "efs_init: efs_gkr_init failed with rc=" D8 }, \
	0004 { "efs_init: EFS kernext initialized." }, \
	0005 { "efs_term: unloading unallowed (EBUSY)" }, \
	0006 { "efs_term: EFS kernext terminating" }, \
	0007 { "efs_term: efs_gkr_destroy returned " D8 }, \
	0008 { "efs_term: EFS kernext terminated" }, \
	0009 { "efs_init: efs_cryptolib_init failed with rc=" D8 }, \
	000A { "efs_term: efs_cryptolib_destroy failed with rc=" D8 }, \
	000B { "efs_init: efs_tkr_init failed with rc=" D8 }, \
	000C { "efs_term: efs_tkr_fini returned " D8 }, \
 	0011 { "efs_addkey: enter with key_ids=" X8 ", buffers=" X8 ", lengths=" X8 }, \
 	0012 { "efs_addkey: error retrieving ptr key_id[" D8 "]: " D8 }, \
 	0013 { "efs_addkey: error retrieving ptr buffers[" D8 "]: " D8 }, \
 	0014 { "efs_addkey: error retrieving key size at location " X8 ": " D8 }, \
 	0015 { "efs_addkey: error retrieving aki data at location " X8 ": " D8 }, \
 	0016 { "efs_addkey: efs_aki_check returned " D8 " on key " D8 " (EINVAL)" }, \
 	0017 { "efs_addkey: not enough memory to copy key data (ENOMEM)" }, \
 	0018 { "efs_addkey: error retrieving key data at location " X8 ": " D8 }, \
 	0019 { "efs_addkey: need to duplicate and privatize the keystore." }, \
 	001A { "efs_addkey: efs_pkr_dup returned " D8 }, \
 	001B { "efs_addkey: efs_pkr_addpk returned " D8 " while adding key " D8 }, \
 	001C { "efs_addkey: exit with rc=0" }, \
  	001D { "efs_addkey: error with tkr: " D8 }, \
	001E { "efs_closekeystore: enter" }, \
 	001F { "efs_closekeystore: exit with rc=0" }, \
 	0021 { "efs_listkeys: enter with buffer=" X8 ", length=" D8 }, \
 	0022 { "efs_listkeys: built a " D8 " bytes list." }, \
 	0023 { "efs_listkeys: return with rc=" D8 }, \
 	0024 { "efs_listkeys: errno=" D8 }, \
 	0029 { "efs_decryptcookie: enter with cookie=" X8 ", datasz=" D8 }, \
 	002A { "efs_decryptcookie: exit with rc=" D8 }, \
 	002B { "efs_decryptcookie: copyin returned rc=" D8 }, \
 	002C { "efs_decryptcookie: wrong version found: " D8 " (EINVAL)" }, \
 	002D { "efs_decryptcookie: pkr_lookup returned rc=" D8 }, \
 	002E { "efs_decryptcookie: memory allocation failed (ENOMEM)" }, \
 	002F { "efs_decryptcookie: efs_asym_decrypt returned rc=" D8 }, \
 	0030 { "efs_decryptcookie: buffer is too small, missing " D8 }, \
 	0031 { "efs_decryptcookie: copyout returned rc=" D8 }, \
	003B { "efs_editea: returning ea data size (" D8 ") to the user in location " X8 }, \
	003C { "efs_editea: efs_ea_rm returned " D8 }, \
	003D { "efs_editea: efs_ea_add returned " D8 }, \
	003E { "efs_editea: efs_ecm_crypt returned " D8 }, \
	003F { "efs_editea: flushing operations" }, \
	0040 { "efs_editea: efs_pkr_lookup returned " D8 " for op #" D8 }, \
 	0041 { "efs_editea: enter with ea=" X8 ", easz=" D8 ", ea_ops=" X8 }, \
 	0042 { "efs_editea: rc=" D8 }, \
 	0043 { "efs_editea: return" }, \
	0044 { "efs_editea: invalid argument (EINVAL)" }, \
	0045 { "efs_editea: not enough memory (ENOMEM)" }, \
	0046 { "efs_editea: copyin returned " D8 }, \
	0047 { "efs_editea: efs_ea_parse returned " D8 }, \
	0048 { "efs_editea: efs_ea_discard returned " D8 }, \
	0049 { "efs_editea: efs_ea_get_ecm returned " D8 }, \
	004A { "efs_editea: copyin returned " D8 ", while processing op #" D8 }, \
	004B { "efs_editea: Got an invalid op code (" D8 ") in operation #" D8 }, \
	004C { "efs_editea: efs_ea_getsize returned " D8 }, \
 	004D { "efs_editea: parsed ea (" D8 "B) is too big for user buffer (" D8 "B) (ENOSPC)" }, \
	004E { "efs_editea: efs_ea_pack returned " D8 }, \
	004F { "efs_editea: copyout returned " D8 }, \
	0051 { "efs_setuid: enter with creds=" X8 ", mask=" X8 }, \
	0052 { "efs_setuid: discard the PKR." }, \
	0053 { "efs_setuid: keep the PKR." }, \
	0054 { "efs_setuid: bypass policy." }, \
	0059 { "efs_crfree: unlinking pkr=" X8 }, \
	005A { "efs_crcopy: linking pkr=" X8 }, \
	0061 { "efs_access: enter with cred=" X8 ", efsea=" X8 ", filekey=" X8 }, \
	0062 { "efs_access: invalid parameter (EINVAL)" }, \
	0063 { "efs_access: no keystore loaded (ENOATTR)" }, \
	0064 { "efs_access: efs_ea_parse returned " D8 }, \
	0065 { "efs_access: efs_ea_get_ecm returned " D8 }, \
	0066 { "efs_access: efs_ea_discard returned " D8 }, \
	0067 { "efs_access: exit with rc=" D8 }, \
	0071 { "efs_create: enter with creds=" X8 ", efsea=" X8 " and objtype=" D8 }, \
	0072 { "efs_create: received an invalid argument (EINVAL)" }, \
	0073 { "efs_create: no keystore (ENOATTR)" }, \
	0074 { "efs_create: efs_pkr_lookup returned " D8 " while searching for user\'s key" }, \
	0075 { "efs_create: user key is public part, we want private (ESAD)" }, \
	0076 { "efs_create: looking for group " D8 " key" }, \
	0077 { "efs_create: efs_pkr_lookup error (" D8 ") for group key, we continue anyway" }, \
	0078 { "efs_create: efs_ecm_init returned " D8 }, \
	0079 { "efs_create: efs_ea_init returned " D8 }, \
	007A { "efs_create: efs_ecm_crypt\(user key\) returned " D8 }, \
	007B { "efs_create: efs_ea_add\(user key\) returned " D8 }, \
	007C { "efs_create: efs_ecm_crypt\(grp key\) returned " D8 }, \
	007D { "efs_create: efs_ea_add\(grp key\) returned " D8 }, \
	007E { "efs_create: efs_ea_pack returned " D8 }, \
	007F { "efs_create: exit with rc=" D8 }, \
	0080 { "efs_create: efs_eadir_init returned " D8 }, \
	0091 { "efs_crypto: enter with filekey=" X8 ", dir=" D8 ", input=" X8 }, \
	0092 { "efs_crypto: invalid argument (EINVAL)" }, \
	0093 { "efs_crypto: efs_crypt_bloc failed with error " D8 }, \
	0099 { "efs_free: free filekey=" X8 }, \
	009A { "efs_free: invalid argument (EINVAL)" }, \
	00A1 { "efs_setattr: enter with creds=" X8 ", efsea=" X8 ", cmd=" D8 }, \
	00A2 { "efs_setattr: Invalid argument (EINVAL)" }, \
	00A3 { "efs_setattr: No keystore (ENOATTR)" }, \
	00A4 { "efs_setattr: using ecm=" X8 " passed as parameter." }, \
	00A5 { "efs_setattr: efs_access returned " D8 }, \
	00A6 { "efs_setattr: operation op=" D8 }, \
	00A7 { "efs_setattr: Could not duplicate the EA (ENOMEM)" }, \
	00A8 { "efs_setattr: efs_ea_parse returned " D8 }, \
	00A9 { "efs_setattr: efs_pkr_lookup(newgid) returned " D8 }, \
	00AA { "efs_setattr: efs_ecm_crypt(newgid) returned " D8 }, \
	00AB { "efs_setattr: efs_ea_add(newgid) returned " D8 }, \
	00AC { "efs_setattr: efs_ea_rm(newgid) returned ENOENT, no problem" }, \
	00AD { "efs_setattr: efs_ea_rm(newgid) returned " D8 }, \
	00AE { "efs_setattr: efs_pkr_lookup(newuid) returned " D8 }, \
	00AF { "efs_setattr: efs_ecm_crypt(newuid) returned " D8 }, \
	00B0 { "efs_setattr: efs_ea_rm(newuid) returned ENOENT, no problem" }, \
	00B1 { "efs_setattr: efs_ea_rm(newuid) returned " D8 }, \
	00B2 { "efs_setattr: efs_ea_add(newuid) returned " D8 }, \
	00B3 { "efs_setattr: efs_pkr_lookup(newgid) returned " D8 }, \
	00B4 { "efs_setattr: efs_ecm_crypt(newgid) returned " D8 }, \
	00B5 { "efs_setattr: efs_ea_rm(newgid) returned ENOENT, no problem" }, \
	00B6 { "efs_setattr: efs_ea_rm(newgid) returned " D8 }, \
	00B7 { "efs_setattr: efs_ea_add(newgid) returned " D8 }, \
	00B8 { "efs_setattr: unsupported op code (ENOSYS)" }, \
	00B9 { "efs_setattr: efs_ea_pack returned " D8 }, \
	00BA { "efs_setattr: efs_free returned " D8 }, \
	0101 { "_efs_ea_li_comp: invalid argument (EINVAL)" }, \
	0102 { "efs_eadir_init: enter with ea=" X8 ", algo=" D8 }, \
	0103 { "efs_eadir_init: invalid argument (EINVAL)" }, \
	0104 { "efs_eadir_getalgo: enter with ea=" X8 ", algo=" X8 }, \
	0105 { "efs_eadir_getalgo: invalid argument (EINVAL)" }, \
	0106 { "efs_eadir_getalgo: invalid EA version: " D8 " (EINVAL)" }, \
	0107 { "efs_ea_init: enter with eak=" X8 ", algo=" D8 }, \
	0108 { "efs_ea_init: invalid argument (EINVAL)" }, \
	0109 { "efs_ea_init: could not alloc ea header (ENOMEM)" }, \
	010A { "efs_ea_add: enter with eak=" X8 ", algo=" D8 }, \
	010B { "efs_ea_add: invalid argument (EINVAL)" }, \
	010C { "efs_ea_add: efs_key_asym_size returned " D8 }, \
	010D { "efs_ea_add: size mismatch \( " D8 " \/ " D8 " \) (EINVAL)" }, \
	010E { "efs_ea_add: not enough memory to create listitem (ENOMEM)" }, \
	010F { "efs_ea_add: exit with rc=0" }, \
	0110 { "efs_ea_rm: enter with eak=" X8 ", kind=" D8 ", id=" D8 }, \
	0111 { "efs_ea_rm: invalid argument (EINVAL)" }, \
	0112 { "efs_ea_rm: exit with rc=" D8 }, \
	0113 { "efs_ea_parse: enter with ea=" X8 ", easize=" D8 ", eak=" X8 }, \
	0114 { "efs_ea_parse: invalid argument (EINVAL)" }, \
	0115 { "efs_ea_parse: wrong EA version " D8 " (EINVAL)" }, \
	0116 { "efs_ea_parse: efs_key_asym_size returned " D8 }, \
	0117 { "efs_ea_parse: size error, truncated EA \(EINVAL\)" }, \
	0118 { "efs_ea_parse: could not allocate listitem (ENOMEM)" }, \
	0119 { "efs_ea_parse: exit with rc=0" }, \
	011A { "efs_ea_discard: freeing eak=" X8 }, \
	011B { "efs_ea_discard: invalid argument (EINVAL)" }, \
	011C { "efs_ea_getsize: enter with eak=" X8 ", sz=" X8 }, \
	011D { "efs_ea_getsize: invalid argument (EINVAL)" }, \
	011E { "efs_ea_getsize: efs_key_asym_size returned " D8 }, \
	011F { "efs_ea_getsize: exit with rc=0" }, \
	0120 { "efs_ea_pack: enter with dest=" X8 ", destlen=" D8 ", eak=" X8 }, \
	0121 { "efs_ea_pack: invalid argument (EINVAL)" }, \
	0122 { "efs_ea_pack: efs_ea_getsize returned " D8 }, \
	0123 { "efs_ea_pack: not enough space to store EA \( " D8 " \/ " D8 " \) (ENOSPC)" }, \
	0124 { "efs_ea_pack: efs_key_asym_size returned " D8 }, \
	0125 { "efs_ea_pack: exit with rc=0" }, \
	0126 { "efs_ea_get_ecm: enter with creds=" X8 ", eak=" X8 ", ecm=" X8 }, \
	0127 { "efs_ea_get_ecm: invalid argument (EINVAL)" }, \
	0128 { "efs_ea_get_ecm: efs_pkr_lookup returned " D8 }, \
	0129 { "efs_ea_get_ecm: no matching key found (ESAD)" }, \
	012A { "efs_ea_get_ecm: efs_ecm_decrypt_alloc returned " D8 }, \
	012B { "efs_ea_get_ecm: exit with rc=" D8 }, \
	012C { "efs_ea_add: this key is already in the list (EEXIST)" }, \
	0141 { "get_gklh: invalid argument!" }, \
	0142 { "gk_create: enter with aki=" X8 ", len=" D8 ", gk=" X8 }, \
	0143 { "gk_create: invalid argument (EINVAL)" }, \
	0144 { "gk_create: efs_key_init returned rc=" D8 }, \
	0145 { "gk_create: Could not create GK (ENOMEM)" }, \
	0146 { "gk_create: exit with rc=0, new gk=" X8 }, \
	0147 { "gk_remove: free gk at location " X8 }, \
	0148 { "efs_gkr_init: reset the GKR" }, \
	0149 { "efs_gkr_init: The GKR is already initialized (EALREADY)" }, \
	014A { "efs_gkr_destroy: enter" }, \
	014B { "efs_gkr_destroy: The GKR is not initialized (ENOTREADY)" }, \
	014C { "efs_gkr_destroy: global counter not empty: " D8 ". (EBUSY)" }, \
	014D { "efs_gkr_destroy: gk list at index i=" D8 " is not empty (EBUSY)" }, \
	014E { "efs_gkr_destroy: exit with rc=0" }, \
	014F { "efs_gkr_getref: enter with id=" X8 ", buffer=" X8 ", gk=" X8 }, \
	0150 { "efs_gkr_getref: The GKR is not initialized (ENOTREADY)" }, \
	0151 { "efs_gkr_getref: invalid argument (EINVAL)" }, \
	0152 { "efs_gkr_getref: id is private where we had public" }, \
	0153 { "efs_gkr_getref: the key was not found (ENOENT)" }, \
	0154 { "efs_gkr_getref: efs_key_init returned rc=" D8 }, \
	0155 { "efs_gkr_getref: the key was not found \(whole lsit\) (ENOENT)" }, \
	0156 { "efs_gkr_getref: new key is being inserted after key " X8 }, \
	0157 { "efs_gkr_getref: gk_create returned " D8 }, \
	0158 { "efs_gkr_geterf: exit with rc=0, *gk=" X8 ", *gk->rc=" D8 }, \
	0159 { "efs_gkr_link: linking gk=" X8 }, \
	015A { "efs_gkr_link: The GKR is not initialized (ENOTREADY)" }, \
	015B { "efs_gkr_link: invalid argument (EINVAL)" }, \
	015C { "efs_gkr_link: invalid GK (EINVAL)" }, \
	015D { "efs_gkr_release: releasing gk=" X8 }, \
	015E { "efs_gkr_release: The GKR is not initialized (ENOTREADY)" }, \
	015F { "efs_gkr_release: invalid argument (EINVAL)" }, \
	0160 { "efs_gkr_release: freeing the GK element" }, \
	0161 { "efs_gkr_getid: get id for gk=" X8 " into aki=" X8 }, \
	0162 { "efs_gkr_getid: The GKR is not initialized (ENOTREADY)" }, \
	0163 { "efs_gkr_getid: invalid argument (EINVAL)" }, \
	0164 { "efs_gkr_getref: Deprecating key" }, \
	0171 { "_pkr_alloc: allocate a new pkr at location " X8 }, \
	0172 { "_pkr_alloc: invalid argument (EINVAL)" }, \
	0173 { "_pkr_alloc: not enough memory (ENOMEM)" }, \
	0174 { "_pkr_free: freeing PKR at location " X8 }, \
	0175 { "_pkr_free: Invalid argument or non-empty PKR (EINVAL)" }, \
	0176 { "_pkl_lookup: enter with pkl=" X8 ", id=" D8 ", fp=" X8 }, \
	0177 { "_pkl_lookup: invalid argument (EINVAL)" }, \
	0178 { "_pkl_lookup: key type mismatch" }, \
	0179 { "_pkl_lookup: testing uid/gid" }, \
	017A { "_pkl_lookup: uid/gid too small" }, \
	017B { "_pkl_lookup: uid/gid too big" }, \
	017C { "_pkl_lookup: testing uid" }, \
	017D { "_pkl_lookup: uid too small" }, \
	017E { "_pkl_lookup: uid too big" }, \
	017F { "_pkl_lookup: testing gid" }, \
	0180 { "_pkl_lookup: gid too small" }, \
	0181 { "_pkl_lookup: gid too big" }, \
	0182 { "_pkl_lookup: key age mismatch" }, \
	0183 { "_pkl_lookup: testing fingerprint" }, \
	0184 { "_pkl_lookup: fingerprint mismatch" }, \
	0185 { "_pkl_lookup: found key " X8 }, \
	0186 { "_pkl_lookup: no key found" }, \
	0187 { "_pkl_insert: enter with pkl=" X8 ", cnt=" X8 ", pk=" X8 }, \
	0188 { "_pkl_insert: invalid argument (EINVAL)" }, \
	0189 { "_pkl_insert: key inserted after " X8 ", cnt=" D8 }, \
	018A { "_pkl_free: enter with pkl=" X8 ", cnt=" X8 }, \
	018B { "_pkl_free: invalid argument (EINVAL)" }, \
	018C { "_pkl_free: efs_gkr_release returned rc=" D8 }, \
	018D { "_pkl_free: exit, rc=0, cnt=" D8 }, \
	018E { "_pkl_dup: enter with src=" X8 ", trg=" X8 ", cnt=" X8 }, \
	018F { "_pkl_dup: invalid argument (EINVAL)" }, \
	0190 { "_pkl_dup: Could not allocate new pk (ENOMEM). pkl has been freed rc=" D8 }, \
	0191 { "_pkl_dup: efs_gkr_link failed with rc=" D8 ". pkl freed with rc=" D8 }, \
	0192 { "_pkl_dup: exit with rc=0, " D8 " pk duplicated." }, \
	0193 { "_pkl_getlist: enter with pkl=" X8 ", akis=" X8 ", len=" X8 }, \
	0194 { "_pkl_getlist: Invalid argument (EINVAL)" }, \
	0195 { "_pkl_getlist: buffer too small (ENOSPC)" }, \
	0196 { "_pkl_getlist: efs_gkr_getid failed with error " D8 }, \
	0197 { "_pkl_getlist: exit rc=0, *len=" D8 }, \
	0198 { "_pk_lookup: searching pkr=" X8 " for key kind=" D8 }, \
	0199 { "_pk_lookup: Invalid argument (EINVAL)" }, \
	019A { "efs_pkr_addpk: enter with pkr=" X8 ", key_id=" X8 ", buffer=" X8 }, \
	019B { "efs_pkr_addpk: Invalid argument (EINVAL)" }, \
	019C { "efs_pkr_addpk: creating a new PKR" }, \
	019D { "efs_pkr_addpk: _pkr_alloc returned " D8 }, \
	019E { "efs_pkr_addpk: found a matching key in PKR at " X8 }, \
	019F { "efs_pkr_addpk: key " X8 " has been marked deprecated" }, \
	01A0 { "efs_pkr_addpk: adding public or already got private: nothing to do." }, \
	01A1 { "efs_pkr_addpk: pk updated to private key, gk unchanged." }, \
	01A2 { "efs_pkr_addpk: efs_gkr_getref returned " D8 }, \
	01A3 { "efs_pkr_addpk: gk and pk updated to private." }, \
	01A4 { "efs_pkr_addpk: Not enough memory to create new PK. (ENOMEM)" }, \
	01A5 { "efs_pkr_addpk: Got an invalid key kind " D8 " (EINVAL)" }, \
	01A6 { "efs_pkr_addpk: _pkl_insert returned " D8 }, \
	01A7 { "efs_pkr_link: linking pkr=" X8 }, \
	01A8 { "efs_pkr_dup: enter with pkr=" X8 }, \
	01A9 { "efs_pkr_dup: Invalid argument (EINVAL)" }, \
	01AA { "efs_pkr_dup: no pkr, nothing to do." }, \
	01AB { "efs_pkr_dup: refcount=1, nothing to do." }, \
	01AC { "efs_pkr_dup: _pkr_alloc returned " D8 }, \
	01AD { "efs_pkr_dup: _pkl_dup(groups) returned " D8 }, \
	01AE { "efs_pkr_dup: _pkl_dup(users) returned " D8 }, \
	01AF { "efs_pkr_dup: _pkl_dup(adms) returned " D8 }, \
	01B0 { "efs_pkr_dup: exit with rc=0, new pkr=" X8 }, \
	01B1 { "efs_pkr_unlink: Invalid argument!!" }, \
	01B2 { "efs_pkr_unlink: unlinking pkr=" X8 }, \
	01B3 { "efs_pkr_unlink: refcount is now " D8 }, \
	01B4 { "efs_pkr_unlink: _pkl_free(u) rc=" D8 ", cnt=" D8 }, \
	01B5 { "efs_pkr_unlink: _pkl_free(g) rc=" D8 ", cnt=" D8 }, \
	01B6 { "efs_pkr_unlink: _pkl_free(a) rc=" D8 ", cnt=" D8 }, \
	01B7 { "efs_pkr_unlink: _pkr_free rc=" D8 }, \
	01B8 { "efs_pkr_lookup: enter with creds=" X8 ", dir=" D8 ", id=" D8 }, \
	01B9 { "efs_pkr_lookup: Invalid argument (EINVAL)" }, \
	01BA { "efs_pkr_lookup: No keystore (ENOENT)" }, \
	01BB { "efs_pkr_lookup: incompat parameters \(fp=null, dir=encrypt\) (EINVAL)" }, \
	01BC { "efs_pkr_lookup: No key found matching criterias (ENOENT)" }, \
	01BD { "efs_pkr_lookup: key identification filled into " X8 }, \
	01BE { "efs_pkr_lookup: exit with rc=0, key=" X8 }, \
	01BF { "efs_pkr_getlist: enter with pkr=" X8 ", list=" X8 ", size=" X8 }, \
	01C0 { "efs_pkr_getlist: no pkr, return 0" }, \
	01C1 { "efs_pkr_getlist: not enough memory to create list (ENOMEM)" }, \
	01C2 { "efs_pkr_getlist: _pkl_getlist(u) returned " D8 }, \
	01C3 { "efs_pkr_getlist: _pkl_getlist(g) returned " D8 }, \
	01C4 { "efs_pkr_getlist: _pkl_getlist(a) returned " D8 }, \
	01C5 { "efs_pkr_getlist: size did not shrink to 0: " D8 }, \
	01C6 { "efs_pkr_lookup: No keystore in TKR (ENOENT)" }, \
	01E1 { "efs_fp_comp: got NULL pointer" }, \
	01E2 { "efs_aki_check: checking aki=" X8 }, \
	01E3 { "efs_aki_check: bad version (" D8 ")" }, \
	01E4 { "efs_aki_check: bad kind (" D8 ")" }, \
	01E5 { "efs_aki_check: bad type (" D8 ")" }, \
	01E6 { "efs_aki_check: bad algo (" D8 ")" }, \
	01E7 { "efs_aki_check: bad age (" D8 ")" }, \
	01E8 { "efs_aki_check: return rc=0" }, \
 	0201 { "efs_key_init: not enough memory (ENOMEM)" }, \
	0202 { "efs_key_asym_size: invalid argument (EINVAL)" }, \
	0203 { "efs_key_asym_size: unknown algo " D8 " (EINVAL)" }, \
	0204 { "efs_ecm_init: invalid argument (EINVAL)" }, \
	0205 { "efs_ecm_init: not enough memory (ENOMEM)" }, \
	0206 { "efs_ecm_decrypt_alloc: invalid argument (EINVAL)" }, \
	0207 { "efs_ecm_decrypt_alloc: not enough memory (ENOMEM)" }, \
	0208 { "efs_ecm_crypt: invalid argument (EINVAL)" }, \
	0209 { "efs_ecm_crypt: unknown algo " D8 " (EINVAL)" }, \
	020A { "efs_ecm_crypt: not enough memory (ENOMEM)" }, \
	020B { "efs_crypt_bloc: invalid argument (EINVAL)" }, \
	0210 { "CLiC kernext was not initialized (efs_cryptolib_init) \(ENOTREADY\)" }, \
	0211 { "efs_cryptolib_init: enter" }, \
	0212 { "efs_cryptolib_init: You must update ciphers_info or pk_infos definitions (ENOSYS)!" }, \
	0213 { "efs_cryptolib_init: CLiC_context_new returned " D8 ", mapped to " D8 }, \
	0214 { "efs_cryptolib_init: initial object count " D8 }, \
	0215 { "efs_cryptolib_destroy: enter" }, \
	0216 { "efs_cryptolib_destroy: object count differs from initialization " D8 " \/ " D8 " \(EBUSY\)" }, \
	0217 { "map_clic_error: " X8 " is not a CLiC error." }, \
	0218 { "map_clic_error: Got unwanted error: " D8 }, \
	0219 { "map_clic_error: This error is not known: " D8 }, \
	021A { "efs_ciphers_init: enter with ecm=" X8 }, \
	021B { "efs_ciphers_init: Got NULL (EINVAL)" }, \
	021C { "efs_ecm_alloc: enter with algo=" D8 }, \
	021D { "efs_ecm_alloc: not enough memory (ENOMEM)" }, \
	021E { "efs_ecm_alloc: invalid parameter (EINVAL)" }, \
	021F { "efs_key_init: enter with buffer: " X8 ", length: " D8 ", key: " X8 }, \
	0220 { "efs_key_init: CLiC_pk returned " D8 ", mapped to " D8 }, \
	0221 { "efs_key_link: linking " X8 }, \
	0222 { "efs_key_unlink: unlinking " X8 }, \
	0223 { "efs_key_asym_size: getting size for algo " D8 }, \
	0224 { "efs_ecm_init: enter with algo: " D8 }, \
	0225 { "efs_ecm_init: efs_ecm_alloc returned " D8 }, \
	0226 { "efs_ecm_init: CLiC_rng returned " D8 ", mapped to " D8 }, \
	0227 { "efs_ecm_init: CLiC_cipher returned " D8 ", mapped to " D8 }, \
	0228 { "efs_ecm_link: linking " X8 }, \
	0229 { "efs_ecm_unlink: unlinking " X8 }, \
	022A { "efs_ecm_decrypt_alloc: enter with pkey=" X8 ", salgo=" D8 ", src=" X8 }, \
	022B { "efs_ecm_decrypt_alloc: efs_ecm_alloc returned " D8 }, \
	022C { "efs_ecm_decrypt_alloc: CLiC_pk_decrypt returned " D8 ", mapped to " D8 }, \
	022D { "efs_ecm_decrypt_alloc: CLiC_pk_decrypt returned " D8 " \(expected: " D8 " \), len \= " D8 " \(exp: 0\) (EINVAL)" }, \
	022E { "efs_ecm_decrypt_alloc: CLiC_cipher returned " D8 ", mapped to " D8 }, \
	022F { "efs_ecm_crypt: enter with ecm: " X8 " and pkey: " X8 }, \
	0230 { "efs_ecm_crypt: CLiC_pk_encrypt returned " D8 ", mapped to " D8 }, \
	0231 { "efs_ecm_crypt: CLiC_pk_encrypt returned " D8 " \(expected: " D8 "\), len \= " D8 " \(exp: 0\) (EINVAL)" }, \
	0232 { "efs_ecm_crypted_free: freeing buffer: " X8 }, \
	0233 { "efs_crypt_bloc: enter with ecm: " X8 ", dir: " D8 ", offset: " D8 }, \
	0234 { "efs_crypt_bloc: CLiC_cipher_reset returned " D8 ", mapped to " D8 }, \
	0235 { "efs_crypt_bloc: CLiC_cipher_update returned " D8 ", mapped to " D8 }, \
	0236 { "efs_crypt_bloc: CLiC_cipher_update returned too small value " D8 " (EINVAL)" }, \
	0237 { "efs_crypt_bloc: internal function returned " D8  }, \
	0238 { "efs_asym_decrypt: enter with key=" X8 ", input=" X8 ", output=" X8  }, \
	0239 { "efs_asym_decrypt: CLiC_pk_decrypt returned " D8 ", mapped to " D8 }, \
	023A { "efs_crypt_bloc: IV len is not 16, use dummy IV generator." }, \
	023B { "efs_key_init: CLiC_pk_encode returned " D8 ", mapped to " D8 }, \
	023C { "efs_key_init: malloc(" D8 ") failed (ENOMEM)" }, \
	023D { "efs_key_init: CLiC_digest_new returned " D8 ", mapped to " D8 }, \
	023E { "efs_key_init: Fingerprint mismatch (EINVAL)" }, \
	0301 { "efs_iv: enter with iv0=" X8 ", offset=" D8 ", iv=" X8 }, \
	0310 { "efs_tkr_init: reset the TKR" }, \
	0311 { "efs_tkr_init: unable to create kproc" }, \
	0312 { "efs_tkr_init: initp failed with rc = " D8 }, \
	0313 { "efs_tkr_fini: destroy TKR" }, \
	0314 { "efs_tkr_fini: TKR is not empty (EBUSY)" }, \
	0315 { "efs_tkr_insert: insert TKR for process " D8 " and uid " D8 }, \
	0316 { "efs_tkr_insert: TKR entry already exists" }, \
	0317 { "efs_tkr_insert: xmalloc failed (ENOMEM)" }, \
	0318 { "efs_tkr_delete: retrieve TKR for process " D8 " and uid " D8 }, \
	0319 { "efs_tkr_delete: exit, pkr = " X8 }, \
	031A { "efs_tkr_getref: retrieve TKR for process " D8 " and uid " D8 }, \
	031B { "efs_tkr_getref: exit, pkr = " X8 }, \
	\* {  MISSING Undefined EFS subhook. Hook Id= \$$HD \n$DEFAULT }
5C0 1.0 "@VMM_PVLIST" \
	$HD, \
	0 { `PVLIST KPROC WAKE: avgfree=$D1 bootavg=$D2 pvl_end=$D3 pvl has $D4/$D5 elements` }, \
	1 { `PVLIST FAILED LISTALLOC: failed to isolate nfr $D1 for $D2 4kpgs` }, \
	2 { `PVLIST HARDALLOC PINFAIL: pinaddr=$D1, pinsize=$D2 error=$D3` }, \
	3 { `PVLIST HARDALLOC NFR: sidx=$D1 sid=$D2 pno=$D3 nfr=$D4` }, \
	4 { `PVLIST ADDPAGE: kspsid=$D1 pno=$D2 nfr=$D3 eaddr=$D4 psize=$D5` }, \
	5 { `PVLIST LESS: avgfree=$D1 bootavg=$D2 numlmb=$D3 extra_groups=$D4` }, \
	6 { `PVLIST REMPAGE: kspsid=$D1 pno=$D2 nfr=$D3 n4kpgs=$D4 rc=$D5` }
5CA 1.0 "@VMSVC_XMEM" \
	$HD, \
	0x00 { `VMSVC XM_SETHKEY: caller=$D1 xmemp=$D2 hset=$D3 flags=$D4` }, \
	0x01 { `VMSVC XM_SETHKEY Err: rc=$D1` }, \
	0x02 { `VMSVC XM_GETHKEY: caller=$D1 xmemp=$D2 hset=$D3 flags=$D4` }, \
	0x03 { `VMSVC XM_GETHKEY Err: rc=$D1` }, \
	0x04 { `VMSVC XM_IO_OK: caller=$D1 xmemp=$D2 aspace_id=$D3` }, \
	0x05 { `VMSVC XM_IO_OK Err: rc=$D1` }, \
	0x06 { `VMSVC XMATTACH: caller=$D1 pid=$D2 vaddr=$D3 count=$D4 segflag=$D5` }, \
	0x07 { `VMSVC XMATTACH Err: rc=$D1` }, \
	0x08 { `VMSVC XMATT_REMIO: caller=$D1 rliobn=$D2 raddr=$D3 count=$D4` }, \
	0x09 { `VMSVC XMATT_REMIO Err: rc=$D1` }, \
	0x0A { `VMSVC XMEMOUTX: caller=$D1 kaddr=$D2 uaddr=$D3 count=$D4 xmemp=$D5` }, \
	0x0B { `VMSVC XMEMOUTX Err: rc=$D1` }, \
	0x0C { `VMSVC XMDETACH: caller=$D1 xmemp=$D2` }, \
	0x0D { `VMSVC XMDETACH Err: rc=$D1` }, \
	0x0E { `VMSVC XMEMIN: caller=$D1 uaddr=$D2 kaddr=$D3 count=$D4 xmemp=$D5` }, \
	0x0F { `VMSVC XMEMIN Err:  caller=$D1 vmhandle=$D2 offset=$D3` }, \
	0x10 { `VMSVC XMEMPIN: caller=$D1 uaddr=$D2 count=$D3 xmemp=$D4` }, \
	0x11 { `VMSVC XMEMPIN Err: rc=$D1` }, \
	0x12 { `VMSVC XMEMUNPIN: caller=$D1 uaddr=$D2 count=$D3 xmemp=$D4 flags=$D5` }, \
	0x13 { `VMSVC XMEMUNPIN Err: rc=$D1` }, \
	0x14 { `VMSVC XL_CREATE: caller=$D1 xmemp=$D2 baddr=$D3 count=$D4 flags=$D5` }, \
	0x15 { `VMSVC XL_CREATE Err: rc=$D1` }, \
	0x16 { `VMSVC XL_REMOVE: caller=$D1 xmemp=$D2` }, \
	0x17 { `VMSVC XL_REMOVE Err: rc=$D1` }, \
	0x18 { `VMSVC XM_MAPIN: caller=$D1 xmemp=$D2 uaddr=$D3 count=$D4 eaddr=$D5` }, \
	0x19 { `VMSVC XM_MAPIN Err: rc=$D1` }, \
	0x1A { `VMSVC XM_DET: caller=$D1 baddr=$D2 xmemp=$D3` }, \
	0x1B { `VMSVC XM_DET Err: rc=$D1` }, \
	0x1C { `VMSVC XMEMDMA: caller=$D1 xmemp=$D2 xaddr=$D3 flags=$D4 nfr=$D5` }, \
	0x1D { `VMSVC XMEMDMA Err: rc=$D1` }, \
	0x1E { `VMSVC XMEMDMA_LIST: caller=$D1 xmemp=$D2 xaddr=$D3 count=$D4 flags=$D5` }, \
	0x1F { `VMSVC XMEMDMA_LIST Err: rc=$D1` }, \
	0x20 { `VMSVC XMZERO: caller=$D1 xmemp=$D2 uaddr=$D3 count=$D4` }, \
	0x21 { `VMSVC XMEMZERO Err: rc=$D1` }, \
	0x22 { `VMSVC XM_GETH: caller=$D1 xmemp=$D2 uaddr=$D3 count=$D4 vmh=$D5` }, \
	0x23 { `VMSVC XM_GETH Err: rc=$D1` }, \
	0x24 { `VMSVC XMEMPSIZE: caller=$D1 xmemp=$D2 addr=$D3 count=$D4` }, \
	0x25 { `VMSVC XMEMPSIZE Err: rc=$D1` }, \
	0x26 { `VMSVC XM_MAXMAP: caller=$D1 xmemp=$D2 uaddr=$D3 len=$D5` }, \
	0x27 { `VMSVC XM_MAXMAP Err: rc=$D1` }
5CB 1.0 L=KERN "Live Dump" \
	{{ ioctlcmd(cmd) \
	     {{ $cmd }} \
	     $cmd, \
	     0x6464 { IOCLDMP_DIR }, \
	     0x6465 { IOCLDMP_THRESHOLD }, \
	     0x6466 { IOCLDMP_LEVEL }, \
	     0x6467 { IOCLDMP_HEAP }, \
	     0x6468 { IOCLDMP_INFOTIME }, \
	     0x6469 { IOCLDMP_DUPSUPPRESS }, \
	     0x646A { IOCLDMP_FREEZETIME }, \
	     0x646B { IOCLDMP_FREEZESTOP }, \
	     0x646C { IOCLDMP_IOSTART }, \
	     0x646D { IOCLDMP_ENABLE }, \
	     0x646E { IOCLDMP_GETINFO }, \
	     0x646F { IOCLDMP_COMPRESS_FACTOR }, \
	     0x6470 { IOCLDMP_SETUP }, \
	     0x6471 { IOCLDMP_COMPSPEC }, \
	     0x6472 { IOCLDMP_PSEUDO }, \
	     0x6473 { IOCLDMP_LIVEDUMP }, \
	     0x6474 { IOCLDMP_FREE } \
	}} \
	$HD, \
	0x1 { RAS_INIT  }, \
	0x2 { LCMP_NOT_IN_MEM comp=$D1 }, \
	0x3 { LCMP_BAD_EYEC comp=$D1 eyec=$D2 }, \
	0x4 { ISTBL_VALID tblp=$D1 }, \
	0x5 { LDMP_SER_PREP cb=XW symptom=$HL%S1 }, \
	0x6 { MTRC_DUP remcomp=$D1 mtrc_cp=$D2 curp=$D3 }, \
	0x7 { LDMP_SER_NOCOMP  }, \
	0x8 { LCMP_DUP comp1=$D1 comp2=$D2 }, \
	0x9 { SEND_PREPARE comp=$D1 }, \
	0xA { PREP_NEW_COMP first=$D1 }, \
	0xB { NO_HEAP_SPACE total=$D1 max=$D2 staging=$D3 }, \
	0xC { LDMP_SER_START cpu=$D1%D1 }, \
	0xD { FREEZE_STOP pass_tics=$D1 curticks=$D2 stopval=$D3%D1 }, \
	0xE { LDMP_SER_IO rv=$D1 }, \
	0xF { LDMP_NO_CFG_SPACE cb=$D1 }, \
	0x10 { FREEZE_TO pass_tics=$D1 curticks=$D2 to_val=$D3%D1 }, \
	0x11 { LDMP_SER_NO_IO  }, \
	0x12 { LDMP_SER_EXIT cb=$D1 }, \
	0x13 { ENDEVENT tid=$D1 }, \
	0x14 { SETUPPARMS  }, \
	0x15 { PARMS_NOT_IN_MEM parms=$D1 }, \
	0x16 { LIVEDUMP parms=$D1 }, \
	0x17 { LIVEDUMP_BUSY  }, \
	0x18 { PARMS_EYEC_VERS parms=$D1 eyec=$D2 vers=$D3 }, \
	0x19 { PARMS_FLAGS parms=$D1 flags=$D2 }, \
	0x1A { PARMS_INTBASE parms=$D1 flags=$D2 }, \
	0x1B { PARMS_PRIO parms=$D1 prio=$D2 }, \
	0x1C { PARMS_STR_MEM strid=$D1%D1 parms=$D2 strptr=$D3 }, \
	0x1D { PARMS_STR_LEN strid=$D1%D1 parms=$D2 strptr=$D3 }, \
	0x1E { PARMS_ERRBUF parms=$D1 errbuf=$D2 }, \
	0x1F { PARMS_COMP parms=$D1 comps=$D1 }, \
	0x20 { LDMP_NOT_ENABLED  }, \
	0x21 { LIVEDUMP_NO_MEM \
	  $D1, \
	    0 { "cb" }, 1 { "prep" }, 2 { "start" }, 3 { "myparms" }, \
	    4 { "errbuf" } \
	  }, \
	0x22 { LIVEDUMP_FREECB kerr=$D1 }, \
	0x23 { LIVEDUMP_EXIT kerr=$D1 }, \
	0x24 { SEND_START cb=$D1 comp=W2 $HL%S1 }, \
	0x25 { ERRSTR_I sz=$D1 W2 $HL%S1 }, \
	0x26 { DMP_EADDR name=$D1 addr=$D2 sz=$D3 }, \
	0x27 { DMP_EADDR_ERR name=$D1 rv=$D2 addr=$D3 sz=$D4 }, \
	0x28 { LDMPFREE cb=$D2 \
	  $D1, 0 { "entry" }, 1 { "exit" } \
	  }, \
	0x29 { GETHS_USEMAX reqsz=$D1 availsz=$D2 max=$D3 staging=$D4 },\
	0x2A { GETHS_NOMEM \
	  $D1, 0 { "toobig" }, 1 { "staging-from-heap" }, \
	    2 { "datavec-from-heap" } \
	  }, \
	0x2B { VALID_BAD id=$D1 }, \
	0x2C { PARMS_FILENAME parms=$D1 filename=$D2 }, \
	0x2D { POST_PASS tid=$D1 pass=$D2 }, \
	0x2E { WAIT_PASS pass=$D1 }, \
	0x2F { WAIT_PASS_ERR }, \
	0x30 { LIVEDUMP_EXISTS pre=$D1 parms=$D2 }, \
	0x31 { TO_CREATE_PASS cb=$D1 fp=$D2 }, \
	0x32 { POST_PASS_ERR cb=$D1 err=$D2 tid=$D3 }, \
	0x33 { LDMPFREE_VM_PROTECT_ERR cb=$D1 rc=$D2 addr=$D3 }, \
	0x34 { SEND_AGAIN cb=$D1 }, \
	0x35 { LIVEDUMP_NO_DUP cb=$D1 pre=$D2 parms=$D3 }, \
	0x36 { ADD_DUP p=$D1 LDG.ldmp_pre=$D2 prev=$D3 next=$D4 eyec=$D5 }, \
	0x37 { LDMP_ENQ qe=$D1 post=$D2 }, \
	0x38 { LDMP_DEQ qelp=$D1 }, \
	0x39 { LDMP_DO_Q qelp=$D1 type=$D2 }, \
	0x3A { REM_DUP p=$D1 LDG.ldmp_pre=$D2 prev=$D3 next=$D4 eyec=$D5 }, \
	0x100 { HEAPSETUP sz=$D1 }, \
	0x101 { BAD_HEAPSETUP id=$D1%D1 err=$D2 }, \
	0x102 { DEFAULTHEAP_ADDR addr=$D1 }, \
	0x103 { ALLOCH_REQUEST sz=$D1 dvp=$D2 retszp=$D3 flags=$D4%D1}, \
	0x104 { FREELIST_ENTRY fl_ptr=$D1 sz=$D2 }, \
	0x105 { XMALLOC_INVID id=$D1 }, \
	0x106 { XMALLOC_BADSZ sz=$D1 }, \
	0x107 { XMALLOC_BADALIGN align=$D1 }, \
	0x108 { XMALLOC_BADRETPTR ptr=$D1 }, \
	0x109 { XMALLOC_ADDR datavec=$D1 }, \
	0x10A { XMFREE_INVID id=$D1 }, \
	0x10B { XMFREE_INVADDR id=$D1 }, \
	0x10C { FREEH_REQUEST sz=$D1 addr=$D2 type=$D3 }, \
	0x10F { BUFDATA_LDMP  }, \
	0x110 { BUFDATA_SDMP  }, \
	0x111 { BUFDATA_LDMPU  }, \
	0x112 { BUFDATA_SDMPU  }, \
	0x113 { BUFDATA_BADFMT  }, \
	0x114 { BUFDATAR_AREA entryp=$D1 datalen=$D2 }, \
	0x115 { BUFDATA_CANDUMP $D1%D1 entries out of $D1%D1 }, \
	0x116 { BUFDATAU_AREA entryp=$D1 datalen=$D2 }, \
	0x117 { FREEH_DRAINHP_FREE  }, \
	0x118 { QUEDUMP cb=$D1 }, \
	0x119 { ALLOCH_DV addr=$D1 sz=$D2 totbufsz=$D3}, \
	0x11A { ALLOCH_RETURN addr=$D1 }, \
	0x11B { FREEHEAP ldmp_heap_t addr=$D1 }, \
	0x11C { HEAP_RESIZE rv=$d1 oldsz=$D2 newsz=$D3 }, \
	0x11E { FREEH_CURRHEAP_Q }, \
	0x11F { FREEH_DRAINHEAP_Q }, \
	0x120 { FREEH_PREHEAP_Q }, \
	0x121 { WRT_BAD_FOPEN cb=$D1 kerr=$D2 }, \
	0x122 { WRITE_ERR kerr=$D1 cb=$D2 buff=$D3 sz=$D4 }, \
	0x123 { IO_DONE cb=$D1 }, \
	0x124 { WRITE cb=$D1 buf=$D2 len=$D3 }, \
	0x125 { WRITE_END cb=$D1 kerr=$D2 }, \
	0x126 { NEW_PROCESS tid=$D1 }, \
	0x127 { WRT_DUMP cb=$D1 }, \
	0x128 { DUMP_SIZE sz=$D1 }, \
	0x129 { WRTDATA_ENOMEM }, \
	0x12A { FNAME W2 $HL%S1 }, \
	0x12B { FILENAME_IDX index=$D1%D1 }, \
	0x12C { DUMP_PASS pass=$D1%D1 }, \
	0x12D { WRITE_EINVAL  }, \
	0x12E { ADDHELD cb=$D1 }, \
	0x12F { LOGIO cb=$D1 fcomp=$D2 rv=$D3 }, \
	0x130 { WRITEHELD cb=$D1 }, \
	0x131 { WRITE_THRD_STARTED tid=$D1 qelp=$D2 }, \
	0x132 { WRITEHELD2 rv=$D1 }, \
	0x133 { POST_DONE cb=$D1 tid=$D2 }, \
	0x134 { POST_HELD cb=$D1 tid=$D2 }, \
	0x135 { BUFDATA_RET kerr=$D1 }, \
	0x136 { COPYH sz=$D1 }, \
	0x137 { COPYH_END kerr=$D1 }, \
	0x138 { FREE_SZ0  }, \
	0x139 { FREELIST_ENTRY_RESIZED fl_ptr=$D1 sz=$D2 }, \
	0x200 { INITSTART  }, \
	0x201 { INITDONE  }, \
	0x202 { SETUP_PROCSTOP  }, \
	0x203 { SETUP_PROCSDONE  }, \
	0x204 { DR register rv=$D1  }, \
	0x205 { IOCTLINVAL ioctlcmd($D1) }, \
	0x206 { CFGIOCTL ioctlcmd($D1) }, \
	0x208 { CFGIOCTLINVAL ioctlcmd($D1) }, \
	0x209 { CFGIOCTLEXIT rc=$D1%D1 }, \
	0x20a { CFGIOCTLHEAPSZ_NOLDMP  }, \
	0x20b { CFGIOCTL_HELD_NEWDIR heldp=$D1 }, \
	0x20c { CFGIOCTL_DUPPROCSTART  }, \
	0x20d { CFGIOCTL_WAITSTART  }, \
	0x20e { CFGIOCTL_ENAB_DISAB \
	$D1, 0 { disable }, \* { enable } \
	}, \
	0x20f { TAKEIOCTL ioctlcmd($D1) }, \
	0x210 { TAKEIOCTL_PSEUDO flags=$D1 parm1=$D2 parm2=$D3 }, \
	0x211 { TAKEIOCTL_DUMP flags=$D1 }, \
	0x212 { TAKEIOCTL_WAITDUMP  }, \
	0x213 { TAKEIOCTL_EXIT rc=$D1%D1 }, \
	0x214 { ID2LDP_BADPTR ptr=$D1 }, \
	0x215 { ID2LDP_NOTLD ptr=$D1 }, \
	0x216 { GETSP_BADPTR ptr=$D1 }, \
	0x217 { FREELDP ptr=$D1 }, \
	0x218 { TAKEIOCTL_COMPSPEC  }, \
	0x219 { TAKEIOCTL_DONE_WAIT retevent=$D1 }, \
	0x220 { CSPEC flags=$D1 comp=$D2 anchor=$D3 }, \
	0x221 { CSPEC_EXIT kerr=$D1 }, \
	0x222 { CSPEC_INTERNAL  }, \
	0x223 { CSPEC_INTEXIT kerr=$D1 }, \
	0x224 { CSPEC_EXTIDP extid=$D1 kerr=$D2 }, \
	0x225 { CSPEC_ADDED lvl=$D1 W2 $HL%S1 }, \
	0x226 { CSPEC_PARMS W2 $HL%S1 }, \
	0x227 { COMPEXT comp=$D1 }, \
	0x228 { COMPEXT_EXIT kerr=$D1 }, \
	0x229 { PSEUDO flags=$D1 callback=$D2 anchor=$D3 }, \
	0x22a { PSEUDO_EXIT kerr=$D1 }, \
	0x22b { CKANCHOR kerr=$D1 }, \
	0x22c { CSPEC_BLOCKNULL }, \
	\* { unknown $HD $D1 $D2 $D3 $D4 $D5 }
5D4 1.0 "@LVM CONFIG EVENTS" \
        $HD%D2, \
         1  { `LVM cfgvg:       ` dev=$D1 event=$D2 line=$D3%DW },\
	 2  { `LVM i_kaddlv:    ` dev=$D1 },\
	 3  { `LVM o_kaddlv:    ` line=$D1%DW },\
	 4  { `LVM i_kchglv:    ` dev=$D1 },\
	 5  { `LVM o_kchglv:    ` line=$D1%DW },\
	 6  { `LVM i_kchklv:    ` dev=$D1 },\
	 7  { `LVM o_kchklv:    ` line=$D1%DW },\
	 8  { `LVM i_kextend:	` num_extred=$D1 num_lps=$D2 },\
	 9  { `LVM o_kextend:   ` line=$D1%DW rc=$D2 },\
	10  { `LVM i_gsextend:	` dev=$D1 },\
	11  { `LVM o_gsextend:  ` line=$D1%DW rc=$D2 },\
	12  { `LVM i_kreduce:	` dev=$D1 },\
	13  { `LVM o_kreduce:   ` line=$D1%DW rc=$D2 },\
	14  { `LVM i_gsreduce:	` dev=$D1 },\
	15  { `LVM o_gsreduce:	` line=$D1%DW rc=$D2 },\
	16  { `LVM i_kmarklv:	` dev=$D1 },\
	17  { `LVM o_kmarklv:	` line=$D1%DW rc=$D2 },\
	18  { `LVM i_kdellv:	` dev=$D1 },\
	19  { `LVM o_kdellv:	` line=$D1%DW },\
	20  { `LVM i_kaddmpv:	` dev=$D1 },\
	21  { `LVM o_kaddmpv:	` line=$D1%DW rc=$D2 },\
	22  { `LVM i_kaddpv:	` dev=$D1 },\
	23  { `LVM o_kaddpv:	` line=$D1%DW rc=$D2 },\
	24  { `LVM i_kcopybb:	` enter=$D1 },\
	25  { `LVM o_kcopybb:	` line=$D1%DW rc=$D2 },\
	26  { `LVM i_kdelpv:	` kvg_ptr=$D1 },\
	27  { `LVM o_kdelpv:	` line=$D1%DW rc=$D2 },\
	28  { `LVM i_kchgvgsa:	` dev=$D1 },\
	29  { `LVM o_kchgvgsa:	` line=$D1%DW rc=$D2 },\
	30  { `LVM i_config:	` dev=$D1 },\
	31  { `LVM o_config:	` line=$D1%DW rc=$D2 },\
	32  { `LVM i_lvm_config:	` cmd=$D2%DW dev=$D1 },\
	33  { `LVM o_lvm_config:	` line=$D1%DW rc=$D2 },\
	34  { `LVM i_verifyvgid:	` vgid=$D1 dev=$D1 },\
	35  { `LVM o_verifyvgid:	` line=$D1%DW rc=$D2 },\
	36  { `LVM i_kdeflvs:	` enter=$D1 },\
	37  { `LVM o_kdeflvs:	` line=$D1%DW rc=$D2 },\
	38  { `LVM i_ksetupvg:	` dev=$D1 },\
	39  { `LVM o_ksetupvg:	` line=$D1%DW rc=$D2 },\
	40  { `LVM i_mwc_fprec:		` numltgs=$D1 },\
	41  { `LVM o_mwc_fprec:		` line=$D1%DW rc=$D2 },\
	42  { `LVM i_kdefvg:	` dev=$D1 },\
	43  { `LVM o_kdefvg:	` line=$D1%DW rc=$D2 },\
	44  { `LVM i_kdelvg:	` dev=$D1 },\
	45  { `LVM o_kdelvg:	` line=$D1%DW rc=$D2 },\
	46  { `LVM i_free_lvols:	` lv_index=$D1 lv_end=$D2 },\
	47  { `LVM o_free_lvols:	` line=$D1%DW },\
	48  { `LVM i_kchgqrm:	` dev=$D1 },\
	49  { `LVM o_kchgqrm:	` line=$D1%DW rc=$D2 },\
	50  { `LVM i_kqryvgs:	` dev=$D1 },\
	51  { `LVM o_kqryvgs:	` line=$D1%DW rc=$D2 },\
	52  { `LVM i_krebuild:	` dev=$D1 },\
	53  { `LVM o_krebuild:	` line=$D1%DW rc=$D2 },\
	54  { `LVM i_kvgstat:	` dev=$D1 },\
	55  { `LVM o_kvgstat:	` line=$D1%DW },\
	56  { `LVM i_cfg:		` enter=$D1 },\
	57  { `LVM o_cfg:		` line=$D1%DW },\
	58  { `LVM i_con1016:	` dev=$D1 },\
	59  { `LVM o_con1016:	` line=$D1%DW rc=$D2 },\
	60  { `LVM i_ext_dalv:	` dev=$D1 },\
	61  { `LVM o_ext_dalv:	` line=$D1%DW rc=$D2 },\
	62  { `LVM alloc_sa_bfs:	` line=$D4%DW d1=$D1 d2=$D2 },\
        63  { `LVM i_kmpaioop:    d1=$D1 d2=$D2 d3=$D3 d4=$D4 line=$D5%DW` },\
        64  { `LVM o_kmpaioop:    rc=$D1 line=$D2%DW` },\
        65  { `LVM i_kupdpv_mpid:   dev=$D1 pvnum=$D2 mpid=$D3 line=$D4%DW` },\
        66  { `LVM o_kupdpv_mpid:   dev=$D1 pvnum=$D2 pvptr=$D3 mpid=$D4 line=$D5%DW` },\
        67  { `LVM i_kppstale:    dev=$D1 lvminor=$D2 lpnum=$D3 isrpv=$D4 line=$D5%DW` },\
        68  { `LVM o_kppstale:    rc=$D1 line=$D2%DW` },\
        69  { `LVM i_kopenaiovg:  dev=$D1 vgflag=$D2` },\
        70  { `LVM o_kopenaiovg:  dev=$D1 vgflag=$D2 line=$D3%DW rc=$D4` },\
        71  { `LVM i_kaiorecvr:   d1=$D1 d2=$D2 d3=$D3 d4=$D4 line=$D5%DW` },\
        72  { `LVM o_kaiorecvr:   rc=$D1 line=$D2%DW` },\
        73  { `LVM aio_config:    d1=$D1 d2=$D2 d3=$D3 d4=$D4 line=$D5%DW` },\
        \*  { `LVM subhook=$HD%DW:	d1=$D1 d2=$D2 d3=$D3` }
5D5 1.0 "@LVM CONCURRENT EVENTS" \
        $HD%D2, \
         1  { `LVM conc:	dist_cmd=$D1%DW` },\
         2  { `LVM conc:	dcfg_child: dev=$D1 msg_type=$D2%DW result=$D3` },\
         3  { `LVM conc:	event: dev=$D1 event=$D2 line=$D3%DW` },\
         4  { `LVM conc:	tstamp: dev=$D1 sec=$D2 nsec=$D3 line=$D4%DW` },\
         5  { `LVM conc:	vgsa_child: dev=$D1 msg_type=$D2%DW vote=$D3` },\
        \*  { `LVM subhook=$HD%DW:	d1=$D1 d2=$D2 d3=$D3` }
5D6 1.0 "@LVM DEBUG EVENTS" \
        $HD%D2, \
         1  { `LVM top:		dev=$D1 event=$D2 line=$D3%DW` },\
        \*   { `LVM subhook=$HD%DW:	d1=$D1 d2=$D2 d3=$D3` }
5D7 1.0 "@LVM ERROR EVENTS" \
        $HD%D2, \
         1  { `LVM hd_bbdir:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
	 2  { `LVM hd_bbrel:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
         3  { `LVM hd_cfglv:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
         4  { `LVM hd_cfgpv:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
         5  { `LVM hd_cfgvg:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
         6  { `LVM hd_gs_conc:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
	 7  { `LVM hd_mircach:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
	 8  { `LVM hd_phys:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
         9  { `LVM hd_sched:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
        10  { `LVM hd_strat:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
        11  { `LVM hd_top:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
        12  { `LVM hd_vgsa:	dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
        13  { `LVM hd_cfgmp:    d1=$D1 d2=$D2 d3=$D3 rc=$D4 line=$D5%DW` },\
        14  { `LVM hd_aiomir:   d1=$D1 d2=$D2 d3=$D3 rc=$D4 line=$D5%DW` },\
	15  { `LVM wpar_err: 	dev=$D1 line=$D2%DW` },\
		16  { `LVM hd_vgda:     dev=$D1 data1=$D2 data2=$D3 line=$D4%DW` },\
        \*  { `LVM subhook=$HD%DW:	d1=$D1 d2=$D2 d3=$D3 d4=$D4` }
5D8 1.0  L=KERN "@WPAR2TID" \
   $GENERIC, \
      1 { \
         $D1, \
         0x02 { W2 cidinstall($TID,D4,0,0,0, S2) \
		"corral_config kcid="W2 D4 "WPAR_name=" S2 "WPAR_root_path=" S2 }, \
         0x03 { W2 cidinstall($TID,D4,0,0,0, $HL%S1) \
		"corral_modify kcid="W2 D4 "newname WPAR_name=" $HL%S1 }, \
           \* { `Unknown Generic hook id=$D1` } \
         $BREAK \
        } \
   $HD, \
    001 { cidinstall($TID, $D2, 0, 0, 0, 0) "brand:  pid="prKernelPID($D1) "kcid="$D2%D4 }, \
    \* { `unknown subhook id $HD` }
5DA 1.0 L=KERN "@ RECOVERY MANAGER" \
	$HD, \
	0x01 {  "ermgr_enter:" trans=$D1 rmgrwa=$D2 }, \
	0x02 {  "ermgr_exit:" rmgrwa=$D1 }, \
	0x03 {  "ermgr_epilog:" trmgrwa=$D1 rmgrwa=$D2 ectxid=$D3 }, \
	0x04 {  "drmgr_enter:" except=$D1 mst=$D2 }, \
	0x05 {  "drmgr_epilog:" rmgrwa=$D1 action=$D2 }, \
	0x06 {  "reentry:" rmgrwa=$D1 id=$D2 iar=$D3 }, \
	0x07 {  "longjmpx:" rmgrwa=$D1 jbuf=$D2 }, \
	0x08 {  "excbranch:" rmgrwa=$D1 excbranch=$D2  }, \
	0x09 {  "transition:" rmgrwa=$D1 trans=$D2 ectxid=$D3 }, \
	0x0a {  "frr_call:" rmgrwa=$D1 frr=$D2 }, \
	0x0b {  "frr_ret:" rmgrwa=$D1 action=$D2 }, \
	0x0c {  "continue:" rmgrwa=$D1 frrid=$D2 iar=$D3 }, \
	0x0d {  "lrmgr_epilog:" rmgrwa=$D1 action=$D2 }, \
	0x0e {  "rmgr_abend:" kerrno=$D1 data=$D2 lr=$D3 }, \
	0x0f {  "rmgr_halt_system:" rmgrwa=$D1 kerrno=$D2 data=$D3 lr=$D4 }, \
	\*   {  "unknown:" subhk=$HD }
5E6 1.0 L=KERN "RAS CT" \
	$HD, \
	0x1 { SUSPEND raspbp=$D1 flags=$D2 base=$D3 in=$D4 lvl|size=$D5 }, \
	0x2 { RESUME raspbp=$D1 flags=$D2 base=$D3 in=$D4 lvl|size=$D5 }, \
	0x3 { MEMBUFSIZE1 raspbp=$D1 flags=$D2 base=$D3 in=$D4 lvl|size=$D5 }, \
	0x4 { MEMBUFSIZE2 raspbp=$D1 flags=$D2 base=$D3 in=$D4 lvl|size=$D5 }, \
	0x5 { ALLOC raspbp=$D1 flags=$D2 base=$D3 in=$D4 lvl|size=$D5 }, \
	0x6 { FREE raspbp=$D1 flags=$D2 base=$D3 in=$D4 lvl|size=$D5 }, \
	0x7 { DR_EXIT event=$D1 size=$D2 rc=$D3 }, \
	0x8 { RTEC rc=$D1 data=$D2 }, \
	0x10 { ACCTPLUS0 raspbp=$D1 delta=$D2 totbuf=$D3 cmd=$D4 }, \
	0x20 { ACCTPLUS1 raspbp=$D1 delta=$D2 totbuf=$D3 cmd=$D4 }, \
	0x30 { ACCTPLUS2 raspbp=$D1 delta=$D2 totbuf=$D3 cmd=$D4 }, \
	0x40 { ACCTPLUS3 raspbp=$D1 delta=$D2 totbuf=$D3 cmd=$D4 }, \
	0xA0 { ACCTMINUS0 raspbp=$D1 delta=-$D2 totbuf=$D3 cmd=$D4 }, \
	0xB0 { ACCTMINUS1 raspbp=$D1 delta=-$D2 totbuf=$D3 cmd=$D4 }, \
	0xC0 { ACCTMINUS2 raspbp=$D1 delta=-$D2 totbuf=$D3 cmd=$D4 }, \
	0xD0 { GETUB raspbp=$D1 eyec=$D2 bufptr=$D3 len=$D4 }, \
	0xE0 { ENDUB raspbp=$D1 rc=$D2 }, \
	0xF0 { UNMANAGED raspbp=$D1 flags=$D2 base=$D3 in=$D4 lvl|size=$D5 }, \
	\* { unknown $HD $D1 $D2 $D3 $D4 $D5 }
5EC 1.0 'RDS ' \
        $HD%D1, \
1	{`rds_init_all_hca_in`}, \
2	{`rds_init_all_hca_out0`}, \
3	{`rds_init_all_hca_out1 rc=$D1%DW ibcp=$D2%XW`}, \
4	{`rds_init_all_hca_out2 rc=$D1%DW ibcp=$D2%XW`}, \
5	{`rds_init_all_hca_out flag=$D1%DW`}, \
6	{`rds_init_in`}, \
7	{`rds_init_out0`}, \
8	{`rds_init_out1 err=$D1%DW`}, \
9	{`rds_init_out2`}, \
10	{`rds_init_out3 err=$D1%DW`}, \
11	{`rds_init_out4`}, \
12	{`rds_init_out5`}, \
13	{`rds_init_out`}, \
14	{`rds_term_in`}, \
15	{`rds_term_out`}, \
16	{`rds_free_postrecv_in m=$D1%XW`}, \
17	{`rds_free_postrecv_out rc=$D1%DW`}, \
18	{`rds_sbappendaddr_in m0=$D1%XW so=$D2%XW control=$D3%XW`}, \
19	{`rds_sbappendaddr_out0 space=$D1%XW rds_sbspace=$D2%XW `}, \
20	{`rds_sbappendaddr_out1 sa_len=$D1%DW MLEN=$D2%DW`}, \
21	{`rds_sbappendaddr_out2 ibcp=$D1%XW`}, \
22	{`rds_sbappendaddr_out ibcp=$D1%XW ret=$D2%DW`}, \
23	{`rds_process_data_in sp=$D1%XW ibcp=$D2%XW sendcb=$D3%XW`}, \
24	{`rds_process_data_out0 sp=$D1%XW ibcp=$D2%XW sendcb=$D3%XW`}, \
25	{`rds_process_data_dbg0 lport=$D1%XW faddr=$D2%XW fport=$D3%XW`}, \
26	{`rds_process_data_out1 msgnum=$D1%XW last_msg_rcvd=$D2%XW lport=$D3%XW faddr=$D4%XW fport=$D5%XW`}, \
27	{`rds_process_data_dbg1 lport=$D1%XW msgnum=$D2%XW msgsize=$D3%XW rcvspace=$D4%XW rcvstalled=$D5%XW`}, \
28	{`rds_process_data_dbg2 newhiwat=$D1%XW msgnum=$D2%XW`}, \
29	{`rds_process_data_out2 ret=$D1%DW fport=$D2%XW rcvspace=$D3%XW sbspace=$D4%XW`}, \
30	{`rds_process_data_out error=$D1%DW sendcb=$D2%XW msgnum=$D3%XW`}, \
31	{`rds_ibcfosterpool_del_in msgnum=$D1%XW lport=$D2%XW fport=$D3%XW`}, \
32	{`rds_ibcfosterpool_del_out msgnum=$D1%XW lport=$D2%XW fport=$D3%XW`}, \
33	{`rds_input_sendcbfound_in sendcb=$D1%XW`}, \
34	{`rds_input_sendcbfound_out0 rc=$D1%DW dst_port=$D2%XW src_port=$D3%XW msgnum=$D4%XW`}, \
35	{`rds_input_sendcbfound_out1 rc=$D1%DW msgtype=$D2%XW rs_lport=$D3%XW`}, \
36	{`rds_input_sendcbfound_out2`}, \
37	{`rds_input_sendcbfound_dbg0 msgtype=$D1%XW msgnum=$D2%XW rs_lport=$D3%XW faddr=$D4%XW fport=$D5%XW`}, \
38	{`rds_input_sendcbfound_dbg1 rs_lport=$D1%XW rs_last_msg_sent=$D2%XW`}, \
39	{`rds_input_sendcbfound_out rc=$D1%DW sendcb=$D2%XW`}, \
40	{`rds_input_sendcbnotfound_in pcb=$D1%XW ibcp=$D2%XW`}, \
41	{`rds_input_sendcbnotfound_dbg0 laddr=$D1%XW dst_port=$D2%XW faddr=$D3%XW src_port=$D4%XW`}, \
42	{`rds_input_sendcbnotfound_dbg1 laddr=$D1%XW dst_port=$D2%XW faddr=$D3%XW src_port=$D4%XW`}, \
43	{`rds_input_sendcbnotfound_out0 ibcp=$D1%XW dst_port=$D2%XW src_port=$D3%XW msgnum=$D4%XW`}, \
44	{`rds_input_sendcbnotfound_out1 ibcp=$D1%XW dst_port=$D2%XW src_port=$D3%XW msgnum=$D4%XW`}, \
45	{`rds_input_sendcbnotfound_out2 rc=$D1%DW  so=$D2%XW sendcb=$D3%XW`}, \
46	{`rds_input_sendcbnotfound_dbg2 laddr=$D1%XW lport=$D2%XW`}, \
47	{`rds_input_sendcbnotfound_dbg3 msgnum=$D1%XW dst_port=$D2%XW src_port=$D3%XW`}, \
48	{`rds_input_sendcbnotfound_out pcb=$D1%XW ibcp=$D2%XW`}, \
49	{`rds_input_in ibcp=$D1%XW lport=$D2%XW faddr=$D3%XW`}, \
50	{`rds_input_dbg0 laddr=$D1%XW lport=$D2%XW`}, \
51	{`rds_input_out0 ret=$D1%DW so=$D2%XW pcb=$D3%XW`}, \
52	{`rds_input_out ret=$D1%DW`}, \
53	{`rds_usrreq_in so=$D1%XW req=$D2%XW`}, \
54	{`rds_usrreq_dbg0 lport=$D1%XW sbspace=$D2%XW hiwat=$D3%XW rcvstalled=$D4%XW`}, \
55	{`rds_usrreq_out error=$D1%DW req=$D2%DW`}, \
56	{`rds_send_unstall_in lport=$D1%XW`}, \
57	{`rds_send_unstall_dbg0 lport=$D1%XW faddr=$D2%XW fport=$D3%XW`}, \
58	{`rds_send_unstall_out rc=$D1%DW error=$D2%DW sendcb=$D3%XW`}, \
59	{`rds_send_in so=$D1%XW`}, \
60	{`rds_send_out0 rc=9`}, \
61	{`rds_send_out1 rc=22`}, \
62	{`rds_send_out2 error=$D1%DW`}, \
63	{`rds_send_out3 error=$D1%DW`}, \
64	{`rds_send_out4 error=$D1%DW lport=$D2%XW faddr=$D3%XW fport=$D4%XW error=$D5%DW`}, \
65	{`rds_send_dbg0 lport=$D1%XW ibc_state=$D2%XW`}, \
66	{`rds_send_out5 so=$D1%XW ibcp=$D2%XW`}, \
67	{`rds_send_dbg1 destcb=$D1%XW lport=$D2%XW space=$D3%XW stopsends=$D4%XW overflow=$D5%XW`}, \
68	{`rds_send_dbg2 last_msgnum=$D1%XW destcb=$D2%XW lport=$D3%XW`}, \
69	{`rds_send_dbg3 msgnum=$D1%XW faddr=$D1%XW dst_port=$D2%XW stopsends=$D3%XW`}, \
70	{`rds_send_out error=$D1%DW so=error=$D1%DW`}, \
71	{`rds_getsendcb_in rcb=$D1%XW destcb=$D2%XW`}, \
72	{`rds_getsendcb_out0`}, \
73	{`rds_getsendcb_out1`}, \
74	{`rds_getsendcb_out2`}, \
75	{`rds_getsendcb_out3`}, \
76	{`rds_getsendcb_out4 sindest=$D1%XW`}, \
77	{`rds_getsendcb_out5 sindest=$D1%XW`}, \
78	{`rds_getsendcb_out6 sindest=$D1%XW ro_rt=$D2%XW`}, \
79	{`rds_getsendcb_out7 sindest=$D1%XW localip=$D2%XW`}, \
80	{`rds_getsendcb_dbg0 lport=$D1%XW ibc_state=$D2%XW`}, \
81	{`rds_getsendcb_out8 rc=$D1%DW sindest=$D2%XW ro=$D3%XW ibcp=$D4%XW`}, \
82	{`rds_getsendcb_out9 lport=$D1%XW ibc_state=$D2%XW`}, \
83	{`rds_getsendcb_out10 rc=$D1%DW lport=$D2%XW ibc_state=$D3%XW`}, \
84	{`rds_getsendcb_out11 lport=$D1%XW sindest=$D2%XW dport=$D3%XW`}, \
85	{`rds_getsendcb_out rc=$D1%DW sendcb=$D2%XW`}, \
86	{`rds_output_in destcb=$D1%XW flags=$D2%XW`}, \
87	{`rds_output_out0`}, \
88	{`rds_output_out1 destcb=$D1%XW`}, \
89	{`rds_output_out2 destcb=$D1%XW`}, \
90	{`rds_output_out3`}, \
91	{`rds_output_out4 error=$D1%DW ibcp=$D2%XW`}, \
92	{`rds_output_out error=$D1%DW ibcp=$D2%XW destcb=$D3%XW`}, \
93	{`rds_send_ack_in ibcp=$D1%XW lport=$D2%XW fport=$D3%XW msgnum=$D4%XW msgtype=$D5%XW`}, \
94	{`rds_send_ack_out0 ibcp=$D1%XW msgnum=$D2%XW`}, \
95	{`rds_send_ack_out1 ibcp=$D1%XW`}, \
96	{`rds_send_ack_dbg0 msgtype=$D1%XW msgnum=$D2%XW laddr=$D3%XW faddr=$D4%XW`}, \
97	{`rds_send_ack_dbg1 msgnum=$D1%XW msgtype=$D2%XW`}, \
98	{`rds_send_ack_out2 m=$D1%XW ibcp=$D2%XW`}, \
99	{`rds_send_ack_dbg2 src_port=$D1%XW faddr=$D2%XW dst_port=$D3%XW msgtype=$D4%XW error=$D5%DW`}, \
100	{`rds_send_ack_out error=$D1%DW ibcp=$D2%XW`}, \
101	{`rds_process_ack_in msgacked=$D1%XW msg=$D2%XW sendcb=$D3%XW`}, \
102	{`rds_process_ack_out0 msgacked=$D1%XW msg=$D2%XW sendcb=$D3%XW`}, \
103	{`rds_process_ack_out1 so=$D1%XW`}, \
104	{`rds_process_ack_out2 msgacked=$D1%XW sendcb=$D2%XW`}, \
105	{`rds_process_ack_dbg0 hiwat=$D1%XW lowat=$D2%XW`}, \
106	{`rds_process_ack_out ibcp=$D1%XW`}, \
107	{`rds_process_ack_rds_ioctl_out cmd=$D1%XW req=$D2%XW`}, \
108	{`set_rdsopt_out0 optval=$D1%XW`}, \
109	{`set_rdsopt_out1 optval=$D1%XW`}, \
110	{`set_rdsopt_out2 optval=$D1%XW`}, \
111	{`set_rdsopt_dflt_out req=$D1%XW`}, \
112	{`get_rdsopt_out0 req=$D1%XW`}, \
113	{`get_rdsopt_out1 req=$D1%XW`}, \
114	{`rds_send_keepalive_in ibcp=$D1%XW msgtype=$D2%XW`}, \
115	{`rds_send_keepalive_out0 ibcp=$D1%XW msgtype=$D2%XW`}, \
116	{`rds_send_keepalive_out1 ack_moutcnt=$D1%XW ackq_overflow=$D2%XW`}, \
117	{`rds_send_keepalive_out faddr=$D1%XW msgtype=$D2%XW`}, \
118	{`rds_pcballoc_in so=$D1%XW`}, \
119	{`rds_pcballoc_out0 so=$D1%XW`}, \
120	{`rds_pcballoc_out so=$D1%XW sp=$D2%XW`}, \
121	{`rds_rds_pcbbind_in sp=$D1%XW`}, \
122	{`rds_rds_pcbbind_out0 sp=$D1%XW`}, \
123	{`rds_rds_pcbbind_out1 m_len=$D1%XW`}, \
124	{`rds_rds_pcbbind_out2 sin_addr=$D1%XW`}, \
125	{`rds_rds_pcbbind_out3 sin_addr=$D1%XW`}, \
126	{`rds_rds_pcbbind_out4 sin_addr=$D1%XW`}, \
127	{`rds_rds_pcbbind_out5 lport=$D1%XW`}, \
128	{`rds_rds_pcbbind_out6 lport=$D1%XW`}, \
129	{`rds_rds_pcbbind_out7 lport=$D1%XW`}, \
130	{`rds_rds_pcbbind_out sp=$D1%XW lport=$D2%XW`}, \
131	{`rds_pcb_hash_ins_in sp=$D1%XW`}, \
132	{`rds_pcb_hash_ins_out0 sp=$D1%XW index=$D2%XW`}, \
133	{`rds_pcb_hash_ins_out1 sp=$D1%XW`}, \
134	{`rds_pcb_hash_ins_out`}, \
135	{`rds_pcb_hash_ins_del_in sp=$D1%XW index=$D2%XW`}, \
136	{`rds_pcb_hash_del_out0 sp=$D1%XW`}, \
137	{`rds_pcb_hash_del_out sp=$D1%XW`}, \
138	{`rds_pcblookup_in index=$D1%XW laddr=$D2%XW lport=$D3%XW`}, \
139	{`rds_pcblookup_out0 match=$D1%XW`}, \
140	{`rds_pcblookup_out1 match=$D1%XW`}, \
141	{`rds_pcblookup_out match=$D1%XW`}, \
142	{`rds_pcbdetach_in sp=$D1%XW`}, \
143	{`rds_pcbdetach_out0 so=$D1%XW`}, \
144	{`rds_pcbdetach_out1 so=$D1%XW refcnt=$D2%XW`}, \
145	{`rds_pcbdetach_out2 so=$D1%XW sp=$D2%XW`}, \
146	{`rds_pcbdetach_out sp=$D1%XW`}, \
147	{`rds_ib_init_in ibcp=$D1%XW ibp=$D2%XW`}, \
148	{`rds_ib_init_out0 ibcp=$D1%XW ibp=$D2%XW rc=$D3%DW`}, \
149	{`rds_ib_init_out1 ibcp=$D1%XW ibp=$D2%XW rc=$D3%DW`}, \
150	{`rds_ib_init_out`}, \
151	{`rds_ib_init_hca_in ibcp=$D1%XW ibp=$D2%XW`}, \
152	{`rds_ib_init_hca_out0 hca_name=$D1%XW hca_number=$D2%XW ibcp=$D3%XW rc=$D4%DW`}, \
153	{`rds_ib_init_hca_dbg0 hca_number=$D1%XW hca_handle=$D2%XW ibp=$D3%XW`}, \
154	{`rds_ib_init_hca_out1 rc=$D1%DW hca_number=$D2%XW hca_handle=$D3%XW`}, \
155	{`rds_ib_init_hca_dbg1 hca_number=$D1%XW hca_handle=$D2%XW ibp=$D3%XW`}, \
156	{`rds_ib_init_hca_out2 rc=$D1%DW hca_number=$D2%XW hca_handle=$D3%XW`}, \
157	{`rds_ib_init_hca_dbg2 hca_number=$D1%XW hca_handle=$D2%XW ibp=$D3%XW`}, \
158	{`rds_ib_init_hca_out3 hca_handle=$D1%XW`}, \
159	{`rds_ib_init_hca_out4 rc=$D1%DW hca_handle=$D2%XW`}, \
160	{`rds_ib_init_hca_dbg3 hca_handle=$D1%XW port=$D2%XW`}, \
161	{`rds_ib_init_hca_out5 hca_handle=$D1%XW port=$D2%XW`}, \
162	{`rds_ib_init_hca_dbg4 hca_handle=$D1%XW port=$D2%XW`}, \
163	{`rds_ib_init_hca_out6 hca_handle=$D1%XW port=$D2%XW`}, \
164	{`rds_ib_init_hca_dbg5 hca_handle=$D1%XW num_ports=$D2%XW`}, \
165	{`rds_ib_init_hca_out7 hca_handle=$D1%XW`}, \
166	{`rds_ib_init_hca_out8 rc=$D1%DW hca_handle=$D2%XW port=$D3%XW`}, \
167	{`rds_ib_init_hca_out9 rc=$D1%DW hca_handle=$D2%XW port=$D3%XW`}, \
168	{`rds_ib_init_hca_dbg6 port=$D1%XW source_lid=$D2%XW hca_handle=$D3%XW`}, \
169	{`rds_ib_init_hca_out`}, \
170	{`rds_ib_init_hca_out10 rc=$D1%DW rc2=$D2%DW hca_handle=$D3%XW hca_number=$D4%XW`}, \
171	{`rds_ib_init_ibc_in hca_handle=$D1%XW faddr=$D2%DW`}, \
172	{`rds_ib_init_ibc_out0 rc=$D1%DW hca_handle=$D2%XW faddr=$D3%XW port=$D4%XW`}, \
173	{`rds_ib_init_ibc_dbg0 rc=$D1%DW hca_handle=$D2%XW ibc_pd=$D3%XW`}, \
174	{`rds_ib_init_ibc_out1 rc=$D1%DW hca_handle=$D2%XW rxcq_size=$D3%XW`}, \
175	{`rds_ib_init_ibc_out2 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW txcq_size=$D4%XW`}, \
176	{`rds_ib_init_ibc_out3 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW rxcq_size=$D4%XW`}, \
177	{`rds_ib_init_ibc_out4 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW txcq_size=$D4%XW`}, \
178	{`rds_ib_init_ibc_out5 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW rxcq_size=$D4%XW`}, \
179	{`rds_ib_init_ibc_out6 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW txcq_size=$D4%XW`}, \
180	{`rds_ib_init_ibc_out7 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW`}, \
181	{`rds_ib_init_ibc_out8 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW qp_handle=$D4%XW qp_number=$D5%XW`}, \
182	{`rds_ib_init_ibc_out9 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW activeside=$D4%XW`}, \
183	{`rds_ib_init_ibc_out hca_handle=$D1%XW`}, \
184	{`rds_ib_init_ibc_out10 rc=$D1%DW rc2=$D2%DW hca_handle=$D3%XW`}, \
185	{`rds_ib_term_ibc_in hca_handle=$D1%XW faddr=$D2%XW`}, \
186	{`rds_ib_term_ibc_out0 rc=$D1%DW hca_handle=$D2%XW faddr=$D3%XW qp_handle=$D4%XW qp_number=$D5%XW`}, \
187	{`rds_ib_term_ibc_out1 rc=$D1%DW hca_handle=$D2%XW rxcq_handle=$D3%XW`}, \
188	{`rds_ib_term_ibc_out2 rc=$D1%DW hca_handle=$D2%XW txcq_handle=$D3%XW`}, \
189	{`rds_ib_term_ibc_out3 rc=$D1%DW hca_handle=$D2%XW rxmem_handle=$D3%XW`}, \
190	{`rds_ib_term_ibc_out4 rc=$D1%DW hca_handle=$D2%XW acktx_handle=$D3%XW`}, \
191	{`rds_ib_term_ibc_out5 rc=$D1%DW hca_handle=$D2%XW txmem_handle=$D3%XW`}, \
192	{`rds_ib_term_ibc_dbg0 faddr=$D1%XW hca_handle=$D2%XW rxbuf_moutcnt=$D3%XW`}, \
193	{`rds_ib_term_ibc_dbg1 faddr=$D1%XW hca_handle=$D2%XW rxbuf_moutcnt=$D3%XW`}, \
194	{`rds_ib_term_ibc_dbg2 faddr=$D1%XW hca_handle=$D2%XW ackbuf_moutcnt=$D3%XW`}, \
195	{`rds_ib_term_ibc_out6 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW pd=$D4%XW`}, \
196	{`rds_ib_term_ibc_out faddr=$D1%XW hca_handle=$D2%XW`}, \
197	{`rds_ib_term_all_hca_in ibc_count=$D1%XW`}, \
198	{`rds_ib_term_all_hca_out0 rc=$D1%DW`}, \
199	{`rds_ib_term_all_hca_out`}, \
200	{`rds_ib_post_recv_in faddr=$D1%XW m=$D2%XW`}, \
201	{`rds_ib_post_recv_out0 rc=$D1%DW faddr=$D2%XW m=$D3%XW rxmem_LKey=$D4%XW`}, \
202	{`rds_ib_post_recv_out rc=$D1%DW`}, \
203	{`rds_cm_connect_in faddr=$D1%XW`}, \
204	{`rds_cm_connect_out0 ifp=$D1%XW`}, \
205	{`rds_cm_connect_out1 ifp=$D1%XW`}, \
206	{`rds_cm_connect_out2 ifp=$D1%XW`}, \
207	{`rds_cm_connect_out3 rc=$D1%DW faddr=$D2%XW`}, \
208	{`rds_cm_connect_dbg0 rc=$D1%DW if_dep=$D2%XW at_flags=$D3%XW`}, \
209	{`rds_cm_connect_out4 rc=$D1%DW at_flags=$D2%XW`}, \
210	{`rds_cm_connect_out5 ap=$D1%DW`}, \
211	{`rds_cm_connect_out6 ap=$D1%DW`}, \
212	{`rds_cm_connect_out7 faddr=$D1%XW`}, \
213	{`rds_cm_connect_out8 ibcp=$D1%XW`}, \
214	{`rds_cm_connect_out9 rc=$D1%DW hca_handle=$D2%XW faddr=$D3%XW hca_number=$D4%XW`}, \
215	{`rds_cm_connect_dbg1 faddr=$D1%XW DLID=$D2%XW`}, \
216	{`rds_cm_connect_out10 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW port=$D4%XW`}, \
217	{`rds_cm_connect_out11 faddr=$D1%XW hca_handle=$D2%XW conn_handle=$D3%XW`}, \
218	{`rds_cm_connect_out12 rc=$D1%DW hca_handle=$D2%XW`}, \
219	{`rds_ib_listener_init_in hca_handle=$D1%XW port=$D2%XW ibc_PKey=$D3%XW`}, \
220	{`rds_ib_listener_init_out0 rc=$D1%DW hca_handle=$D2%XW port=$D3%XW`}, \
221	{`rds_ib_listener_init_out`}, \
222	{`rds_cm_listen_complete_in hca_handle=$D1%XW faddr=$D2%XW port=$D3%XW`}, \
223	{`rds_cm_listen_complete_out0 faddr=$D1%XW`}, \
224	{`rds_cm_listen_complete_out1 rc=$D1%DW hca_handle=$D2%XW port=$D3%XW`}, \
225	{`rds_cm_listen_complete_out2 rc=$D1%DW hca_handle=$D2%XW faddr=$D3%XW`}, \
226	{`rds_cm_listen_complete_out`}, \
227	{`rds_cm_listen_complete_out3 rc2=$D1%DW rc=$D2%DW`}, \
228	{`rds_cm_accept_in ibcp=$D1%XW`}, \
229	{`rds_cm_accept_out0 ibcp=$D1%XW`}, \
230	{`rds_cm_accept_out1 rc=$D1%DW faddr=$D2%XW hca_handle=$D3%XW`}, \
231	{`rds_cm_accept_out faddr=$D1%XW hca_handle=$D2%XW conn_handle=$D3%XW`}, \
232	{`rds_cm_accept_ontimer_in faddr=$D1%XW hca_handle=$D2%XW`}, \
233	{`rds_cm_accept_ontimer_out rc=$D1%DW ibcp=$D2%XW`}, \
234	{`rds_ib_input_in ibcp=$D1%XW`}, \
235	{`rds_ib_input_out0 faddr=$D1%XW msgtype=$D2%XW msgnum=$D3%XW`}, \
236	{`rds_ib_input_out1 rc=$D1%DW m=$D2%XW ibcp=$D3%XW`}, \
237	{`rds_ib_input_dbg0 faddr=$D1%XW msgtype=$D2%XW msgnum=$D3%XW datadue=$D4%XW`}, \
238	{`rds_ib_input_out rc=$D1%DW`}, \
239	{`rds_ib_output_in sendcb=$D1%XW`}, \
240	{`rds_ib_output_out0 sendcb=$D1%XW`}, \
241	{`rds_ib_output_out1 sendcb=$D1%XW`}, \
242	{`rds_ib_output_out2 sendcb=$D1%XW`}, \
243	{`rds_ib_output_out3 sendcb=$D1%XW`}, \
244	{`rds_ib_output_out4 sendcb=$D1%XW`}, \
245	{`rds_ib_output_dbg0 faddr=$D1%XW cur_msgnum=$D2%XW last_msg_sent=$D3%XW msgnum=$D4%XW pkt2send=$D5%XW`}, \
246	{`rds_ib_output_out5 sendcb=$D1%XW`}, \
247	{`rds_ib_output_dbg1 arg1=$D1%XW arg2=$D2%XW arg3=$D3%XW arg4=$D4%XW`}, \
248	{`rds_ib_output_dbg2 faddr=$D1%XW ibcseqnum=$D2%XW seqnum_deliv=$D3%XW ackseq_deliv=$D4%XW`}, \
249	{`rds_ib_output_out6 cur_msgnum=$D1%XW lport=$D2%XW fport=$D3%XW faddr=$D4%XW`}, \
250	{`rds_ib_output_out7 rc=$D1%DW txbuf_moutcnt=$D2%XW ibc_seqnum=$D3%XW seqnum_deliv=$D4%XW ackseq_deliv=$D5%XW`}, \
251	{`rds_ib_output_dbg3 cur_msgnum=$D1%XW stopsends=$D2%XW sendq_taken=sendq_taken`}, \
252	{`rds_ib_output_dbg4 ibcp=$D1%XW`}, \
253	{`rds_ib_output_out rc=$D1%DW`}, \
254	{`rds_sendcb_copy_newpool_in lport=$D1%XW faddr=$D2%XW fport=$D3%XW msgnum=$D4%XW`}, \
255	{`rds_sendcb_copy_newpool_out0 error=$D1%XW so=$D2%XW ibcp=$D3%XW`}, \
256	{`rds_sendcb_copy_newpool_out sendcb=$D1%XW`}, \
257	{`rds_cm_conn_ready_in ibcp=$D1%XW`}, \
258	{`rds_cm_conn_ready_out0 ibcp=$D1%XW sendcb=$D2%XW`}, \
259	{`rds_cm_conn_ready_out1 sendcb=$D1%XW rdspcb=$D2%XW`}, \
260	{`rds_cm_conn_ready_out`}, \
261	{`rds_warn_sendcb_ibcerror_in ibcp=$D1%XW error=$D2%XW`}, \
262	{`rds_warn_sendcb_ibcerror_out`}, \
263	{`rds_cm_rejected_in faddr=$D1%XW ibc_state=$D2%XW`}, \
264	{`rds_cm_rejected_out0 so=$D1%XW newm=$D2%XW`}, \
265	{`rds_cm_rejected_out1 so=$D1%XW newm=$D2%XW`}, \
266	{`rds_cm_rejected_out2 faddr=$D1%XW`}, \
267	{`rds_cm_rejected_out`}, \
268	{`rds_cm_disconnect_in ibcp=$D1%XW`}, \
269	{`rds_cm_disconnect_out0 ibc_state=$D1%XW`}, \
270	{`rds_cm_disconnect_out1 rc=$D1%DW ibc_state=$D2%XW`}, \
271	{`rds_cm_disconnect_out2 rc=$D1%DW ibc_state=$D2%XW`}, \
272	{`rds_cm_disconnect_out rc=$D1%DW`}, \
273	{`rds_ib_rxcq_handler_in ibcp=$D1%XW`}, \
274	{`rds_ib_rxcq_handler_out0 faddr=$D1%XW PollHcaHandle=$D2%XW hca_handle=$D3%XW CqHandleIn=$D4%XW rxcq_handle=$D5%XW`}, \
275	{`rds_ib_rxcq_handler_out1 faddr=$D1%XW rc=$D2%DW`}, \
276	{`rds_ib_rxcq_handler_out2 hca_handle=$D1%XW`}, \
277	{`rds_ib_rxcq_handler_out3 faddr=$D1%XW ifpnew=$D2%XW`}, \
278	{`rds_ib_rxcq_handler_dbg0 hca_number=$D1%XW hca_handle=$D2%XW ibp=$D3%XW`}, \
279	{`rds_ib_rxcq_handler_dbg1 hca_number=$D1%XW hca_handle=$D2%XW ibp=$D3%XW`}, \
280	{`rds_ib_rxcq_handler_dbg2 hca_number=$D1%XW hca_handle=$D2%XW ibp=$D3%XW`}, \
281	{`rds_ib_rxcq_handler_out`}, \
282	{`rds_ib_txcq_handler_in hca_handle=$D1%XW txcq_handle=$D2%XW`}, \
283	{`rds_ib_txcq_handler_out0 ibcp=$D1%XW rc=$D2%DW`}, \
284	{`rds_ib_txcq_handler_out ibcp=$D1%XW`}, \
285	{`rds_ib_txcq_poll_in ibcp=$D1%XW`}, \
286	{`rds_ib_txcq_poll_out0 txcq_handle=$D1%XW hca_handle=$D2%XW`}, \
287	{`rds_ib_txcq_poll_out1 faddr=$D1%XW rc=$D2%DW`}, \
288	{`rds_ib_txcq_poll_dbg0 faddr=$D1%XW ErrorType=$D2%XW WrkReqId=$D3%XW`}, \
289	{`rds_ib_txcq_poll_dbg1 faddr=$D1%XW qp_number=$D2%XW LocalQpn=$D3%XW`}, \
290	{`rds_ib_txcq_poll_dbg2 faddr=$D1%XW wrid=$D2%XW sendq_overflow=$D3%XW ackq_overflow=$D4%XW`}, \
291	{`rds_ib_txcq_poll_dbg3 msgtype=$D1%XW msgnum=$D2%XW sendq_taken=$D3%XW`}, \
292	{`rds_ib_txcq_poll_out rc=$D1%DW ibcp=$D2%XW`}, \
293	{`rds_ib_eq_handler hca_handle=$D1%XW event=$D2%XW`}, \
294	{`rds_ib_cm_handler_in cm_ibcp=$D1%XW hca_handle=$D2%XW`}, \
295	{`rds_ib_cm_handler_out0 hca_handle=$D1%XW ConnHandle=$D2%XW`}, \
296	{`rds_ib_cm_handler_dbg0 faddr=$D1%XW ReasonCode=$D2%XW ConnHandle=$D3%XW hca_handle=$D4%XW`}, \
297	{`rds_ib_cm_handler_dbg1 faddr=$D1%XW ReasonCode=$D2%XW ConnHandle=$D3%XW hca_handle=$D4%XW`}, \
298	{`rds_ib_cm_handler_dbg2 src_addr=$D1%XW ConnHandle=$D2%XW hca_handle=$D3%XW`}, \
299	{`rds_ib_cm_handler_out1 hca_handle=$D1%XW ConnHandle=$D2%XW RoleType=$D3%XW`}, \
300	{`rds_ib_cm_handler_dbg3 faddr=$D1%XW ConnHandle=$D2%XW hca_handle=$D3%XW`}, \
301	{`rds_ib_cm_handler_out2 hca_handle=$D1%XW`}, \
302	{`rds_ib_cm_handler_dbg4 faddr=$D1%XW EventCode=$D2%XW`}, \
303	{`rds_ib_cm_handler_out`}, \
304	{`rds_ib_term_hca_in hca_number=$D1%XW`}, \
305	{`rds_ib_term_hca_out0 hca_number=$D1%XW`}, \
306	{`rds_ib_term_hca_out1 rc=$D1%DW hca_handle=$D2%XW`}, \
307	{`rds_ib_term_hca_out2 rc=$D1%DW hca_handle=$D2%XW`}, \
308	{`rds_ib_term_hca_out`}, \
309	{`rds_ib_conn_close_in`}, \
310	{`rds_ib_conn_close_out`}, \
311	{`rds_find_ibsoftc_in hca_handle=$D1%XW port=$D2%XW`}, \
312	{`rds_find_ibsoftc_out0 tmpibp=$D1%XW`}, \
313	{`rds_find_ibsoftc_out hca_handle=$D1%XW`}, \
314	{`rds_send_ack_ontimer_in`}, \
315	{`rds_send_ack_ontimer_dbg0 faddr=$D1%XW lport=$D2%XW fport=$D3%XW `}, \
316	{`rds_send_ack_ontimer_out`}, \
317	{`rds_timer_in`}, \
318	{`rds_timer_dbg0 faddr=$D1%XW`}, \
319	{`rds_timer_dbg1 rc=$D1%DW faddr=$D2%XW`}, \
320	{`rds_timer_dbg2 faddr=$D1%XW`}, \
321	{`rds_timer_out0 faddr=$D1%XW`}, \
322	{`rds_timer_out1 faddr=$D1%XW`}, \
323	{`rds_timer_out2 faddr=$D1%XW`}, \
324	{`rds_timer_out3 faddr=$D1%XW ifpnew=$D2%XW`}, \
325	{`rds_timer_out4 faddr=$D1%XW`}, \
326	{`rds_timer_out5 ibcp=$D1%XW`}, \
327	{`rds_timer_out`}, \
328	{`rds_ib_failover_in faddr=$D1%XW`}, \
329	{`rds_ib_failover_out`}, \
330	{`rds_clear_ibc_in ibcp=$D1%XW`}, \
331	{`rds_clear_ibc_dbg faddr=$D1%XW`}, \
332	{`rds_clear_ibc_out ibcp=$D1%XW`}, \
333	{`rds_ibc_hash_ins_in faddr=$D1%XW loopback=$D2%XW`}, \
334	{`rds_ibc_hash_ins_out0 ibctmp=$D1%XW faddr=$D2%XW`}, \
335	{`rds_ibc_hash_ins_out1 faddr=$D1%XW`}, \
336	{`rds_ibc_hash_ins_out newibc=$D1%XW`}, \
337	{`rds_ibc_hash_del_in ibcp=$D1%XW`}, \
338	{`rds_ibc_hash_del_out1`}, \
339	{`rds_ibc_hash_del_out0 ibcp=$D1%XW`}, \
340	{`rds_ibc_hash_del_out`}, \
341	{`rds_ibc_hash_lookup_in lookupaddr=$D1%XW`}, \
342	{`rds_ibc_hash_lookup_out0 ibctmp=$D1%XW`}, \
343	{`rds_ibc_hash_out`}, \
344	{`rds_ibclookup_in rdsibkp=$D1%XW`}, \
345	{`rds_ibclookup_out0`}, \
346	{`rds_ibclookup_out1 ibcp=$D1%XW`}, \
347	{`rds_ibclookup_out2 match=$D1%XW`}, \
348	{`rds_ibclookup_out match=$D1%XW`}, \
349	{`rds_sendcb_hash_ins_in fport=$D1%XW faddr=$D2%XW lport=$D3%XW`}, \
350	{`rds_sendcb_hash_ins_out0 sendcbtmp=$D1%XW`}, \
351	{`rds_sendcb_hash_ins_out1 lport=$D1%XW fport=$D2%XW`}, \
352	{`rds_sendcb_hash_ins_out2 pcb=$D1%XW`}, \
353	{`rds_sendcb_hash_ins_out3 so=$D1%XW`}, \
354	{`rds_sendcb_hash_ins_out4 newsendcb=$D1%XW`}, \
355	{`rds_sendcb_hash_ins_out5 newsendcb=$D1%XW`}, \
356	{`rds_sendcb_hash_ins_out lport=$D1%XW faddr=$D2%XW fport=$D3%XW newsendcb=$D4%XW`}, \
357	{`rds_sendcb_hash_del_in lport=$D1%XW faddr=$D2%XW fport=$D3%XW`}, \
358	{`rds_sendcb_hash_del_out0 sendcb=$D1%XW`}, \
359	{`rds_sendcb_hash_del_out sendcb=$D1%XW`}, \
360	{`rds_sendcb_hash_lookup_in lport=$D1%XW faddr=$D2%XW fport=$D3%XW`}, \
361	{`rds_sendcb_hash_lookup_out0 faddr=$D1%XW fport=$D2%XW sendcbtmp=$D3%XW`}, \
362	{`rds_sendcb_hash_lookup_out faddr=$D1%XW`}, \
363	{`rds_movetofosterpool_in laddr=$D1%XW lport=$D2%XW fport=$D3%XW`}, \
364	{`rds_movetofosterpool_out0 sendcb=$D1%XW last_msg_sent=$D2%XW`}, \
365	{`rds_movetofosterpool_out ibcp=$D1%XW sendcb=$D2%XW`}, \
366	{`rds_rds_sendcbdetach_in sp=$D2%XW`}, \
367	{`rds_rds_sendcbdetach_dbg0 faddr=$D1%XW lport=$D2%XW fport=$D3%XW`}, \
368	{`rds_rds_sendcbdetach_out0 laddr=$D1%XW lport=$D2%XW fport=$D3%XW`}, \
369	{`rds_rds_sendcbdetach_out1 sendcb=$D1%XW`}, \
370	{`rds_rds_sendcbdetach_out2 sendcb=$D1%XW`}, \
371	{`rds_rds_sendcbdetach_dbg1 faddr=$D1%XW lport=$D2%XW fport=$D3%XW unsentmsg=$D4%XW`}, \
372	{`rds_rds_sendcbdetach_out`}, \
373	{`rds_register_pools_in ibcp=$D1%XW pool=$D2%XW`}, \
374	{`rds_register_pools_dbg0 rxpooloutcnt=$D1%XW faddr=$D2%XW`}, \
375	{`rds_register_pools_out0 rc=$D1%DW hca_handle=$D2%XW`}, \
376	{`rds_register_pools_out1 rc=$D1%DW ibcp=$D2%XW`}, \
377	{`rds_register_pools_out2 rc=$D1%DW ibcp=$D2%XW`}, \
378	{`rds_register_pools_out3 rc=$D1%DW ibcp=$D2%XW`}, \
379	{`rds_register_pools_out ibcp=$D1%DW`}, \
380	{`rds_build_buf_pool_in ibcp=$D1%XW allpools=$D2%XW`}, \
381	{`rds_build_buf_pool_out0 faddr=$D1%XW`}, \
382	{`rds_build_buf_pool_out rc=$D1%DW ibcp=$D2%XW faddr=$D3%XW`}, \
383	{`rds_fetch_buffer_in so=$D1%DW ibcp=$D2%XW`}, \
384	{`rds_fetch_buffer_out0 txbuf_pool=$D1%DW`}, \
385	{`rds_fetch_buffer_out1 ibcp=$D1%XW`}, \
386	{`rds_fetch_buffer_out ibcp=$D1%XW`}, \
387	{`rds_loopback_output_in sendcb=$D1%XW`}, \
388	{`rds_loopback_output_out0 sendcb=$D1%XW`}, \
389	{`rds_loopback_output_out1 sendcb=$D1%XW`}, \
390	{`rds_loopback_output_out2 sendcb=$D1%XW ibcp=$D2%XW`}, \
391	{`rds_loopback_output_out3 last_msgnum=$D1%XW`}, \
392	{`rds_loopback_output_out4 sendcb=$D1%XW`}, \
393	{`rds_loopback_output_out5 msgnum=$D1%XW last_msg_sent=$D2%XW pkt2send=$D3%XW`}, \
394	{`rds_loopback_output_out6 sendcb=$D1%XW`}, \
395	{`rds_loopback_output_out7 error=$D1%XW pkt2send=$D2%XW ibcp=$D3%XW`}, \
396	{`rds_loopback_output_dbg cur_msgnum=$D1%XW rs_stopsends=$D2%XW sendq_taken=$D3%XW`}, \
397	{`rds_loopback_output_out nummsg=$D1%XW so=$D2%XW`}, \
398	{`rds_loopback_ibc_create_out faddr=$D1%XW ibcp=$D2%XW`}, \
399	{`rds_restart_sends_in ibcp=$D1%XW`}, \
400	{`rds_restart_sends_out0 ibcp=$D1%XW`}, \
401	{`rds_restart_sends_out1 ibcp=$D1%XW sendcb=$D2%XW`}, \
402	{`rds_restart_sends_out`}, \
\* { unknown subhook $HD $ERROR }
5F0 1.0 L=KERN "@Network RTEC Error Log" \
    {{ \
    print_decoded_kerrno(kerrno) \
        "kerrno = " $kerrno \n \
        {{ $kerrno_block = $kerrno & 0xFFF000 }} \
    	{{ $kerrno_src_line = $kerrno & 0xFFF }} \
    	{{ $kerrno_block_found = 1 }} \
	$kerrno_block - 0x940000, \
	    0x000000 { "src/bos/kernel/lib/libofed_wrappers/linked_lists.c" }, \
	    0x001000 { "src/bos/kernel/lib/libofed_wrappers/syncronization_primitives.c" }, \
	    0x002000 { "src/bos/kernel/lib/libofed_wrappers/work_queues.c" }, \
	    0x003000 { "src/ofed/kernext/rds/af_rds.c" }, \
	    0x004000 { "src/ofed/kernext/rds/aix_rds_config.c" }, \
	    0x005000 { "src/ofed/kernext/rds/aix_ofed_socket.c" }, \
	    0x006000 { "src/ofed/kernext/rds/bind.c" }, \
	    0x007000 { "src/ofed/kernext/rds/cong.c" }, \
	    0x008000 { "src/ofed/kernext/rds/connection.c" }, \
	    0x009000 { "src/ofed/kernext/rds/info.c" }, \
	    0x00A000 { "src/ofed/kernext/rds/loop.c" }, \
	    0x00B000 { "src/ofed/kernext/rds/message.c" }, \
	    0x00C000 { "src/ofed/kernext/rds/page.c" }, \
	    0x00D000 { "src/ofed/kernext/rds/recv.c" }, \
	    0x00E000 { "src/ofed/kernext/rds/send.c" }, \
	    0x00F000 { "src/ofed/kernext/rds/stats.c" }, \
	    0x010000 { "src/ofed/kernext/rds/aix_rds_sysctl.c" }, \
	    0x011000 { "src/ofed/kernext/rds/threads.c" }, \
	    0x012000 { "src/ofed/kernext/rds/transport.c" }, \
	    0x013000 { "src/bos/kernel/lib/libofed_wrappers/ofed_ras.c" }, \
	    0x014000 { "src/ofed/kernext/rds/aix_rds_proto.c" }, \
	    0x015000 { "src/bos/kernel/lib/libofed_wrappers/memory_management.c" }, \
	    0x016000 { "src/bos/kernel/lib/libofed_wrappers/multiprocessor.c" }, \
	    0x017000 { "src/ofed/kernext/rds/ib.c" }, \
	    0x018000 { "src/ofed/kernext/rds/ib_cm.c" }, \
	    0x019000 { "src/ofed/kernext/rds/ib_ring.c" }, \
	    0x01A000 { "src/ofed/kernext/rds/ib_stats.c" }, \
	    0x01B000 { "src/ofed/kernext/rds/ib_recv.c" }, \
	    0x01C000 { "src/ofed/kernext/rds/ib_send.c" }, \
	    0x01D000 { "src/ofed/kernext/rds/aix_ofed_ib_dma.c" }, \
	    0x01E000 { "src/ofed/kernext/rds/aix_ib_wrapper.c" }, \
	    0x01F000 { "src/ofed/kernext/rds/aix_ib_arp_provider.c" }, \
	    0x020000 { "src/bos/kernel/lib/libofed_wrappers/ofed_misc_wrappers.c" }, \
	    0x021000 { "src/bos/kernel/lib/libofed_wrappers/hash_tables.c" }, \
	    0x022000 { "src/bos/kernel/lib/libofed_wrappers/red_black_trees.c" }, \
	    0x023000 { "src/ofed/kernext/rds/aix_ib_cm.c" }, \
	    0x024000 { "src/ofed/kernext/rds/rdma.c" }, \
	    0x025000 { "src/ofed/kernext/rds/ib_rdma.c" }, \
	    0x026000 { "src/ofed/kernext/rds/aix_ib_device.c" }, \
	    0x027000 { "src/ofed/kernext/rds/aix_ib_dma_page_pool.c" }, \
	    0x028000 { "src/ofed/kernext/rds/aix_rdma_wrappers.c" }, \
	    0x029000 { "src/ofed/kernext/rds/aix_rds_wire_tracing.c" }, \
	    0X02A000 { "src/rnic/kernext/ofed_core/aix_ofed_core.c" }, \
	    0X02B000 { "src/rnic/kernext/ofed_core/iwcm.c" }, \
	    0X02C000 { "src/rnic/kernext/ofed_core/verbs.c" }, \
	    0X02D000 { "src/rnic/kernext/ofed_core/cma.c" }, \
	    0X02E000 { "src/rnic/kernext/ofed_core/device.c" }, \
	    0X02F000 { "src/rnic/kernext/ofed_core/cache.c" }, \
	    0X030000 { "src/rnic/kernext/ofed_core/packer.c" }, \
	    0X031000 { "src/rnic/kernext/ofed_core/ucma.c" }, \
	    0X032000 { "src/rnic/kernext/ofed_core/ud_header.c" }, \
	    0X033000 { "src/rnic/kernext/ofed_core/uverbs_main.c" }, \
	    0X034000 { "src/rnic/kernext/ofed_core/addr.c" }, \
	    0X035000 { "src/rnic/kernext/ofed_core/aix_addr.c" }, \
	    0X036000 { "src/bos/kernel/lib/libofed_wrappers/idr.c" }, \
	    0X037000 { "src/rnic/kernext/ofed_core/uverbs_cmd.c" }, \
	    \*       { {{ $kerrno_block_found = 0 }} } \
	$kerrno_block_found, \
	    1 { ":" $kerrno_src_line%UW \n } \
    }} \
    {{ $kerrno = XW }} \
    {{ $seq_num = X2 }} \
    {{ $num_data_args = X2 }} \
    {{ $stktrace_len = X2 }} \
    {{ $stktrace_sel = X1 }} \
    {{ $stktrace_skip_bytes = X1 }} \
    \n "TID=" $TID "CPU=" $CPUID \n \
    "Seq num = " $seq_num \n \
    print_decoded_kerrno($kerrno) \
    "Data args = " \n \
    LOOP $num_data_args { XW \n } \
    LOOP $stktrace_skip_bytes { O1 } \
    $stktrace_sel, \
        0 { }, \
        1 { "Stack trace = " \n \
	    $stktrace_len%S2 }, \
        2 { {{ $stktrace_len  = $stktrace_len / 8 }} \
            "Stack trace = " \n \
	    LOOP $stktrace_len { XW \n } \
          }, \
    \*  { "unknown stktrace selector " $stktrace_sel }
5F1 1.0 L=KERN "RAS Infra" \
	$HD, \
	0x1 { REG_EXIT rasr=$D1 parent_in=$D2 flags=$D3 rc=$D4 }, \
	0x2 { REGSTATIC_EXIT rasr=$D1 parent_in=$D2 flags=$D3 rc=$D4 }, \
	0x3 { REGINT_SET raspbp=$D1 }, \
	0x4 { CUST_SET raspbp=$D1 }, \
	0x5 { CUST_EXIT raspbp=$D1 rc=$D2 }, \
	0x6 { UNREG_START raspbp=$D1 }, \
	0x7 { UNREG_ERROR ras[p/r]bp=$D1 rc=$D2 }, \
	0x8 { UNREG_SLEEP raspbp=$D1 refcount=$D2 }, \
	0x9 { UNREG_FINISH raspbp=$D1 }, \
	0xA { GET_START raspbp=$D1 }, \
	0xB { GET_ERROR raspbp=$D1 rc=$D2 }, \
	0xC { PUT_WAKE raspbp=$D1 }, \
	0xD { PUT_EXIT raspbp=$D1 rc=$D2 }, \
	0xE { LOOKUP_EXIT rc=$D1 W2 $HL%S1 }, \
	0xF { PATLOOKUP_EXIT rc=$D1 W2 $HL%S1 }, \
	0x10 { GETFULLPATH_EXIT raspbp=$D1 rc=$D2 }, \
	0x11 { APPLYALL_EXIT parent=$D1 func=$D2 param=$D3 rc=$D4 }, \
	0x12 { CONTROL_ENTER path|raspbp=$D1 cmd=$D2 arg=$D3 }, \
	0x13 { CONTROL_EXIT path|raspbp=$D1 cmd=$D2 arg=$D3 rc$D4 }, \
	0x14 { CONTROL_ERROR path|raspbp|NULL=$D1 cmd=$D2 arg=$D3 rc$D4 }, \
	0x15 { INFRA_RTEC rc$D1 data=$D2 }, \
	\* { unknown $HD $D1 $D2 $D3 $D4 $D5 }
5F2 1.0 L=APPL "SEC TRACE:"                           \
      UW,                                               \
      10 { "" },                                        \
      20 { "file: " },                                  \
      30 { "handle: " },                                \
      40 { "attribute: " },                             \
      50 { "record: " },                                \
      60 { "passwd: " },                                \
      70 { "group: " },                                 \
      \* { "UNKNOWN SUBHOOK ID:" $D1%UW $BREAK }        \
      LOOP $HL {A1.1""}
5F5 1.0 'RDS2 ' \
        $HD%D1, \
1	{`ib_init_hca: Enter hcanum=$D1%DW hcahandle=$D2%XW ibp=$D3%XW`}, \
2	{`ib_init_hca: port=$D1%DW LID=$D2%XW hcahandle=$D3%XW`}, \
3	{`ib_init_ibc: Enter faddr=$D1%XW hcahandle=$D2%XW `}, \
4	{`ib_init_ibc: Qp created faddr=$D1%XW QPnum=$D2%XW QPhandle=$D3%XW`}, \
5	{`ib_term_ibc: Enter faddr=$D1%XW`}, \
6	{`ib_term_ibc: Exit faddr=$D1%XW`}, \
7	{`cm_connect: Enter faddr=$D1%XW`}, \
8	{`cm_connect: Arp done faddr=$D1%XW LID=$D2%XW `}, \
9	{`cm_connect: Req rcvd from $D1%XW Will accept on timer `}, \
10	{`cm_connect: Req rcvd from $D1%XW on diff Hca. OldHca $D2%XW NewHca $D3%XW OldPort $D4%XW NewPort $D5%XW `}, \
11	{`cm_connect: Req rcvd from $D1%XW OldConn $D2%XW NewConn $D3%XW Hca $D4%XW `}, \
12	{`cm_connect: Req sent to $D1%XW Conn $D2%XW Hca $D3%XW `}, \
13	{`cm_accept: Rep sent to $D1%XW Conn $D2%XW Hca $D3%XW `}, \
14	{`accept_ontimer: faddr $D1%XW - diff Hca. OldConn $D2%XW NewConn $D3%XW OldHca $D4%XW NewHca $D5%XW `}, \
15	{`accept_ontimer: faddr $D1%XW OldConn $D2%XW NewConn $D3%XW Hca $D4%XW `}, \
16	{`cm_handler: Conn ready to $D1%XW Conn $D2%DW Hca $D3%DW `}, \
17	{`cm_handler: Req rcvd from $D1%XW Conn $D2%DW Hca $D3%DW - Already connected`}, \
18	{`cm_handler: Sim open from $D1%XW Conn $D2%DW Hca $D3%DW - We are active `}, \
19	{`cm_handler: Sim open from $D1%XW Conn $D2%DW Hca $D3%DW - We are passive, but accept on timer`}, \
20	{`cm_handler: Sim open from $D1%XW Conn $D2%DW Hca $D3%DW - We are passive `}, \
21	{`cm_handler: Req rcvd from $D1%XW Conn $D2%DW Hca $D3%DW - Accept in cm_connect `}, \
22	{`cm_handler: Req rcvd from $D1%XW Conn $D2%DW Hca $D3%DW `}, \
22	{`cm_handler: Req rcvd from $D1%XW Conn $D2%DW Hca $D3%DW `}, \
23	{`timer: Build pools for Ibc faddr $D1%XW `}, \
24	{`timer ERR: Keepalive failure with faddr $D1%XW `}, \
25	{`build_pool: faddr $D1%XW - Rxpool built `}, \
26	{`build_pool: faddr $D1%XW - Txpool built `}, \
27	{`build_pool: faddr $D1%XW - Ackpool built `}, \
28	{`cm_handler: Rej rcvd from $D1%XW reason $D2%XW Conn $D3%DW Hca $D4%DW `}, \
29	{`cm_handler: Default event from $D1%XW Evcode $D2%XW `}, \
50	{`ib_init_ibc ERR: Qp creation error faddr $D1%XW hca $D2%DW rc $D3%XW`}, \
51	{`ib_term_ibc ERR: Pd destroy error faddr $D1%XW hca $D2%DW rc $D3%XW`}, \
52	{`cm_connect ERR: IbCmConnect error faddr $D1%XW hca $D2%DW rc $D3%XW`}, \
53	{`cm_accept ERR: IbCmAccept error faddr $D1%XW hca $D2%DW rc $D3%XW`}, \
54	{`ib_input ERR: reassm datadue -ve faddr $D1%XW msgtype $D2%XW msgnum $D3%XW`}, \
55	{`ib_output ERR: out-of-order faddr $D1%XW curmsgnum $D2%XW lastmsgsent $D3%XW`}, \
56	{`ib_output ERR: postsend error lport $D1%XW fport $D2%XW faddr $D3%XW msgnum $D4%XW rc $D5%XW`}, \
57	{`rxcq ERR: Poll error faddr $D1%XW rc $D2%XW `}, \
58	{`rxcq ERR: ErrorStatus faddr $D1%XW errortype $D2%XW `}, \
59	{`rxcq ERR: QpNum mismatch faddr $D1%XW Ibc-val $D2%XW != EvVal $D3%XW `}, \
60	{`txcq ERR: Poll error faddr $D1%XW rc $D2%XW `}, \
61	{`txcq ERR: ErrorStatus faddr $D1%XW ErrorType $D2%XW WrkReqId $D3%XW `}, \
62	{`txcq ERR: QpNum mismatch faddr $D1%XW Ibc-val $D2%XW != EvVal $D3%XW `}, \
63	{`cm_handler: Rej rcvd for closing IBC from $D1%XW reason $D2%XW Conn $D3%XW Hca $D4%XW `}, \
64	{`sendcbdetach ERR: Unsent msgs faddr=$D1%XW lport=$D2%XW fport=$D3%XW unsent msgs=$D4%DW `}, \
65	{`ib_output ERR: postsend (cont'd) txpool->outcnt $D1%DW ibcseqnum $D2%DW seq_deliv $D3%DW ackseq_deliv $D4%DW `}, \
66	{`sendcbnotfound: Creating sendcb failed laddr $D1%XW lport $D2%DW from $D3%XW : $D4%DW `}, \
67	{`sendcbnotfound: Pcb closing laddr $D1%XW lport $D2%DW from $D3%XW : $D4%DW `}, \
68	{`send_ack: Post-send failure lport $D1%DW to $D2%XW : $D3%DW msgtype $D4%DW error $D5%XW `}, \
69	{`send_keepalive: Post-send failure ackpool->outcnt $D1%DW lport $D2%DW ackq_overflow $D2%DW `}, \
70	{`config_rds ERR: Adding bypass domain err=$D1%DW `}, \
71	{`config_rds ERR: kernext already loaded `}, \
72	{`config_rds ERR: protobypass_enable err=$D1%DW `}, \
73	{`init_all_hca ERR: no mem for listener ibc alloc `}, \
74	{`init_hca ERR: hca_open err $D1%XW hca-num $D2%DW ibp $D3%XW `}, \
75	{`init_hca ERR: set_cm_hndlr err $D1%XW hca-num $D2%DW `}, \
76	{`init_hca ERR: set_async_hndlr err $D1%XW hca-num $D2%DW `}, \
77	{`init_hca ERR: hca_query err $D1%XW hca_handle $D2%DW `}, \
78	{`init_hca ERR: nodeinfo malloc hca_handle $D1%XW `}, \
79	{`init_hca ERR: port_query err $D1%XW hca_handle $D2%DW port $D3%DW `}, \
80	{`init_hca ERR: primary port inactive err $D1%XW hca_handle $D2%DW port $D3%DW `}, \
81	{`init_ibc ERR: protection domain alloc faddr $D1%XW err $D2%XW hca_handle $D3%DW port $D4%DW `}, \
82	{`init_ibc ERR: RxCq create. faddr $D1%XW err $D2%XW hca_handle $D3%DW rxcqsz $D4%DW `}, \
83	{`init_ibc ERR: TxCq create. faddr $D1%XW err $D2%XW hca_handle $D3%DW rxcqsz $D4%DW `}, \
84	{`init_ibc ERR: SetRxCqHandler. faddr $D1%XW err $D2%XW hca_handle $D3%DW rxcq_handle $D4%DW `}, \
85	{`init_ibc ERR: SetTxCqHandler. faddr $D1%XW err $D2%XW hca_handle $D3%DW txcq_handle $D4%DW `}, \
86	{`init_ibc ERR: RxCqNotify. faddr $D1%XW err $D2%XW hca_handle $D3%DW rxcq_handle $D4%DW `}, \
87	{`init_ibc ERR: TxCqNotify. faddr $D1%XW err $D2%XW hca_handle $D3%DW txcq_handle $D4%DW `}, \
88	{`init_ibc ERR: Modify Qp to Init. faddr $D1%XW err $D2%XW hca_handle $D3%DW qp_handle $D4%DW qp_number $D5%DW `}, \
89	{`term_ibc ERR: Destroy Qp. faddr $D1%XW err $D2%XW hca_handle $D3%DW qp_handle $D4%DW qp_number $D5%DW `}, \
90	{`term_ibc ERR: Destroy RxCq. faddr $D1%XW err $D2%XW rxcq_handle $D3%DW `}, \
91	{`term_ibc ERR: Destroy TxCq. faddr $D1%XW err $D2%XW txcq_handle $D3%DW `}, \
92	{`term_ibc ERR: Dereg Rxpool. faddr $D1%XW err $D2%XW rxmem_handle $D3%DW `}, \
93	{`term_ibc ERR: Dereg Ackpool. faddr $D1%XW err $D2%XW ackmem_handle $D3%DW `}, \
94	{`term_ibc ERR: Dereg Ackpool. faddr $D1%XW err $D2%XW txmem_handle $D3%DW `}, \
95	{`post_recv ERR: faddr $D1%XW err $D2%XW mbuf $D3%XW rxmem_lkey $D4%XW `}, \
96	{`cm_connect ERR: ibc malloc. faddr $D1%XW `}, \
97	{`cm_listen ERR: hca_handle $D1%DW err $D2%XW port $D3%DW `}, \
98	{`cm_listen_complete ERR: ibc malloc. faddr $D1%XW `}, \
99	{`cm_rejected: faddr $D1%XW state $D2%XW `}, \
100	{`rxcq_handler ERR: hca/rxcq mismatch. faddr $D1%XW hca1 $D2%DW hca2 $D3%DW cq1 $D4%DW cq2 $D5%DW `}, \
101	{`rxcq_handler ERR: Null mbuf from wrid. faddr $D1%XW `}, \
102	{`rxcq_handler ERR: Non-Rx event. faddr $D1%XW `}, \
103	{`eq_handler: Just monitoring. hca_handle $D1%DW event $D2%DW `}, \
104	{`cm_handler ERR: Rcvd Rej, no ibc found. hca_handle $D1%DW conn_handle $D2%DW `}, \
105	{`cm_handler ERR: Rcvd Rtu, no ibc found. hca_handle $D1%DW conn_handle $D2%DW role_type $D3%DW `}, \
106	{`rds_timer ERR: accept_ontimer faddr $D1%XW err $D2%XW `}, \
107	{`ib_failover: faddr $D1%XW `}, \
108	{`term_ibc on failover ERR: rx->outcnt!=0 faddr $D1%XW outcnt $D2%DW `}, \
109	{`register_pools ERR: rxpool faddr $D1%XW err $D2%XW hca $D3%DW ibcp $D4%XW`}, \
110	{`register_pools ERR: txpool faddr $D1%XW err $D2%XW hca $D3%DW ibcp $D4%XW`}, \
111	{`register_pools ERR: ackpool faddr $D1%XW err $D2%XW hca $D3%DW ibcp $D4%XW`}, \
112	{`process_data ERR: out-of-order Expectin msg# $D1%DW got $D2%DW lport $D3%DW from $D4%XW : $D5%DW `}, \
113	{`process_data ERR: dup msg# $D1%DW last_rcvd $D2%DW lport $D3%DW from $D4%XW : $D5%DW `}, \
120	{`rds_timer ERR: keepalive failure - ifp null faddr $D1%XW `}, \
121	{`rds_timer ERR: keepalive failure - vipa not config faddr $D1%XW `}, \
122	{`rds_timer ERR: keepalive failure - rt null faddr $D1%XW `}, \
123	{`rds_timer ERR: keepalive failure - ifp same, faddr $D1%XW ifp $D2%XW `}, \
124	{`rds_timer ERR: keepalive failure - ifa null, faddr $D1%XW `}, \
130	{`process_data: Duplicate msgs lport=$D1%DW faddr=$D2%XW fport=$D3%DW msg_last_rcvd=$D4%DW new_msg=$D5%DW `}, \
131	{`process_data ERR: Out-of-order msgs lport=$D1%DW faddr=$D2%XW fport=$D3%DW msg_last_rcvd=$D4%DW new_msg=$D5%DW `}, \
132	{`process_data ERR: Out-of-order msgdata $D1%XW $D2%XW $D3%DW $D4%DW $D5%DW `}, \
133	{`ibc_clear: Non-mt reassm lport=$D1%DW fport=$D2%DW faddr=$D3%XW msg=$D4%DW `}, \
135	{`conn_ready Pull back lastmsgsent: lport=$D1%DW faddr=$D2%XW fport=$D3%DW lastmsgsent=$D4%DW firstmsg=$D5%DW`}, \
137	{`copy_newpool: lport=$D1%DW faddr=$D2%XW fport=$D3%DW firstmsg=$D4%DW `}, \
138	{`process_data ERR: dup lport=$D1%DW faddr=$D2%XW fport=$D3%DW lastmsgrcvd=$D4%DW new msg=$D5%DW `}, \
\* { unknown subhook $HD $ERROR }
5F6 1.0 "@VRME" \
        $HD, \
        0x00 { `VRME Create Pool: vh=$D1 flags=$D2 caller=$D3 rc=$D4` }, \
        0x01 { `VRME Delete Pool: vh=$D1 caller=$D2 rc=$D3` }, \
        0x02 { `VRME Reserve0: vh=$D1 des=$D2 min=$D3 rsvd=$D4 inuse=$D5` }, \
        0x03 { `VRME Reserve1: vh=$D1 min_req=$D2 des_req=$D3 caller=$D4 rc=$D5` }, \
        0x04 { `VRME Alloc Wait: amt=$D1 nwaits=$D2 rc=$D3` }, \
        0x05 { `VRME Alloc Succ: vh=$D1 inuse=$D2 rsvd=$D3, amt=$D4, caller=$D5` }, \
        0x06 { `VRME Alloc Fail0: vh=$D1 amt=$D2 rc=$D3 caller=$D4` }, \
        0x07 { `VRME Alloc Fail1: vh=$D1 inuse=$D2 rsvd=$D3 des=$D4` }, \
        0x08 { `VRME Free: vh=$D1 inuse=$D2 rsvd=$D3 amt=$D4 caller=$D5` }, \
        0x09 { `VRME Reset HWmark: caller=$D1` }, \
        0x0A { `VRME DR Add: new=$D1 delta=$D2 free=$D3 rsvd=$D4` }, \
        0x0B { `VRME DR Rem: orig=$D1 delta=$D2 free=$D3 rsvd=$D4 rc=$D5` }
5FE 1.0 "@VMM_MPSS" \
	$HD, \
	0 { `VMM MPSS: sid=$D1 pno=$D2 first=$D3 nfr=$D4` }, \
	1 { `VMM MPSS: ` }, \
	2 { `VMM MPSS: sid=$D1 pno=$D2 nfr=$D3 mpss_cnt=$D4` }, \
	3 { `VMM MPSS: frs_id=$D1 sid=$D2 pno=$D3 nfr=$D4 soft_l2psize=$D5` }, \
	4 { `VMM MPSS: sid=$D1 pno=$D2 nfr=$D3 frs_id=$D4 caller=$D5` }, \
	5 { `VMM MPSS: sid=$D1 head_pno=$D2 head_free=$D3 tail_free=$D4 nfree=$D4` }
5FF 1.0 "@VMM_VRM" \
	$HD, \
	0x1 { `VMM VRM phyp rq more loan: goal=$D1` }, \
	0x2 { `VMM VRM phyp rq less loan: goal=$D1` }, \
	0x3 { `VMM VRM pin limit: psx=$D1 npages=$D2 pfavail=$D3 rsvdblks=$D4` }, \
	0x4 { `VMM VRM psmd demote unloan: memp=$D1 frs=$D2 nfr=$D3` }, \
	0x5 { `VMM VRM psmd unloan:        memp=$D1 frs=$D2 nfr=$D3` }, \
	0x6 { `VMM VRM lru unloan: pfavail=$D1 nloaned=$D2 thresh=$D3 freeblks=$D4 npswarn=$D5` }, \
	0x7 { `VMM VRM lru unloan frame:   memp=$D1 frs=$D2 nfr=$D3` }
600 0.3 L=APPL "Pthread user scheduler thread" \n \
    {{ $subhookid = $HD & 0xFFFF}} \
      $subhookid, \
        0x1 { "subhook: KERN_SLEEP" \n }, \
        0x2 { "subhook: KERN_AWAKE" \n }, \
        0x3 { "subhook: KERN_YIELD" \n }, \
        0x4 { "subhook: SLEEP" \n \
              "Pthread library sleep" \n \
              "ID of pthread going to sleep: " $D1 \n \
              "Address of sleep queue: 0x"$D2%XW \n \
            }, \
        0x5 { "subhook RUNQ_ADD: pthreadID="$D1 \n }, \
        0x6 { "subhook: TIMESLICE_ENTRY" \n "vptid : 0x"$D1%XW \n "ptid : 0x"$D2%XW \n }, \
        0x7 { "subhook: TIMESLICE_EXIT" \n "vptid : 0x"$D1%XW \n "ptid : 0x"$D2%XW \n }, \
        0x8 { "subhook: TIMESLICE_EXIT_DISABLED" \n "vptid : 0x"$D1%XW \n "ptid : 0x"$D2%XW \n  }, \
        \* { "subhook unknown: "$subhookid%XW \n } \
    "ptid: "$D3%DW \n \
    "Caller: 0x"$D4%XW \n \
    "Caller-Caller: 0x"$D5%XW \n
603 0.3 L=APPL "Pthread timer thread" \n \
    {{ $subhookid = $HD & 0xFFFF}} \
      $subhookid, \
        0x1 { "subhook: KERN_SLEEP" \n }, \
        0x2 { "subhook: KERN_SLEEP (sleep-queue empty)" \n }, \
        0x3 { "subhook: KERN_AWAKE" \n }, \
        0x4 { "subhook: KERN_AWAKE (sleep-queue empty)" \n }, \
        \* { "subhook unknown: "$subhookid%XW \n } \
    "ptid: "$D3%DW \n \
    "Caller: 0x"$D4%XW \n \
    "Caller-Caller: 0x"$D5%XW \n
605 0.3 L=APPL "Pthread vp sleep" \n \
    {{ $subhookid = $HD & 0xFFFF}} \
      $subhookid, \
        0x1 { "VPSLEEP KERN SLEEP" \n "vptid : 0x"$D1%XW \n }, \
        0x2 { "VPSLEEP KERN AWAKE" \n "vptid : 0x"$D1%XW \n }, \
        0x3 { "VPSLEEP ENTRY" \n "vptid : 0x"$D1%XW \n "ptid : 0x"$D2%XW \n }, \
        0x4 { "VPSLEEP EXIT" \n "vptid : 0x"$D1%XW \n }, \
        \* { "subhook unknown: "$subhookid%XW \n } \
    "ptid: "$D3%DW \n \
    "Caller: 0x"$D4%XW \n \
    "Caller-Caller: 0x"$D5%XW \n
606 0.3 L=APPL "Pthread condition variable" \
    $GENERIC, \
      1 { ": Address=0x"$D2%XW \n \
          {{ $subhookid = $D1 & 0xFFFF}} \
            $subhookid, \
              0x1 { "init" \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
            "ptid: "$D4%DW \n \
            {{ $length = $HL / $WORDSIZE }} \
            {{ $length = $length - 3 }} \
            $length, 0 {}, \
              \* { W5 "call-chain:" LOOP $length { "\t 0x"XW \n } } \
        }, \
      0 { ": Address=0x"$D1%XW \n \
          {{ $subhookid = $HD & 0xFFFF}} \
            $subhookid, \
              0x2 { "destroy" \n }, \
              0x3 { "wait entry" \n }, \
              0x4 { "wait exit" \n }, \
              0x5 { "timedwait entry" \n }, \
              0x6 { "timedwait exit" "result="$D2\n }, \
              0x7 { "signal" \n }, \
              0x8 { "broadcast" \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
            "ptid: "$D3%DW \n \
            "Caller: 0x"$D4%XW \n \
            "Caller-Caller: 0x"$D5%XW \n \
        }
607 0.3 L=APPL "Pthread mutex" \
    $GENERIC, \
      1 { ": Address=0x"$D2%XW \n \
          {{ $subhookid = $D1 & 0xFFFF}} \
            $subhookid, \
              0x01 { "init" \n }, \
              0x13 { "mutex_boost: mt_flags="$D3 "prioceiling="$D4 "mt_bcount="$D5 "self_lockbcount="$D6\n }, \
	      0x14 { "mutex_unboost: boostcount="$D3 \n }, \
	      0x15 { "ceiling fails: mutex-prio="$D3 "thread-prio="$D4 \n }, \
	      0x16 { "wait on global: may-boost="$D3 \n }, \
	      0x17 { "wait on local" \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
            "ptid: "$D4%DW \n \
          {{ $length = $HL / $WORDSIZE }} \
          {{ $length = $length - 3 }} \
            $length, 0 {}, \
            \* { W5 "call-chain:" LOOP $length { "\t 0x"XW \n } } \
        }, \
      0 { ": Address=0x"$D1%XW \n \
          {{ $subhookid = $HD & 0xFFFF}} \
            $subhookid, \
              0x02 { "destroy" \n }, \
              0x03 { "spin lock local common(taken): lockword=0x"$D2%XW \n }, \
              0x04 { "spin lock global common (taken): lockword=0x"$D2%XW \n }, \
              0x05 { "spin lock local common(miss): lockword=0x"$D2%XW \n }, \
              0x06 { "spin lock global common(miss): lockword=0x"$D2%XW \n }, \
              0x07 { "spin trylock local (taken): lockword=0x"$D2%XW \n }, \
              0x08 { "spin trylock global (taken): lockword=0x"$D2%XW \n }, \
              0x09 { "spin trylock local (miss): lockword=0x"$D2%XW \n }, \
              0x0A { "spin trylock global (miss): lockword=0x"$D2%XW \n }, \
              0x0B { "lock recursive: lockcount=0x"$D2%XW \n }, \
              0x0C { "unlock local: lockword=0x"$D2%XW \n }, \
              0x0D { "unlock global: lockword=0x"$D2%XW \n }, \
              0x0E { "unlock recursive: lockcount=0x"$D2%XW \n }, \
              0x0F { "wait local: lockword=0x"$D2%XW \n }, \
              0x10 { "wait global: lockword=0x"$D2%XW \n }, \
              0x11 { "spin lock runQ slow: owner(tid for pthread or vp)=0x"$D2%XW \n }, \
              0x12 { "spin unlock runQ slow: owner(tid for pthread or vp)=0x"$D2%XW \n }, \
              0x18 { "spin lock local (timeout)" \n }, \
              0x19 { "spin lock global (timeout)" \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
          "ptid: "$D3%DW \n \
          "Caller: 0x"$D4%XW \n \
          "Caller-Caller: 0x"$D5%XW \n \
        }
608 0.3 L=APPL "Pthread read/write lock" \
    $GENERIC, \
      1 { ": Address=0x"$D2%XW \n \
          {{ $subhookid = $D1 & 0xFFFF}} \
            $subhookid, \
              0x1 { "init" \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
          "ptid: "$D4%DW \n \
          {{ $length = $HL / $WORDSIZE }} \
          {{ $length = $length - 3 }} \
            $length, 0 {}, \
              \* { W5 "call-chain:" LOOP $length { "\t 0x"XW \n } } \
        }, \
      0 { ": Address=0x"$D1%XW \n \
          {{ $subhookid = $HD & 0xFFFF}} \
            $subhookid, \
              0x2 { "destroy" \n }, \
              0x3 { "unlock: lockcount="$D2%DW \n }, \
              0x8 { "lock for WRITE (taken): lockcount="$D2%DW \n }, \
              0x9 { "lock for WRITE (miss): lockcount="$D2%DW \n }, \
              0xA { "try lock for WRITE (taken): lockcount="$D2%DW \n }, \
              0xB { "try lock for WRITE (miss): lockcount="$D2%DW \n }, \
              0xC { "lock for READ (taken): lockcount="$D2%DW \n }, \
              0xD { "lock for READ (miss): lockcount="$D2%DW \n }, \
              0xE { "try lock for READ (taken): lockcount="$D2%DW \n }, \
              0xF { "try lock for READ (miss): lockcount="$D2%DW \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
           "ptid: "$D3%DW \n \
           "Caller: 0x"$D4%XW \n \
           "Caller-Caller: 0x"$D5%XW \n \
         }
609 0.5 L=APPL "General pthread library call" \n \
    $GENERIC, \
      1 { {{ $subhookid = $D1 & 0xFFFF}} \
            $subhookid, \
              0x1 { "CREATE pthread (entry): start func addr=0x"$D2%XW \n }, \
              \* { "subhook unknown: "$subhookid%XW \n } \
          "ptid: "$D4%DW \n \
          {{ $length = $HL / $WORDSIZE }} \
          {{ $length = $length - 3 }} \
            $length, 0 {}, \
              \* { W5 "call-chain:" LOOP $length { "\t 0x"XW \n } } \
        }, \
      0 { {{ $subhookid = $HD & 0xFFFF}} \
            $subhookid, \
                0x13 { }, \
                \*   { ": Address=0x"$D1%XW" \n" } \
            $subhookid, \
              0x1 { "CREATE pthread (entry):" \n " start func addr=0x"$D2%XW \n }, \
              0x2 { "CREATE pthread (exit) local:" \n "ptid created : 0x"$D1%XW \n "start func addr=0x"$D2%XW \n }, \
              0x3 { "CREATE pthread (exit) global:" \n "ptid created : 0x"$D1%XW \n "start func addr=0x"$D2%XW \n }, \
              0x4 { "EXIT pthread: status=0x"$D1%XW \n }, \
              0x5 { "KILL pthread (entry): target=0x"$D1%XW "signal="$D2%DW \n }, \
              0x6 { "KILL pthread (exit):  target=0x"$D1%XW "signal="$D2%DW \n }, \
              0x7 { "JOIN pthread (entry): partner=0x"$D1%XW \n }, \
              0x8 { "JOIN pthread (exit):  partner=0x"$D1%XW " exit value of partner="$D2%DW \n }, \
              0x9 { "DETACH pthread (entry): detached=0x"$D1%XW \n }, \
              0xA { "DETACH pthread (exit):  detached=0x"$D1%XW \n }, \
              0xB { "CANCEL pthread (entry) target=0x"$D1%XW \n }, \
              0xC { "CANCEL pthread (exit)  target=0x"$D1%XW \n }, \
              0xD { "DISPATCH pthread (entry)" \n "vptid : 0x"$D1%XW \n "ptid : 0x"$D2%XW \n }, \
              0xE { "DISPATCH pthread (exit)" \n "vptid : 0x"$D1%XW \n "ptid : 0x"$D2%XW \n }, \
              0xF { "CREATE INITIAL pthread (entry): target=0x"$D1%XW "start func addr=0x"$D2%XW  \n }, \
              0x10 { "CREATE INITIAL pthread (exit) global:" \n "ptid created : 0x"$D1%XW \n "start func addr=0x"$D2%XW  \n }, \
              0x11 { "CREATE INITIAL pthread (exit) local:" \n "ptid created : 0x"$D1%XW \n "start func addr=0x"$D2%XW  \n }, \
	      0x12 { "pthread_setschedprio: pthread=0x"$D1%XW  \n "priority=0x"$D2%XW  \n }, \
                0x13 { `CREATE pthread failure: thread limit reached.` \n \
                       `By uid=$D1%D4 pid=$D2%D1` \n \
                       `Number of pthreads=$D3%D4 limit=$D4%D8` \n }, \
                \* { "subhook unknown: "$subhookid%XW \n } \
           $subhookid, \
               0x13 { }, \
               \*   { `ptid: $D3%DW ` \n \
                      `Caller: 0x$D4%XW` \n \
                      `Caller-Caller: 0x$D5%XW` \n } \
        }
60a 1.0 L=APPL "HKWD_LIBC_MALLOC_SUBSYSTEM "\
    "function="\
    $D1,0{"malloc() [ Common Parameter Validation -- malloc of 0 bytes ] size=0 retval=NULL thread ID=" $D2},\
        1{"free() [ Common Parameter Validation -- free of NULL ptr ] ptr=NULL thread ID=" $D2},\
        2{"free() [ Common Parameter Validation -- free of out of range ptr ] ptr=" $D2 " thread ID=" $D3},\
        3{"free() [ posix_memalign allocation ] ptr=" $D2 " thread ID=" $D3},\
        4{"free() [ posix_memalign allocation -- prefix corruption] ptr=" $D2 " thread ID=" $D3},\
        5{"realloc() [ Common Parameter Validation -- realloc of NULL ptr ] ptr=NULL size=" $D2 " retval=" $D3 " thread ID=" $D4},\
        6{"realloc() [ Common Parameter Validation -- realloc of 0 bytes ] ptr=" $D2 " size=0 thread ID=" $D3},\
        7{"realloc() [ Common Parameter Validation -- realloc of out of range ptr ] ptr=" $D2 " size=" $D3 " retval=NULL thread ID=" $D4},\
        8{"realloc() [ posix_memalign allocation ENOMEM ] ptr=" $D2 " size=" $D3 " retval=NULL thread ID=" $D4},\
        9{"realloc() [ posix_memalign allocation ] ptr=" $D2 " size=" $D3 " retval=" $D4 " thread ID=" $D5},\
        a{"posix_memalign() [ posix_memalign of 0 bytes ] ptr=NULL align=" $D2 " size=0 retval=" $D3 " thread ID=" $D4},\
        b{"posix_memalign() [ posix_memalign alignment error ] ptr=NULL align=" $D2 " size=" $D3 " retval=" $D4 " thread ID=" $D5},\
        c{"posix_memalign() [ posix_memalign ENOMEM ] ptr=NULL align=" $D2 " size=" $D3 " retval=" $D4 " thread ID=" $D5},\
        d{"posix_memalign() [ posix_memalign ] ptr=" $D2 " align=" $D3 " size=" $D4 " thread ID=" $D5},\
       10{"malloc() [ catch_overflow ENOMEM ] size=" $D2 " retval=NULL thread ID=" $D3},\
       11{"malloc() [ catch_overflow ] size=" $D2 " retval=" $D3 " thread ID=" $D4},\
       12{"free() [ catch_overflow ] ptr=" $D2 " thread ID=" $D3},\
       13{"realloc() [ catch_overflow ] ptr=" $D2 " size=" $D3 " retval=" $D4 " thread ID=" $D5},\
       14{"realloc() [ catch_overflow ENOMEM ] ptr=" $D2 " size=" $D3 " retval=NULL thread ID=" $D4},\
       20{"malloc() [ threadcache ] size=" $D2 " retval=" $D3 "bucket=" $D4 " thread ID=" $D5},\
       21{"free() [ threadcache ] ptr=" $D2 "bucket=" $D3 " thread ID=" $D4},\
       30{"malloc() [ heapcache ] size=" $D2 " retval=" $D3 "bucket=" $D4 " thread ID=" $D5},\
       31{"free() [ heapcache ] ptr=" $D2 "bucket=" $D3 " thread ID=" $D4},\
       40{ {{ $HEAP = $D4 & 0xffff }} {{ $BUCK = $D4 / 65536 }}\
           "malloc() [ buckets -- allocation from bucket free-list] size=" $D2 " retval=" $D3 " heap=" $HEAP " bucket=" $BUCK "thread ID=" $D5},\
       41{ {{ $HEAP = $D4 & 0xffff }} {{ $BUCK = $D4 / 65536 }}\
          "malloc() [ buckets -- allocation from bucket] size=" $D2 " retval=" $D3 " heap=" $HEAP " bucket=" $BUCK "thread ID=" $D5},\
       43{"free() [ buckets ] ptr=" $D2 " heap=" $D3 " bucket=" $D4 "thread ID=" $D5},\
       44{"free() [ buckets -- prefix corrupted ] ptr=" $D2 "thread ID=" $D3},\
       46{ {{ $HEAP = $D5 & 0xffff }} {{ $BUCK = $D5 / 65536 }}\
          "realloc() [ buckets ] ptr=" $D2 " size=" $D3 " retval=" $D4 " heap=" $HEAP "bucket=" $BUCK },\
       47{"realloc() [ buckets -- prefix corrupted] inptr=" $D2 " size=" $D3 " returnptr=NULL heap=" $D4 "thread ID=" $D5},\
       48{"malloc() [Newbuckets Allocator] size=" $D2 " returnptr=" $D3},\
       49{"free() [Newbuckets Allocator] inptr=" $D2},\
       4a{"realloc() [Newbuckets Allocator] inptr=" $D2 "\nsize=" $D3 \
          " returnptr=" $D4},\
       50{"malloc() [ default allocator ] size=" $D2 " retval=" $D3 " heap=" $D4 " thread ID=" $D5},\
       51{"malloc() [ default allocator ENOMEM] size=" $D2 " retval=NULL thread ID=" $D3},\
       52{"free() [ default allocator ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       54{"free() [ default allocator -- unaligned ptr ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       55{"free() [ default allocator -- prefix corrupted ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       56{"free() [ default allocator -- internal corruption detected ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       57{"realloc() [ default allocator ] ptr=" $D2 " size=" $D3 " retval=" $D4 " heap=" $D5},\
       58{"realloc() [ default allocator ENOMEM] ptr=" $D2 " size=" $D3 " retval=NULL heap=" $D4 " thread ID=" $D5},\
       5A{"realloc() [ default allocator -- unaligned ptr ] ptr=" $D2 " size=" $D3 " retval=NULL heap=" $D4 " thread ID=" $D5},\
       5B{"realloc() [ default allocator -- prefix corrupted ] ptr=" $D2 " size=" $D3 " retval=NULL heap=" $D4 " thread ID=" $D5},\
       60{"malloc() [ watson allocator ] size=" $D2 " retval=" $D3 " heap=" $D4 " thread ID=" $D5},\
       61{"malloc() [ watson allocator ENOMEM] size=" $D2 " retval=NULL thread ID=" $D3},\
       63{"free() [ watson allocator ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       64{"free() [ watson allocator -- unaligned ptr ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       65{"free() [ watson allocator -- prefix corrupted ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       66{"free() [ watson allocator -- internal corruption detected ] ptr=" $D2 " heap=" $D3 " thread ID=" $D4},\
       68{"realloc() [ watson allocator ] ptr=" $D2 " size=" $D3 " retval=" $D4 " heap=" $D5},\
       69{"realloc() [ watson allocator ENOMEM] ptr=" $D2 " size=" $D3 " retval=NULL heap=" $D4 " thread ID=" $D5},\
       6A{"realloc() [ watson allocator -- unaligned ptr ] ptr=" $D2 " size=" $D3 " retval=NULL heap=" $D4 " thread ID=" $D5},\
       6B{"realloc() [ watson allocator -- prefix corrupted ] ptr=" $D2 " size=" $D3 " retval=NULL heap=" $D4 " thread ID=" $D5},\
       70{"malloc() [ 3.1 allocator ] size=" $D2 " returnptr=" $D3 " thread ID=" $D4 },\
       71{"malloc() [ 3.1 allocator ENOMEM ] size=" $D2 " returnptr=NULL thread ID=" $D3},\
       72{"free() [ 3.1 allocator] ptr=" $D2 " thread ID=" $D3},\
       73{"free()  [ 3.1 allocator -- prefix corrupted ] ptr=" $D2 " thread ID=" $D3},\
       74{"realloc() [ 3.1 Allocator ] ptr=" $D2 " size=" $D3 " retval=" $D4 " thread ID=" $D5},\
       75{"realloc() [ 3.1 Allocator ENOMEM ] ptr=" $D2 " size=" $D3 " retval=NULL thread ID=" $D4},\
       80{"malloc() [User-Defined Allocator] size=" $D2 " returnptr=" $D3},\
       81{"free() [User-Defined Allocator] inptr=" $D2},\
       82{"realloc() [User-Defined Allocator] inptr=" $D2 " size=" $D3 \
          " returnptr=" $D4},\
       \*{"unknown\n"}
60b 1.0 L=APPL "HKWD_LIBC_MALL_INTERNAL\n"\
    "function="\
   $D1,20{"malloc() [ threadcache create failed ] size=" $D2 " thread ID=" $D3},\
       21{"malloc() [ threadcache bucket fill failed ] size=" $D2 " bucket=" $D3 " thread ID=" $D4},\
       22{"malloc() [ threadcache bucket filled ] size=" $D2 " bucket=" $D3 " thread ID=" $D4},\
       24{"free() [ threadcache bucket halved ] ptr=" $D2 " bucket=" $D3 " thread ID=" $D4},\
       25{"free() [ threadcache not accessible ] ptr=" $D2 " thread ID=" $D3},\
        1{"malloc() [Default Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4 "\nnodes=" $D5},\
        2{"malloc() [3.1 Allocator]\ndepth=" $D2 "\nfreespace=" $D3},\
        3{"malloc() [Buckets Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4},\
        4{"malloc() [User-Defined Allocator]\n"},\
        5{"malloc() [Debug Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4 "\nnodes=" $D5},\
       11{"free() [Default Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4 "\nnodes=" $D5},\
       12{"free() [3.1 Allocator]\ndepth=" $D2 "\nfreespace=" $D3},\
       13{"free() [Buckets Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4},\
       14{"free() [User-Defined Allocator]\n"},\
       15{"free() [Debug Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4 "\nnodes=" $D5},\
       21{"realloc() [Default Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4 "\nnodes=" $D5},\
       22{"realloc() [3.1 Allocator]\ndepth=" $D2 "\nfreespace=" $D3},\
       23{"realloc() [Buckets Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4},\
       24{"realloc() [User-Defined Allocator]\n"},\
       25{"realloc() [Debug Allocator]\nheap=" $D2 "\ndepth=" $D3 \
          "\nfreespace=" $D4 "\nnodes=" $D5},\
       \*{"unknown\n"}
60C 1.0 L=SVC "@ UKEY_PROTECT SYSTEM CALL" \
	"ukey_protect addr="$D1" len="$D2" ukey="$D3
60D 1.0 L=SVC "@ UKEY_GETKEY SYSTEM CALL" \
	"ukey_getkey addr="$D1" ukey="$D2
60e 1.0 L=APPL "HKWD_LIBC_SPAWN_FATHER\n"\
    W2\
    $D1,\
        0{"add file_action: action= "prargs($HL)},\
        1{"add_file_action() failure: "prargs($HL)},\
        2{"add_file_action: file_actions= "prargs($HL)},\
	7{"posix_spawn_file_actions_addclose() failure: filedes=" $D2 "errno=" $D3},\
        8{"posix_spawn_file_actions_addclose() failure: "prargs($HL)},\
	9{"posix_spawn_file_actions_adddup2() failure: filedes=" $D2 "newfiledes=" $D3 "errno=" $D4},\
        A{"posix_spawn_file_actions_adddup2() failure: "prargs($HL)},\
	B{"posix_spawn_file_actions_addopen() failure: filedes=" $D2 "errno=" $D3},\
        C{"posix_spawn_file_actions_addopen() failure: "prargs($HL)},\
        F{prargs($HL)},\
       \*{"unknown\n"}
60f 1.0 L=APPL "HKWD_LIBC_SPAWN_CHILD\n"\
    W2\
    $D1,\
	0{"change_attr()"},\
	1{"change_attr() setpgid failure: pgroup=" $D2 "errno=" $D3},\
        2{"change_attr() sigaction failure: cannot set signal=" $D2 "to default act. errno=" $D3},\
	3{"change_attr() sched_setscheduler failure: policy=" $D2 " priority=" $D3 "errno=" $D4},\
	4{"change_attr() sched_setparam failure: policy=" $D2 " priority=" $D3 "errno=" $D4},\
        A{"change_file_actions() "prargs($HL)},\
        F{"change_file_actions() failure: "prargs($HL)},\
	10{prargs($HL)},\
       \*{"unknown\n"}
615 1.0 'NET' \
	$HD%D1, \
	1   { `netinet callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	2   { `tcp callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	3   { `udp callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	4   { `ipv4 callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	5   { `netinet misc callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	6   { `if_en callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	7   { `ethchan callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	8   { `netmalloc callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	9   { `net callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	10   { `route callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	11   { `cdli callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	12   { `loop callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	13   { `mbuf callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	14   { `socket callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	15   { `unix socket callback error error=$D1%DW rasblk=$D2%XW cmd=$D3%XW` }, \
	16   { `network_ras_unregister_error ret=$D1%DW component=$D2%XW` }, \
	17   { `network_ras_register comp=$D1%XW, name=$D2%XW desc=$D3%XW` }, \
	18   { `return from network_ras_register comp=$D1%XW ret=$D2%DW` }, \
	19   { `network_ras_register error1 ret=$D1%DW` }, \
	20   { `network_ras_register error2 ret=$D1%DW` }, \
	21   { `network_ras_register error3 ret=$D1%DW` }, \
	22   { `network_ras_register error4 ret=$D1%DW` }, \
	23   { `network_ras_register error5 ret=$D1%DW` }, \
	24   { `network_ras_register error6 ret=$D1%DW` }, \
	25   { `network_ras_register error7 ret=$D1%DW` }, \
	26   { `network_ras_register error8 ret=$D1%DW` }, \
	27   { `network_ras_register error9 ret=$D1%DW` }, \
	28   { `network_ras_unregister comp=$D1%XW` }, \
	29   { `return from network_ras_unregister ret=$D1%XW` }, \
	30   { `ras_callback_common comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	31   { `return from ras_callback_common ret=$D1%DW` }, \
	32   { `ras_callback_common error1 ret=$D1%DW` }, \
	33   { `ras_callback_common error2 ret=$D1%DW` }, \
	34   { `ras_callback_common error3 ret=$D1%DW` }, \
	35   { `ras_callback_common error4 ret=$D1%DW` }, \
	36   { `ras_callback_common error5 ret=$D1%DW` }, \
	37   { `ras_callback_common error6 ret=$D1%DW` }, \
	38   { `ras_callback_common error7 ret=$D1%DW` }, \
	39   { `ras_callback_common error8 ret=$D1%DW` }, \
	40   { `ras_callback_common error9 ret=$D1%DW` }, \
	41   { `ras_callback_common error10 ret=$D1%DW` }, \
	42   { `ras_callback_common error11 ret=$D1%DW` }, \
	43   { `ras_callback_common error12 ret=$D1%DW` }, \
	44   { `ras_callback_common error13 ret=$D1%DW` }, \
	45   { `ras_callback_common error14 ret=$D1%DW` }, \
	46   { `ras_netinet_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	47   { `return from ras_netinet_callback error=$D1%DW` }, \
	48   { `ras_netinet_tcp_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	49   { `return from ras_netinet_tcp_callback error=$D1%DW` }, \
	50   { `ras_netinet_udp_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	51   { `return from ras_netinet_udp_callback error=$D1%DW` }, \
	52   { `ras_netinet_ipv4_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	53   { `return from ras_netinet_ipv4_callback error=$D1%DW` }, \
	54   { `ras_netinet_misc_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	55   { `return from ras_netinet_misc_callback error=$D1%DW` }, \
	56   { `ras_if_en_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	57   { `return from ras_if_en_callback error=$D1%DW` }, \
	58   { `ras_ethchan_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	59   { `return from ras_ethchan_callback error=$D1%DW` }, \
	60   { `ras_netmalloc_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	61   { `return from ras_netmalloc_callback error=$D1%DW` }, \
	62   { `ras_net_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	63   { `return from ras_net_callback error=$D1%DW` }, \
	64   { `ras_net_route_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	65   { `return from ras_net_route_callback error=$D1%DW` }, \
	66   { `ras_net_cdli_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	67   { `return from ras_net_cdli_callback error=$D1%DW` }, \
	68   { `ras_net_loop_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	69   { `return from ras_net_loop_callback error=$D1%DW` }, \
	70   { `ras_mbuf_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	71   { `return from ras_mbuf_callback error=$D1%DW` }, \
	72   { `ras_socket_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	73   { `return from ras_socket_callback error=$D1%DW` }, \
	74   { `ras_socket_so_unix_callback comp=$D1%XW cmd=$D2%DW, arg=$D3%XW, cdata=$D4%XW` }, \
	75   { `return from ras_socket_so_unix_callback error=$D1%DW` }, \
	76   { `ras_callback_common error15 ret=$D1%DW` }, \
	77   { `ras_callback_common error16 ret=$D1%DW` }, \
	78   { `ras_callback_common error17 ret=$D1%DW` }, \
 	\* { unknown subhook $HD $ERROR }
616 1.0 'ETHCHAN' \
	$HD%D1, \
	1   { `ethchan config` }, \
	2   { `ethchan config return rc=$D1%DW` }, \
	3   { `ethchan_init_ccs p_ccs=$D1%XW` }, \
	4   { `ethchan_init_ccs return` }, \
	5   { `ethchan_open p_ccs=$D1%XW` }, \
	6   { `ethchan_open return rc=$D1%DW` }, \
	7   { `ethchan_close p_ccs=$D1%XW` }, \
	8   { `ethchan_close return rc=$D1%DW` }, \
	9   { `ethchan_output p_ccs=$D1%XW p_mbuf=$D2%XW` }, \
	10   { `ethchan_output return error=$D1%DW` }, \
	11   { `ethchan_arp_sender_timeout p_wdt=$D1%XW` }, \
	12   { `ethchan_arp_sender_timeout return` }, \
	13   { `ethchan_send_arp p_ccs=$D1%XW` }, \
	14   { `ethchan_send_arp return rc=$D1%DW` }, \
	15   { `ethchan_null_receive_func nddp=$D1%XW m=$D2%XW` }, \
	16   { `ethchan_null_receive_func return` }, \
	17   { `ethchan_link_status_callback_func p_ccs=$D1%XW flag=$D2%DW calling_nddp=$D3%XW` }, \
	18   { `ethchan_link_status_callback_func return` }, \
	19   { `ethchan_verify_failover	p_ccs=$D1%XW force_failover=$D2%DW` }, \
	20   { `ethchan_verify_failover return rc=$D1%DW` }, \
	21   { `ethchan_initiate_failover p_ccs=$D1%XW failcode=$D2%DW` }, \
	22   { `ethchan_initiate_failover return` }, \
	23   { `ethchan_swap_channel p_ccs=$D1%XW failcode=$D2%DW` }, \
	24   { `ethchan_swap_channel return` }, \
	25   { `ethchan_ping_timeout p_wdt=$D1%XW` }, \
	26   { `ethchan_ping_timeout return` }, \
	27   { `ethchan_icmp_output p_ccs=$D1%XW sa=$D2%XW` }, \
	28   { `ethchan_icmp_output return` }, \
	29   { `ethchan_icmp_input m=$D1%XW` }, \
	30   { `ethchan_icmp_input return` }, \
	31   { `ethchan_add_adapter p_ccs=$D1%XW len=$D2%DW` }, \
	32   { `ethchan_add_adapter return rc=$D1%DW` }, \
	33   { `ethchan_delete_adapter p_ccs=$D1%XW len=$D2%DW` }, \
	34   { `ethchan_delete_adapter return rc=$D1%DW` }, \
	35   { `ethchan_change_attribute p_ccs=$D1%XW mod=$D2%XW len=$D3%DW` }, \
	36   { `ethchan_change_attribute return rc=$D1%DW` }, \
	37   { `ethchan_config error1 error=$D1%DW` }, \
	38   { `ethchan_config error2 error=$D1%DW` }, \
	39   { `ethchan_config error3 error=$D1%DW` }, \
	40   { `ethchan_config error4 error=$D1%DW` }, \
	41   { `ethchan_config error5 error=$D1%DW` }, \
	42   { `ethchan_config error6 error=$D1%DW` }, \
	43   { `ethchan_config error7 error=$D1%DW` }, \
	44   { `ethchan_config error8 error=$D1%DW` }, \
	45   { `ethchan_init_ccs error1 error=$D1%DW` }, \
	46   { `ethchan_init_ccs error2 error=$D1%DW` }, \
	47   { `ethchan_open error1 error=$D1%DW` }, \
	48   { `ethchan_open error2 error=$D1%DW` }, \
	49   { `ethchan_open error3 error=$D1%DW` }, \
	50   { `ethchan_open error4 error=$D1%DW` }, \
	51   { `ethchan_open error5 error=$D1%DW` }, \
	52   { `ethchan_output error1 error=$D1%DW` }, \
	53   { `ethchan_output error2 error=$D1%DW` }, \
	54   { `ethchan_send_arp error1 error=$D1%DW` }, \
	55   { `ethchan_send_arp error2 error=$D1%DW` }, \
	56   { `ethchan_send_arp error3 error=$D1%DW` }, \
	57   { `ethchan_verify_failover error1 error=$D1%DW` }, \
	58   { `ethchan_icmp_output error1 error=$D1%DW` }, \
	59   { `ethchan_icmp_output error2 error=$D1%DW` }, \
	60   { `ethchan_icmp_output error3 error=$D1%DW` }, \
	61   { `ethchan_add_adapter error1 error=$D1%DW` }, \
	62   { `ethchan_add_adapter error2 error=$D1%DW` }, \
	63   { `ethchan_add_adapter error3 error=$D1%DW` }, \
	64   { `ethchan_add_adapter error4 error=$D1%DW` }, \
	65   { `ethchan_add_adapter error5 error=$D1%DW` }, \
	66   { `ethchan_add_adapter error6 error=$D1%DW` }, \
	67   { `ethchan_add_adapter error7 error=$D1%DW` }, \
	68   { `ethchan_add_adapter error8 error=$D1%DW` }, \
	69   { `ethchan_delete_adapter error1 error=$D1%DW` }, \
	70   { `ethchan_delete_adapter error2 error=$D1%DW` }, \
	71   { `ethchan_change_attribute error1 error=$D1%DW` }, \
	72   { `ethchan_change_attribute error2 error=$D1%DW` }, \
	73   { `ethchan_change_attribute error3 error=$D1%DW` }, \
 	\* { unknown subhook $HD $ERROR }
617 1.0 'ROUTE' \
        $HD%D1, \
        1  { `rtinithead fam=$D1%DW count=$D2%DW` }, \
        2  { `route_configure` }, \
        3  { `route_init`},\
        4  { `rn_inithead head=$D1%XW off=$D2%DW`},\
        5  { `rn_inithead error1`},\
        6  { `rn_init`},\
        7  { `rtredirect fam=$D1%DW gw=$D2%XW netmask=$D3%XW flags=$D4%XW src=$D5%XW`},\
        8  { `rtexpire rn=$D1%XW`},\
        9  { `rtexpire return error=$D1%DW`},\
        10  { `rtioctl so=$D1%XW req=$D2%DW data=$D3%XW`},\
        11  { `rtioctl return so=$D1%XW error=$D2%DW`},\
        12  { `dead_gateway dst=$D1%XW active=$D2%DW`},\
        13  { `gateway_up dst=$D1%XW`},\
        14  { `raise_cost 1 addr1=$D1%XW addr2=$D2%XW`},\
        15  { `raise_cost 2 addr1=$D1%XW addr2=$D2%XW`},\
        16  { `restore_cost 1 addr1=$D1%XW addr2=$D2%XW`},\
        17  { `restore_cost 2 addr1=$D1%XW addr2=$D2%XW`},\
        18  { `rn_change_cost  rt=$D1%XW rt_cost=$D2%DW cost=$D3%DW`},\
        19  { `rn_change_cost  return`},\
        20  { `rn_change_cost  out1`},\
        21  { `rn_change_cost  out2`},\
        22  { `rn_change_cost  out3`},\
        23  { `rt_changegids gidlist=$D1%XW inuse=$D2%DW`},\
        24  { `rt_changegids return`},\
        25  { `rt_changegids out1`},\
        26  { `rt_changegids error1 error=$D1%DW`},\
        27  { `rt_changegids error2 inuse= $D1%DW error=$D2%DW`},\
        28  { `rt_changegids error3 error=$D1%DW`},\
        29  { `route_output so=$D1%XW m=$D2%XW`},\
        30  { `route_output rtm=$D1%XW error=$D2%XW`},\
        31  { `route_output error1 so=$D1%XW m=$D2%XW error=$D3%DW`},\
        32  { `route_output error2 len=$D1%DW data_len=$D2%DW error=$D3%DW`},\
        33  { `route_output error3 len=$D1%DW data_len=$D2%DW error=$D3%DW`},\
        34  { `route_output error4 len=$D1%DW data_len=$D2%DW error=$D3%DW`},\
        35  { `route_output error5 len=$D1%DW data_len=$D2%DW error=$D3%DW`},\
        36  { `route_output error6 version=$D1%DW error=$D2%DW`},\
        37  { `route_output error7 error=$D1%DW`},\
        38  { `route_output error8 weight=$D1%DW policy=$D2%DW error=$D3%DW`},\
        39  { `route_output error9 error=$D1%DW`},\
        40  { `route_output error10 error=$D1%DW`},\
        41  { `route_output error11 ifpaddr=$D1%XW ifaaddr=$D2%XW error=$D3%DW`},\
        42  { `route_output error12 error=$D1%DW`},\
        43  { `route_output error13 error=$D1%DW`},\
        44  { `route_output error14 error=$D1%DW`},\
        45  { `route_output error15 error=$D1%DW`},\
        46  { `route_output error16 so=$D1%XW error=$D2%DW`},\
        47  { `route_output error17 error=$D1%DW`},\
        48  { `route_output error18 error=$D1%DW`},\
        49  { `route_output error19 so=$D1%XW error=$D2%DW`},\
        50  { `route_output error20 so=$D1%XW error=$D2%DW`},\
        51  { `route_output error21 so=$D1%XW error=$D2%DW`},\
        52  { `route_output error22 error=$D1%DW`},\
        53  { `route_output error23 error=$D1%DW`},\
        54  { `route_output error24 error=$D1%DW`},\
        55  { `route_output error25 error=$D1%DW`},\
        56  { `route_output error26 error=$D1%DW`},\
        57  { `route_output error27 error=$D1%DW`},\
        58  { `route_output error28 error=$D1%DW`},\
        59  { `route_output error29 error=$D1%DW`},\
        60  { `route_output error30 error=$D1%DW`},\
        61  { `rt_missmsg type=$D1%DW rtinfo=$D2%XW flags=$D3%XW error=$D4%DW count=$D5%DW`},\
        62  { `rt_missmsg out1`},\
        63  { `rt_missmsg out2 type=$D1%DW rtinfo=$D2%XW`},\
	64  { `rn_select t=$D1%XW ifa=$D2%XW gidlist=$D3%XW flags=$D4%XW policy=$D5%DW`},\
        65  { `rn_select return r=$D1%XW rt_index=$D2%DW`},\
        66  { `rn_select out1 r=$D1%XW rt_index=$D2%DW`},\
        67  { `rn_select out2 r=$D1%XW rt_index=$D2%DW`},\
        68  { `rn_lookup v_arg=$D1%XW m_arg=$D2%XW head=$D3%XW gidlist=$D4%XW`},\
        69  { `rn_lookup return`},\
        70  { `rn_lookup out1`},\
        71  { `rn_lookup out2`},\
        72  { `rn_lookup out3`},\
        73  { `rn_lookup out4`},\
        74  { `rn_genmatch v_arg=$D1%XW head=$D2%XW gidlist=$D3%XW ifa=$D4%XW flags=$D5%XW`},\
        75  { `rn_genmatch return`},\
        76  { `rn_genmatch out1 flags=$D1%XW ifa=$D2%XW gidlist=$D3%XW`},\
        77  { `rn_genmatch out2`},\
        78  { `rn_genmatch out3`},\
        79  { `rn_genmatch out4 t=$D1%XW`},\
        80  { `rn_genmatch out5 r=$D1%XW`},\
        81  { `rn_genmatch out6 x=$D1%XW`},\
        82  { `rn_addmask error1`},\
        83  { `rn_new_radix_mask error1`},\
        84  { `rn_addroute v_arg=$D1%XW n_arg=$D2%XW head=$D3%XW g_arg=$D4%XW rt_parm=$D5%XW`},\
        85  { `rn_addroute return tt=$D1%XW`},\
        86  { `rn_addroute out1`},\
        87  { `rn_addroute out2`},\
        88  { `rn_addroute out3`},\
        89  { `rn_addroute out4 tt=$D1%XW`},\
        90  { `rn_addroute out5 tt=$D1%XW`},\
        91  { `rn_delete v_arg=$D1%XW netmask_arg=$D2%XW g_arg=$D3%XW ifp=$D4%XW cost=$D5%DW`},\
        92  { `rn_delete return tt=$D1%XW`},\
        93  { `rn_delete out1 vlen=$D1%DW head_off=$D2%DW v=$D3%XW`},\
        94  { `rn_delete out2`},\
        95  { `rn_delete out3 match=$D1%DW`},\
        96  { `rn_delete out4`},\
        97  { `rn_delete out5 g_arg=$D1%XW`},\
        98  { `rn_delete out6`},\
        99  { `rn_delete out7`},\
        100  { `rn_change v_arg=$D1%XW m_arg=$D2%XW g_arg=$D3%XW ifp=$D4%XW cost=$D5%DW`},\
        101  { `rn_change return dt=$D1%XW`},\
        102  { `rn_change out1`},\
        103  { `rn_change out2 cp=$D1%XW cp2=$D2%XW`},\
        104  { `rn_change out3 duplist=$D1%XW`},\
        105  { `rn_change out4 match=$D1%DW`},\
        106  { `rn_change out5 similar=$D1%DW`},\
        107  { `rn_walktree h=$D1%XW w=$D2%XW`},\
        108  { `rn_walktree return h=$D1%XW w=$D2%XW`},\
        109  { `rn_walktree out1`},\
        110  { `rn_walktree error1 error=$D3%DW`},\
        111  { `rn_walktree error2 error=$D3%DW`},\
        112  { `rn_change_policy ifp=$D1%XW cost=$D2%DW v_arg=$D3%XW netmask_arg=$D4%XW head=$D5%XW`},\
        113  { `rn_change_policy return dtt=$D1%XW`},\
        114  { `rn_change_policy out1`},\
        115  { `rn_change_policy out2`},\
        116  { `rn_change_policy out3`},\
        117  { `rn_change_policy out4`},\
        118  { `rn_change_policy out5`},\
        119  { `rn_change_policy out6`},\
        120  { `rn_change_policy out7`},\
        121  { `nextroute ro=$D1%XW gidlist=$D2%XW`},\
        122  { `nextroute return`},\
        123  { `nextroute out1`},\
        124  { `nextroute out2 rt=$D1%XW`},\
        125  { `rtalloc1_nolock_gr dst=$D1%XW report=$D2%DW gidlist=$D3%XW ifa=$D4%XW flags=$D5%XW`},\
        126  { `rtalloc1_nolock_gr return newrt=$D1%XW`},\
        129  { `rtalloc1_nolock_gr error1 gidlist=$D1%XW gid_inuse=$D2%DW`},\
        130  { `rtalloc1_nolock_gr error1 error=$D1%DW new_rt=$D2%XW`},\
        131  { `rtalloc1_nolock_gr error1 new_rt=$D1%XW`},\
        132  { `rtfree_nolock out1 rt=$D1%XW refcnt=$D2%DW flags=$D3%XW`},\
        133  { `rtfree_nolock out2 rt=$D1%XW refcnt=$D2%DW`},\
        134  { `rtredirect error1 error=$D1%DW`},\
        135  { `rtredirect error2 error=$D1%DW`},\
        136  { `rtredirect error3 error=$D1%DW`},\
        137  { `rtredirect error4 error=$D1%DW`},\
        138  { `rtioctl error1 so=$D1%XW req=$D2%DW data=$D3%XW error=$D4%DW`},\
        139  { `rtioctl error2 so=$D1%XW req=$D2%DW error=$D3%DW`},\
        140  { `rtioctl error3 so=$D1%XW state=$D2%XW error=$D3%DW`},\
        141  { `ifa_ifwithroute error1 rt=$D1%XW`},\
        142  { `ifa_ifwithroute error2`},\
        143  { `ifa_ifwithroute error3`},\
        144  { `rtrequest_nolock dst=$D1%XW gw=$D2%XW netmask=$D3%XW flags=$D4%XW` }, \
        145  { `rtrequest_nolock return error=$D1%DW`},\
        146  { `rtrequest_nolock error1 error=$D1%DW`},\
        147  { `rtrequest_nolock error2 error=$D1%DW`},\
        148  { `rtrequest_nolock error3 error=$D1%DW`},\
        149  { `rtrequest_nolock error4 error=$D1%DW`},\
        150  { `rtrequest_nolock error5 error=$D1%DW`},\
        151  { `rtrequest_nolock error6 error=$D1%DW`},\
        152  { `rtrequest_nolock error7 error=$D1%DW`},\
        153  { `rtrequest_nolock error8 error=$D1%DW`},\
        154  { `rtrequest_nolock error9 error=$D1%DW`},\
        155  { `rtrequest_nolock error10 error=$D1%DW`},\
        156  { `rtrequest_nolock error11 error=$D1%DW`},\
        157  { `rtrequest_nolock error12 error=$D1%DW`},\
        158  { `rtrequest_nolock error13 error=$D1%DW`},\
        159  { `rt_setgate rt0=$D1%XW dst=$D2%XW gate=$D3%XW glen=$D4%DW`},\
        160  { `rt_setgate error1 error=$D1%DW`},\
        161  { `rt_setgate error2`},\
        162  { `rtinit ifa=$D1%XW cmd=$D2%DW flags=$D3%XW ipv6=$D4%DW`},\
        163  { `rtinit return error=$D1%DW`},\
        164  { `rtinit error1 error=$D1%DW`},\
        165  { `rtinit error2 error=$D1%DW`},\
        166  { `rtinit error3 error=$D1%DW`},\
        167  { `rt_cleanclones rn=$D1%XW newroute=$D2%XW`},\
        168  { `rt_cleanclones return`},\
        169  { `adjust_gateways`},\
        170  { `adjust_gateways return`},\
        171  { `route_usrreq so=$D1%XW req=$D2%DW m=$D3%XW nam=$D4%DW control=$D5%XW` }, \
        172  { `route_usrreq return error=$D1%DW`},\
        173  { `route_usrreq error1 so=$D1%XW error=$D2%DW`},\
        174  { `route_usrreq error2 so=$D1%XW error=$D2%DW`},\
        175  { `route_usrreq error3 so=$D1%XW error=$D2%DW`},\
        176  { `rt_setmetrics which=$D1%XW in=$D2%XW out=$D3%XW`},\
        177  { `m_copyback m0=$D1%XW off=$D2%DW len=$D3%DW cp=$D4%XW`},\
        178  { `m_copyback return pkthdr_len=$D1%DW totlen=$D2%DW`},\
        179  { `m_copyback error1 error=$D1%DW`},\
        180  { `m_copyback error2 error=$D1%DW`},\
        181  { `rt_msg1 type=$D1%DW rtinfo=$D2%XW`},\
        182  { `rt_msg1 return m=$D1%XW`},\
        183  { `rt_msg2 type=$D1%DW rtinfo=$D2%XW cp=$D3%XW w=$D4%XW version=$D5%DW` }, \
        184  { `rt_msg1 return len=$D1%DW`},\
        185  { `rt_ifmsg error1  ifp=$D1%XW error=$D2%DW`},\
        186  { `raw_init`},\
        187  { `raw_input m0=$D1%XW proto=$D2%XW src=$D3%XW dst=$D4%XW`},\
        188  { `raw_input return sockets=$D1%DW`},\
        189  { `raw_usrreq so=$D1%XW req=$D2%DW m=$D3%XW nam=$D4%XW control=$D5%XW`}, \
        190  { `raw_usrreq return so=$D1%XW error=$D2%DW`},\
        191  { `raw_usrreq error1 so=$D1%XW error=$D2%DW`},\
        192  { `raw_usrreq error2 so=$D1%XW error=$D2%DW`},\
        193  { `raw_usrreq error3 so=$D1%XW error=$D2%DW`},\
        194  { `raw_usrreq error4 so=$D1%XW error=$D2%DW`},\
        195  { `raw_usrreq error5 so=$D1%XW error=$D2%DW`},\
        196  { `raw_usrreq error6 so=$D1%XW error=$D2%DW`},\
        197  { `raw_usrreq error7 so=$D1%XW error=$D2%DW`},\
        198  { `raw_usrreq error8 so=$D1%XW error=$D2%DW`},\
        199  { `raw_usrreq error9 so=$D1%XW error=$D2%DW`},\
        200  { `raw_usrreq error10 so=$D1%XW error=$D2%DW`},\
        201  { `raw_usrreq error11 so=$D1%XW error=$D2%DW`},\
        202  { `raw_usrreq error12 so=$D1%XW error=$D2%DW`},\
        203  { `raw_usrreq error13 so=$D1%XW error=$D2%DW` }, \
        204  { `raw_usrreq error14 so=$D1%XW error=$D2%DW` }, \
        205  { `raw_usrreq error15 so=$D1%XW nam=$D2%XW error=$D3%DW `}, \
        206  { `raw_usrreq error16 so=$D1%XW nam=$D2%XW error=$D3%DW` }, \
        207  { `raw_usrreq error17 so=$D1%XW nam=$D2%XW error=$D3%DW` }, \
        208  { `raw_usrreq error18 so=$D1%XW error=$D2%DW` }, \
        209  { `rn_genmatch out7 r=$D1%XW` }, \
        210  { `rtexpire_delete so_addr=$D1%XW error=$D2%DW` }, \
        211  { `rn_insert_in radix_node=$D1%XW`},\
        212  { `rn_insert_out radix_node=$D1%XW`},\
        213  { `route_output error31 m=$D1%XW route_proto=$D2%XW route_src=$D3%XW route_dst=$D4%XW error=$D5%DW`}, \
        \* { unknown subhook $HD $ERROR }
618 1.0 'LOOP' \
        $HD%D1, \
        1  { `loinit` }, \
        2  { `loattach` }, \
        3  { `looutput ifp=$D1%XW m=$D2%XW dst=$D3%XW rt=$D4%XW` }, \
        4  { `return from looutput` }, \
        5  { `loioctl ifp=$D1%XW cmd=$D2%DW data=$D3%XW` }, \
        6  { `return from loioctl error=$D1%DW` }, \
        7  { `looutput out1` }, \
        8  { `looutput out2` }, \
        9  { `looutput out3` }, \
        10  { `looutput error1 error=$D1%DW` }, \
        11  { `looutput error2` }, \
        12  { `looutput error3 error=$D1%DW` }, \
        13  { `loioctl error1 error=$D1%DW` }, \
        14  { `loioctl error2 error=$D1%DW` }, \
 	\* { unknown subhook $HD $ERROR }
619 1.0 'CDLI' \
        $HD%D1, \
        1  { `ifinit` }, \
        2  { `return from ifinit` }, \
        3  { `ifreset n=$D1%DW` }, \
        4  { `return from ifreset` }, \
        5  { `netif_handler transid=$D1%DW cmd=$D1%DW arg=$D3%XW` }, \
        6  { `return from netif_handler ipri=$D1%DW` }, \
        7  { `if_attach ifp=$D1%XW` }, \
        8  { `return from if_attach` }, \
        9  { `link_rtrequest cmd=$D1%DW rt=$D1%XW sa=$D3%XW` }, \
        10  { `return from link_rtrequest` }, \
        11  { `link_rtrequest out1 cmd=$D1%DW` }, \
        12  { `if_down ifp=$D1%XW` }, \
        13  { `return from if_down` }, \
        14  { `if_detach ifp=$D1%XW` }, \
        15  { `return from if_detach` }, \
        16  { `if_rt_delete ifp=$D1%XW` }, \
        17  { `return from if_rt_delete` }, \
        19  { `if_rt_updroute ifr=$D1%XW` }, \
        20  { `ifioctl so=$D1%XW cmd=$D2%DW data=$D3%XW` }, \
        21  { `ifioctl error1 error=$D1%DW` }, \
        22  { `ifioctl error2 error=$D1%DW` }, \
        23  { `ifioctl error3 error=$D1%DW` }, \
        24  { `ifioctl error4 error=$D1%DW` }, \
        25  { `ifioctl error5 error=$D1%DW` }, \
        26  { `ifioctl error6 error=$D1%DW` }, \
        27  { `ifioctl error7 error=$D1%DW` }, \
        28  { `ifioctl error8 error=$D1%DW` }, \
        29  { `ifioctl error9 error=$D1%DW` }, \
        30  { `ifioctl error10 error=$D1%DW` }, \
        31  { `ifioctl error11 error=$D1%DW` }, \
        32  { `ifioctl error12 error=$D1%DW` }, \
        33  { `ifioctl error13 error=$D1%DW` }, \
        34  { `ifioctl error14 error=$D1%DW` }, \
        35  { `ifioctl error15 error=$D1%DW` }, \
        36  { `ifioctl error16 error=$D1%DW` }, \
        37  { `ifioctl error17 error=$D1%DW` }, \
        38  { `ifioctl error18 error=$D1%DW` }, \
        39  { `ifioctl error19 error=$D1%DW` }, \
        40  { `ifioctl error20 error=$D1%DW` }, \
        41  { `ifioctl error21 error=$D1%DW` }, \
        42  { `ifioctl error22 error=$D1%DW` }, \
        43  { `ifioctl error23 error=$D1%DW` }, \
        44  { `ifioctl error24 error=$D1%DW` }, \
        45  { `ifioctl error25 error=$D1%DW` }, \
        46  { `ifioctl error26 error=$D1%DW` }, \
        47  { `ifioctl error27 error=$D1%DW` }, \
        48  { `ifioctl error28 error=$D1%DW` }, \
        49  { `ifioctl error29 error=$D1%DW` }, \
        50  { `ifioctl error30 error=$D1%DW` }, \
        51  { `ifioctl error31 error=$D1%DW` }, \
        52  { `ifioctl error32 error=$D1%DW` }, \
        53  { `ifioctl error33 error=$D1%DW` }, \
        54  { `ifioctl error34 error=$D1%DW` }, \
        55  { `ifioctl error35 error=$D1%DW` }, \
        56  { `ifioctl error36 ifr_mtu=$D1%DW error=$D2%DW` }, \
        57  { `ifioctl error37 error=$D1%DW` }, \
        58  { `ifioctl error38 error=$D1%DW` }, \
        59  { `ifioctl error39 error=$D1%DW` }, \
        60  { `ifioctl error40 error=$D1%DW` }, \
        61  { `ifioctl error41 error=$D1%DW` }, \
        62  { `ifioctl error42 error=$D1%DW` }, \
        63  { `ifioctl error43 error=$D1%DW` }, \
        64  { `ifioctl error44 error=$D1%DW` }, \
        65  { `ifioctl error45 error=$D1%DW` }, \
        66  { `ifioctl error46 error=$D1%DW` }, \
        67  { `ifioctl error47 error=$D1%DW` }, \
        68  { `ifioctl error48 error=$D1%DW` }, \
        69  { `ifioctl error49 error=$D1%DW` }, \
        70  { `ifioctl error50 error=$D1%DW` }, \
        71  { `ifioctl error51 error=$D1%DW` }, \
        72  { `ifioctl error52 error=$D1%DW` }, \
        73  { `ifioctl error53 error=$D1%DW` }, \
        74  { `ifioctl error54 error=$D1%DW` }, \
        75  { `ifioctl error55 error=$D1%DW` }, \
        76  { `ifioctl error56 error=$D1%DW` }, \
        77  { `ifioctl error57 error=$D1%DW` }, \
        78  { `ifioctl error58 error=$D1%DW` }, \
        79  { `ifioctl error59 error=$D1%DW` }, \
        80  { `ifioctl error60 error=$D1%DW` }, \
        81  { `ifioctl error61 error=$D1%DW` }, \
        82  { `ifioctl error62 error=$D1%DW` }, \
        83  { `ifioctl error63 error=$D1%DW` }, \
        84  { `ifioctl error64 error=$D1%DW` }, \
        85  { `ifioctl error65 error=$D1%DW` }, \
        86  { `ifioctl error66 error=$D1%DW` }, \
        87  { `ifioctl error67 error=$D1%DW` }, \
        88  { `ifconf error1 error=$D1%DW` }, \
        89  { `ifconf error2 error=$D1%DW` }, \
        90  { `ifconf error3 error=$D1%DW` }, \
        91  { `insert_mtu mtu=$D1%DW` }, \
        92  { `insert_mtu error1` }, \
        93  { `insert_mtu error2 error=$D1%DW` }, \
        94  { `return from insert_mtu` }, \
        95  { `delete_mtu mtu=$D1%DW` }, \
        96  { `delete_mtu error1` }, \
        97  { `delete_mtu error2` }, \
        98  { `return from delete_mtu` }, \
        99  { `next_mtu mtu=$D1%DW` }, \
        100  { `return from next_mtu` }, \
        101  { `listifvipa ifp=$D1%XW` }, \
        102  { `return from listifvipa numifp=$D1%DW` }, \
        103  { `setifvipa ifrv=$D1%XW ifp=$D2%XW` }, \
        104  { `setifvipa error1 error=$D1%DW` }, \
        105  { `setifvipa error2 error=$D1%DW` }, \
        106  { `setifvipa error3 error=$D1%DW` }, \
        107  { `setifvipa error4 error=$D1%DW` }, \
        108  { `delifvipa ifrv=$D1%XW ifp=$D2%XW` }, \
        109  { `delifvipa error1 error=$D1%DW` }, \
        110  { `delifvipa error2 error=$D1%DW` }, \
        111  { `delifvipa error3 error=$D1%DW` }, \
        112  { `delifvipa error4 error=$D1%DW` }, \
        113  { `delifvipaxface ifp=$D1%XW` }, \
	117  { `if_reset_route_addr:point=$D1%DW radix node=$D2%XW data ptr=$D3%XW interface address=$D4%XW` }, \
	118  { `if_rt_ifaddr_reset interface ptr=$D1%XW address family=$D2%DW` }, \
	119  { `if_rt_ifaddr_reset:return point=$D1%DW interface ptr=$D2%XW address family=$D3%DW` }, \
        120  { `ifioctl error70 error=$D1%DW` }, \
        121  { `ifioctl error71 error=$D1%DW` }, \
        122  { `ifioctl error72 error=$D1%DW` }, \
        123  { `ifioctl error73 error=$D1%DW` }, \
 	\* { unknown subhook $HD $ERROR }
61A 1.0 'NETINET_MISC' \
        $HD%D1, \
        1  { `arpinit` }, \
        2  { `arpinit error1 error=$D1%DW` }, \
        3  { `arptimer_init` }, \
        4  { `arpresolve_common ac=$D1%XW m=$D2%XW arpwhohas=$D3%XW dst=$D4%XW hwaddr=$D5%XW` }, \
        5  { `return from arpresolve_common ret=$D1%DW` }, \
        6  { `arpresolve_common out1 ret=$D1%DW` }, \
        7  { `arpresolve_common out2 ret=$D1%DW` }, \
        8  { `arpresolve_common out3 ret=$D1%DW` }, \
        9  { `arpresolve_common out4 ret=$D1%DW` }, \
        10  { `arpupdate ac=$D1%XW m=$D2%XW hp=$D3%XW action=$D4%DW prm=$D5%XW` }, \
        11  { `return from arpupdate` }, \
        12  { `arpioctl cmd=$D1%DW data=$D2%XW` }, \
        13  { `return from arpioctl` }, \
        14  { `arptnew` }, \
        15  { `arptnew_call_arptfree at=$D1%XW` }, \
        16  { `arpupdate out1 ret=$D1%DW` }, \
        17  { `arpupdate out2 ret=$D1%DW` }, \
        18  { `arpupdate out3 ret=$D1%DW` }, \
        19  { `arpupdate out4 ret=$D1%DW` }, \
        20  { `arpupdate out5 ret=$D1%DW` }, \
        21  { `arpupdate out6 ret=$D1%DW` }, \
        22  { `arpupdate error1 error=$D1%DW` }, \
        23  { `arpupdate error2 error=$D1%DW` }, \
        24  { `arpupdate error3 error=$D1%DW` }, \
        25  { `arpupdate error4 error=$D1%DW` }, \
        26  { `arpupdate error5 error=$D1%DW` }, \
        27  { `arpupdate error6 error=$D1%DW` }, \
        28  { `arpupdate error7 error=$D1%DW` }, \
        29  { `arpupdate error8 error=$D1%DW` }, \
        30  { `add_gateway out1` }, \
        31  { `mark_gateway_down out1` }, \
        32  { `in_control error1 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        33  { `in_control error2 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        34  { `in_control error3 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        35  { `in_control error4 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        36  { `in_control error5 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        37  { `in_control error6 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        38  { `in_control error7 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        39  { `in_control error8 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        40  { `in_control error9 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        41  { `in_control error10 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        42  { `in_control error11 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        43  { `in_control error12 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        44  { `in_control error13 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        45  { `in_control error14 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        46  { `in_control error15 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        47  { `in_control error16 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        48  { `in_control error17 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        49  { `in_control error18 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        50  { `in_ifattach error1 ifp=$D1%XW error=$D2%DW` }, \
        51  { `in_ifattach error2 ifp=$D1%XW error=$D2%DW` }, \
        52  { `in_ifattach error3 ifp=$D1%XW error=$D2%DW` }, \
        53  { `in_ifattach error4 ifp=$D1%XW error=$D2%DW` }, \
        54  { `in_ifattach error5 ifp=$D1%XW error=$D2%DW` }, \
        55  { `in_ifinit error1 ifp=$D1%XW error=$D2%DW` }, \
        56  { `in_ifinit out1 ifp=$D1%XW error=$D2%DW` }, \
        57  { `in_ifinit out2 ifp=$D1%XW error=$D2%DW` }, \
        58  { `in_ifinit out3 ifp=$D1%XW error=$D2%DW` }, \
        59  { `in_addmulti out1 s_addr=$D1%XW ret=$D2%DW` }, \
        60  { `in_addmulti out2 s_addr=$D1%XW ret=$D2%DW` }, \
        61  { `in_hash_add out1 s_addr=$D1%XW` }, \
        62  { `in_ifscrub_vipa addr=$D1%XW` }, \
        63  { `in_ifscrub_vipa ifp=$D1%XW ia=$D2%XW` }, \
        65  { `in_pcballoc error1 so=$D1%XW error=$D2%DW` }, \
        66  { `in_pcbbind error1 inp=$D1%XW error=$D2%DW` }, \
        67  { `in_pcbbind error2 inp=$D1%XW error=$D2%DW` }, \
        68  { `in_pcbbind error3 inp=$D1%XW error=$D2%DW` }, \
        69  { `in_pcbbind error4 inp=$D1%XW error=$D2%DW` }, \
        70  { `in_pcbbind error5 inp=$D1%XW error=$D2%DW` }, \
        71  { `in_pcbbind error6 inp=$D1%XW error=$D2%DW` }, \
        72  { `in_pcbbind error7 inp=$D1%XW error=$D2%DW` }, \
        73  { `in_pcbbind error8 inp=$D1%XW error=$D2%DW` }, \
        74  { `in_pcbconnect error1 inp=$D1%XW error=$D2%DW` }, \
        75  { `in_pcbconnect error2 inp=$D1%XW error=$D2%DW` }, \
        76  { `in_pcbconnect error3 inp=$D1%XW error=$D2%DW` }, \
        77  { `in_pcbconnect error4 inp=$D1%XW error=$D2%DW` }, \
        78  { `in_pcbconnect error5 inp=$D1%XW error=$D2%DW` }, \
        79  { `in_pcbconnect error6 inp=$D1%XW error=$D2%DW` }, \
        80  { `in_pcbconnect error7 inp=$D1%XW error=$D2%DW` }, \
        81  { `in_pcbconnect error8 inp=$D1%XW error=$D2%DW` }, \
        82  { `in_pcbconnect error9 inp=$D1%XW error=$D2%DW` }, \
        83  { `in_pcbpseudoconnect error1 inp=$D1%XW error=$D2%DW` }, \
        84  { `in_pcbpseudoconnect error2 inp=$D1%XW error=$D2%DW` }, \
        85  { `in_pcbpseudoconnect error3 inp=$D1%XW error=$D2%DW` }, \
        86  { `in_pcbpseudoconnect error4 inp=$D1%XW error=$D2%DW` }, \
        87  { `in_pcbpseudoconnect error5 inp=$D1%XW error=$D2%DW` }, \
        88  { `in_pcbpseudoconnect error6 inp=$D1%XW error=$D2%DW` }, \
        89  { `in_pcbpseudoconnect error7 inp=$D1%XW error=$D2%DW` }, \
        90  { `in_pcbpseudoconnect error8 inp=$D1%XW error=$D2%DW` }, \
        91  { `in_pcbpseudoconnect error9 inp=$D1%XW error=$D2%DW` }, \
        92  { `in_pcbpseudobind error1 inp=$D1%XW error=$D2%DW` }, \
        93  { `in_pcbpseudobind error2 inp=$D1%XW error=$D2%DW` }, \
        94  { `in_pcbpseudobind error3 inp=$D1%XW error=$D2%DW` }, \
        95  { `in_pcbpseudobind error4 inp=$D1%XW error=$D2%DW` }, \
        96  { `in_pcbpseudobind error5 inp=$D1%XW error=$D2%DW` }, \
        97  { `in_pcbpseudobind error6 inp=$D1%XW error=$D2%DW` }, \
        98  { `in_pcbpseudobind error7 inp=$D1%XW error=$D2%DW` }, \
        99  { `in_pcbpseudobind error8 inp=$D1%XW error=$D2%DW` }, \
        100  { `in_pcbnotify out1` }, \
        101  { `in_pcbnotify out2` }, \
        102  { `in_pcbnotify out3` }, \
        103  { `in_pcbnotifyall out1` }, \
        104  { `in_pcbnotifyall out2` }, \
        105  { `in_pcbnotifyall out3` }, \
        106  { `in_pcblocalipnotifyall out1` }, \
        107  { `in_pcblocalipnotifyall out2` }, \
        108  { `in_pcblocalipnotifyall out3` }, \
        109  { `icmp_unreachable nextmtu=$D1%DW pt_mtu=$D2%DW` }, \
        111  { `in_control error20 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        112  { `in_control error21 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        113  { `in_control error22 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
        114  { `in_control error23 so=$D1%DW cmd=$D2%DW error=$D3%DW` }, \
 	\* { unknown subhook $HD $ERROR }
61B 1.0 'SOCKET_UNIX' \
        $HD%D1, \
        1  { `uipc_init` }, \
        2  { `unp_dispose m=$D1%XW` }, \
        3  { `unp_drop unp=$D1%XW error=$D2%DW` }, \
        4  { `unp_externalize so=$D1%XW rights=$D2%XW` }, \
        5  { `unp_internalize control=$D1%XW cm=$D2%XW` }, \
        6  { `uipc_usrreq error1 so=$D1%XW error=$D2%DW` }, \
        7  { `uipc_usrreq error2 so=$D1%XW error=$D2%DW` }, \
        8  { `uipc_usrreq error3 so=$D1%XW error=$D2%DW` }, \
        9  { `uipc_usrreq error4 so=$D1%XW error=$D2%DW req=$D3%DW` }, \
        10  { `uipc_usrreq error5 so=$D1%XW error=$D2%DW` }, \
        11  { `uipc_usrreq error6 so=$D1%XW error=$D2%DW` }, \
        12  { `uipc_usrreq error7 so=$D1%XW error=$D2%DW` }, \
        13  { `uipc_usrreq error8 so=$D1%XW error=$D2%DW` }, \
        14  { `uipc_usrreq error9 so=$D1%XW error=$D2%DW` }, \
        15  { `uipc_usrreq error10 so=$D1%XW error=$D2%DW` }, \
        16  { `uipc_usrreq error11 so=$D1%XW error=$D2%DW` }, \
        17  { `uipc_usrreq error12 so=$D1%XW error=$D2%DW` }, \
        18  { `uipc_usrreq error13 so=$D1%XW error=$D2%DW` }, \
        19  { `uipc_usrreq error14 so=$D1%XW error=$D2%DW` }, \
        20  { `uipc_usrreq error15 so=$D1%XW error=$D2%DW` }, \
        21  { `uipc_usrreq error16 so=$D1%XW error=$D2%DW` }, \
        22  { `uipc_usrreq error17 so=$D1%XW error=$D2%DW` }, \
        23  { `uipc_usrreq error18 so=$D1%XW error=$D2%DW` }, \
        24  { `uipc_usrreq error19 so=$D1%XW error=$D2%DW` }, \
        25  { `uipc_usrreq error20 so=$D1%XW error=$D2%DW` }, \
        26  { `uipc_usrreq error21 so=$D1%XW error=$D2%DW m=$D3%XW` }, \
        27  { `uipc_usrreq error22 so=$D1%XW error=$D2%DW m=$D3%XW` }, \
        28  { `uipc_usrreq error23 so=$D1%XW error=$D2%DW` }, \
        29  { `unp_attach error1 so=$D1%XW error=$D2%DW snd_sb_hiwat=$D3%XW rcv_sb_hiwat=$D4%XW` }, \
        30  { `unp_attach error2 so=$D1%XW error=$D2%DW size=$D3%XW` }, \
        31  { `unp_bind error1 error=$D1%DW` }, \
        32  { `unp_bind error2 error=$D1%DW` }, \
        33  { `unp_bind error3 error=$D1%DW` }, \
        34  { `unp_bind error4 error=$D1%DW` }, \
        35  { `unp_bind error5 error=$D1%DW` }, \
        36  { `unp_bind error6 error=$D1%DW` }, \
        37  { `unp_bind error7 error=$D1%DW` }, \
        38  { `unp_bind error8 error=$D1%DW` }, \
        39  { `unp_bind error9 error=$D1%DW` }, \
        40  { `unp_bind error10 error=$D1%DW` }, \
        41  { `unp_connect error1 error=$D1%DW` }, \
        42  { `unp_connect error2 error=$D1%DW` }, \
        43  { `unp_connect error3 error=$D1%DW` }, \
        44  { `unp_connect error4 error=$D1%DW` }, \
        45  { `unp_connect error5 error=$D1%DW` }, \
        46  { `unp_connect error6 error=$D1%DW` }, \
        47  { `unp_connect error7 error=$D1%DW` }, \
        48  { `unp_connect error8 error=$D1%DW` }, \
        49  { `unp_connect error9 error=$D1%DW` }, \
        50  { `unp_connect2 error1 error=$D1%DW` }, \
        51  { `unp_connect2 error2 error=$D1%DW` }, \
        52  { `unp_internalize error1 cm=$D1%XW error=$D2%DW` }, \
        53  { `unp_internalize error2 control=$D1%XW error=$D2%DW` }, \
        54  { `unp_internalize error3 control=$D1%XW needsize=$D2%DW error=$D3%DW` }, \
        55  { `unp_internalize error4 control=$D1%XW rc=$D2%DW error=$D3%DW` }, \
        56  { `unp_connect so=$D1%XW nam=$D2%DW` }, \
        57  { `return from unp_connect so=$D1%XW error=$D2%DW` }, \
        58  { `unp_bind unp=$D1%XW nam=$D2%DW` }, \
        59  { `return from unp_bind` }, \
        60  { `uipc_usrreq so=$D1%XW req=$D2%DW m=$D3%XW nam=$D4%XW control=$D5%XW` }, \
        61  { `return from uipc_usrreq error=$D1%DW` }, \
        62  { `unp_detach unp=$D1%XW` }, \
        63  { `return from unp_detach` }, \
        64  { `unp_attach so=$D1%XW` }, \
        65  { `return from unp_attach` }, \
        66  { `unp_shutdown unp=$D1%XW` }, \
        67  { `return from unp_shutdown` }, \
	68  { `uipc_usrreq_err24 so=$D1%XW error=$D2%DW` }, \
	69  { `uipc_usrreq_err25 so=$D1%XW error=$D2%DW req=$D3%DW` }, \
	70  { `unp_connect2_err3 so=$D1%XW so2=$D2%XW error=$D3%DW` }, \
	71  { `unp_bind_err11 error=$D1%DW` }, \
 	\* { unknown subhook $HD $ERROR }
624 1.0 "@VMSVC_PIN" \
        $HD, \
        0x00 { `VMSVC PIN: caller=$D1 addr=$D2 bytes=$D3 pintype=$D4 segtype=$D5` }, \
	0x01 { `VMSVC PIN Err: rc=$D1` }, \
        0x02 { `VMSVC UNPIN: caller=$D1 addr=$D2 bytes=$D3 pintype=$D4` }, \
	0x03 { `VMSVC UNPIN Err: rc=$D1` },\
        0x04 { `VMSVC XL PIN: caller=$D1 xmemd=$D2 addr=$D3 count=$D4 rw=$D5` }, \
	0x05 { `VMSVC XL PIN Err: rc=$D1` }, \
        0x06 { `VMSVC XL UNPIN: caller=$D1 xmemd=$D2 addr=$D3 count=$D4` }, \
	0x07 { `VMSVC XL UNPIN Err: rc=$D1` }, \
	0x08 { `VMSVC PIN forced: psx=$D1 pfavail=$D2 pfrsvdblks=$D3 pintype=$D4` }
625 1.0 "@VMSVC_DR" \
	$HD, \
        0x00 { `VMSVC RMLMB: caller=$D1 start=$D2 len=$D3 flags=$D4` }, \
	0x01 { `VMSVC RMLMB Err: rc=$D1` },\
        0x02 { `VMSVC ADDLMB: caller=$D1 start=$D2 len=$D3 flags=$D4` }, \
	0x03 { `VMSVC ADDLMB Err: rc=$D1` }, \
        0x04 { `VMSVC ADDMEM: caller=$D1 start=$D2 len=$D3 flags=$D4` }, \
	0x05 { `VMSVC ADDMEM Err: rc=$D1` }, \
        0x06 { `VMSVC FREEMEM: caller=$D1 start=$D2 len=$D3 flags=$D4` }, \
	0x07 { `VMSVC FREEMEM Err: rc=$D1` }
626 1.0 "@VMSVC_GALLOC" \
        $HD, \
        0x00 { `VMSVC GFREE: caller=$D1 addr=$D2 size=$D3` }, \
	0x01 { `VMSVC GFREE Err: rc=$D1` }, \
        0x02 { `VMSVC GALLOC ATT: caller=$D1 type=$D2 size=$D3 policy=$D4` }, \
	0x03 { `VMSVC GALLOC ATT Err: rc=$D1` }
627 1.0 "@VMSVC_DELETE" \
	$HD, \
        0x00 { `VMSVC DELETE: caller=$D1 sidx=$D2` vmmsibits($D3) }, \
	0x01 { `VMSVC DELETE Err: rc=$D1` },\
        0x02 { `VMSVC RELEASE: caller=$D1 addr=$D2 bytes=$D3` }, \
	0x03 { `VMSVC RELEASE Err: rc=$D1` },\
        0x04 { `VMSVC RELEASEP: caller=$D1 sid=$D2 pfirst=$D3 npages=$D4` }, \
	0x05 { `VMSVC RELEASEP Err: rc=$D1` },\
        0x06 { `VMSVC DISCLAIM: caller=$D1 addr=$D2 len=$D3` }, \
	0x07 { `VMSVC DISCLAIM Err: rc=$D1` }, \
	0x08 { `VMSVC SETSEG_HKEY: caller=$D1 sid=$D2 hkey=$D3` }, \
	0x09 { `VMSVC SETSEG_HKEY Err: rc=$D1` }, \
	0x0A { `VMSVC SETSEG_KKEY: caller=$D1 sid=$D2 kkey=$D3` }, \
	0x0B { `VMSVC SETSEG_KKEY Err: rc=$D1` }
628 1.0 "@VMSVC_VMS_IOWAITF" \
        $HD, \
        0x00 { `VMSVC IOWAITF: caller=$D1 sid=$D2 flags=$D3` }, \
	0x01 { `VMSVC IOWAITF Err: rc=$D1` }
629 1.0 "@VMSVC_VM_PROTECT" \
        $HD, \
        0x00 { `VMSVC PROTECT: caller=$D1 addr=$D2 bytes=$D3 key=$D4`}, \
	0x01 { `VMSVC PROTECT Err: rc=$D1` }, \
        0x02 { `VMSVC MPROTECT: caller=$D1 start=$D2 end=$D3 prot=$D4 mode=$D5`}, \
	0x03 { `VMSVC MPROTECT Err: rc=$D1` }
62A 1.0 "@VMSVC_WRITE" \
        $HD, \
        0x00 { `VMSVC WRITE: caller=$D1 addr=$D2 bytes=$D3 force=$D4` }, \
	0x01 { `VMSVC WRITE Err: rc=$D1` },\
        0x02 { `VMSVC XWRITEP: caller=$D1 sid=$D2 pfirst=$D3 npages=$D4 flags=$D5` }, \
	0x03 { `VMSVC XWRITEP Err: rc=$D1` }
62B 1.0 "@VMSVC_AS" \
        $HD, \
        0x00 { `VMSVC AS_ATT: caller=$D1 vmhandle=$D2 offset=$D3` }, \
	0x01 { `VMSVC AS_ATT Err: rc=$D1` }, \
        0x02 { `VMSVC AS_DET: caller=$D1 addr=$D2` }, \
	0x03 { `VMSVC AS_DET Err: rc=$D1` }, \
        0x04 { `VMSVC AS_SETH: caller=$D1 addr=$D2 vmhandle=$D3` }, \
	0x05 { `VMSVC AS_SETH Err: rc=$D1` }, \
	0x06 { `VMSVC AS_LW_ATT: caller=$D1 xmem=$D2 offset=$D3 length=$D4 addr = $D5` }, \
	0x07 { `VMSVC AS_LW_ATT Err: rc=$D1` }, \
	0x08 { `VMSVC AS_LW_DET: caller=$D1 xmem=$D2 addr=$D3 length=$D4` }, \
	0x09 { `VMSVC AS_LW_DET Err: rc=$D1` }, \
	0x0A { `VMSVC AS_LW_POOL: caller=$D1 pool_size=$D2 flags=$D3` }, \
	0x0B { `VMSVC AS_LW_POOL Err: rc=$D1` }, \
	0x0C { `VMSVC VMS_LIMITS: caller=$D1, sid=$D2, uplim=$D3, downlim=$D4, oldlims=$D5` }, \
	0x0D { `VMSVC VMS_LIMITS Err: rc=$D1` }, \
	0x0E { `VMSVC MPC_SEND: caller=$D1 old_hand=$D2 det_eaddr=$D3 stab_version=$D4` }, \
	0x0F { `VMSVC MPC_SEND Err: rc=$D1` }, \
	0x10 { `VMSVC_TID_SRAD_ATCH: getcaller=$D1 rc=$D2 tid=$D3 sradid=$D4 attach?=$D5 ` }
62C 1.0 "@MIG_DR" \
{{ \
	heavy(flags) \
		$flags \
		BITFLAGS $flags, \
		& 0x0001 0x0000 "light", \
		0x0001 "heavy", \
		0x0002 "mappers", \
		0x0004 "64k", \
		& 0x0004 0x0000 "4k" \
}} \
        $HD, \
        0x00 { `VMM MIG: start=$D1 end=$D2 flags=$D3 nfr=$D4 pft_swbits=$D5` }, \
	0x01 { `VMM MIG Err: rc=$D1 start=$D2 flags=$D3 nfr =$D4 pft_swbits=$D5` }, \
	0x02 { `VMM MIG PAGE: sid=$D1 pno=$D2 nfr=$D3 n_nfr=$D4 ` heavy($D5) }, \
	0x03 { `VMM MIG PAGE Err: rc=$D1 sid=$D2 pno=$D3 nfr=$D4 n_nfr=$D5` }, \
	0x04 { `VMM MIG SERV: nfr=$D1 pft_swbits=$D2` }, \
	0x05 { `VMM MIG SERV Err: rc=$D1 nfr=$D2 pft_swbits=$D3` }, \
	0x06 { `VMM REAFF SERV: sid=$D1 pno=$D2 nfr=$D3` }, \
	0x07 { `VMM REAFF SERV Err: krc=$D1 sid=$D2 pno=$D3 nfr=$D4 mig=$D5` }
62D 1.0 "@ARM_TRACE" \
        $D1%D1, \
        00 { "REG_APP_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "appname_off: " X4 "\n" \
                "appname_len: " {{ $alen = X4 }} $alen "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "app_id: " X8 "\n" \
                "flags: " X4 "\n" \
                "id_prop_cnt: " {{ $cnt = X4 }} $cnt "\n" \
                "id_prop_off: " X4 "\n" \
                "charset: " D4 "\n" \
                {{ $bbptr = $DATAPOINTER }} \
                "app_name: " LOOP $alen {A0} "\n" \
                $cnt, \
                0 { No Identity Properties \n }, \
                \* { "Identity Properties:\n" } \
                      LOOP $cnt { \
                        {{ $noff = X4 }} {{ $nlen = X4 }} \
                        {{ $voff = X4 }} {{ $vlen = X4 }} \
                        {{ $bptr = $DATAPOINTER }} \
                        {{ $DATAPOINTER = $bbptr + $noff }} \
                        "Prop Name: " LOOP $nlen {A0}  "Prop Value: " LOOP $vlen {A0} "\n" \
                        {{ $DATAPOINTER = $bptr }} \
                      } \
                "\n"}, \
        01 { "REG_APP_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        02 { "DESTROY_APP_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        03 { "DESTROY_APP_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "rc: " D4 "\n" \
                "\n"}, \
	04 { "START_APP_ENTER"\n \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "grp_name_off: " X4 "\n" \
                "grp_name_len: " {{ $glen = X4 }} $glen "\n" \
                "inst_name_off: " X4 "\n" \
                "inst_name_len: " {{ $ilen = X4 }} $ilen "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "context_cnt: " {{ $cnt = X4 }} $cnt "\n" \
                "context_off: " X4 "\n" \
                "sysaddr_buf: " X4 "\n" \
                {{ $bbptr = $DATAPOINTER }} \
                "group_name: " LOOP $glen {A0} "\n" \
                "instance_name: " LOOP $ilen {A0} "\n" \
                $cnt, \
                0 { No application context \n }, \
                \* { "Application context: \n" } \
                      LOOP $cnt { \
                        {{ $off = X4 }} {{ $len = X4 }} \
                        {{ $bptr = $DATAPOINTER }} \
                        {{ $DATAPOINTER = $bbptr + $off }} \
                        "Context Value: " LOOP $len {A0} "\n" \
                        {{ $DATAPOINTER = $bptr }} \
                      } \
                "\n"}, \
        05 { "START_APP_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "aeid: " X8 "\n" \
                "aiid: " X8 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        06 { "STOP_APP_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "buff4Adr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
	07 { "STOP_APP_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "rc: " D4 "\n" \
                "\n"}, \
        08 { "REG_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "tran_name_off: " X4 "\n" \
                "tran_name_len: " {{ $tlen = X4 }} $tlen "\n" \
                "in_tran_id: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "id_prop_cnt: " {{ $cnt = X4 }} $cnt "\n" \
                "id_prop_off: " X4 "\n" \
                {{ $bbptr = $DATAPOINTER }} \
                "tran_name: " LOOP $tlen {A0} "\n" \
                $cnt, \
                0 { No Identity Properties \n }, \
                \* { "Identity Properties:\n" } \
                      LOOP $cnt { \
                        {{ $noff = X4 }} {{ $nlen = X4 }} \
                        {{ $voff = X4 }} {{ $vlen = X4 }} \
                        {{ $bptr = $DATAPOINTER }} \
                        {{ $DATAPOINTER = $bbptr + $noff }} \
                        "Prop Name: " LOOP $nlen {A0}  "Prop Value: " LOOP $vlen {A0} "\n" \
                        {{ $DATAPOINTER = $bptr }} \
                      } \
                "\n"}, \
        09 { "REG_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "output_tran_id: " X8 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        10 { "START_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "tran_id: " X8 "\n" \
                "corr_off: " X4 "\n" \
                "corr_len: " {{ $clen = X4 }} $clen "\n" \
                "arrival_time: " D8 "\n" \
                "context_cnt: " {{ $cnt = X4 }} $cnt "\n" \
                "context_off: " X4 "\n" \
                "username_off: " X4 "\n" \
                "username_len: " {{ $ulen = X4 }} $ulen "\n" \
                "user_id: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                {{ $bbptr = $DATAPOINTER }} \
                "parent_correlator: " LOOP $clen {X0} "\n" \
                "user_name: " LOOP $ulen {A0} "\n" \
                $cnt, \
                0 { No Context Properties \n }, \
                \* { "Context Properties:\n" } \
                      LOOP $cnt { \
                        {{ $off = X4 }} {{ $len = X4 }} \
                        {{ $bptr = $DATAPOINTER }} \
                        {{ $DATAPOINTER = $bbptr + $off }} \
                        "Context Value: " LOOP $len {A0} "\n" \
                        {{ $DATAPOINTER = $bptr }} \
                      } \
                "\n"}, \
        11 { "START_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "output_tran_handle: " X8 "\n" \
                "current_corr_off: " X4 "\n" \
                "current_corr_len: " {{ $clen = X4 }} $clen "\n" \
                "tran_start_time: " D8 "\n" \
                "rc: " D4 "\n" \
                "tran_class_id: " D2 "\n" \
                "current_correlator: " LOOP $clen {X0} "\n" \
                "\n"}, \
        12 { "STOP_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "tran_status: " D4 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        13 { "STOP_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_stop_time: " D8 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        14 { "BLOCK_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        15 { "BLOCK_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_block_handle: " X8 "\n" \
                "block_start_time: " D8 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        16 { "UNBLOCK_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "tran_block_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        17 { "UNBLOCK_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "block_stop_time: " D8 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        18 { "UPDATE_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        19 { "UPDATE_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "rc: " D4 "\n" \
                "\n"}, \
        20 { "DISCARD_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        21 { "DISCARD_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "rc: " D4 "\n" \
                "\n"}, \
        22 { "BIND_THREAD_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        23 { "BIND_THREAD_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "rc: " D4 "\n" \
                "\n"}, \
        24 { "UNBIND_THREAD_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "\n"}, \
        25 { "UNBIND_THREAD_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "rc: " D4 "\n" \
                "\n"}, \
        26 { "GEN_CORR_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "tran_id: " X8 "\n" \
                "parent_corr_off: " X4 "\n" \
                "parent_corr_len: "{{ $pclen = X4 }} $pclen "\n" \
                "context_cnt: " {{ $cnt = X4 }} $cnt "\n" \
                "context_off: " X4 "\n" \
                "username_off: " X4 "\n" \
                "username_len: " {{ $ulen = X4 }} $ulen "\n" \
                "user_id: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                {{ $bbptr = $DATAPOINTER }} \
                "parent_correlator: " LOOP $pclen {X0} "\n" \
                "user_name: " LOOP $ulen {A0} "\n" \
                $cnt, \
                0 { No context values \n }, \
                \* { "Context values: \n" } \
                      LOOP $cnt { \
                        {{ $off = X4 }} {{ $len = X4 }} \
                        {{ $bptr = $DATAPOINTER }} \
                        {{ $DATAPOINTER = $bbptr + $off }} \
                        "Context Value: " LOOP $len {A0} "\n" \
                        {{ $DATAPOINTER = $bptr }} \
                      } \
                "\n"}, \
        27 { "GEN_CORR_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "current_corr_off: " X4 "\n" \
                "current_corr_len: " {{ $clen = X4 }} $clen "\n" \
                "rc: " D4 "\n" \
                "current_correlator: " LOOP $clen {X0} "\n" \
                "\n"}, \
        28 { "REPORT_TRAN_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "tran_id: " X8 "\n" \
                "response_time: " D8 "\n" \
                "stop_time: " D8 "\n" \
                "tran_status: " D4 "\n" \
                "parent_corr_off: " X4 "\n" \
                "parent_corr_len: " {{ $pclen = X4 }} $pclen "\n" \
                "current_corr_off: " X4 "\n" \
                "current_corr_len: " {{ $cclen = X4 }} $cclen "\n" \
                "context_cnt: " {{ $cnt = X4 }} $cnt "\n" \
                "context_off: " X4 "\n" \
                "username_off: " X4 "\n" \
                "username_len: " {{ $ulen = X4 }} $ulen "\n" \
                "flags: " X4 "\n" \
                "user_id: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                {{ $bbptr = $DATAPOINTER }} \
                "parent_correlator: " LOOP $pclen {X0} "\n" \
                "current_correlator: " LOOP $cclen {X0} "\n" \
                "username: " LOOP $ulen {A0} "\n" \
                $cnt, \
                0 { No context values \n }, \
                \* { "Context values: \n" } \
                      LOOP $cnt { \
                        {{ $off = X4 }} {{ $len = X4 }} \
                        {{ $bptr = $DATAPOINTER }} \
                        {{ $DATAPOINTER = $bbptr + $off }} \
                        "Context Value: " LOOP $len {A0} "\n" \
                        {{ $DATAPOINTER = $bptr }} \
                      } \
                "\n"}, \
        29 { "REPORT_TRAN_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "rc: " D4 "\n" \
                "\n"}, \
        30 { "REG_METRIC_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "input_metric_id: " X8 "\n" \
                "app_id: " X8 "\n" \
                "metric_name_off: " X4 "\n" \
                "metric_name_len: " {{ $mnlen = X4 }} $mnlen "\n" \
                "metric_unit_off: " X4 "\n" \
                "metric_unit_len: " {{ $mulen = X4 }} $mulen "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "metric_usage: " D2 "\n" \
                "metric_format: " D1 "\n" \
                "mertic_name: " LOOP $mnlen {A0} "\n" \
                "metric_unit: " LOOP $mulen {A0} "\n" \
                "\n"}, \
        31 { "REG_METRIC_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "output_metric_id: " X8 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        32 { "CLASSIFY_CORR_ENTER\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "tran_id: "  X8 "\n" \
                "context_cnt: " {{ $cnt = X4 }} $cnt "\n" \
                "context_off: " X4 "\n" \
                "username_off: " X4 "\n" \
                "username_len: " {{ $ulen = X4 }} $ulen "\n" \
                "user_id: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                {{ $bbptr = $DATAPOINTER }} \
                "username: " LOOP $ulen {A0} \
                $cnt, \
                0 { No context values \n }, \
                \* { "Context values: \n" } \
                      LOOP $cnt { \
                        {{ $off = X4 }} {{ $len = X4 }} \
                        {{ $bptr = $DATAPOINTER }} \
                        {{ $DATAPOINTER = $bbptr + $off }} \
                        "Context Value: " LOOP $len {A0} "\n" \
                        {{ $DATAPOINTER = $bptr }} \
                      } \
                "\n"}, \
        33 { "CLASSIFY_CORR_EXIT\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "classify_corr_off: " X4 "\n" \
                "classify_corr_len: " {{ $cclen = X4 }} $cclen "\n" \
                "tran_class_id: " D8 "\n" \
                "rc: " D4 "\n" \
                "classify_correlator: " LOOP $cclen {X0} "\n" \
                "\n"}, \
        34 { "REG_APP_ADAP\n" \
                 $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "app_name_off: " X4 "\n" \
                "app_name_len: " {{ $alen = X4 }} $alen "\n" \
                "assigned_app_id: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "app_name: " LOOP $alen {A0} "\n" \
                "\n"}, \
        35 { "DESTROY_APP_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        36 { "START_APP_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "app_handle: " X8 "\n" \
                "grp_name_off: " X4 "\n" \
                "grp_name_len: " {{ $glen = X4 }} $glen "\n" \
                "instance_off: " X4 "\n" \
                "instance_len: " {{ $ilen = X4 }} $ilen "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "rc: " D4 "\n" \
                "group_name: " LOOP $glen {A0} "\n" \
                "instance_name: " LOOP $ilen {A0} "\n" \
                "\n"}, \
        37 { "STOP_APP_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "rc: " D4 "\n" \
                "\n"}, \
        38 { "REG_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "in_tran_id: " X8 "\n" \
                "app_id: " X8 "\n" \
                "tran_name_off: " X4 "\n" \
                "tran_name_len: "{{ $tlen = X4 }} $tlen "\n" \
                "assigned_tran_id: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "tran_name: " LOOP $tlen {A0} "\n" \
                "\n"}, \
        39 { "START_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "tran_id: " X8 "\n" \
                "parent_corr_off: " X4 "\n" \
                "parent_corr_len: " {{ $pclen = X4 }} $pclen "\n" \
                "parent_corr_suff_off: " X2 "\n" \
                "tran_class_id: " D2 "\n" \
                "assigned_tran_handle: " O4 X8 "\n" \
                "tran_start_time: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "out_adap_flags: " X4 "\n" \
                "adap_corr_suff_len: " {{ $cslen = X1}} $cslen "\n" \
                "hop_count: " D1 "\n" \
                "adap_corr_suff_off: " X2 "\n" \
                "adaprc: " D4 "\n" \
                "paren_correlator: " LOOP $pclen {X0} "\n" \
                "correlator_suffix: " LOOP $cslen {X0} "\n" \
                "\n"}, \
        40 { "STOP_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "input_tran_handle: " X8 "\n" \
                "tran_stop_time: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "tran_status: " D4 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        41 { "BLOCK_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "tran_block_handle: " X8 "\n" \
                "block_start_time: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        42 { "UNBLOCK_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "block_tran_handle: " X8 "\n" \
                "block_stop_time: " D8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        43 { "UPDATE_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        44 { "DISCARD_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        45 { "BIND_THREAD_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        46 { "UNBIND_THREAD_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "tran_handle: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "\n"}, \
        47 { "GEN_CORR_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "tran_id: " X8 "\n" \
                "parent_corr_off: " X4 "\n" \
                "parent_corr_len: " {{ $pclen = X4 }} $pclen "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "adap_out_flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "parent_corr_suffix_off: " X2 "\n" \
                "adap_corr_suff_off: " X2 "\n" \
                "adap_corr_suff_len: " {{ $cslen = X1 }} $cslen "\n" \
                "parent_correlator: " LOOP $pclen {X0} "\n" \
                "correlator_suffix: " LOOP $cslen {X0} "\n" \
                "\n"}, \
        48 { "REPORT_TRAN_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_handle: " X8 "\n" \
                "tran_id: " X8 "\n" \
                "response_time: " D8 "\n" \
                "stop_time: " D8 "\n" \
                "parent_corr_off: " X4 "\n" \
                "parent_corr_len: " {{ $pclen = X4 }} $pclen "\n" \
                "current_corr_off: " X4 "\n" \
                "current_corr_len: " {{ $cclen = X4 }} $cclen "\n" \
                "curr_corr_suff_off: " X2 "\n" \
                "parent_corr_suff_off: " X2 O4 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "flags: " X4 "\n" \
                "tran_status: " D4 "\n" \
                "adaprc: " D4 "\n" \
                "parent_correlator: " LOOP $pclen {X0} "\n" \
                "current_correlator: " LOOP $cclen {X0} "\n" \
                "\n"}, \
        49 { "REG_METRIC_ADAP\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "app_id: " X8 "\n" \
                "metric_name_off: " X4 "\n" \
                "metric_name_len: " {{ $mnlen = X4 }} $mnlen "\n" \
                "metric_unit_off: " X4 "\n" \
                "metric_unit_len: " {{ $mulen = X4 }} $mulen "\n" \
                "input_metric_id: " X8 "\n" \
                "buff4Addr: 0x"X8 "\n" \
                "output_metric_id: " X8 "\n" \
                "flags: " X4 "\n" \
                "adaprc: " D4 "\n" \
                "metric_usage: " D2 "\n" \
                "metric_format: " D1 "\n" \
                "mertic_name: " LOOP $mnlen {A0} "\n" \
                "metric_unit: " LOOP $mulen {A0} "\n" \
                "\n"}, \
        50 { "INTERNAL_BLOCKED_TIME"\n \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "blocked_interval_time: " D8 "\n" \
                "\n"}, \
        51 { "INTERNAL_DISCARDED_TRAN\n" \
                $HOOKENV, \
                32 { O4 }, \
                64 { O8 } \
                "discarded_transactions: " D4 "\n" \
                "\n"}
632 1.0 "@DIAG_ASYNC_PCI" \
        "HD="$HD " arg1="$D1 "arg2=" $D2 "arg3=" $D3
634 1.0 "@VMSVC_MOUNT" \
	$HD, \
	0x00 { `VMSVC SETDEVID:	caller=$D1, sid=$D2, type=$D3, devid=$D4, flags=$D5` }, \
	0x01 { `VMSVC SETDEVID Err: rc=$D1` }, \
	0x02 { `VMSVC UMOUNTX:	caller=$D1, type=$D2, devid=$D3, bpp=$D4, d_pdtx=$D5` }, \
	0x03 { `VMSVC UMOUNTX Err: rc=$D1` }, \
	0x04 { `VMSVC MOUNTX:	caller=$D1, type=$D2, devid=$D3, nbufstr=$D4, inputptr=$D5` }, \
	0x05 { `VMSVC MOUNTX Err: rc=$D1` }
63C 1.0 "VPM " \
    $HD, \
    0x1 {`rsnm_mkxrset:    cpu=$D1, gpp=$D2`},\
    0x2 {`rsnm_rmxrset:    cpu=$D1, gpp=$D2`},\
    0x3 {`vpm_fold_cpu:    cpu=$D1, gpp=$D2`},\
    0x4 {`vpm_unfold_cpu:  cpu=$D1, gpp=$D2`},\
    0x5 {`mrq_online_cpu:  cpu=$D1, gpcpus=$D2, gpcores=$D3`},\
    0x6 {`mrq_offline_cpu: cpu=$D1, gpcpus=$D2, gpcores=$D3`},\
    0x7 {`Folding disabled`},\
    0x8 {`timer: cpu=$D1, func=$D3%XW, sec=$D4%DW, nsec=$D5%DW`},\
    0x9 {`sleep: cpu=$D1`},\
    0xA {`wake:  cpu=$D1, state=$D2`},\
    0xB {`prod:  cpu=$D1`},\
    0xC {`ready: cpu=$D1, pcpu=$D2, sec=$D3%DW, nsec=$D4%DW`},\
    0xE {`vpm_get_latencies: pal not initialized`},\
    0xF {`vpm_get_latencies: pal rc=$D1`},\
    0x10 {`cede latency: specifier=$D1, latency=$D2%DW, masks=$D3`},\
    0x13 {`sched timer: srad=$D1, old_cpu=$D2, new_cpu=$D3`},\
    0x50 {`H_BEST_ENERGY: drc_index=$D2, pri=$D1`},\
    0x51 {`H_BEST_ENERGY: eflags=$D1%XW`},\
    0x52 {`H_BEST_ENERGY: rc=$D1`},\
    0x53 {`Intelligent folding not supported on this platform`},\
    0x100 {`get_state: gather begin`},\
    0x101 {`get_state: gather complete`},\
    0x102 {`get_state: interval=$D1%DW ns`},\
    0x103 {`    interrupt=$D1%DW ns`},\
    0x104 {`    sradid=$D1%DW util=$D2%DW ns last=$D3%DW cores=$D4%DW`},\
    0x105 {`    high check: $D1%DW > $D2%DW ns`},\
    0x106 {`High workload, skipping evaluation phase`},\
    0x110 {`flatten: util=$D1%DW, last=$D2%DW, cores=$D3%DW`},\
    0x120 {"eval:" G9 bid=D1 G8 type=D1 `util=$D2%DW cores=$D4%DW last=$D3%DW active=$D5%DW`},\
    0x121 {`    adjusted util=$D1%DW`},\
    0x122 {`    need=$D1%DW active=$D2%DW gp=$D3%DW, rc=$D4%DW`},\
    0x123 {`    remainder=$D1%DW cap=$D2%DW pri=$D3%DW`},\
    0x130 {`    raw need=$D1%DW cores`},\
    0x131 {`    capped need=$D1%DW cores`},\
    0x132 {`aggregate: bid=$D1%DW`},\
    0x133 {"    " G9 bid=D1 G8 type=D1 `util=$D2%DW, last=$D3%DW, cores=$D4%DW, active=$D5%DW`},\
    0x140 {`    coreid=$D1%DW, pri=$D2%DW, be=$D3%DW, cycle=$D4%DW`},\
    \* {`Unknown subhook $HD`}
64C 1.0 'RBAC' \
        $HD%D1, \
	25   { `hkwd_rbac_get_secflags_var1: cid=$D1%XW` }, 					\
	26   { `hkwd_rbac_get_secflags_ret1: rc=$D1%XW` }, 					\
	27   { `hkwd_rbac_get_secflags_ret2: secflag=$D1%XW` }, 				\
	28   { `hkwd_rbac_wpar_run_mode_var1: cid=$D1%XW` }, 					\
	29   { `hkwd_rbac_wpar_run_mode_ret: mode=$D1%XW` }, 					\
	30   { `hkwd_rbac_getkst4cid_var1: kst=$D1%XW cid=$D2%XW` }, 				\
	31   { `hkwd_rbac_wpar_config_kst_in: flags=$D1%XW cid=$D2%XW corralp=$D3%XW unused=$D4%XW` },							\
	32   { `hkwd_rbac_wpar_config_kst_ret1: rc=$D1%XW` }, 					\
	33   { `hkwd_rbac_wpar_config_kst_ret2: rc=$D1%XW` }, 					\
	34   { `hkwd_rbac_getkstcid_in: cid=$D1%XW` }, 						\
	35   { `hkwd_rbac_getkstcid_ret1: rc=$D1%XW` }, 					\
	36   { `hkwd_rbac_getkstcid_var1: i=$D1%XW` }, 						\
	37   { `hkwd_rbac_getkstcid_ret2: rc=$D1%XW` }, 					\
	38   { `hkwd_rbac_unlockkstcid_in: cid=$D1%XW` }, 					\
	101   { `hkwd_rbac_sort_auths_by_id_in: auths=$D1%XW nauths=$D2%XW` }, 			\
	102   { `hkwd_rbac_sort_auths_by_id_ret1: rc=$D1%XW` }, 				\
	103   { `hkwd_rbac_sort_auths_by_name_in: auths=$D1%XW nauths=$D2%XW` }, 		\
	104   { `hkwd_rbac_sort_auths_by_name_ret1: rc=$D1%XW` }, 				\
	105   { `hkwd_rbac_getauth4num_in: auths=$D1%XW nauths=$D2%XW authnum=$D3%XW` }, 	\
	106   { `hkwd_rbac_getauth4name_in: nauths=$D1%XW authname=$D2%XW` }, 			\
	107   { `hkwd_rbac_get_auth_k_size_in: authp=$D1%XW nauth=$D2%XW` }, 			\
	108   { `hkwd_rbac_get_auth_k_size_ret: buf_siz=$D1%XW` }, 				\
	109   { `hkwd_rbac_convert_2_auth_k_in: authp=$D1%XW auth_kp=$D2%XW nauth=$D3%XW` }, 	\
	110   { `hkwd_rbac_convert_2_auth_k_ret: rc=$D1%XW` }, 					\
	111   { `hkwd_rbac_get_usr_kat_ptrs_ret1: rc=$D1%XW` }, 				\
	112   { `hkwd_rbac_get_usr_kat_ptrs_ret2: rc=$D1%XW` }, 				\
	113   { `hkwd_rbac_get_auth_k_4_name_in: auth_k_p=$D1%XW u_authname=$D2%XW` }, 		\
	114   { `hkwd_rbac_get_auth_k_4_name_ret1: rc=$D1%XW` }, 				\
	115   { `hkwd_rbac_get_auth_k_4_name_ret2: rc=$D1%XW` }, 				\
	116   { `hkwd_rbac_get_auth_k_4_name_ret3: rc=$D1%XW` }, 				\
	117   { `hkwd_rbac_get_auth_k_4_num_in: auth_k_p=$D1%XW authnum=$D2%XW` }, 		\
	118   { `hkwd_rbac_get_auth_k_4_num_ret1: rc=$D1%XW` }, 				\
	119   { `hkwd_rbac_get_auth_k_4_num_ret2: rc=$D1%XW` }, 				\
	120   { `hkwd_rbac_get_auth_k_4_num_ret3: rc=$D1%XW` }, 				\
	121   { `hkwd_rbac_get_proc_rids_in: crp=$D1%XW rid=$D2%XW` }, 				\
	122   { `hkwd_rbac_add_chkauth_in: crp=$D1%XW aid=$D2%XW` }, 				\
	123   { `hkwd_rbac___checkauth_in: authname=$D1%XW` }, 					\
	124   { `hkwd_rbac__checkauth_ret1: rc=$D1%XW` }, 					\
	125   { `hkwd_rbac__checkauth_ret2: rc=$D1%XW` }, 					\
	126   { `hkwd_rbac__checkauth_ret3: rc=$D1%XW` }, 					\
	127   { `hkwd_rbac__checkauth_ret4: rc=$D1%XW` }, 					\
	128   { `hkwd_rbac_get_auths_k_in: auth_k=$D1%XW for_AAS=$D2%XW` }, 			\
	129   { `hkwd_rbac_get_auths_k_ret1: rc=$D1%XW` }, 					\
	130   { `hkwd_rbac_get_auths_k_ret2: rc=$D1%XW` }, 					\
	131   { `hkwd_rbac_get_auths_k_ret3: found=$D1%XW` }, 					\
	132   { `hkwd_rbac__check_auths_any_in: authid=$D1%XW` }, 				\
	133   { `hkwd_rbac__check_auths_any_ret1: rc=$D1%XW` }, 				\
	134   { `hkwd_rbac__check_auths_any_ret2: rc=$D1%XW` }, 				\
	135   { `hkwd_rbac__check_auths_bitmap_in: authid=$D1%XW` }, 				\
	136   { `hkwd_rbac__check_auths_bitmap_ret4: bitmap=$D1%XW` }, 				\
	137   { `hkwd_rbac__checkauthid_in: authid=$D1%XW` }, 					\
	138   { `hkwd_rbac__checkauthid_ret1: rc=$D1%XW` }, 					\
	139   { `hkwd_rbac__checkauthid_ret2: rc=$D1%XW` }, 					\
	140   { `hkwd_rbac__checkauthid_ret3: rc=$D1%XW` }, 					\
	141   { `hkwd_rbac__checkauthid_ret4: rc=$D1%XW` }, 					\
	142   { `hkwd_rbac__checkauthid_ret5: rc=$D1%XW` }, 					\
	143   { `hkwd_rbac_free_a_kat_in: katp=$D1%XW` }, 					\
	144   { `hkwd_rbac_find_auth_in_array_in: authid=$D1%XW auths=$D2%XW nauths=$D3%XW` }, 	\
	145   { `hkwd_rbac_find_auth_in_array_ret: found=$D1%XW` }, 				\
	146   { `hkwd_rbac_setkat_in: authp=$D1%XW nauth=$D2%XW` }, 				\
	147   { `hkwd_rbac_setkat_ret1: rc=$D1%XW` }, 						\
	148   { `hkwd_rbac_setkat_ret2: rc=$D1%XW` }, 						\
	149   { `hkwd_rbac_setkat_ret3: rc=$D1%XW` }, 						\
	150   { `hkwd_rbac_setkat_ret4: rc=$D1%XW` }, 						\
	151   { `hkwd_rbac_setkat_ret5: rc=$D1%XW` }, 						\
	152   { `hkwd_rbac_setkat_ret6: rc=$D1%XW` }, 						\
	153   { `hkwd_rbac_getauthname4num_in: authnum=$D1%XW authname=$D2%XW` }, 		\
	154   { `hkwd_rbac_getauthname4num_ret: rc=$D1%XW` }, 					\
	155   { `hkwd_rbac_sec_setkat_in: authp=$D1%XW auth=$D2%XW` }, 				\
	156   { `hkwd_rbac_sec_setkat_ret1: rc=$D1%XW` }, 					\
	157   { `hkwd_rbac_sec_setkat_ret2: rc=$D1%XW` }, 					\
	158   { `hkwd_rbac_sec_setkat_ret3: rc=$D1%XW` }, 					\
	159   { `hkwd_rbac_sec_setkat_ret4: rc=$D1%XW` }, 					\
	160   { `hkwd_rbac_sec_setkat_ret5: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	161   { `hkwd_rbac_sec_getkat_in: authp=$D1%XW siz=$D2%XW` }, 				\
	162   { `hkwd_rbac_sec_getkat_ret1: rc=$D1%XW` }, 					\
	163   { `hkwd_rbac_sec_getkat_ret2: rc=$D1%XW` }, 					\
	164   { `hkwd_rbac_sec_getkat_ret3: rc=$D1%XW` }, 					\
	165   { `hkwd_rbac_sec_getkat_ret4: rc=$D1%XW` }, 					\
	166   { `hkwd_rbac_sec_getkat_ret5: rc=$D1%XW` }, 					\
	167   { `hkwd_rbac_sec_getkat_ret6: rc=$D1%XW` }, 					\
	168   { `hkwd_rbac_sec_getkat_ret7: rc=$D1%XW` }, 					\
	169   { `hkwd_rbac_sec_getkat_ret8: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	170   { `hkwd_rbac_sec_sec_getuserkat_in: authp=$D1%XW siz=$D2%XW` }, 			\
	171   { `hkwd_rbac_sec_sec_getuserkat_ret1: rc=$D1%XW` }, 				\
	172   { `hkwd_rbac_sec_sec_getuserkat_ret2: rc=$D1%XW` }, 				\
	173   { `hkwd_rbac_sec_sec_getuserkat_ret3: rc=$D1%XW` }, 				\
	174   { `hkwd_rbac_sec_sec_getuserkat_ret4: rc=$D1%XW` }, 				\
	175   { `hkwd_rbac_sec_sec_getuserkat_ret5: rc=$D1%XW` }, 				\
	176   { `hkwd_rbac_sec_sec_getuserkat_var1: i=$D1%XW` }, 				\
	177   { `hkwd_rbac_sec_sec_getuserkat_ret6: rc=$D1%XW` }, 				\
	178   { `hkwd_rbac_sec_sec_getuserkat_ret7: rc=$D1%XW` }, 				\
	179   { `hkwd_rbac_sec_sec_getuserkat_ret8: u.u_error=$D1%XW rc=$D2%XW` }, 		\
	180   { `hkwd_rbac_sec_authidtoname_in: authnum=$D1%XW u_authname=$D2%XW` }, 		\
	181   { `hkwd_rbac_sec_authidtoname_ret1: rc=$D1%XW` }, 				\
	182   { `hkwd_rbac_sec_authidtoname_ret2: rc=$D1%XW` }, 				\
	183   { `hkwd_rbac_sec_authidtoname_ret3: rc=$D1%XW` }, 				\
	184   { `hkwd_rbac_sec_authidtoname_ret4: rc=$D1%XW` }, 				\
	185   { `hkwd_rbac_sec_authidtoname_ret5: rc=$D1%XW` }, 				\
	186   { `hkwd_rbac_sec_authidtoname_ret6: rc=$D1%XW` }, 				\
	187   { `hkwd_rbac_sec_authidtoname_ret7: rc=$D1%XW` }, 				\
	188   { `hkwd_rbac_sec_authidtoname_ret8: rc=$D1%XW` }, 				\
	189   { `hkwd_rbac_sec_authidtoname_ret9: rc=$D1%XW` }, 				\
	190   { `hkwd_rbac_sec_authidtoname_ret11: rc=$D1%XW` }, 				\
	191   { `hkwd_rbac_sec_authidtoname_ret12: u.u_error=$D1%XW rc=$D2%XW` }, 		\
	192   { `hkwd_rbac_sec_authnametoid_in: u_authname=$D1%XW u_authnum=$D2%XW` }, 		\
	193   { `hkwd_rbac_sec_authnametoid_ret1: rc=$D1%XW` }, 				\
	194   { `hkwd_rbac_sec_authnametoid_ret2: rc=$D1%XW` }, 				\
	195   { `hkwd_rbac_sec_authnametoid_ret3: rc=$D1%XW` }, 				\
	196   { `hkwd_rbac_sec_authnametoid_ret4: rc=$D1%XW` }, 				\
	197   { `hkwd_rbac_sec_authnametoid_ret5: rc=$D1%XW` }, 				\
	198   { `hkwd_rbac_sec_authnametoid_ret6: rc=$D1%XW` }, 				\
	199   { `hkwd_rbac_sec_authnametoid_ret7: rc=$D1%XW` }, 				\
	200   { `hkwd_rbac_sec_authnametoid_ret8: rc=$D1%XW` }, 				\
	201   { `hkwd_rbac_sec_authnametoid_ret9: u.u_error=$D1%XW rc=$D2%XW` }, 		\
	202   { `hkwd_rbac_sec_checkauth_in: authname=$D1%XW` }, 				\
	203   { `hkwd_rbacsec_checkauth_ret1: rc=$D1%XW` }, 					\
	204   { `hkwd_rbacsec_checkauth_ret2: rc=$D1%XW` }, 					\
	205   { `hkwd_rbacsec_checkauth_ret3: rc=$D1%XW` }, 					\
	206   { `hkwd_rbacsec_checkauth_ret4: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	207   { `hkwd_rbac_sec_checkauthid_in: authid=$D1%XW` }, 				\
	208   { `hkwd_rbac_sec_checkauthid_ret1: rc=$D1%XW` }, 					\
	209   { `hkwd_rbac_sec_checkauthid_ret2: u.u_error=$D1%XW rc=$D2%XW` }, 		\
	210   { `hkwd_rbac_sec_getkatids_in: authp=$D1%XW siz=$D2%XW` }, 			\
	211   { `hkwd_rbac_sec_getkatids_ret1: rc=$D1%XW` }, 					\
	212   { `hkwd_rbac_sec_getkatids_ret2: rc=$D1%XW` }, 					\
	213   { `hkwd_rbac_sec_getkatids_ret3: rc=$D1%XW` }, 					\
	214   { `hkwd_rbac_sec_getkatids_ret4: rc=$D1%XW` }, 					\
	215   { `hkwd_rbac_sec_getkatids_ret5: rc=$D1%XW` }, 					\
	216   { `hkwd_rbac_sec_getkatids_var1: katp->nauths=$D1%XW` }, 				\
	217   { `hkwd_rbac_sec_getkatids_ret6: rc=$D1%XW` }, 					\
	218   { `hkwd_rbac_sec_getkatids_ret7: rc=$D1%XW` }, 					\
	219   { `hkwd_rbac_sec_getkatids_ret8: u.u_error=$D1%XW rc=$D2%XW` },			\
	220   { `hkwd_rbac_init_sys_KAT_ret1: rc=$D1%XW` }, 					\
	221   { `hkwd_rbac_init_sys_KAT_ret2: rc=$D1%XW` }, 					\
	222   { `hkwd_rbac_is_sys_KAT_id_in: authid=$D1%XW` }, 					\
	223   { `hkwd_rbac_init_sys_KAT_id_ret: rc=$D1%XW` }, 					\
	224   { `hkwd_rbac_sec_getauths_in: pid=$D1%XW` }, 					\
	225   { `hkwd_rbac_sec_getauths_ret1: u.u_error=$D1%XW` }, 				\
	226   { `hkwd_rbac_sec_getauths_ret2: u.u_error=$D1%XW` }, 				\
	227   { `hkwd_rbac_sec_getauths_ret3: u.u_error=$D1%XW` }, 				\
	228   { `hkwd_rbac_sec_getauths_ret4: error=$D1%XW` }, 					\
	229   { `hkwd_rbac_sec_getauths_ret5: error=$D1%XW` }, 					\
	230   { `hkwd_rbac_sec_getauths_ret6: rc=$D1%XW` }, 					\
	300   { `hkwd_rbac_setkpcdt_in1: id=$D1%XW u_path_list=$D2%XW u_rule_list=$D3%XW u_num_entries=$D4%XW u_max_path_len=$D5%XW` },			\
	301   { `hkwd_rbac_setkpcdt_in2: flags=$D1%XW` }, 					\
	302   { `hkwd_rbac_setkpcdt_ret1: rc=$D1%XW` }, 					\
	303   { `hkwd_rbac_setkpcdt_ret2: rc=$D1%XW` }, 					\
	304   { `hkwd_rbac_setkpcdt_var1: myKey=$D1%XW` }, 					\
	305   { `hkwd_rbac_setkpcdt_ret3: rc=$D1%XW` }, 					\
	306   { `hkwd_rbac_getkpct_in: path_list_buf=$D1%XW rule_list_buf=$D2%XW num_entries=$D3%XW max_path_len=$D4%XW flags=$D5%XW` },	 	\
	307   { `hkwd_rbac_getkpct_var1: myKey=$D1%XW` }, 					\
	308   { `hkwd_rbac_getkpct_var2: myId=$D1%XW` }, 					\
	309   { `hkwd_rbac_getkpct_ret: rc=$D1%XW` }, 						\
	310   { `hkwd_rbac_find_rbac_rule_in: path_name=$D1%XW flags=$D2%XW` }, 		\
	311   { `hkwd_rbac_find_rbac_rule_var1: myKey=$D1%XW` }, 				\
	312   { `hkwd_rbac_find_rbac_rule_var2: myId=$D1%XW` }, 				\
	313   { `hkwd_rbac_find_rbac_rule_ret1: rc=$D1%XW` }, 					\
	314   { `hkwd_rbac_sec_getkpct_in: u_path_list_buf=$D1%XW u_rule_list_buf=$D2%XW u_num_entries=$D3%XW u_max_path_len=$D4%XW` },	 		\
	315   { `hkwd_rbac_sec_getkpct_ret1: rc=$D1%XW` }, 					\
	316   { `hkwd_rbac_sec_getkpct_ret: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	317   { `hkwd_rbac_sec_getkpdt_in: u_path_list_buf=$D1%XW u_rule_list_buf=$D2%XW u_num_entries=$D3%XW u_max_path_len=$D4%XW` },	 		\
	318   { `hkwd_rbac_sec_getkpdt_ret1: rc=$D1%XW` }, 					\
	319   { `hkwd_rbac_sec_getkpdt_ret: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	320   { `hkwd_rbac_sec_getcmdattrs_in: u_path=$D1%XW u_rule_buf=$D2%XW` }, 		\
	321   { `hkwd_rbac_sec_getcmdattrs_ret1: rc=$D1%XW` }, 					\
	322   { `hkwd_rbac_sec_getcmdattrs_ret2: u.u_error=$D1%XW rc=$D2%XW` },			\
	323   { `hkwd_rbac_sec_getdevattrs_in: u_path=$D1%XW u_rule_buf=$D2%XW` }, 		\
	324   { `hkwd_rbac_sec_getdevattrs_ret1: rc=$D1%XW` }, 					\
	325   { `hkwd_rbac_sec_getdevattrs_ret2: u.u_error=$D1%XW rc=$D2%XW` },			\
	326   { `hkwd_rbac_sec_setwpscid_in: cid=$D1%XW wps=$D2%XW` }, 				\
	327   { `hkwd_rbac_sec_setwpscid_ret1: rc=$D1%XW` }, 					\
	328   { `hkwd_rbac_sec_setwpscid_ret2: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	329   { `hkwd_rbac_getwpscid_in: cid=$D1%XW wps=$D2%XW` }, 				\
	330   { `hkwd_rbac_getwpscid_ret1: rc=$D1%XW` }, 					\
	331   { `hkwd_rbac_getwpscid_ret2: rc=$D1%XW` }, 					\
	332   { `hkwd_rbac_free_a_wps_in: wps=$D1%XW` }, 					\
	333   { `hkwd_rbac_sec_getsysprivs_in: wps=$D1%XW` }, 					\
	334   { `hkwd_rbac_sec_getsysprivs_var1: cid=$D1%XW` }, 				\
	335   { `hkwd_rbac_sec_getsysprivs_ret: rc=$D1%XW` }, 					\
	400   { `hkwd_rbac_sec_setkst_in: u_setkstp=$D1%XW u_siz=$D2%XW u_status=$D3%XW` }, 	\
	401   { `hkwd_rbac_sec_setkst_ret1: rc=$D1%XW` }, 					\
	402   { `hkwd_rbac_sec_setkst_ret2: rc=$D1%XW` }, 					\
	403   { `hkwd_rbac_sec_setkst_ret3: rc=$D1%XW` }, 					\
	404   { `hkwd_rbac_sec_setkst_ret4: rc=$D1%XW` }, 					\
	405   { `hkwd_rbac_sec_setkst_var1: setkstp->auth.flags=$D1%XW` }, 			\
	406   { `hkwd_rbac_sec_setkst_ret5: status=$D1%XW rc=$D2%XW` }, 			\
	407   { `hkwd_rbac_sec_setkst_var2: setkstp->role.flags=$D1%XW` }, 			\
	408   { `hkwd_rbac_sec_setkst_ret6: status=$D1%XW rc=$D2%XW` }, 			\
	409   { `hkwd_rbac_sec_setkst_var3: setkstp->pcmd.flags=$D1%XW` }, 			\
	410   { `hkwd_rbac_sec_setkst_ret7: status=$D1%XW rc=$D2%XW` }, 			\
	411   { `hkwd_rbac_sec_setkst_var4: setkstp->pdev.flags=$D1%XW` }, 			\
	412   { `hkwd_rbac_sec_setkst_ret8: status=$D1%XW rc=$D2%XW` }, 			\
	413   { `hkwd_rbac_sec_setkst_ret9: rc=$D1%XW` }, 					\
	414   { `hkwd_rbac_sec_setkst_var5: myKey=$D1%XW` }, 					\
	415   { `hkwd_rbac_sec_setkst_ret10: rc1=$D1%XW` }, 					\
	416   { `hkwd_rbac_sec_setkst_ret11: rc1=$D1%XW` }, 					\
	417   { `hkwd_rbac_sec_setkst_ret12: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	500   { `hkwd_rbac_set_kprt_in1: key=$D1%XW kprt_id=$D2%XW num_entries=$D3%XW max_path_sz=$D4%XW` },					 	\
	501   { `hkwd_rbac_set_kprt_in2: path_list=$D1%XW rule_sz=$D2%XW vp_rootdir=$D3%XW find_rule_method=$D4%XW` },				 	\
	502   { `hkwd_rbac_set_kprt_ret1: rc=$D1%XW` }, 					\
	503   { `hkwd_rbac_set_kprt_ret2: rc=$D1%XW` }, 					\
	504   { `hkwd_rbac_set_kprt_ret3: rc=$D1%XW` }, 					\
	505   { `hkwd_rbac_set_kprt_ret4: rc=$D1%XW` }, 					\
	506   { `hkwd_rbac_set_kprt_ret5: rc=$D1%XW` }, 					\
	507   { `hkwd_rbac_set_kprt_ret6: rc=$D1%XW` }, 					\
	508   { `hkwd_rbac_set_kprt_ret7: rc=$D1%XW` }, 					\
	509   { `hkwd_rbac_set_kprt_ret8: rc=$D1%XW` }, 					\
	510   { `hkwd_rbac_set_kprt_var1: kprtId=$D1%XW bktIndex=$D2%XW` }, 			\
	511   { `hkwd_rbac_set_kprt_var2: kprtId=$D1%XW NUM_KPRTS=$D2%XW` }, 			\
	512   { `hkwd_rbac_set_kprt_ret9: rc=$D1%XW` }, 					\
	513   { `hkwd_rbac_set_kprt_ret10: rc=$D1%XW` }, 					\
	514   { `hkwd_rbac_create_kprt_htbl_var1: h_kprtp=$D1%XW` }, 			  	\
	515   { `hkwd_rbac_create_kprt_htbl_ret : rc=$D1%XW` }, 				\
	516   { `hkwd_rbac_populate_base_htbl_in: num_entries=$D1%XW max_path_sz=$D2%XW path_list=$D3%XW hash_index_mask=$D4%XW`},			\
	517   { `hkwd_rbac_populate_base_htbl_ret1: rc=$D1%XW` }, 				\
	518   { `hkwd_rbac_populate_base_htbl_ret2: rc=$D1%XW` }, 				\
	519   { `hkwd_rbac_populate_base_htbl_ret3: rc=$D1%XW` }, 				\
	520   { `hkwd_rbac_populate_base_htbl_var1: basename=$D1%XW` }, 			\
	521   { `hkwd_rbac_populate_base_htbl_ret4: rc=$D1%XW` }, 				\
	522   { `hkwd_rbac_rk_hash_in: name=$D1%XW` }, 						\
	523   { `hkwd_rbac_rk_hash_ret: hash=$D1%XW` }, 					\
	524   { `hkwd_rbac_populate_fid_htbl_in: num_entries=$D1%XW max_path_sz=$D2%XW path_list=$D3%XW vp_rootdir=$D4%XW` }, 				\
	525   { `hkwd_rbac_populate_fid_htbl_ret1: rc=$D1%XW` }, 				\
	526   { `hkwd_rbac_populate_fid_htbl_ret2: rc=$D1%XW` }, 				\
	527   { `hkwd_rbac_populate_fid_htbl_var1: index=$D1%XW fidBkt=$D2%XW` }, 		\
	528   { `hkwd_rbac_populate_fid_htbl_ret3: rc=$D1%XW` }, 				\
	529   { `hkwd_rbac_insert_fid_node_in: fid_bkt=$D1%XW fid_list=$D2%XW path_id=$D3%XW objInfo=$D4%XW` }, 					\
	530   { `hkwd_rbac_delete_fid_node_in: fid_bkt=$D1%XW path_id=$D2%XW` }, 		\
	531   { `hkwd_rbac_update_fid_node_in: kprt=$D1%XW rule_id=$D2%XW objInfo=$D3%XW` }, 	\
	532   { `hkwd_rbac_update_fid_node_ret1: rc=$D1%XW` }, 					\
	533   { `hkwd_rbac_update_fid_node_ret2: rc=$D1%XW` }, 					\
	534   { `hkwd_rbac_free_a_kprt_in: key=$D1%XW kprt_id=$D2%XW` }, 			\
	535   { `hkwd_rbac_free_a_kprt_ret1: rc=$D1%XW` }, 					\
	536   { `hkwd_rbac_free_a_kprt_ret2: rc=$D1%XW` }, 					\
	537   { `hkwd_rbac_free_a_kprt_var1: bktIndex=$D1%XW` }, 				\
	538   { `hkwd_rbac_free_a_kprt_var2: nKprt=$D1%XW` }, 					\
	539   { `hkwd_rbac_free_a_kprt_var3: kprt_id=$D1%XW NUM_KPRTS=$D2%XW` }, 		\
	540   { `hkwd_rbac_free_a_kprt_ret3: rc=$D1%XW` }, 					\
	541   { `hkwd_rbac_get_kprt_in: key=$D1%XW kprt_id=$D2%XW num_entries=$D3%XW max_path_sz=$D4%XW rule_sz=$D5%XW` },				\
	542   { `hkwd_rbac_get_kprt_ret1: rc=$D1%XW` }, 					\
	543   { `hkwd_rbac_get_kprt_ret2: rc=$D1%XW` }, 					\
	544   { `hkwd_rbac_get_kprt_var1: bktIndex=$D1%XW nKprt=$D2%XW curKprt=$D3%XW` }, 	\
	545   { `hkwd_rbac_get_kprt_var2: kprt_id=$D1%XW NUM_KPRTS=$D2%XW` }, 			\
	546   { `hkwd_rbac_get_kprt_var3: num_entries=$D1%XW max_path_sz=$D2%XW rule_sz=$D3%XW` },					 		\
	547   { `hkwd_rbac_get_kprt_ret3: rc=$D1%XW` }, 												\
	548   { `hkwd_rbac_find_kprt_rule_in1: key=$D1%XW kprt_id=$D2%XW path_name=$D3%XW rule_sz=$D4%XW` }, 						\
	549   { `hkwd_rbac_find_kprt_rule_ret1: rc=$D1%XW` }, 					\
	550   { `hkwd_rbac_find_kprt_rule_ret2: rc=$D1%XW` }, 					\
	551   { `hkwd_rbac_find_kprt_rule_var1: bktIndex=$D1%XW nKprt=$D2%XW curKprt=$D3%XW` },	\
	552   { `hkwd_rbac_find_kprt_rule_ret3: rc=$D1%XW` }, 					\
	553   { `hkwd_rbac_find_kprt_rule_var2: curKprt->find_rule_method=$D1%XW` }, 		\
	554   { `hkwd_rbac_find_kprt_rule_ret4: rc=$D1%XW` }, 					\
	555   { `hkwd_rbac_find_kprt_rule_ret5: rc=$D1%XW` }, 					\
	556   { `hkwd_rbac_find_rule_method_basename_in1: kprt=$D1%XW path_name=$D2%XW rule=$D3%XW ruleId=$D4%XW res_path=$D5%XW` },			\
	557   { `hkwd_rbac_find_rule_method_basename_in2: objInfo=$D1%XW dvp=$D2%XW vp=$D3%XW crp=$D4%XW` }, 						\
	558   { `hkwd_rbac_find_rule_method_basename_ret1: rc=$D1%XW` }, 			\
	559   { `hkwd_rbac_find_rule_method_basename_ret2: rc=$D1%XW` }, 			\
	560   { `hkwd_rbac_find_rule_method_basename_var1: path=$D1%XW` }, 			\
	561   { `hkwd_rbac_find_rule_method_basename_ret3: rc=$D1%XW` }, 			\
	562   { `hkwd_rbac_find_rule_method_basename_ret4: rc=$D1%XW` }, 			\
	563   { `hkwd_rbac_find_rule_method_basename_fid_in: kprt=$D1%XW path_name=$D2%XW rule=$D3%XW ruleId=$D4%XW crp=$D5%XW` },		 	\
	564   { `hkwd_rbac_find_rule_method_basename_fid_ret1: rc=$D1%XW` }, 			\
	565   { `hkwd_rbac_find_rule_method_basename_fid_var1: kprt->kprt_id=$D1%XW vat.va_serialno=$D2%XW` },						\
	566   { `hkwd_rbac_find_rule_method_basename_fid_var2: curFidNode->stat=$D1%XW curFidNode->ino=$D2%XW curFidNode->dev=$D3%XW` }, 		\
	567   { `hkwd_rbac_find_rule_method_basename_fid_ret2: rc1=$D1%XW` }, 			\
	568   { `hkwd_rbac_find_rule_method_basename_fid_ret3: rc=$D1%XW` }, 			\
	569   { `hkwd_rbac_resolve_basename_in: path_name=$D1%XW resolved_path=$D2%XW size=$D3%XW crp=$D4%XW` },					\
	570   { `hkwd_rbac_resolve_basename_ret1: rc=$D1%XW` }, 				\
	571   { `hkwd_rbac_resolve_basename_ret2: rc=$D1%XW` }, 				\
	572   { `hkwd_rbac_get_dirname_len_in: path=$D1%XW` }, 					\
	573   { `hkwd_rbac_get_dirname_len_ret: n=$D1%XW` }, 					\
	574   { `hkwd_rbac_compare_vnodes_in: vp_obj=$D1%XW abs_path=$D2%XW vp_rootdir=$D3%XW crp=$D4%XW flag=$D5%XW` }, 				\
	575   { `hkwd_rbac_compare_vnodes_ret1: rc=$D1%XW` }, 					\
	576   { `hkwd_rbac_compare_vnodes_ret2: rc=$D1%XW` }, 					\
	577   { `hkwd_rbac_compare_vnodes_ret3: rc=$D1%XW` }, 					\
	578   { `hkwd_rbac_compare_vnodes_ret4: rc=$D1%XW` }, 					\
	579   { `hkwd_rbac_update_kprt_rule_in: key=$D1%XW kprt_id=$D2%XW path_id=$D3%XW rule_sz=$D4%XW new_rule=$D5%XW` }, 				\
	580   { `hkwd_rbac_update_kprt_rule_ret1: rc=$D1%XW` }, 				\
	581   { `hkwd_rbac_update_kprt_rule_ret2: rc=$D1%XW` }, 				\
	582   { `hkwd_rbac_update_kprt_rule_var1: bktIndex=$D1%XW` }, 				\
	583   { `hkwd_rbac_update_kprt_rule_var2: nKprt=$D1%XW curKprt=$D2%XW` }, 		\
	584   { `hkwd_rbac_update_kprt_rule_var3: curKprt->kprt_id=$D1%XW path_id=$D2%XW` }, 	\
	585   { `hkwd_rbac_update_kprt_rule_ret3: rc=$D1%XW` }, 				\
	700   { `hkwd_rbac_setkrt_in: rolep=$D1%XW buf_siz=$D2%XW` }, 				\
	701   { `hkwd_rbac_setkrt_ret1: rc=$D1%XW` }, 						\
	702   { `hkwd_rbac_setkrt_ret2: rc=$D1%XW` }, 						\
	703   { `hkwd_rbac_setkrt_ret3: rc=$D1%XW` }, 						\
	704   { `hkwd_rbac_setkrt_ret4: rc=$D1%XW` }, 						\
	705   { `hkwd_rbac_setkrt_ret5: rc=$D1%XW` }, 						\
	706   { `hkwd_rbac_setkrt_ret6: rc=$D1%XW` }, 						\
	707   { `hkwd_rbac_setkrt_ret7: rc=$D1%XW` }, 						\
	708   { `hkwd_rbac_setkrt_ret8: rc=$D1%XW` }, 						\
	709   { `hkwd_rbac_sort_roles_by_id_in: roles=$D1%XW nroles=$D2%XW` }, 			\
	710   { `hkwd_rbac_sort_roles_by_id_ret1: rc=$D1%XW` }, 				\
	711   { `hkwd_rbac_sort_roles_by_name_in: roles=$D1%XW nroles=$D2%XW` }, 		\
	712   { `hkwd_rbac_sort_roles_by_name_ret1: rc=$D1%XW` }, 				\
	713   { `hkwd_rbac_getrole4num_in: roles=$D1%XW nroles=$D2%XW rolenum=$D3%XW` }, 	\
	714   { `hkwd_rbac_getrole4name_in: nroles=$D1%XW rolename=$D2%XW` }, 			\
	715   { `hkwd_rbac_get_role_t_size_in: kprt=$D1%XW` }, 					\
	716   { `hkwd_rbac_get_role_t_size_ret: size=$D1%XW` }, 				\
	717   { `hkwd_rbac_get_role_k_t_size_in: rolep=$D1%XW size=$D2%XW nrole=$D3%XW naz=$D4%XW` }, 							\
	718   { `hkwd_rbac_get_role_k_t_size_ret: buf_siz=$D1%XW` }, 				\
	719   { `hkwd_rbac_convert_2_role_k_in: rolep=$D1%XW role_kp=$D2%XW nrole=$D3%XW nauths=$D4%XW` }, 						\
	720   { `hkwd_rbac_convert_2_role_k_ret: rc=$D1%XW` }, 					\
	721   { `hkwd_rbac_get_krt_ptrs_ret: rc=$D1%XW` }, 					\
	722   { `hkwd_rbac_check_auths_in_roles_in: authp=$D1%XW authnum=$D2%XW rolesp=$D3%XW authidx=$D4%XW` },					\
	723   { `hkwd_rbac_check_auths_in_roles_ret1: rc=$D1%XW` }, 				\
	724   { `hkwd_rbac_check_auths_in_roles_ret2: rc=$D1%XW` }, 				\
	725   { `hkwd_rbac_check_auths_in_roles_ret3: rc=$D1%XW` }, 				\
	726   { `hkwd_rbac_check_auth_bitmap_in_roles_in: auth_k_p=$D1%XW rolesp=$D2%XW` }, 	\
	727   { `hkwd_rbac_check_auth_bitmap_in_roles_ret1: rc=$D1%XW` }, 			\
	728   { `hkwd_rbac_check_auth_bitmap_in_roles_ret2: rc=$D1%XW` }, 			\
	729   { `hkwd_rbac_check_auth_bitmap_in_roles_ret3: rc=$D1%XW` }, 			\
	730   { `hkwd_rbac_free_a_krt_in: krtp=$D1%XW` }, 					\
	825   { `hkwd_rbac_sec_setkrt_in: rolep=$D1%XW buf_siz=$D2%XW` }, 			\
	826   { `hkwd_rbac_sec_setkrt_ret1: rc=$D1%XW` }, 					\
	827   { `hkwd_rbac_sec_setkrt_ret2: rc=$D1%XW` }, 					\
	828   { `hkwd_rbac_sec_setkrt_ret3: rc=$D1%XW` }, 					\
	829   { `hkwd_rbac_sec_setkrt_ret4: rc=$D1%XW` }, 					\
	830   { `hkwd_rbac_sec_setkrt_ret5: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	831   { `hkwd_rbac_getkrtroles_common_in: rolep=$D1%XW siz=$D2%XW` }, 			\
	832   { `hkwd_rbac_getkrtroles_common_ret1: rc=$D1%XW` }, 				\
	833   { `hkwd_rbac_getkrtroles_common_ret2: rc=$D1%XW` }, 				\
	834   { `hkwd_rbac_getkrtroles_common_ret3: rc=$D1%XW` }, 				\
	835   { `hkwd_rbac_getkrtroles_common_ret4: rc=$D1%XW` }, 				\
	836   { `hkwd_rbac_getkrtroles_common_ret5: rc=$D1%XW` }, 				\
	837   { `hkwd_rbac_sec_getkrt_in: rolep=$D1%XW siz=$D2%XW` },	 			\
	838   { `hkwd_rbac_sec_getkrt_ret1: rc=$D1%XW` }, 					\
	839   { `hkwd_rbac_sec_getkrt_ret2: rc=$D1%XW` }, 					\
	840   { `hkwd_rbac_sec_getkrt_ret3: rc=$D1%XW` }, 					\
	841   { `hkwd_rbac_sec_getkrt_ret4: u.u_error=$D1%XW rc=$D2%XW` }, 			\
	842   { `hkwd_rbac_sec_getrolebyid_in: rid=$D1%XW rolep=$D2%XW siz=$D3%XW` }, 		\
	843   { `hkwd_rbac_sec_getrolebyid_ret1: rc=$D1%XW` }, 					\
	844   { `hkwd_rbac_sec_getrolebyid_ret2: rc=$D1%XW` }, 					\
	845   { `hkwd_rbac_sec_getrolebyid_ret3: rc=$D1%XW` }, 					\
	846   { `hkwd_rbac_sec_getrolebyid_ret4: rc=$D1%XW` }, 					\
	847   { `hkwd_rbac_sec_getrolebyid_ret5: rc=$D1%XW` }, 					\
	848   { `hkwd_rbac_sec_getrolebyid_ret6: rc=$D1%XW` }, 					\
	849   { `hkwd_rbac_sec_getrolebyid_ret7: u.u_error=$D1%XW rc=$D2%XW` }, 		\
	850   { `hkwd_rbac_sec_getrolebyname_in: rname=$D1%XW rolep=$D2%XW siz=$D3%XW` },	\
	851   { `hkwd_rbac_sec_getrolebyname_ret1: rc=$D1%XW` }, 				\
	852   { `hkwd_rbac_sec_getrolebyname_ret2: rc=$D1%XW` }, 				\
	853   { `hkwd_rbac_sec_getrolebyname_ret3: rc=$D1%XW` }, 				\
	854   { `hkwd_rbac_sec_getrolebyname_ret4: rc=$D1%XW` }, 				\
	855   { `hkwd_rbac_sec_getrolebyname_ret5: u.u_error=$D1%XW rc=$D2%XW` }, 		\
	856   { `hkwd_rbac_sec_roleidtoname_in: rid=$D1%XW rname=$D2%XW` }, 			\
	857   { `hkwd_rbac_sec_roleidtoname_ret1: rc=$D1%XW` }, 				\
	858   { `hkwd_rbac_sec_roleidtoname_ret2: rc=$D1%XW` }, 				\
	859   { `hkwd_rbac_sec_roleidtoname_ret3: rc=$D1%XW` }, 				\
	860   { `hkwd_rbac_sec_roleidtoname_ret4: rc=$D1%XW` }, 				\
	861   { `hkwd_rbac_sec_roleidtoname_ret5: rc=$D1%XW` }, 				\
	862   { `hkwd_rbac_sec_roleidtoname_ret6: rc=$D1%XW` }, 				\
	863   { `hkwd_rbac_sec_roleidtoname_ret7: u.u_error=$D1%XW rc=$D2%XW` },		\
	864   { `hkwd_rbac_sec_rolenametoid_in: rname=$D1%XW rid=$D2%XW` }, 			\
	865   { `hkwd_rbac_sec_rolenametoid_ret1: rc=$D1%XW` }, 				\
	866   { `hkwd_rbac_sec_rolenametoid_ret2: rc=$D1%XW` }, 				\
	867   { `hkwd_rbac_sec_rolenametoid_ret3: rc=$D1%XW` }, 				\
	868   { `hkwd_rbac_sec_rolenametoid_ret4: rc=$D1%XW` }, 				\
	869   { `hkwd_rbac_sec_rolenametoid_ret5: rc=$D1%XW` }, 				\
	870   { `hkwd_rbac_sec_rolenametoid_ret6: rc=$D1%XW` }, 				\
	871   { `hkwd_rbac_sec_rolenametoid_ret7: u.u_error=$D1%XW rc=$D2%XW` }, 		\
        \* { unknown subhook $HD $ERROR }
64F 1.0 "@VMM_CMEM" \
	$HD, \
	0x01 { `ADD_BLKS: cbpx=$D1 nblks=$D2 vmcbp_nblks=$D3 krc=$D4` }, \
	0x02 { `REM_BLKS: cbpx:$D1 nblks=$D2 vmcbp_nblks=$D3` }, \
	0x03 { `ALLOC: sidx=$D1 pno=$D2 psx=$D3 xpt=$D4 cbdaddr=$D5` }, \
	0x05 { `FREE: sidx=$D1 pno=$D2 pdtx=$D3 cbddaddr=$D4 locked=$D5` }, \
	0x06 { `DECOMP: sidx=$D1 pno=$D2 nfr=$D3 pdtx=$D4 cbdaddr=$D5` }, \
	0x07 { `COMP: sidx=$D1 pno=$D2 nfr=$D3 pdtx=$D4 cbdaddr=$D5` }, \
	0x08 { `ONL_POOL: cbpx=$D1 krc=$D2` }, \
	0x09 { `REM_ABORT: cbpx=$D1 vmcbp_nblks=$D2 pk_start=$D3 nblks=$D4` }, \
	0x0A { `FR_WT: cbpx=$D1 fr_wt_tb=$D2 grow_prog=$D3 getcaller1=$D4	getcaller2=$D5` }, \
	0x0B { `FRWT_WAKE0: cbpx=$D1 fr_wt_list=$D2 fr_wt_tb=$D3 msec=$D4` }, \
	0x0C { `FRWT_WAKE1: cbpx=$D1 fr_wt_list=$D2 fr_wt_tb=$D3 msec=$D4` }, \
	0x0D { `FORCE_PGIN: cbpx=$D1 cbx=$D2 headx=$D3 sidx=$D4 pno=$D5` }, \
	0x0E { `AMEF_DR: rc=$D1 old_amef=$D2 new_amef=$D3` }, \
	0x0F { `CHKPS_DR_FAIL: ame_numfrb=$D1 ame_def_sz=$D2 nloaned=$D3	psfreeblks=$D4 ame_npgs_rem=$D5` }, \
	0x10 { `SHWT_WAKE0: cbpx=$D1 sh_wt_list=$D2 sh_wt_tb=$D3 msec=$D4` }, \
	0x11 { `SHWT_WAKE1: cbpx=$D1 sh_wt_list=$D2 sh_wt_tb=$D3 msec=$D4` }, \
	0x12 { `REF_CNT_RESET` }, \
	0x13 { `SHRINK_SUSP: cbpx=$D1 sh_wt_tb=$D2` }, \
	0x14 { `MOVE_BLK: cbpx=$D1 cbx=$D2 new_cbx=$D3 rc=$D4` }, \
	0x15 { `MOVE_HEAD: sidx=$D1 osidx=$D2 pno=$D3 rc=$D4` }
655 1.0 "@VMM_LSA" \
	$HD, \
	0x01 { `CREATE_1TB_FAIL: nsegs=$D1 psx=$D2 unsh=$D3 i=$D4` }, \
	0x02 { `SET_UNO_FAIL: esid=$D1 ns_left=$D2 nsegs=$D3` }, \
	0x03 { `PROMOTE_FAIL0: rc=$D1 esid=$D2 data=$D3` }, \
	0x04 { `PROMOTE_FAIL1: rc=$D1 esid=$D2 data=$D3` }, \
	0x05 { `PROMOTE_FAIL2: rc=$D1 esid=$D2 data=$D3` }, \
	0x06 { `REMOVE_SIDX: sidx=$D1 sid=$D2 npgs=$D3` }, \
	0x07 { `DEMOTE_ALIAS: eaddr=$D1 vmh=$D2 atyp=$D3` }, \
	0x08 { `PROMOTE_ALIAS: esid=$D1 vmh=$D2 shared=$D3` }
656 1.0 L=APPL "@RDMACM" \
	$HD,\
	0x0100 { `rdmacm_get_env_val env_str=$D1%XW def_val=$D2%XW` }, \
	0x0101 { `return from rdmacm_get_env_val def_val=$D1%XW` }, \
	0x0200 { `ucma_cleanup` }, \
	0x0201 { `return from ucma_cleanup` }, \
	0x0300 { `ucma_init` }, \
	0x0301 { `return from ucma_init` }, \
	0x0302 { `return from ucma_init exit1` }, \
	0x0320 { `ucma_init error1 cma_dev_cnt=$D1%XW` }, \
	0x0322 { `ucma_init error2 ret=$D1%XW` }, \
	0x0324 { `ucma_init error3 ret=$D1%XW` }, \
	0x0326 { `ucma_init error4 ret=$D1%XW` }, \
	0x0328 { `ucma_init error5 ret=$D1%XW` }, \
	0x032a { `ucma_init error6 ret=$D1%XW` }, \
	0x0400 { `rdma_get_devices` }, \
	0x0401 { `return from rdma_get_devices devs=$D1%XW num_devices=$D2%XW` }, \
	0x0420 { `rdma_get_devices error1` }, \
	0x0440 { `rdma_get_devices info1 cma_dev_cnt=$D1%XW` }, \
	0x0600 { `rdma_create_event_channel` }, \
	0x0601 { `return from rdma_create_event_channel channel=$D1%XW` }, \
	0x0602 { `return from rdma_create_event_channel exit1` }, \
	0x0621 { `return from rdma_create_event_channel error1 cma_dev_cnt=$D1%XW` }, \
	0x0623 { `return from rdma_create_event_channel error2` }, \
	0x0624 { `rdma_create_event_channel error3 channel_fd=$D1%XW` }, \
	0x0700 { `rdma_destroy_event_channel channel=$D1%XW` }, \
	0x0701 { `return from rdma_destroy_event_channel` }, \
	0x0721 { `return from rdma_destroy_event_channel error1` }, \
	0x0800 { `ucma_get_device id_priv=$D1%XW guid=$D2%XW` }, \
	0x0801 { `return from ucma_get_device cma_dev=$D1%XW id.verbs=$D2%XW` }, \
	0x0821 { `return from ucma_get_device error1 ret=$D1%XW` }, \
	0x0900 { `ucma_free_id id_priv=$D1%XW` }, \
	0x0901 { `return from ucma_free_id` }, \
	0x0a00 { `ucma_alloc_id channel=$D1%XW context=$D2%XW ps=$D3%XW` }, \
	0x0a01 { `return from ucma_alloc_id id_priv=$D1%XW` }, \
	0x0a02 { `return from ucma_alloc_id exit1` }, \
	0x0a21 { `return from ucma_alloc_id error1` }, \
	0x0a22 { `ucma_alloc_id error2` }, \
	0x0b00 { `rdma_create_id channel=$D1%XW id=$D2%XW context=$D3%XW ps=$D4%XW` }, \
	0x0b01 { `return from rdma_create_id id=$D1%XW` }, \
	0x0b02 { `return from rdma_create_id exit1` }, \
	0x0b03 { `return from rdma_create_id exit2 ret=$D1%XW` }, \
	0x0b21 { `return from rdma_create_id error1 channel=$D1%XW id=$D2%XW ret=$D3%XW` }, \
	0x0b23 { `return from rdma_create_id error2 ps=$D1%XW ret=$D2%XW` }, \
	0x0b25 { `return from rdma_create_id error3 ret=$D1%XW` }, \
	0x0b27 { `return from rdma_create_id error4 errno=$D1%XW ret=$D2%XW` }, \
	0x0c00 { `ucma_destroy_kern_id fd=$D1%XW handle=$D2%XW` }, \
	0x0c01 { `return from ucma_destroy_kern_id events_reported=$D1%XW` }, \
	0x0c21 { `return from ucma_destroy_kern_id error1 errno=$D1%XW ret=$D2%XW` }, \
	0x0d00 { `rdma_destroy_id id=$D1%XW` }, \
	0x0d01 { `return from rdma_destroy_id id=$D1%XW` }, \
	0x0d21 { `return from rdma_destroy_id error1 id=$D1%XW channel=$D2%XW ret=$D3%XW` }, \
	0x0d23 { `return from rdma_destroy_id error2 ret=$D1%XW` }, \
	0x0e00 { `ucma_query_route id=$D1%XW` }, \
	0x0e01 { `return from ucma_query_route` }, \
	0x0e21 { `return from ucma_query_route error1 errno=$D1%XW ret=$D2%XW` }, \
	0x0e23 { `return from ucma_query_route error2 ret=$D1%XW` }, \
	0x0e25 { `return from ucma_query_route error3 ret=$D1%XW` }, \
	0x0f00 { `rdma_bind_addr id=$D1%XW addr=$D2%XW` }, \
	0x0f01 { `return from rdma_bind_addr ret=$D1%XW` }, \
	0x0f21 { `return from rdma_bind_addr error1 ret=$D1%XW` }, \
	0x0f23 { `return from rdma_bind_addr error2 ret=$D1%XW` }, \
	0x0f25 { `return from rdma_bind_addr error3 ret=$D1%XW p2=$D2%XW` }, \
	0x1000 { `rdma_resolve_addr id=$D1%XW src_addr=$D2%XW dst_addr=$D3%XW timeout_ms=$D4%XW` }, \
	0x1001 { `return from rdma_resolve_addr` }, \
	0x1021 { `return from rdma_resolve_addr error1 ret=$D1%XW` }, \
	0x1023 { `return from rdma_resolve_addr error2 ret=$D1%XW` }, \
	0x1025 { `return from rdma_resolve_addr error3 errno=$D1%XW ret=$D2%XW` }, \
	0x1100 { `rdma_resolve_route id=$D1%XW timeout_ms=$D2%XW` }, \
	0x1101 { `return from rdma_resolve_route` }, \
	0x1121 { `return from rdma_resolve_route error1 ret=$D1%XW` }, \
	0x1123 { `return from rdma_resolve_route error2 errno=$D1%XW ret=$D2%XW` }, \
	0x1200 { `rdma_init_qp_addr id=$D1%XW qp_attr=$D2%XW qp_attr_mask=$D3%XW` }, \
	0x1201 { `return from rdma_init_qp_addr qp_attr_mask=$D1%XW` }, \
	0x1221 { `return from rdma_init_qp_addr error1 errno=$D1%XW ret=$D2%XW` }, \
	0x1300 { `ucma_modify_qp_rtr id=$D1%XW conn_param=$D2%XW` }, \
	0x1301 { `return from ucma_modify_qp_rtr ret=$D1%XW` }, \
	0x1321 { `return from ucma_modify_qp_rtr error1 ret=$D1%XW` }, \
	0x1323 { `return from ucma_modify_qp_rtr error2 ret=$D1%XW` }, \
	0x1325 { `return from ucma_modify_qp_rtr error3 ret=$D1%XW` }, \
	0x1327 { `return from ucma_modify_qp_rtr error4 ret=$D1%XW` }, \
	0x1400 { `ucma_modify_qp_rts id=$D1%XW` }, \
	0x1401 { `return from ucma_modify_qp_rts ret=$D1%XW` }, \
	0x1421 { `return from ucma_modify_qp_rts error1 ret=$D1%XW` }, \
	0x1500 { `ucma_modify_qp_sqd id=$D1%XW` }, \
	0x1501 { `return from ucma_modify_qp_sqd ret=$D1%XW` }, \
	0x1521 { `return from ucma_modify_qp_sqd error1` }, \
	0x1600 { `ucma_modify_qp_err id=$D1%XW` }, \
	0x1601 { `return from ucma_modify_qp_err ret=$D1%XW` }, \
	0x1621 { `return from ucma_modify_qp_err error1` }, \
	0x1700 { `ucma_find_pkey cma_dev=$D1%XW port_num=$D2%XW pkey=$D3%XW pkey_index=$D4%XW` }, \
	0x1701 { `return from ucma_find_pkey` }, \
	0x1721 { `return from ucma_find_pkey error1 ret=$D1%XW` }, \
	0x1800 { `ucma_init_conn_qp id_priv=$D1%XW qp=$D2%XW` }, \
	0x1801 { `return from ucma_init_conn_qp ret=$D1%XW` }, \
	0x1802 { `return from ucma_init_conn_qp exit1 abi_ver=$D1%XW ret=$D2%XW` }, \
	0x1821 { `return from ucma_init_conn_qp error1 ret=$D1%XW` }, \
	0x1900 { `rdma_create_qp id=$D1%XW pd=$D2%XW qp_init_attr=$D3%XW` }, \
	0x1901 { `return from rdma_create_qp qp=$D1%XW` }, \
	0x1902 { `return from rdma_create_qp exit1 ret=$D1%XW` }, \
	0x1921 { `return from rdma_create_qp error1 id=$D1%XW pd=$D2%XW qp_init_attr=$D3%XW ret=$D4%XW` }, \
	0x1923 { `return from rdma_create_qp error2 ret=$D1%XW` }, \
	0x1925 { `return from rdma_create_qp error3 ret=$D1%XW` }, \
	0x1927 { `return from rdma_create_qp error4 ret=$D1%XW` }, \
	0x1a00 { `rdma_destroy_qp id=$D1%XW` }, \
	0x1a01 { `return from rdma_destroy_qp` }, \
	0x1a21 { `return from rdma_destroy_qp error1` }, \
	0x1b00 { `rdma_connect id=$D1%XW conn_param=$D2%XW` }, \
	0x1b01 { `return from rdma_connect` }, \
	0x1b21 { `return from rdma_connect error1 id=$D1%XW conn_param=$D2%XW ret=$D3%XW` }, \
	0x1b23 { `return from rdma_connect error2 ret=$D1%XW` }, \
	0x1b25 { `return from rdma_connect error3 errno=$D1%XW ret=$D2%XW` }, \
	0x1c00 { `rdma_listen id=$D1%XW backlog=$D2%XW` }, \
	0x1c01 { `return from rdma_listen ret=$D1%XW` }, \
	0x1c21 { `return from rdma_listen error1 ret=$D1%XW` }, \
	0x1c23 { `return from rdma_listen error2 errno=$D1%XW ret=$D2%XW` }, \
	0x1d00 { `rdma_accept id=$D1%XW conn_param=$D2%XW` }, \
	0x1d01 { `return from rdma_accept` }, \
	0x1d21 { `return from rdma_accept error1 id=$D1%XW conn_param=$D2%XW ret=$D3%XW` }, \
	0x1d23 { `return from rdma_accept error2 ret=$D1%XW` }, \
	0x1d25 { `return from rdma_accept error3 ret=$D1%XW` }, \
	0x1d27 { `return from rdma_accept error4 errno=$D1%XW ret=$D2%XW` }, \
	0x1e00 { `rdma_reject id=$D1%XW private_data=$D2%XW private_data_len=$D3%XW` }, \
	0x1e01 { `return from rdma_reject` }, \
	0x1e21 { `return from rdma_reject error1 ret=$D1%XW` }, \
	0x1e23 { `return from rdma_reject error2 errno=$D1%XW ret=$D2%XW` }, \
	0x1f00 { `rdma_disconnect id=$D1%XW` }, \
	0x1f01 { `return from rdma_disconnect` }, \
	0x1f21 { `return from rdma_disconnect error1 ret=$D1%XW` }, \
	0x1f23 { `return from rdma_disconnect error2 ret=$D1%XW` }, \
	0x1f25 { `return from rdma_disconnect error3 errno=$D1%XW ret=$D2%XW` }, \
	0x2000 { `rdma_ack_cm_event event=$D1%XW` }, \
	0x2001 { `return from rdma_ack_cm_event` }, \
	0x2021 { `return from rdma_ack_cm_event error1 ret=$D1%XW` }, \
	0x2100 { `ucma_process_conn_req evt=$D1%XW handle=$D2%XW` }, \
	0x2101 { `return from ucma_process_conn_req` }, \
	0x2102 { `return from ucma_process_conn_req exit1` }, \
	0x2120 { `ucma_process_conn_req error1 ret=$D1%XW` }, \
	0x2122 { `ucma_process_conn_req error2 ret=$D1%XW` }, \
	0x2200 { `ucma_process_conn_resp id_priv=$D1%XW` }, \
	0x2201 { `return from ucma_process_conn_resp` }, \
	0x2220 { `ucma_process_conn_resp error1 ret=$D1%XW` }, \
	0x2222 { `ucma_process_conn_resp error2 ret=$D1%XW` }, \
	0x2224 { `ucma_process_conn_resp error3 errno=$D1%XW ret=$D2%XW` }, \
	0x2300 { `rdma_get_cm_event channel=$D1%XW event=$D2%XW` }, \
	0x2301 { `return from rdma_get_cm_event ret=$D1%XW` }, \
	0x2321 { `return from rdma_get_cm_event error1 cma_dev_cnt=$D1%XW ret=$D2%XW` }, \
	0x2323 { `return from rdma_get_cm_event error2 event=$D1%XW channel=$D2%XW ret=$D3XW` }, \
	0x2325 { `return from rdma_get_cm_event error3 ret=$D1%XW` }, \
	0x2327 { `return from rdma_get_cm_event error4 errno=$D1%XW ret=$D2%XW` }, \
	0x2400 { `ucma_copy_conn_event event=$D1%XW src=$D2%XW` }, \
	0x2401 { `return from ucma_copy_conn_event dst=$D1%XW` }, \
	0x2500 { `rdma_migrate_id id=$D1%XW channel=$D2%XW` }, \
	0x2501 { `return from rdma_migrate_id` }, \
	0x2521 { `return from rdma_migrate_id error1 channel=$D1%XW id=$D2%XW ret=$D3%XW` }, \
	0x2523 { `return from rdma_migrate_id error2 errno=$D1%XW ret=$D2%XW` }, \
	\* { "Unknown subhook for 0x656: "$HD%D1 }
657 1.0 L=APPL "@IBV" \
	$HD,\
	0x0100 { `ibv_get_device_guid device=$D1%XW` }, \
	0x0101 { `return from ibv_get_device_guid devport_guid=$D1%XW` }, \
	0x0121 { `return from ibv_get_device_guid error1` }, \
	0x0123 { `return from ibv_get_device_guid error2 fd_adm=$D1%XW admdevname=$D2%XW errno=$D3%XW` }, \
	0x0125 { `return from ibv_get_device_guid error3 rc=$D1%XW errno=$D2%XW` }, \
	0x0200 { `find_sys_devs` }, \
	0x0201 { `return from find_sys_devs` }, \
	0x0221 { `return from find_sys_devs error1 fd_adm=$D1%XW admdevname=$D2%XW errno=$D3%XW` }, \
	0x0223 { `return from find_sys_devs error2 rc=$D1%XW errno=$D2%XW` }, \
	0x0224 { `find_sys_devs error3 rc=$D1%XW errno=$D2%XW uverbsname=$D3%XW` }, \
	0x0226 { `find_sys_devs error4 uverbsname=$D1%XW` }, \
	0x0300 { `adm_query_device_attr sys_dev=$D1%XW device_attr=$D2%XW` }, \
	0x0301 { `return from adm_query_device_attr pabi_version=$D1%XW` }, \
	0x0321 { `return from adm_query_device_attr error1 fd_adm=$D1%XW admdevname=$D2%XW errno=$D3%XW` }, \
	0x0323 { `return from adm_query_device_attr error2 rc=$D1%XW qattr_uverbsname=$D2%XW errno=$D3%XW` }, \
	0x0400 { `try_driver driver=$D1%XW sys_dev=$D2%XW` }, \
	0x0401 { `return from try_driver dev=$D1%XW` }, \
	0x0421 { `return from try_driver error1 rc=$D1%XW` }, \
	0x0423 { `return from try_driver error2` }, \
	0x0500 { `load_driver name=$D1%XW` }, \
	0x0501 { `return from load_driver` }, \
	0x0521 { `return from load_driver error1 name=$D1%XW` }, \
	0x0522 { `load_driver error2 name=$D1%XW` }, \
	0x0600 { `ibverbs_init list=$D1%XW` }, \
	0x0601 { `return from ibverbs_init num_devices=$D1%XW` }, \
	0x0621 { `return from ibverbs_init error1` }, \
	0x0622 { `ibverbs_init error2` }, \
	0x0624 { `ibverbs_init error3` }, \
	0x0700 { `ibv_query_gid context=$D1%XW port_num=$D2%XW index=$D3%XW gid=$D4%XW` }, \
	0x0701 { `return from ibv_query_gid context=$D1%XW port_num=$D2%XW index=$D3%XW gid=$D4%XW` }, \
	0x0721 { `return from ibv_query_gid error1` }, \
	0x0723 { `return from ibv_query_gid error2 rc=$D1%XW errno=$D2%XW admdevname=$D3%XW` }, \
	0x0725 { `return from ibv_query_gid error3 rc=$D1%XW errno=$D2%XW` }, \
	0x0800 { `ibv_query_pkey context=$D1%XW port_num=$D2%XW index=$D3%XW pkey=$D4%XW` }, \
	0x0801 { `return from ibv_query_pkey pkey=$D1%XW` }, \
	0x0821 { `return from ibv_query_pkey error1` }, \
	0x0823 { `return from ibv_query_pkey error2 rc=$D1%XW errno=$D2%XW admdevname=$D3%XW` }, \
	0x0825 { `return from ibv_query_pkey error3 rc=$D1%XW errno=$D2%XW` }, \
	0x0900 { `ibv_cmd_get_context_v2 context=$D1%XW new_cmd=$D2%XW new_cmd_size=$D3%XW resp=$D4%XW resp_size=$D5%XW` }, \
	0x0901 { `return from ibv_cmd_get_context_v2 context=$D1%XW abi_compat=$D2%XW` }, \
	0x0921 { `return from ibv_cmd_get_context_v2 error1 rc=$D1%XW` }, \
	0x0923 { `return from ibv_cmd_get_context_v2 error2 errno=$D1%XW` }, \
	0x0a00 { `ibv_cmd_get_context context=$D1%XW cmd=$D2%XW cmd_size=$D3%XW resp=$D4%XW resp_size=$D5%XW` }, \
	0x0a01 { `return from ibv_cmd_get_context context=$D1%XW` }, \
	0x0a02 { `return from ibv_cmd_get_context exit1 abi_ver=$D1%XW ret=$D2%XW` }, \
	0x0a21 { `return from ibv_cmd_get_context error1 errno=$D1%XW` }, \
	0x0b00 { `ibv_cmd_query_device context=$D1%XW device_attr=$D2%XW raw_fw_ver=$D3%XW cmd=$D4%XW cmd_size=$D5%XW` }, \
	0x0b01 { `return from ibv_cmd_query_device device_attr=$D1%XW` }, \
	0x0b21 { `return from ibv_cmd_query_device error1 errno=$D1%XW` }, \
	0x0c00 { `ibv_cmd_query_port context=$D1%XW port_num=$D2%XW port_attr=$D3%XW cmd=$D4%XW cmd_size=$D5%XW` }, \
	0x0c01 { `return from ibv_cmd_query_port port_attr=$D1%XW` }, \
	0x0c21 { `return from ibv_cmd_query_port error1 errno=$D1%XW` }, \
	0x0d00 { `ibv_cmd_alloc_pd context=$D1%XW pd=$D2%XW cmd=$D3%XW resp=$D4%XW` }, \
	0x0d01 { `return from ibv_cmd_alloc_pd pd=$D1%XW` }, \
	0x0d21 { `return from ibv_cmd_query_port error1 errno=$D1%XW` }, \
	0x0e00 { `ibv_cmd_dealloc_pd pd=$D1%XW` }, \
	0x0e01 { `return from ibv_cmd_dealloc_pd` }, \
	0x0e21 { `return from ibv_cmd_dealloc_pd error1 errno=$D1%XW` }, \
	0x0f00 { `ibv_cmd_reg_mr pd=$D1%XW addr=$D2%XW access=$D3%XW mr=$D4%XW cmd=$D5%XW` }, \
	0x0f01 { `return from ibv_cmd_reg_mr mr=$D1%XW` }, \
	0x0f21 { `return from ibv_cmd_reg_mr error1 errno=$D1%XW` }, \
	0x1000 { `ibv_cmd_dereg_mr mr=$D1%XW` }, \
	0x1001 { `return from ibv_cmd_dereg_mr` }, \
	0x1021 { `return from ibv_cmd_dereg_mr error1 errno=$D1%XW` }, \
	0x1100 { `ibv_cmd_create_cq_v2 context=$D1%XW cqe=$D2%XW cq=$D3%XW new_cmd=$D4%XW resp=$D5%XW` }, \
	0x1101 { `return from ibv_cmd_create_cq_v2 cq=$D1%XW` }, \
	0x1121 { `return from ibv_cmd_create_cq_v2 error1 errno=$D1%XW` }, \
	0x1200 { `ibv_cmd_create_cq context=$D1%XW cqe=$D2%XW channel=$D3%XW cq=$D4%XW cmd=$D5%XW` }, \
	0x1201 { `return from ibv_cmd_create_cq cq=$D1%XW` }, \
	0x1202 { `return from ibv_cmd_create_cq exit1 abi_ver=$D1%XW ret=$D2%XW` }, \
	0x1221 { `return from ibv_cmd_create_cq error1 errno=$D1%XW` }, \
	0x1300 { `ibv_cmd_poll_cq ibcq=$D1%XW ne=$D2%XW wc=$D3%XW` }, \
	0x1301 { `return from ibv_cmd_poll_cq` }, \
	0x1321 { `return from ibv_cmd_poll_cq error1` }, \
	0x1322 { `ibv_cmd_poll_cq error2 errno=$D1%XW` }, \
	0x1400 { `ibv_cmd_req_notify_cq ibcq=$D1%XW solicited_only=$D2%XW` }, \
	0x1401 { `return from ibv_cmd_req_notify_cq` }, \
	0x1421 { `return from ibv_cmd_req_notify_cq error1 errno=$D1%XW` }, \
	0x1500 { `ibv_cmd_destroy_cq_v1 cq=$D1%XW` }, \
	0x1501 { `return from ibv_cmd_destroy_cq_v1` }, \
	0x1521 { `return from ibv_cmd_destroy_cq_v1 error1 errno=$D1%XW` }, \
	0x1600 { `ibv_cmd_destroy_cq cq=$D1%XW` }, \
	0x1601 { `return from ibv_cmd_destroy_cq` }, \
	0x1602 { `return from ibv_cmd_destroy_cq exit1 abi_ver=$D1%XW ret=$D2%XW` }, \
	0x1621 { `return from ibv_cmd_destroy_cq error1 errno=$D1%XW` }, \
	0x1700 { `ibv_cmd_create_qp pd=$D1%XW qp=$D2%XW attr=$D3%XW cmd=$D4%XW resp=$D5%XW` }, \
	0x1701 { `return from ibv_cmd_create_qp` }, \
	0x1721 { `return from ibv_cmd_create_qp error1 errno=$D1%XW` }, \
	0x1800 { `ibv_cmd_query_qp qp=$D1%XW attr=$D2%XW attr_mask=$D3%XW init_attr=$D4%XW cmd=$D5%XW` }, \
	0x1801 { `return from ibv_cmd_query_qp init_attr=$D1%XW` }, \
	0x1821 { `return from ibv_cmd_query_qp error1 errno=$D1%XW` }, \
	0x1900 { `ibv_cmd_modify_qp qp=$D1%XW attr=$D2%XW attr_mask=$D3%XW cmd=$D4%XW cmd_size=$D5%XW` }, \
	0x1901 { `return from ibv_cmd_modify_qp` }, \
	0x1921 { `return from ibv_cmd_modify_qp error1 errno=$D1%XW` }, \
	0x1a00 { `ibv_cmd_destroy_qp_v1 qp=$D1%XW` }, \
	0x1a01 { `return from ibv_cmd_destroy_qp_v1` }, \
	0x1a21 { `return from ibv_cmd_destroy_qp_v1 error1 errno=$D1%XW` }, \
	0x1b00 { `ibv_cmd_post_send ibqp=$D1%XW wr=$D2%XW bad_wr=$D3%XW` }, \
	0x1b01 { `return from ibv_cmd_post_send` }, \
	0x1b20 { `ibv_cmd_post_send error1 errno=$D1%XW` }, \
	0x1c00 { `ibv_cmd_post_recv ibqp=$D1%XW wr=$D2%XW bad_wr=$D3%XW` }, \
	0x1c01 { `return from ibv_cmd_post_recv` }, \
	0x1c20 { `ibv_cmd_post_recv error1 errno=$D1%XW` }, \
	0x1d00 { `ibv_cmd_destroy_qp qp=$D1%XW` }, \
	0x1d01 { `return from ibv_cmd_destroy_qp` }, \
	0x1d02 { `return from ibv_cmd_destroy_qp exit1 abi_ver=$D1%XW ret=$D2%XW` }, \
	0x1d21 { `return from ibv_cmd_destroy_qp error1 errno=$D1%XW` }, \
	0x1e00 { `ibv_get_device_list num=$D1%XW` }, \
	0x1e01 { `return from ibv_get_device_list *num=$D1%XW l=$D2%XW num_devices=$D3%XW` }, \
	0x1f00 { `ibv_free_device_list list=$D1%XW` }, \
	0x1f01 { `return from ibv_free_device_list` }, \
	0x2000 { `ibv_get_device_name device=$D1%XW` }, \
	0x2001 { `return from ibv_get_device_name device=$D1%XW name=$D2%XW` }, \
	0x2100 { `ibv_open_device device=$D1%XW` }, \
	0x2101 { `return from ibv_open_device context=$D1%XW` }, \
	0x2102 { `return from ibv_open_device exit1` }, \
	0x2121 { `return from ibv_open_device error1 device=$D1%XW` }, \
	0x2123 { `return from ibv_open_device error2 cmd_fd=$D1%XW errno=$D2%XW devpath=$D3%XW` }, \
	0x2124 { `ibv_open_device error3` }, \
	0x2200 { `ibv_close_device context=$D1%XW` }, \
	0x2201 { `return from ibv_close_device` }, \
	0x2221 { `return from ibv_close_device error1` }, \
	0x2300 { `ibv_get_async_event context=$D1%XW event=$D2%XW` }, \
	0x2301 { `return from ibv_get_async_event event_type=$D1%XW event=$D2%XW` }, \
	0x2321 { `return from ibv_get_async_event error1 context=$D1%XW event=$D2%XW` }, \
	0x2323 { `return from ibv_get_async_event error2 errno=$D1%XW` }, \
	0x2400 { `ibv_ack_async_event event=$D1%XW` }, \
	0x2401 { `return from ibv_ack_async_event event_type=$D1%XW` }, \
	0x2402 { `return from ibv_ack_async_event exit1 event_type=$D1%XW` }, \
	0x2403 { `return from ibv_ack_async_event exit2 event_type=$D1%XW` }, \
	0x2404 { `return from ibv_ack_async_event exit3 event_type=$D1%XW` }, \
	0x2421 { `return from ibv_ack_async_event error1` }, \
	0x2500 { `ibv_register_driver name=$D1%XW init_func=$D2%XW` }, \
	0x2501 { `return from ibv_register_driver driver=$D1%XW` }, \
	0x2521 { `return from ibv_register_driver error1 name=$D1%XW` }, \
	0x2600 { `load_drivers` }, \
	0x2601 { `return from load_drivers` }, \
	0x2700 { `read_config_file path=$D1%XW` }, \
	0x2701 { `return from read_config_file` }, \
	0x2721 { `return from read_config_file error1 errno=$D1%XW path=$D2%XW` }, \
	0x2722 { `read_config_file error2 field=$D1%XW` }, \
	0x2724 { `read_config_file error3 field=$D1%XW` }, \
	0x2726 { `read_config_file error4 field=$D1%XW path=$D2%XW` }, \
	0x2800 { `read_config` }, \
	0x2801 { `return from read_config` }, \
	0x2821 { `return from read_config error1 dir=$D1%XW` }, \
	0x2823 { `return from read_config error2 dir=$D1%XW name=$D2%XW` }, \
	0x2900 { `try_drivers sysfs_dev=$D1%XW` }, \
	0x2901 { `return from try_drivers` }, \
	0x2902 { `return from try_drivers exit1 dev=$D1%XW` }, \
	0x2a00 { `check_memlock_limit` }, \
	0x2a01 { `return from check_memlock_limit` }, \
	0x2a02 { `return from check_memlock_limit exit1` }, \
	0x2a23 { `return from check_memlock_limit error2 ret=$D1%XW` }, \
	0x2a24 { `check_memlock_limit error3 rlim_cur=$D1%XW` }, \
	0x2b00 { `add_device dev=$D1%XW dev_list=$D2%XW num_devices=$D3%XW lis_size=$D4%XW` }, \
	0x2b01 { `return from add_device dev=$D1%XW` }, \
	0x2b02 { `return from add_device exit1` }, \
	0x2c00 { `ibv_query_device context=$D1%XW device_attr=$D2%XW` }, \
	0x2c01 { `return from ibv_query_device ret=$D1%XW` }, \
	0x2c21 { `return from ibv_query_device error1 ret=$D1%XW` }, \
	0x2d00 { `ibv_query_port context=$D1%XW port_num=$D2%XW port_attr=$D3%XW` }, \
	0x2d01 { `return from ibv_query_port ret=$D1%XW` }, \
	0x2d21 { `return from ibv_query_port error1 ret=$D1%XW` }, \
	0x2e00 { `ibv_alloc_pd context=$D1%XW` }, \
	0x2e01 { `return from ibv_alloc_pd` }, \
	0x2e21 { `return from ibv_alloc_pd error1` }, \
	0x2f00 { `ibv_dealloc_pd pd=$D1%XW` }, \
	0x2f01 { `return from ibv_dealloc_pd ret=$D1%XW` }, \
	0x2f21 { `return from ibv_dealloc_pd error1 ret=$D2%XW` }, \
	0x3000 { `ibv_reg_mr pd=$D1%XW addr=$D2%XW length=$D3%XW access=$D4%XW` }, \
	0x3001 { `return from ibv_reg_mr mr=$D1%XW` }, \
	0x3021 { `return from ibv_reg_mr error1 pd=$D1%XW context=$D2%XW addr=$D3%XW length=$D4%XW` }, \
	0x3023 { `return from ibv_reg_mr error2 addr=$D1%XW length=$D2%XW` }, \
	0x3100 { `ibv_dereg_mr mr=$D1%XW` }, \
	0x3101 { `return from ibv_dereg_mr` }, \
	0x3121 { `return from ibv_dereg_mr error1 ret=$D1%XW` }, \
	0x3200 { `ibv_create_comp_channel_v2 context=$D1%XW` }, \
	0x3201 { `return from ibv_create_comp_channel_v2` }, \
	0x3202 { `return from ibv_create_comp_channel_v2 exit1 channel=$D1%XW` }, \
	0x3300 { `ibv_create_comp_channel context=$D1%XW` }, \
	0x3301 { `return from ibv_create_comp_channel channel=$D1%XW` }, \
	0x3302 { `return from ibv_create_comp_channel exit1 ret=$D1%XW` }, \
	0x3321 { `return from ibv_create_comp_channel error1` }, \
	0x3323 { `return from ibv_create_comp_channel error2` }, \
	0x3325 { `return from ibv_create_comp_channel error3` }, \
	0x3400 { `ibv_destroy_comp_channel_v2 channel=$D1%XW` }, \
	0x3401 { `return from ibv_destroy_comp_channel_v2` }, \
	0x3500 { `ibv_destroy_comp_channel channel=$D1%XW` }, \
	0x3501 { `return from ibv_destroy_comp_channel` }, \
	0x3521 { `return from ibv_destroy_comp_channel error1 ret=$D1%XW` }, \
	0x3522 { `ibv_destroy_comp_channel error2 ret=$D1%XW` }, \
	0x3600 { `ibv_create_cq context=$D1%XW cqe=$D2%XW cq_context=$D3%XW channel=$D4%XW comp_vector=$D5%XW` }, \
	0x3601 { `return from ibv_create_cq cq=$D1%XW` }, \
	0x3621 { `return from ibv_create_cq error1 context=$D1%XW cqe=$D2%XW comp_vector=$D3%XW num_comp_vectors=$D4%XW` }, \
	0x3700 { `ibv_destroy_cq cq=$D1%XW` }, \
	0x3701 { `return from ibv_destroy_cq ret=$D1%XW` }, \
	0x3721 { `return from ibv_destroy_cq error1 ret=$D1%XW` }, \
	0x3800 { `ibv_get_cq_event channel=$D1%XW cq=$D2%XW cq_context=$D3%XW` }, \
	0x3801 { `return from ibv_get_cq_event` }, \
	0x3821 { `return from ibv_get_cq_event error1 channel=$D1%XW cq=$D2%XW cq_context=$D3%XW` }, \
	0x3823 { `return from ibv_get_cq_event error2 errno=$D1%XW` }, \
	0x3900 { `ibv_ack_cq_events cq=$D1%XW nevents=$D2%XW` }, \
	0x3901 { `return from ibv_ack_cq_events` }, \
	0x3921 { `return from ibv_ack_cq_events error1` }, \
	0x3a00 { `ibv_create_qp pd=$D1%XW qp_init_attr=$D2%XW` }, \
	0x3a01 { `return from ibv_create_qp qp=$D1%XW` }, \
	0x3a21 { `return from ibv_create_qp error1 pd=$D1%XW qp_init_attr=$D2%XW send_cq=$D3%XW recv_cq=$D4%XW qp_type=$D5%XW` }, \
	0x3b00 { `ibv_modify_qp qp=$D1%XW attr=$D2%XW attr_mask=$D3%XW` }, \
	0x3b01 { `return from ibv_modify_qp` }, \
	0x3b21 { `return from ibv_modify_qp error1 qp=$D1%XW context=$D2%XW attr=$D3%XW attr_mask=$D4%XW ret=$D5%XW` }, \
	0x3b23 { `return from ibv_modify_qp error2 ret=$D1%XW` }, \
	0x3c00 { `ibv_destroy_qp qp=$D1%XW` }, \
	0x3c01 { `return from ibv_destroy_qp ret=$D1%XW` }, \
	0x3c21 { `return from ibv_destroy_qp error1 qp=$D1%XW context=$D2%XW ret=$D3%XW` }, \
	0x3d00 { `ibv_get_env_val env_str=$D1%XW def_val=$D2%XW` }, \
	0x3d01 { `return from ibv_get_env_val def_val=$D1%XW` }, \
	\* { "Unknown subhook for 0x657: "$HD%D1 }
7FF 1.0 'STREAMS (PSE)' \
    $HD%D1, \
    01 { `getmsg($D1%DW, $D2%XW, $D3%XW, $D4%XW)` }, \
    02 { `getmsg returned $D1%DW` }, \
    03 { `getpmsg($D1%DW, $D2%XW, $D3%XW, $D4%XW, $D4%XW)` }, \
    04 { `getpmsg returned $D1%DW` }, \
    05 { `putmsg($D1%DW, $D2%XW, $D3%XW, $D4%XW)` }, \
    06 { `putmsg returned $D1%DW` }, \
    07 { `putpmsg($D1%DW, $D2%XW, $D3%XW, $D4%XW, $D4%XW)` }, \
    08 { `putmsg returned $D1%DW` }, \
    09 { `mps_open($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    10 { `mps_open returned $D1%DW)` }, \
    11 { `mps_clone($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    12 { `mps_clone returned $D1%DW` }, \
    13 { `mps_close($D1%XW, $D2%XW)` }, \
    14 { `mps_close returned $D1%DW` }, \
    15 { `mps_read($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    16 { `mps_read returned $D1%DW` }, \
    17 { `mps_write($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    18 { `mps_write returned $D1%DW` }, \
    19 { `mps_ioctl($D1%XW, $D2%XW, $D3%XW, $D4%XW, $D5%XW)` }, \
    20 { `mps_ioctl returned $D1%DW` }, \
    21 { `mps_poll($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    22 { `mps_poll returned $D1%DW` }, \
    23 { `hkwd_pse_revoke_in($D1%DW, $D2%XW, $D3%XW)` }, \
    24 { `hkwd_pse_revoke_out($D1%XW)` }, \
    25 { `allocb_in($D1%XW, $D2%XW)` }, \
    26 { `allocb_out_bad($D1%XW)` }, \
    27 { `allocb_out_ok($D1%XW)` }, \
    28 { `freeb_in($D1%XW)` }, \
    29 { `flushband_in($D1%DW, $D2%XW, $D3%XW)` }, \
    30 { `flushq_in($D1%XW, $D2%XW)` }, \
    31 { `freemsg_in($D1%XW)` }, \
    32 { `getq_in($D1%XW)` }, \
    33 { `getq_out($D1%XW)` }, \
    34 { `insq_in($D1%DW, $D2%XW, $D3%XW)` }, \
    35 { `insq_out($D1%XW)` }, \
    36 { `putq_in($D1%XW, $D2%XW)` }, \
    37 { `putq_out($D1%XW)` }, \
    38 { `putbq_in($D1%XW, $D2%XW)` }, \
    39 { `putbq_out($D1%XW)` }, \
    40 { `putctl_comm_in($D1%XW, $D2%XW, $D3%XW, $D4%XW, $D5%XW)` }, \
    41 { `putctl_comm_out($D1%XW)` }, \
    42 { `putnext_in($D1%XW, $D2%XW)` }, \
    43 { `qreply_in($D1%XW, $D2%XW)` }, \
    44 { `rmvq_in($D1%XW, $D2%XW)` }, \
    45 { `str_putnext_in($D1%XW, $D2%XW)` }, \
    46 { `strqget_in($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    47 { `strqget_out($D1%XW)` }, \
    48 { `strqset_in($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    49 { `strqset_out($D1%XW)` }, \
    50 { `insqband_in($D1%DW, $D2%XW, $D3%XW)` }, \
    51 { `insqband_out($D1%XW)` }, \
    52 { `putbqband_in($D1%XW, $D2%XW)` }, \
    53 { `putbqband_out($D1%XW)` }, \
    54 { `puthere_in($D1%XW, $D2%XW)` }, \
    55 { `putqband_in($D1%XW, $D2%XW)` }, \
    56 { `putqband_out($D1%XW)` }, \
    57 { `strtune_module_info($D1%DW, $D2%XW, $D3%XW)` }, \
    58 { `strtune_modsw($D1%DW, $D2%XW, $D3%XW)` }, \
    59 { `strtune_queue($D1%DW, $D2%XW, $D3%XW)` }, \
    60 { `hkwd_pse_add_device_1($D1%XW)` }, \
    61 { `hkwd_pse_add_device_2($D1%XW)` }, \
    62 { `hkwd_pse_add_device_3($D1%XW)` }, \
    63 { `hkwd_pse_add_device_4($D1%XW)` }, \
    64 { `hkwd_pse_bufcall_configure($D1%XW)` }, \
    65 { `hkwd_pse_clone_configure($D1%XW)` }, \
    66 { `hkwd_pse_close_wrapper($D1%XW)` }, \
    67 { `hkwd_pse_del_device_1($D1%XW)` }, \
    68 { `hkwd_pse_del_device_2($D1%XW)` }, \
    69 { `hkwd_pse_dmodsw_install_1($D1%XW)` }, \
    70 { `hkwd_pse_dmodsw_install_2($D1%XW)` }, \
    71 { `hkwd_pse_dmodsw_install_3($D1%XW)` }, \
    72 { `hkwd_pse_dmodsw_remove($D1%XW)` }, \
    73 { `hkwd_pse_dmodsw_search($D1%XW)` }, \
    74 { `hkwd_pse_do_ioctl_job_control_1($D1%XW)` }, \
    75 { `hkwd_pse_do_ioctl_job_control_2($D1%XW)` }, \
    76 { `hkwd_pse_do_ioctl_job_control_3($D1%XW)` }, \
    77 { `hkwd_pse_do_read_job_control_1($D1%XW)` }, \
    78 { `hkwd_pse_do_read_job_control_2($D1%XW)` }, \
    79 { `hkwd_pse_do_write_job_control_1($D1%XW)` }, \
    80 { `hkwd_pse_do_write_job_control_2($D1%XW)` }, \
    81 { `hkwd_pse_do_write_job_control_3($D1%XW)` }, \
    82 { `hkwd_pse_drv_priv($D1%XW)` }, \
    83 { `hkwd_pse_fd_alloc($D1%XW)` }, \
    84 { `hkwd_pse_fmodsw_install_1($D1%XW)` }, \
    85 { `hkwd_pse_fmodsw_install_2($D1%XW)` }, \
    86 { `hkwd_pse_fmodsw_install_3($D1%XW)` }, \
    87 { `hkwd_pse_fmodsw_remove($D1%XW)` }, \
    88 { `hkwd_pse_funnel_init($D1%XW)` }, \
    89 { `hkwd_pse_get_sth_from_fd_1($D1%XW)` }, \
    90 { `hkwd_pse_get_sth_from_fd_2($D1%XW)` }, \
    91 { `hkwd_pse_get_sth_from_fd_3($D1%XW)` }, \
    92 { `hkwd_pse_get_sth_from_fd_4($D1%XW)` }, \
    93 { `hkwd_pse_get_sth_from_fd_5($D1%XW)` }, \
    94 { `hkwd_pse_get_sth_from_fd_6($D1%XW)` }, \
    95 { `hkwd_pse_getmsg($D1%XW)` }, \
    96 { `hkwd_pse_getpmsg($D1%XW)` }, \
    97 { `hkwd_pse_init_funnel($D1%XW)` }, \
    98 { `hkwd_pse_log_configure_1($D1%XW)` }, \
    99 { `hkwd_pse_log_configure_2($D1%XW)` }, \
    100 { `hkwd_pse_log_open_1($D1%XW)` }, \
    101 { `hkwd_pse_log_open_2($D1%XW)` }, \
    102 { `hkwd_pse_mi_offset_param_mblk_1($D1%XW)` }, \
    103 { `hkwd_pse_mi_offset_param_mblk_2($D1%XW)` }, \
    104 { `hkwd_pse_mi_offset_param_mblk_3($D1%XW)` }, \
    105 { `hkwd_pse_mi_open_comm_1($D1%XW)` }, \
    106 { `hkwd_pse_mi_open_comm_2($D1%XW)` }, \
    107 { `hkwd_pse_mi_open_comm_3($D1%XW)` }, \
    108 { `hkwd_pse_nd_get_default($D1%XW)` }, \
    109 { `hkwd_pse_nd_get_names($D1%XW)` }, \
    110 { `hkwd_pse_nd_set_long($D1%XW)` }, \
    111 { `hkwd_pse_open_wrapper($D1%XW)` }, \
    112 { `hkwd_pse_osr_atmark($D1%XW)` }, \
    113 { `hkwd_pse_osr_bufcall($D1%XW)` }, \
    114 { `hkwd_pse_osr_canput($D1%XW)` }, \
    115 { `hkwd_pse_osr_ckband($D1%XW)` }, \
    116 { `hkwd_pse_osr_close_subr_2($D1%XW)` }, \
    117 { `hkwd_pse_osr_fdinsert($D1%XW)` }, \
    118 { `hkwd_pse_osr_fifo($D1%XW)` }, \
    119 { `hkwd_pse_osr_find($D1%XW)` }, \
    120 { `hkwd_pse_osr_flush($D1%XW)` }, \
    121 { `hkwd_pse_osr_flushband($D1%XW)` }, \
    122 { `hkwd_pse_osr_flushdata_1($D1%XW)` }, \
    123 { `hkwd_pse_osr_flushdata_2($D1%XW)` }, \
    124 { `hkwd_pse_osr_flushdata_3($D1%XW)` }, \
    125 { `hkwd_pse_osr_getband($D1%XW)` }, \
    126 { `hkwd_pse_osr_getmsg($D1%XW)` }, \
    127 { `hkwd_pse_osr_getmsg_subr($D1%XW)` }, \
    128 { `hkwd_pse_osr_getpmsg($D1%XW)` }, \
    129 { `hkwd_pse_osr_getsig($D1%XW)` }, \
    130 { `hkwd_pse_osr_link($D1%XW)` }, \
    131 { `hkwd_pse_osr_list($D1%XW)` }, \
    132 { `hkwd_pse_osr_look($D1%XW)` }, \
    133 { `hkwd_pse_osr_peek($D1%XW)` }, \
    134 { `hkwd_pse_osr_pipe($D1%XW)` }, \
    135 { `hkwd_pse_osr_pipestat($D1%XW)` }, \
    136 { `hkwd_pse_osr_pop($D1%XW)` }, \
    137 { `hkwd_pse_osr_putmsg($D1%XW)` }, \
    138 { `hkwd_pse_osr_putmsg_subr($D1%XW)` }, \
    139 { `hkwd_pse_osr_putpmsg($D1%XW)` }, \
    140 { `hkwd_pse_osr_read($D1%XW)` }, \
    141 { `hkwd_pse_osr_recvfd($D1%XW)` }, \
    142 { `hkwd_pse_osr_revoke_1($D1%XW)` }, \
    143 { `hkwd_pse_osr_revoke_2($D1%XW)` }, \
    144 { `hkwd_pse_osr_run($D1%XW)` }, \
    145 { `hkwd_pse_osr_sendfd($D1%XW)` }, \
    146 { `hkwd_pse_osr_setcltime($D1%XW)` }, \
    147 { `hkwd_pse_osr_setsig($D1%XW)` }, \
    148 { `hkwd_pse_osr_sleep($D1%XW)` }, \
    149 { `hkwd_pse_osr_srdopt_1($D1%XW)` }, \
    150 { `hkwd_pse_osr_srdopt_2($D1%XW)` }, \
    151 { `hkwd_pse_osr_srdopt_3($D1%XW)` }, \
    152 { `hkwd_pse_osr_srdopt_4($D1%XW)` }, \
    153 { `hkwd_pse_osr_str($D1%XW)` }, \
    154 { `hkwd_pse_osr_swropt($D1%XW)` }, \
    155 { `hkwd_pse_osr_tcsak_1($D1%XW)` }, \
    156 { `hkwd_pse_osr_tcsak_2($D1%XW)` }, \
    157 { `hkwd_pse_osr_tcskep($D1%XW)` }, \
    158 { `hkwd_pse_osr_tctrust_1($D1%XW)` }, \
    159 { `hkwd_pse_osr_tctrust_2($D1%XW)` }, \
    160 { `hkwd_pse_osr_tctrust_3($D1%XW)` }, \
    161 { `hkwd_pse_osr_tctrust_4($D1%XW)` }, \
    162 { `hkwd_pse_osr_tcxonc($D1%XW)` }, \
    163 { `hkwd_pse_osr_tioccons_1($D1%XW)` }, \
    164 { `hkwd_pse_osr_tioccons_2($D1%XW)` }, \
    165 { `hkwd_pse_osr_tiocgpgrp($D1%XW)` }, \
    166 { `hkwd_pse_osr_tiocgsid($D1%XW)` }, \
    167 { `hkwd_pse_osr_tiocknopgrp($D1%XW)` }, \
    168 { `hkwd_pse_osr_tiocknosess($D1%XW)` }, \
    169 { `hkwd_pse_osr_tiocsctty_1($D1%XW)` }, \
    170 { `hkwd_pse_osr_tiocsctty_2($D1%XW)` }, \
    171 { `hkwd_pse_osr_unlink_subr($D1%XW)` }, \
    172 { `hkwd_pse_osr_write($D1%XW)` }, \
    173 { `hkwd_pse_pse_clone_open_2($D1%XW)` }, \
    174 { `hkwd_pse_pse_close_2($D1%XW)` }, \
    175 { `hkwd_pse_pse_ctb_callback($D1%XW)` }, \
    176 { `hkwd_pse_pse_init_1($D1%XW)` }, \
    177 { `hkwd_pse_pse_init_2($D1%XW)` }, \
    178 { `hkwd_pse_pse_ioctl_2($D1%XW)` }, \
    179 { `hkwd_pse_pse_open_4($D1%XW)` }, \
    180 { `hkwd_pse_pse_read_2($D1%XW)` }, \
    181 { `hkwd_pse_pse_revoke_2($D1%XW)` }, \
    182 { `hkwd_pse_pse_select($D1%XW)` }, \
    183 { `hkwd_pse_pse_write_2($D1%XW)` }, \
    184 { `hkwd_pse_psebufcalls_init($D1%XW)` }, \
    185 { `hkwd_pse_psetimers_init($D1%XW)` }, \
    186 { `hkwd_pse_putmsg($D1%XW)` }, \
    187 { `hkwd_pse_putpmsg($D1%XW)` }, \
    188 { `hkwd_pse_sad_configure($D1%XW)` }, \
    189 { `hkwd_pse_sth_fattach_1($D1%XW)` }, \
    190 { `hkwd_pse_sth_fattach_2($D1%XW)` }, \
    191 { `hkwd_pse_sth_fattach_3($D1%XW)` }, \
    192 { `hkwd_pse_sth_fd_to_sth_1($D1%XW)` }, \
    193 { `hkwd_pse_sth_fd_to_sth_2($D1%XW)` }, \
    194 { `hkwd_pse_sth_read_seek_1($D1%XW)` }, \
    195 { `hkwd_pse_sth_read_seek_2($D1%XW)` }, \
    196 { `hkwd_pse_sth_test_and_set_sth($D1%XW)` }, \
    197 { `hkwd_pse_sth_tiocspgrp_1($D1%XW)` }, \
    198 { `hkwd_pse_sth_tiocspgrp_2($D1%XW)` }, \
    299 { `hkwd_pse_sth_tiocspgrp_3($D1%XW)` }, \
    200 { `hkwd_pse_sth_tiocspgrp_4($D1%XW)` }, \
    201 { `hkwd_pse_sth_tiocspgrp_5($D1%XW)` }, \
    202 { `hkwd_pse_str_config($D1%XW)` }, \
    203 { `hkwd_pse_str_init($D1%XW)` }, \
    204 { `hkwd_pse_str_install($D1%XW)` }, \
    205 { `hkwd_pse_str_term($D1%XW)` }, \
    206 { `hkwd_pse_strinfo_1($D1%XW)` }, \
    207 { `hkwd_pse_strinfo_2($D1%XW)` }, \
    208 { `hkwd_pse_strinfo_3($D1%XW)` }, \
    209 { `hkwd_pse_strinfo_4($D1%XW)` }, \
    210 { `hkwd_pse_strlog_1($D1%XW)` }, \
    211 { `hkwd_pse_strlog_2($D1%XW)` }, \
    212 { `hkwd_pse_strlog_3($D1%XW)` }, \
    213 { `hkwd_pse_strlog_4($D1%XW)` }, \
    214 { `hkwd_pse_strmod_add_1($D1%XW)` }, \
    215 { `hkwd_pse_strmod_add_2($D1%XW)` }, \
    216 { `hkwd_pse_strmod_add_3($D1%XW)` }, \
    217 { `hkwd_pse_strmod_del_1($D1%XW)` }, \
    218 { `hkwd_pse_strmod_del_2($D1%XW)` }, \
    219 { `hkwd_pse_strmod_del_3($D1%XW)` }, \
    220 { `hkwd_pse_strqget_1($D1%XW)` }, \
    221 { `hkwd_pse_strqget_2($D1%XW)` }, \
    222 { `hkwd_pse_strqset_1($D1%XW)` }, \
    223 { `hkwd_pse_strqset_2($D1%XW)` }, \
    224 { `hkwd_pse_strreset($D1%XW)` }, \
    225 { `hkwd_pse_unweldq_1($D1%XW)` }, \
    226 { `hkwd_pse_unweldq_2($D1%XW)` }, \
    227 { `hkwd_pse_unweldq_3($D1%XW)` }, \
    228 { `hkwd_pse_weldq_1($D1%XW)` }, \
    229 { `hkwd_pse_weldq_2($D1%XW)` }, \
    230 { `hkwd_pse_weldq_3($D1%XW)` }, \
    231 { `hkwd_pse_weldq_comm($D1%XW)` }, \
    232 { `alloc_qband($D1%XW, $D2%XW)` }, \
    233 { `bcanput($D1%XW, $D2%XW)` }, \
    234 { `bufcall_init_1($D1%XW, $D2%XW)` }, \
    235 { `bufcall_init_2($D1%XW, $D2%XW)` }, \
    236 { `canput($D1%XW, $D2%XW)` }, \
    237 { `csq_lateral($D1%XW, $D2%XW)` }, \
    238 { `csq_run_1($D1%XW, $D2%XW)` }, \
    239 { `csq_run_2($D1%XW, $D2%XW)` }, \
    240 { `csq_run_3($D1%XW, $D2%XW)` }, \
    241 { `csq_run_4($D1%XW, $D2%XW)` }, \
    242 { `enableok($D1%XW, $D2%XW)` }, \
    243 { `flushband_1($D1%XW, $D2%XW)` }, \
    244 { `flushband_2($D1%XW, $D2%XW)` }, \
    245 { `flushq_1($D1%XW, $D2%XW)` }, \
    246 { `flushq_2($D1%XW, $D2%XW)` }, \
    247 { `funnel_putp($D1%XW, $D2%XW)` }, \
    248 { `funnelq_run_1($D1%XW, $D2%XW)` }, \
    249 { `funnelq_run_2($D1%XW, $D2%XW)` }, \
    250 { `funnelq_run_3($D1%XW, $D2%XW)` }, \
    251 { `funnelq_run_4($D1%XW, $D2%XW)` }, \
    252 { `getq_1($D1%XW, $D2%XW)` }, \
    253 { `getq_2($D1%XW, $D2%XW)` }, \
    254 { `getq_3($D1%XW, $D2%XW)` }, \
    255 { `getq_4($D1%XW, $D2%XW)` }, \
    256 { `getq_5($D1%XW, $D2%XW)` }, \
    257 { `insq($D1%XW, $D2%XW)` }, \
    258 { `insqband($D1%XW, $D2%XW)` }, \
    259 { `mult_sqh_acquire($D1%XW, $D2%XW)` }, \
    260 { `mult_sqh_release($D1%XW, $D2%XW)` }, \
    261 { `noenable($D1%XW, $D2%XW)` }, \
    262 { `osr_add_modules($D1%XW, $D2%XW)` }, \
    263 { `osr_alloc($D1%XW, $D2%XW)` }, \
    264 { `osr_close_subr_1($D1%XW, $D2%XW)` }, \
    265 { `osr_open_1($D1%XW, $D2%XW)` }, \
    266 { `osr_open_2($D1%XW, $D2%XW)` }, \
    267 { `osr_open_3($D1%XW, $D2%XW)` }, \
    268 { `osr_open_4($D1%XW, $D2%XW)` }, \
    269 { `osr_pipe_1($D1%XW, $D2%XW)` }, \
    270 { `osr_pipe_2($D1%XW, $D2%XW)` }, \
    271 { `osr_pop_subr_1($D1%XW, $D2%XW)` }, \
    272 { `osr_pop_subr_2($D1%XW, $D2%XW)` }, \
    273 { `osr_pop_subr_3($D1%XW, $D2%XW)` }, \
    274 { `osr_push_1($D1%XW, $D2%XW, $D3%XW, $D4%XW)` }, \
    275 { `osr_push_2($D1%XW, $D2%XW)` }, \
    276 { `osr_push_3($D1%XW)` }, \
    277 { `osr_str_1($D1%XW, $D2%XW)` }, \
    278 { `osr_str_2($D1%XW, $D2%XW)` }, \
    279 { `osr_str_3($D1%XW, $D2%XW)` }, \
    280 { `osr_str_4($D1%XW, $D2%XW)` }, \
    281 { `pse_clone_open_1($D1%XW, $D2%XW)` }, \
    282 { `pse_close_1($D1%XW, $D2%XW)` }, \
    283 { `pse_ioctl_2($D1%XW, $D2%XW)` }, \
    284 { `pse_open_1($D1%XW, $D2%XW)` }, \
    285 { `pse_open_2($D1%XW, $D2%XW)` }, \
    286 { `pse_open_3($D1%XW, $D2%XW)` }, \
    287 { `pse_read_1($D1%XW, $D2%XW)` }, \
    288 { `pse_revoke_1($D1%XW, $D2%XW)` }, \
    289 { `pse_write_1($D1%XW, $D2%XW)` }, \
    290 { `putbq($D1%XW, $D2%XW)` }, \
    291 { `putbqband($D1%XW, $D2%XW)` }, \
    292 { `putq($D1%XW, $D2%XW)` }, \
    293 { `putqband($D1%XW, $D2%XW)` }, \
    294 { `q_alloc_1($D1%XW, $D2%XW)` }, \
    295 { `q_alloc_2($D1%XW, $D2%XW)` }, \
    296 { `rmvq_1($D1%XW, $D2%XW)` }, \
    297 { `rmvq_2($D1%XW, $D2%XW)` }, \
    298 { `rmvq_3($D1%XW, $D2%XW)` }, \
    399 { `rmvq_4($D1%XW, $D2%XW)` }, \
    300 { `sqh_set_parent_1($D1%XW, $D2%XW)` }, \
    301 { `sqh_set_parent_3($D1%XW, $D2%XW)` }, \
    302 { `sqh_set_parent_4($D1%XW, $D2%XW)` }, \
    303 { `sqh_set_parent_5($D1%XW, $D2%XW)` }, \
    304 { `sqh_set_parent_6($D1%XW, $D2%XW)` }, \
    305 { `sqh_set_parent_7($D1%XW, $D2%XW)` }, \
    306 { `sq_wrapper($D1%XW, $D2%XW)` }, \
    307 { `sqh_set_parent_2($D1%XW, $D2%XW)` }, \
    308 { `unweldq_cnx($D1%XW, $D2%XW)` }, \
    309 { `unweldq_exec($D1%XW, $D2%XW)` }, \
    310 { `weldq_cnx($D1%XW, $D2%XW)` }, \
    311 { `weldq_exec($D1%XW, $D2%XW)` }, \
    \* { `unknown STREAMS subhook $HD $ERROR` }
919 1.0 "@VMM_REL" \
        $HD, \
        0 { `VMM rel: write   sid=$D1 first=$D3 npages=$D4 flags=$D5` vmmsibits($D2) }, \
        1 { `VMM rel: flush   sid=$D1 first=$D3 last=$D4 npages=$D5` vmmsibits($D2) }, \
        2 { `VMM rel: Release range  sid=$D1 first=$D3 last=$D4 chunk=$D5` vmmsibits($D2) }
DD1 1.0 "" \
        {{ $loc = X1 }} \
        $loc, \
        0x1  { "entry_open:" \
                $DD2 "rwflag:" XW "chan:" XW "ext:" XW \
                } , \
        0x2  { "exit_open:" $DD2 } , \
        0x3  { "entry_close:" $DD2 } , \
        0x4  { "exit_close:" $DD2 } , \
        0x5  { "entry_read:" $DD2 } , \
        0x6  { "exit_read:" $DD2 } , \
        0x7  { "entry_write:" $DD2 } , \
        0x8  { "exit_write:" $DD2 } , \
        0x9  { "entry_ioctl:" \
                $DD2 "op:" XW "flag:" XW "chan:" XW "ext:" XW \
                } , \
        0xA  { "exit_ioctl:" $DD2 } , \
        0xB  { "entry_select:" $DD2 } , \
        0xC  { "exit_select:" $DD2 } , \
        0xD  { "entry_config:" \
                $DD2 "op:" XW \
                } , \
        0xE  { "exit_config:" $DD2 } , \
        0xF  { "entry_strategy:" \
                $DD2 "bp:" XW "flags: "XW "block:" DW "bcount:" DW \
                } , \
        10  { "exit_strategy:" $DD2 $SKIP } , \
        11  { "entry_mpx:" $DD2 } , \
        12  { "exit_mpx:" \
                $DD2 "name:" XW "chan:" DW "oflag:" XW \
                } , \
        13  { "entry_revoke:" $DD2 } , \
        14  { "exit_revoke:" $DD2 } , \
        15  { "entry_intr:" $DD2 } , \
        16  { "exit_intr:" $DD2 } , \
        17  { "entry_bstart:" $DD2 \
                        bp=$D2 pblock=$D4 bcount=$D5 bflags($D3) }, \
        18  { "exit_bstart:" $DD2 $SKIP} , \
        19  { "entry_cstart:" $DD2 } , \
        1A  { "exit_cstart:" $DD2 } , \
        1B  { "entry_iodone:" $DD2 $SKIP } , \
        1C  { "exit_iodone:" $DD2 $SKIP } , \
        1D  { "scsi_intr:" \
                $DD2 "sc_bufp:" XW \
                }, \
        1E  { `coalesce: (bp,sc_bp)=($D2,$D3)` }, \
        1F  { iodone: devtoname($D1) bp=$D2 endtimer(0x221,$D2) }, \
        20  { "performance:" "flag:" X1 "ID:" XW }

DD2 1.0 "" \
        "errno:" X1 "devno:" XW
4FD 1.0 L=KERN "PMSVCS" \
	$GENERIC, \
    	0 { \
            {{ $mode = $HD & 0xFFFF }} \
 	    $mode & 0xF800, \
	    0x0000 { $mode & 0x07F0, \
		   0  { $HL%S1 }, \
		   \* { "unknown subhook" `($mode)` } \
                   }, \
	    0x0800 { $mode & 0x07F0, \
                   0x0010 { $mode & 0x000F, \
                          1 { "reserve_context():\tcalled for" " count="$D1 }, \
                          2 { "reserve_context():\t" "WARNING: not returning to INTBASE" }, \
                          3 { "reserve_context():\t" "count="$D1 " alloccount="$D2 " Totcount="$D3 " Freecount="$D4 " Freereserve="$D5 }, \
                          4 { "reserve_context():\t" "failed count="$D1 " alloccount="$D2 " Totcount="$D3 " Freecount="$D4 " Freereserve="$D5 }, \
                          5 { "reserve_context():\t" "count="$D1 " alloccount="$D2 " Totcount="$D3 " Freecount="$D4 " Freereserve="$D5 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0020 { $mode & 0x000F, \
                          1 { "alloc_context():\tcalled for" " tid="$D1 " pid="$D2 " ptid="$D3 }, \
                          2 { "alloc_context():\tcalled for" " tid="$D1 " pid="$D2 " ptid="$D3 " context already exists" }, \
                          3 { "alloc_context():\tcalled for" " tid="$D1 " pid="$D2 " ptid="$D3 " but Freelist was empty" }, \
                          4 { "alloc_context():\t" "context="$D1 " for new group Tot ="$D2 " Free ="$D3 " Reserve="$D4 }, \
                          5 { "alloc_context():\t" "context="$D1 " tid="$D2 " pid="$D3 " ptid="$D4 " Totcount="$D5 }, \
                          6 { "alloc_context():\t" "Freecount="$D1 " Freereserve="$D2 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0030 { $mode & 0x000F, \
                          1 { "free_context():\tcalled for" " already freed" " context="$D1 " Totcount="$D2 " Freecount="$D3 " Freereserve="$D4 }, \
                          2 { "free_context():\tfree" " context="$D1 " Totcount="$D2 " Freecount="$D3 " Freereserve="$D4 }, \
                          3 { "free_context():\tfree" " context="$D1 " from thread="$D2 " Totcount="$D3 " Freecount="$D4 " Freereserve="$D5 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0040 { $mode & 0x000F, \
                          1 { "free_all_context():\ttry to free a context twice" " to_be_freed="$D1 }, \
                          2 { "free_all_context():\tfree" " context="$D1 " from thread="$D2 " Totcount="$D3 " Freecount="$D4 " Freereserve="$D5 }, \
                          3 { "free_all_context():\t" " cntx_count="$D1 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0050 { $mode & 0x000F, \
                          1 { "collect_context():\t" "WARNING: not returning to INTBASE" }, \
                          2 { "collect_context():\t" "Freecount="$D1 " Freecount+delta="$D2 " Freereserve="$D3 " delta="$D4 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0060 { $mode & 0x000F, \
                          1 { "update_group_context():\t" "action="$D1 " context="$D2 " group="$D3 " refcount="$D4 }, \
                          2 { "update_group_context():\t" "flags="$D1 " consistent 1 process 2 valid 4" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0070 { $mode & 0x000F, \
                          1 { "accumulate_context():\tunlink from invalid group" " context="$D1 " tid="$D2 " group="$D3 }, \
                          2 { "accumulate_context():\tcould not reset pmcontext pointer for thread" " tid="$D1 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0080 { $mode & 0x000F, \
                          1 { "restore_context():\trestore:unlink invalid group" " tpmc="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " group="$D5 }, \
                          2 { "restore_context():\tjoining reprog group" " tpmc="$D1  " pid="$D2 " tid="$D3 }, \
                          3 { "restore_context():\tcould not reset pmcontext pointer" " pid="$D1 " tid="$D2 " ptid="$D3 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0090 { $mode & 0x000F, \
                          1 { "context_handler():\tcannot reserve pm_pid_cntx_list" " pid="$D1 " tid="$D2 " ptid="$D3 " parent="$D4 }, \
                          2 { "context_handler():\tcannot reserve pmcontext" " pid="$D1 " tid="$D2 " ptid="$D3 " parent="$D4 }, \
                          3 { "context_handler():\tParent has no context" " pid="$D1 " tid="$D2 " ptid="$D3 " parent="$D4 }, \
                          4 { "context_handler():\tcannot reserve pm_pid_cntx_list(dispatch)" " pid="$D1 " tid="$D2 " ptid="$D3 " parent="$D4 }, \
                          5 { "context_handler():\tcannot reserve pmcontext(dispatch)" " pid="$D1 " tid="$D2 " ptid="$D3 " parent="$D4 }, \
                          6 { "context_handler():\tthreadinit after a fork" " pid="$D1 " tid="$D2 " ptid="$D3 " parent="$D4 " pid_of_tid="$D5 }, \
                          7 { "context_handler():\tcould not set pmcontext for new thread" " reason="$D1 " pid="$D2 " tid="$D3 }, \
                          8 { "context_handler():\tnew context" " reason="$D1 " pid="$D2 " tid="$D3 " newcontext="$D4 }, \
                          9 { "context_handler():\tcannot allocate pmcontext" "reason="$D1 "pid="$D2 "tid="$D3 "parent="$D4 }, \
                          a { "context_handler():\tthe exiting thread has a context" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 }, \
                          b { "context_handler():\tthe exiting thread has a context" " mycontext="$D1 " group="$D2 " tid="$D3 " ptid="$D4 }, \
                          c { "context_handler():\tcould not reset pmcontext pointer" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 }, \
                          d { "context_handler():\tfork" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " parent="$D5 }, \
                          e { "context_handler():\tfork" " context="$D1 " group="$D2 }, \
                          f { "context_handler():\tnewcontext" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " newcontext="$D5 }, \
			  \* { "unknown number" } \
                          }, \
                   0x00a0 { $mode & 0x000F, \
                          1 { "unconfig_context():\tcalled for" " try to free a context twice" " to_be_freed="$D1 }, \
                          \* { "unknown number" } \
                          }, \
                   0x00b0 { $mode & 0x000F, \
                          1 { "context_handler():\tcannot allocate pmcontext" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " parent="$D5 }, \
                          2 { "context_handler():\tdispatch" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " thread.ptid="$D5 }, \
                          3 { "context_handler():\tdispatch" " mycontext="$D1 " group="$D2 }, \
                          4 { "context_handler():\tcould not reset pmcontext pointer" " reason="$D1 " pid="$D2 " tid="$D3 " thread.ptid="$D4 }, \
                          5 { "context_handler():\tcould not reset pmcontext pointer" " reason="$D1 " pid="$D2 " tid="$D3 " thread.ptid="$D4 }, \
                          6 { "context_handler():\tcannot allocate pmcontext" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " thread.ptid="$D4 }, \
                          7 { "context_handler():\tnot in a valid group" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 }, \
                          8 { "context_handler():\tjoining new group" " reason="$D1 " new group="$D2 " old group="$D3 }, \
                          9 { "context_handler():\trestore the hardware counters" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " newcontext="$D5 }, \
                          a { "context_handler():\trestore the hardware counters" " group="$D1 }, \
                          b { "context_handler():\tmode changes" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " mycontext="$D5 }, \
                          c { "context_handler():\tmode changes" " group="$D1 }, \
                          d { "context_handler():\tcontext chained into the per-process" " reason="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " mycontext="$D5 }, \
                          e { "context_handler():\tPROCHR callback default" " reason="$D1 " tid="$D2 }, \
                          \* { "unknown number" } \
                          }, \
		   \*     { "pmcontext: unknown function" ` ($mode)` } \
		   }, \
	    0x1000 { $mode & 0x07F0, \
                   0x0010 { $mode & 0x000F, \
                          1 { "pm_init_eprof():\tcalled for" " kregs.pmc["$D1"]="$D2 }, \
                          2 { "pm_init_eprof():\tcalled for" " Prof_pmc="$D1 " Aggress_pmc="$D2 }, \
                          3 { "pm_init_eprof():\tcalled for" " Aggress_threshold="$D1 }, \
                          4 { "pm_init_eprof():\tpm_init_eprof: only one option" }, \
                          5 { "pm_init_eprof():\twhen running on GS, pmc5-6 can not be used" }, \
                          6 { "pm_init_eprof():\tkregs.mmcr["$D1"]="$D2 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0020 { $mode & 0x000F, \
                          1 { "register_eprof():"  }, \
                          2 { "register_eprof():\tcalled for" " Reset_regs_p="$D1 }, \
                          3 { "register_eprof():\tcalled for" " Dup_reset_regs_p="$D1 }, \
                          \* { "unknown number" } \
                          }, \
		   \*     { "pmeprof: unknown function" ` ($mode)` } \
		   }, \
	    0x1800 {  $mode & 0x07F0, \
                   0x0010 { $mode & 0x000F, \
                          1 { "pmAlloc():\tcalled for" " virtual_only_flag="$D1 " size="$D2 " rheap_remain="$D3 }, \
                          2 { "pmAlloc():\tcalled for" " vaddr="$D1 " raddr="$D2 " size="$D3 " pagesize="$D4 }, \
                          3 { "pmAlloc():\tcalled for" " address="$D1 " Rheap_esid="$D2 }, \
                          4 { "pmAlloc():\tcalled for" " esida="$D1 }, \
                          5 { "pmAlloc():\tcalled for" " address="$D1 }, \
                          6 { "pmAlloc():\tRmalloc failed." }, \
                          7 { "pmAlloc():\tRmalloc cannot be used." }, \
                          8 { "pmAlloc():\ttry xmalloc (%u, ...)." }, \
                          9 { "pmAlloc():\tOk. Address." " address="$D1}, \
                          a { "pmAlloc():\tFailed." }, \
                          b { "pmAlloc():\tGet real address." }, \
                          c { "pmAlloc():\tReal start end." " real_end="$D1 $D2 " read_end="$D3 $D4 }, \
                          d { "pmAlloc():\tRejected. Out of range." }, \
                          e { "pmAlloc():\tOk." }, \
                          f { "pmAlloc():\tpmAlloc: address" " address="$D1 " size="$D2 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0020 { $mode & 0x000F, \
                          1 { "pmFree():\tcalled for" " address="$D1 " size="$D2 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0030 { $mode & 0x000F, \
                          1 { "register_handlers():\tVcom_ar" }, \
                          2 { "register_handlers():\tVcom_ar" " Vcom_ar="$D1 }, \
                          3 { "register_handlers():\tVcom_ar assigned into patch area at" " Vcom_ar="$D1 }, \
                          4 { "register_handlers():\tVcom_ar" " Vcom_ar="$D1 }, \
                          \* { "unknown number" } \
                          }, \
                   0x0040 { $mode & 0x000F, \
                          1 { "pmError():\tcalled for" " err_code="$D1 }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { " pminit: unknown function" ` ($mode)` } \
                   }, \
	    0x2000 {  $mode & 0x07F0, \
                   0x0010 { $mode & 0x000F, \
                          1 { "pm_create_thread_context():\tcalled for" " thread="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " group="$D5 }, \
		          \* { "unknown number" } \
                          }, \
                   0x0020 { $mode & 0x000F, \
                          1 { "pm_get_context_program():\tcalled for thread/group" " thread="$D1 " group="$D2 }, \
                          2 { "pm_get_context_program():\tcalled for thread/group" " tpmc="$D1 " pid="$D2 " tid="$D3 " ptid="$D4 " mmcr[0]="$D5 }, \
		          \* { "unknown number" } \
                          }, \
                   0x0030 { $mode & 0x000F, \
                          1 { "pm_delete_context_program():\tcalled for" " thread="$D1 " group="$D2 }, \
                          2 { "pm_delete_context_program():\tcalled for" " tpmc="$D1 " tpid="$D2 " ttid="$D3 " tptid="$D4 }, \
		          \* { "unknown number" } \
                          }, \
                   0x0040 { $mode & 0x000F, \
                          1 { "pm_start_context_counting():\tcalled for" " thread="$D1 " group="$D2 }, \
                          2 { "pm_start_context_counting():\tcalled for" " tpmc="$D1 " tpid="$D2 " ttid="$D3 " tptid="$D4 }, \
		          \* { "unknown number" } \
                          }, \
                   0x0050 { $mode & 0x000F, \
                          1 { "pm_stop_context_counting():\tcalled for" " thread="$D1 " group="$D2}, \
                          2 { "pm_stop_context_counting():\tcalled for" " tpmc="$D1 " tpid="$D2 " ttid="$D3 " tptid="$D4 }, \
		          \* { "unknown number" } \
                          }, \
                   0x0060 { $mode & 0x000F, \
                          1 { "pm_get_context_data():\tcalled for" " tpid="$D1 " ttid="$D2 " tptid="$D3 }, \
                          2 { "pm_get_context_data():\tcalled for" " tpmc="$D1 " group="$D2 " tpid="$D3 " ttid="$d4 " tptid="$D5 }, \
		          \* { " unknown number" } \
                          }, \
                   0x0070 { $mode & 0x000F, \
                          1 { "pm_reset_context_data():\tcalled for" " thread="$D1 " group="$D2 }, \
                          2 { "pm_reset_context_data():\tcalled for" " tpmc="$D1 " tpid="$D2 " ttid="$D3 " tptid="$D4 }, \
		          \* { "unknown number" } \
                          }, \
	           \*     { "pmsvcs: unknown function" ` ($mode)` } \
                   }, \
	    \* {   "unknown module " ` ($mode)` } \
	    }, \
	\* { "not generic" }
4FE 1.0 L=SVC "PM_SVC" \
        $GENERIC, \
        0 { \
            {{ $mode = $HD & 0xFFFF}} \
            $mode & 0xFF00, \
            0x0000 { $mode & 0x07F0, \
                   0  { $HL%S1 }, \
                   \* { "unknown subhook" `($mode)` } \
                   }, \
            0x0100 { $mode & 0x003F, \
                   1 { "pm_set_global_msr" }, \
                   2 { "pm_set_global_msr :\tcalled for" " msr_bits="$D1 }, \
                   3 { "pm_set_global_msr :\treturn error" " no slih registered" }, \
                   4 { "pm_set_global_msr :\treturn error" " non-perfmon bits are set" }, \
                   5 { "pm_set_global_msr :\treturn error" " illegal combination of legal bits" }, \
                   6 { "pm_set_global_msr :\treturn" }, \
                   \*     { "pm_set_global_msr: unknown subhook" ` ($mode)` } \
                   }, \
            0x0200 { $mode & 0x003F, \
                   1 { "pm_run_loop" }, \
                   2 { "pm_run_loop" " uloop="$D1 }, \
                   3 { "pm_run_loop return error" " Pm_partmig="$D1 }, \
                   4 { "pm_run_loop return" " rc="$D1 }, \
                   \*     { "pm_run_loop: unknown subhook" ` ($mode)` } \
                   }, \
            0x0300 { $mode & 0x003F, \
                   1 { "pm_uregs_op" }, \
                   2 { "pm_uregs_op" " cpuid="$D1 " uop="$D2 " udata="$D3 " ureset="$D4 }, \
                   3 { "pm_uregs_op return error" " cpuid incorrect" }, \
                   4 { "pm_uregs_op return error" " copyin udata" }, \
                   5 { "pm_uregs_op return error" " copyin ureset" }, \
                   6 { "pm_uregs_op return error" " copyin kdata" }, \
                   7 { "pm_uregs_op return" }, \
                   \*     { "pm_uregs_op: unknown subhook" ` ($mode)` } \
                   }, \
            0x0400 { $mode & 0x003F, \
                   1 { "pm_usregs_op" }, \
                   2 { "pm_usregs_op" " cpuid="$D1 " uop="$D2 " udata="$D3 }, \
                   3 { "pm_usregs_op return error" " Pm_partmig >1" }, \
                   4 { "pm_usregs_op return error" " cpuid incorrect" }, \
                   5 { "pm_usregs_op return error" " copyin udata" }, \
                   6 { "pm_usregs_op return error" " wasfunnelled="$D1 }, \
                   7 { "pm_usregs_op return error" " copyin kdata" }, \
                   8 { "pm_usregs_op return" }, \
                   \*     { "pm_usregs_op: unknown subhook" ` ($mode)`} \
                   }, \
            0x0500 { $mode & 0x003F, \
                   1 { "pm_get_pmdata" }, \
                   2 { "pm_get_pmdata" " lcpuid="$D1 " results="$D2 " accu="$D3 }, \
                   3 { "pm_get_pmdata return error" " Pm_partmig >1" }, \
                   4 { "pm_get_pmdata return error" " Perfmon_prog_set.mmcr is NULL" }, \
                   5 { "pm_get_pmdata return error" " total is NULL" }, \
                   6 { "pm_get_pmdata return error" " rc="$D1 }, \
                   7 { "pm_get_pmdata return error" " max_ncpus="$D1 }, \
                   8 { "pm_get_pmdata return error" " pm_get_pmdata_cpu_internal="$D1 }, \
                   9 { "pm_get_pmdata return error" " Bad CPU" }, \
                   a { "pm_get_pmdata return error" " copyout results" }, \
                   b { "pm_get_pmdata return error" " copyout accu" }, \
                   c { "pm_get_pmdata return error" " copyout64 results" }, \
                   d { "pm_get_pmdata return error" " copyout64 accu" }, \
                   e { "pm_get_pmdata return" }, \
                   \*     { "pm_get_pmdata: unknown subhook" ` ($mode)` } \
                   }, \
            0x0600 { $mode & 0x003F, \
                   1 { "pm_reset_pmdata" }, \
                   2 { "pm_reset_pmdata" }, \
                   3 { "pm_reset_pmdata return error" " Pm_partmig >1" }, \
                   4 { "pm_reset_pmdata return error" " Perfmon_prog_set.mmcr is NULL" }, \
                   5 { "pm_reset_pmdata return error" " wasfunnelled < 0" }, \
                   6 { "pm_reset_pmdata return" }, \
                   \*     { "pm_reset_pmdata: unknown subhook" ` ($mode)` } \
                   }, \
            0x0700 { $mode & 0x003F, \
                   1 { "pm_start_count" }, \
                   2 { "pm_start_count" "time="$D1 }, \
                   3 { "pm_start_count return error" " Pm_partmig >1" }, \
                   4 { "pm_start_count return error" " Perfmon_prog_set.mmcr is NULL" }, \
                   5 { "pm_start_count return error" " pm_enter_funnel<0" }, \
                   6 { "pm_start_count return" " rc="$D1 }, \
                   \*     { "pm_start_count: unknown subhook" ` ($mode)` } \
                   }, \
            0x0800 { $mode & 0x003F, \
                   1 { "pm_stop_count" }, \
                   2 { "pm_stop_count" " time="$D1 }, \
                   3 { "pm_stop_count return error" " Pm_partmig >1" }, \
                   4 { "pm_stop_count return error" " Perfmon_prog_set.mmcr is NULL" }, \
                   5 { "pm_stop_count return error" " pm_stop_timers not ok" }, \
                   6 { "pm_stop_count return error" " lcpuid="$D1 "high_cpuid="$D2 }, \
                   7 { "pm_stop_count return" " rc="$D1 }, \
                   \*     { "pm_stop_count: unknown subhook" ` ($mode)` } \
                   }, \
            0x0900 { $mode & 0x003F, \
                   1 { "pm_power4_setup" }, \
                   2 { "pm_power4_setup" }, \
                   3 { "pm_power4_setup return" " rc="$D1 }, \
                   \*     { "pm_power4_setup: unknown subhook" ` ($mode)` } \
                   }, \
            0x0A00 { $mode & 0x003F, \
                   1 { "pm_set_context_program" }, \
                   2 { "pm_set_context_program" " pid="$D1 " tid="$D2 " ptid="$D3 " group="$D4 }, \
                   3 { "pm_set_context_program" " cregs="$D1 " mmcrs="$D2 }, \
                   4 { "pm_set_context_program return error" " Pm_partmig >1" }, \
                   5 { "pm_set_context_program return error" " copyin kcregs" }, \
                   6 { "pm_set_context_program return error" " xmalloc pid_cntx_list" }, \
                   7 { "pm_set_context_program return error" " xmalloc tmmcrs" }, \
                   8 { "pm_set_context_program return error" " copyin mmcrs64" }, \
                   9 { "pm_set_context_program return error" " xmalloc taccu_set" }, \
                   a { "pm_set_context_program return error" " xmalloc gmmcrs" }, \
                   b { "pm_set_context_program return error" " xmalloc gaccu_set" }, \
                   c { "pm_set_context_program return" }, \
                   \*     { "pm_set_context_program: unknown subhook" ` ($mode)` } \
                   }, \
            0x0B00 { $mode & 0x003F, \
                   1 { "pm_get_context_program" }, \
                   2 { "pm_get_context_program" " pid="$D1 " tid="$D2 " ptid="$D3 " group="$D4 }, \
                   3 { "pm_get_context_program" " cregs="$D1 " mmcrs="$D2 " nb_set="$D3 }, \
                   4 { "pm_get_context_program return error" " Pm_partmig >1" }, \
                   5 { "pm_get_context_program return error" " xmalloc kcregs.mmcr" }, \
                   6 { "pm_get_context_program return error" ` ttid == -1` }, \
                   7 { "pm_get_context_program return error" ` ttid == -2` }, \
                   8 { "pm_get_context_program return error" ` ttid == -3` }, \
                   9 { "pm_get_context_program return error" " target thread has no context taccu_set" }, \
                   a { "pm_get_context_program return error" " group flag on and no group" }, \
                   b { "pm_get_context_program return error" " copyout cregs" }, \
                   c { "pm_get_context_program return error" " copyout mmcrs" }, \
                   d { "pm_get_context_program return error" " copyout cregs64" }, \
                   e { "pm_get_context_program return error" " copyout mmcrs64" }, \
                   f { "pm_get_context_program return" }, \
                   \*     { "pm_get_context_program: unknown subhook" ` ($mode)` } \
                   }, \
            0x0D00 { $mode & 0x003F, \
                   1 { "pm_get_context_data" }, \
                   2 { "pm_get_context_data" " pid="$D1 " tid="$D2 " ptid="$D3 " group="$D4 }, \
                   3 { "pm_get_context_data" " results="$D1 " accu="$D2 " nb_set="$D3 }, \
                   4 { "pm_get_context_data return error" " Pm_partmig >1" }, \
                   5 { "pm_get_context_data return error" ` ttid == -1` }, \
                   6 { "pm_get_context_data return error" ` ttid == -2` }, \
                   7 { "pm_get_context_data return error" ` ttid == -3` }, \
                   8 { "pm_get_context_data return error" " target thread has no context" }, \
                   9 { "pm_get_context_data return error" " context is member of an invalid group" }, \
                   a { "pm_get_context_data return error" " thread was member of an invalid group gmmcrs" }, \
                   b { "pm_get_context_data return error" " copyout results" }, \
                   c { "pm_get_context_data return error" " copyout accu" }, \
                   d { "pm_get_context_data return error" " copyout results64" }, \
                   e { "pm_get_context_data return error" " copyout accu64" }, \
                   f { "pm_get_context_data return" }, \
                   \*     { "pm_get_context_data: unknown subhook" ` ($mode)` } \
                   }, \
            0x0E00 { $mode & 0x003F, \
                   1 { "pm_reset_context_data" }, \
                   2 { "pm_reset_context_data" " pid="$D1 " tid="$D2 " ptid="$D3 " group="$D4 }, \
                   3 { "pm_reset_context_data return error" " Pm_partmig >1="$D1 }, \
                   4 { "pm_reset_context_data return error" ` ttid == -1` }, \
                   5 { "pm_reset_context_data return error" ` ttid == -2` }, \
                   6 { "pm_reset_context_data return error" ` ttid == -3` }, \
                   7 { "pm_reset_context_data return error" " target thread has no context taccu_set" }, \
                   8 { "pm_reset_context_data return error" " asking for group and none available" }, \
                   9 { "pm_reset_context_data return" }, \
                   \*     { "pm_reset_context_data: unknown subhook" ` ($mode)` } \
                   }, \
            0x0F00 { $mode & 0x003F, \
                   1 { "pm_start_context_counting" }, \
                   2 { "pm_start_context_counting" " pid="$D1 " tid="$D2 " ptid="$D3 " group="$D4 " time="$D5 }, \
                   3 { "pm_start_context_counting return error" " Pm_partmig >1="$D1 }, \
                   4 { "pm_start_context_counting return error" ` ttid == -1` }, \
                   5 { "pm_start_context_counting return error" ` ttid == -2` }, \
                   6 { "pm_start_context_counting return error" ` ttid == -3` }, \
                   7 { "pm_start_context_counting return error" " target thread has no context taccu_set" }, \
                   8 { "pm_start_context_counting return error" " group flag on and no group" }, \
                   9 { "pm_start_context_counting return error" " context was member" " ttid="$D1 }, \
                   a { "pm_start_context_counting return" " rc="$D1 }, \
                   \*     { "pm_start_context_counting: unknown subhook" ` ($mode)` } \
                   }, \
            0x1000 { $mode & 0x003F, \
                   1 { "pm_stop_context_counting" }, \
                   2 { "pm_stop_context_counting" " pid="$D1 " tid="$D2 " ptid="$D3 " group="$D4 " time="$D5 }, \
                   3 { "pm_stop_context_counting return error" " Pm_partmig >1="$D1 }, \
                   4 { "pm_stop_context_counting return error" ` ttid == -1` }, \
                   5 { "pm_stop_context_counting return error" ` ttid == -2` }, \
                   6 { "pm_stop_context_counting return error" ` ttid == -3` }, \
                   7 { "pm_stop_context_counting return error" " target thread has no context taccu_set" }, \
                   8 { "pm_stop_context_counting return error" " context was member" " ttid ="$D1 }, \
                   9 { "pm_stop_context_counting return error" " group flag on and no group" " ttid="$D1 }, \
                   a { "pm_stop_context_counting return" " rc="$D1 }, \
                   \*     { "pm_start_context_counting: unknown subhook" ` ($mode)` } \
                   }, \
            0x1100 { $mode & 0x003F, \
                   1 { "pm_create_thread_group" }, \
                   2 { "pm_create_thread_group" " pid="$D1 " ptid="$D2 " tidlist="$D3 " ntids="$D4 " process="$D5 }, \
                   3 { "pm_create_thread_group" " cregs="$D1 " ummcrs="$D2 }, \
                   4 { "pm_create_thread_group return error" " Pm_partmig >1="$D1 }, \
                   5 { "pm_create_thread_group return error" " ntids < 1="$D1 }, \
                   6 { "pm_create_thread_group return error" " xmalloc ktidlist" }, \
                   7 { "pm_create_thread_group return error" " copyin ktidlist (IS64U)" }, \
                   8 { "pm_create_thread_group return error" " copyin ktidlist (IS32U)" }, \
                   9 { "pm_create_thread_group return error" " copyin kcregs" }, \
                   a { "pm_create_thread_group return error" " copyin64 kcregs" }, \
                   b { "pm_create_thread_group return error" " xmalloc pool" }, \
                   c { "pm_create_thread_group return error" " xmalloc pool..mmcr" }, \
                   d { "pm_create_thread_group return error" " xmalloc pool.accu_set" }, \
                   e { "pm_create_thread_group return error" " copyin mmcr" }, \
                   f { "pm_create_thread_group return error" " reserve_context is NULL" }, \
                   0x10 { "pm_create_thread_group return error" " xmalloc pid_cntx_list" }, \
                   0x11 { "pm_create_thread_group return error" " pm_create_thread_context rc="$D1 }, \
                   0x12 { "pm_create_thread_group return error" " only one thread" }, \
                   0x13 { "pm_create_thread_group return error" " rc="$D1 }, \
                   \*     { "pm_create_thread_group: unknown subhook" ` ($mode)` } \
                   }, \
            0x1200 { $mode & 0x003F, \
                   1 { "pm_init_count" }, \
                   2 { "pm_init_count" " pmregs="$D1 " ummcrs="$D2 " upmcs="$D3 }, \
                   3 { "pm_init_count return error" " Pm_partmig >1="$D1 }, \
                   4 { "pm_init_count return error" " copyin pmregs rc="$D1 }, \
                   5 { "pm_init_count return error" " xmalloc mmcr" }, \
                   6 { "pm_init_count return error" " copyin mmcr" }, \
                   7 { "pm_init_count return error" " xmalloc pmc" }, \
                   8 { "pm_init_count return error" " copyin pmc" }, \
                   9 { "pm_init_count return error" " xmalloc accu" }, \
                   a { "pm_init_count return" }, \
                   \*     { "pm_init_count: unknown subhook" ` ($mode)` } \
                   }, \
            0x1300 { $mode & 0x003F, \
                   1 { "pm_delete_count" }, \
                   2 { "pm_delete_count" }, \
                   3 { "pm_delete_count return error" " Pm_partmig >1="$D1 }, \
                   4 { "pm_delete_count return" }, \
                   \*     { "pm_delete_count: unknown subhook" ` ($mode)` } \
                   }, \
            0x1400 { $mode & 0x003F, \
                   1 { "pm_get_context_nb_slice" }, \
                   2 { "pm_get_context_nb_slice" " pid="$D1 " tid="$D2 " ptid="$D3 }, \
                   3 { "pm_get_context_nb_slice return error" " Pm_partmig >1="$D1 }, \
                   4 { "pm_get_context_nb_slice return" }, \
                   \*     { "pm_get_context_nb_slice: unknown subhook" ` ($mode)` } \
                   }, \
            0x1800 { $mode & 0x003F, \
                   1 { "pm_patch_kernel" }, \
                   2 { "pm_patch_kernel" " Libpmapi_patch="$D1 }, \
                   3 { "pm_patch_kernel return error" " CONFIG_PMCONTEXT error" }, \
                   4 { "pm_patch_kernel return error" " CONFIG_PERFMON error" }, \
                   5 { "pm_patch_kernel return" " rc="$D1 " undo_rc="$D2 }, \
                   \*     { "pm_patch_kernel: unknown subhook" ` ($mode)` } \
                   }, \
            0x1900 { $mode & 0x003F, \
                   1 { "pm_unpatch_kernel" }, \
                   2 { "pm_unpatch_kernel" " Libpmapi_patch="$D1 " force="$D2 }, \
                   3 { "pm_unpatch_kernel return" " rc="$D1 }, \
                   \*     { "pm_unpatch_kernel: unknown subhook" ` ($mode)` } \
                   }, \
            0x1a00 { $mode & 0x003F, \
                   1 { "pm_set_perfm_regs" }, \
                   2 { "pm_set_perfm_regs" " cpuid="$D1 " op="$D2 }, \
                   3 { "pm_set_perfm_regs return error" " lcpuid="$D1 }, \
                   4 { "pm_set_perfm_regs return error" " wasfunnelled="$D1 }, \
                   5 { "pm_set_perfm_regs return" }, \
                   \*     { "pm_set_perfm_regs: unknown subhook" ` ($mode)` } \
                   }, \
            0x1b00 { $mode & 0x003F, \
                   1 { "pm_register_sc_" }, \
                   2 { "pm_register_sc" " command="$D1 }, \
                   3 { "pm_register_sc return" }, \
                   \*     { "pm_register_sc: unknown subhook" ` ($mode)` } \
                   }, \
            0x1c00 { $mode & 0x003F, \
                   1 { "pm_init_eprof" }, \
                   2 { "pm_init_eprof" " uregs="$D1 " which_prof="$D2 " uevt="$D3 " freq="$D4 }, \
                   3 { "pm_init_eprof return error" " only one option" }, \
                   4 { "pm_init_eprof return error" " on GS, pmc5-6 can not be used" }, \
                   5 { "pm_init_eprof return" }, \
                   \*     { "pm_register_sc: unknown subhook" ` ($mode)` } \
                   }, \
            0x1d00 { $mode & 0x003F, \
                   1 { "pm_register_eprof" }, \
                   2 { "pm_register_eprof" " opts="$D1 }, \
                   3 { "pm_register_eprof return error" " other tprof -E are in pm_register" }, \
                   4 { "pm_register_eprof return error" " no perfmon flih are registered" }, \
                   5 { "pm_register_eprof return error" " xmalloc Reset_regs_p" }, \
                   6 { "pm_register_eprof return error" " xmalloc Dup_reset_regs_p" }, \
                   7 { "pm_register_eprof return error" " free rc="$D1 }, \
                   8 { "pm_register_eprof return" }, \
                   \*     { "pm_register_eprof: unknown subhook" ` ($mode)` } \
                   }, \
            0x1e00 { $mode & 0x003F, \
                   1 { "pm_unregister_eprof" }, \
                   2 { "pm_unregister_eprof" }, \
                   3 { "pm_unregister_eprof return" }, \
                   \*     { "pm_unregister_eprof: unknown subhook" ` ($mode)` } \
                   }, \
            0x1f00 { $mode & 0x003F, \
                   1 { "pm_th_pgetpthinfo" }, \
                   2 { "pm_th_pgetpthinfo" " tid="$D1 " scope="$D2 " ptid="$D3 }, \
                   3 { "pm_th_pgetpthinfo return error" " pm_th_getpthinfo rc="$D1 }, \
                   4 { "pm_th_pgetpthinfo return" " rc="$D1 }, \
                   \*     { "pm_th_pgetpthinfo: unknown subhook" ` ($mode)` } \
                   }, \
            0x2000 { $mode & 0x003F, \
                   1 { "pm_getCounterStatus" }, \
                   2 { "pm_getCounterStatus" " cnt_res="$D1 " counter_mode="$D2 " nb_pid="$D3 }, \
                   3 { "pm_getCounterStatus return" " rc="$D1 }, \
                   \*     { "pm_getCounterStatus: unknown subhook" ` ($mode)` } \
                   }, \
            0x2100 { $mode & 0x003F, \
                   1 { "pm_getCounterDetail" }, \
                   2 { "pm_getCounterDetail" " nb_pid="$D1 " buff="$D2 }, \
                   3 { "pm_getCounterDetail return" " i="$D1 }, \
                   \*     { "pm_getCounterDetail: unknown subhook" ` ($mode)` } \
                   }, \
            0x2200 { $mode & 0x003F, \
                   1 { "pm_resetCounterResource" }, \
                   2 { "pm_resetCounterResource" }, \
                   3 { "pm_resetCounterResource return" " rc="$D1 }, \
                   \*     { "pm_resetCounterResource: unknown subhook" ` ($mode)` } \
                   }, \
            0x2300 { $mode & 0x003F, \
                   1 { "pm_get_gsmode" }, \
                   2 { "pm_get_gsmode" }, \
                   3 { "pm_get_gsmode return" " gsmode="$D1 }, \
                   \*     { "pm_get_gsmode: unknown subhook" ` ($mode)` } \
                   }, \
            0x2400 { $mode & 0x003F, \
                   1 { "pm_trb_freq_init" }, \
                   2 { "pm_trb_freq_init" " freq="$D1 }, \
                   3 { "pm_trb_freq_init return" " Pm_trb_val="$D1 }, \
                   \*     { "pm_trb_freq_init: unknown subhook" ` ($mode)` } \
                   }, \
            0x2500 { $mode & 0x003F, \
                   1 { "pm_bind_to_logical_cpu" }, \
                   2 { "pm_bind_to_logical_cpu" " cpuid="$D1 }, \
                   \*     { "pm_bind_to_logical_cpu: unknown subhook" ` ($mode)` } \
                   }, \
            0x2600 { $mode & 0x003F, \
                   1 { "pm_entry" }, \
                   2 { "pm_entry" " uiop="$D1 }, \
                   3 { "pm_entry return" " rc="$D1 }, \
                   \*     { "pm_entry: unknown subhook" ` ($mode)` } \
                   }, \
            \* {   "unknown module " ` ($mode)` } \
            }, \
        \* { "not generic" }
4FF 1.0 L=INT "PM_INTR" \
        $GENERIC, \
        0 { \
            {{ $mode = $HD & 0xFFFF}} \
            $mode & 0xFC00, \
            0x0000 { $mode & 0x03F0, \
                   0  { $HL%S1 }, \
                   \* { "unknown subhook" `($mode)`} \
                   }, \
            0x0400 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          0 { "minslih():\tcalled for" " minimum_slih"  }, \
                          \* { "unknown number" } \
                          }, \
                   0x0010 { $mode & 0x000F, \
                          0 { "minslih():\tcalled for" " full_slih fullslih="$D1  }, \
                          \* { "unknown number" } \
                          }, \
                  \*     { "minslih: unknown function" ` ($mode)` } \
                   }, \
            0x0800 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          0 { "minflih():\tcalled for" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0010 { $mode & 0x000F, \
                          0 { "minflih():\tcalled for" }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "minflih: unknown function" ` ($mode)` } \
                   }, \
            0x0C00 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          1 { "counter_handler():\tcalled for" " PROCHR_THREADINIT proch="$D1 " reason="$D2 " tid="$D3 " ptid="$D4 }, \
                          2 { "counter_handler():\tcalled for" " PROCHR_THREADINIT reg_error="$D1 }, \
                          3 { "counter_handler():\tcalled for" " PROCHR_THREADINIT Pm_pid_number="$D1 }, \
                          0 { "counter_handler():\tcalled for" " PROCHR_THREADINIT" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0010 { $mode & 0x000F, \
                          1 { "counter_handler():\tcalled for" " PROCHR_TERMINATE proch="$D1 " reason="$D2 " tid="$D3 " ptid="$D4 }, \
                          2 { "counter_handler():\tcalled for" " PROCHR_TERMINATE Pm_pid_number="$D1 }, \
                          3 { "counter_handler():\tcalled for" " PROCHR_TERMINATE return" }, \
                          4 { "counter_handler():\tcalled for" " PROCHR_TERMINATE Pm_pid_number="$D1 }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "counter_handler: unknown function" ` ($mode)` } \
                   }, \
            0x1000 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_CPU_ADD_PRE" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0010 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_CPU_ADD_POST" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0020 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_CPU_ADD_POST_ERROR" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0030 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_CPU_REMOVE_PRE" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0040 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_CPU_REMOVE_POST" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0050 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_CPU_REMOVE_POST_ERROR" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0060 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_PMIG_CHECK" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0070 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_PMIG_PRE" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0080 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_PMIG_POST" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0090 { $mode & 0x000F, \
                          0 { "pmsvcs_dr_handler():\tcalled for" " DR_PMIG_POST_ERROR" }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "pmsvcs_dr_handler: unknown function" ` ($mode)` } \
                   }, \
            0x1400 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          1 { "context_handler():\tcalled for" " PROCHR_THREADINIT proch="$D1 " reason="$D2 " tid="$D3 " ptid=$D4" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0010 { $mode & 0x000F, \
                          1 { "context_handler():\tcalled for" " PROCHR_TLOCAL_INIT proch="$D1 " reason="$D2 " tid="$D3 " ptid=$D4" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0020 { $mode & 0x000F, \
                          1 { "context_handler():\tcalled for" " PROCHR_TLOCAL_DISPATCH proch="$D1 " reason="$D2 " tid="$D3 " ptid=$D4" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0030 { $mode & 0x000F, \
                          1 { "context_handler():\tcalled for" " PROCHR_THREADTERM proch="$D1 " reason="$D2 " tid="$D3 " ptid=$D4" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0040 { $mode & 0x000F, \
                          1 { "context_handler():\tcalled for" " PROCHR_TLOCAL_TERM proch="$D1 " reason="$D2 " tid="$D3 " ptid=$D4" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0050 { $mode & 0x000F, \
                          1 { "context_handler():\tcalled for" " PROCHR_TERMINATE proch="$D1 " reason="$D2 " tid="$D3 " ptid=$D4" }, \
                          \* { "unknown number" } \
                          }, \
                   0x0060 { $mode & 0x000F, \
                          1 { "context_handler():\tcalled for" " PROCHR_TLOCAL_MODE proch="$D1 " reason="$D2 " tid="$D3 " ptid=$D4" }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "context_handler: unknown function" ` ($mode)` } \
                   }, \
            0x1800 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          1 { "context_dispatcher():\tcalled for" " oldcontext="$D1 " newcontext="$D2 }, \
                          2 { "context_dispatcher():\tcalled for" " CONT_COUNTING" }, \
                          3 { "context_dispatcher():\tcalled for" " STOP_COUNTING" }, \
                          4 { "context_dispatcher():\tcalled for" " restore_context" }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "context_dispatcher: unknown function" ` ($mode)` } \
                   }, \
            0x1C00 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          1 { "pm_trb_handler():\tcalled for" " trb="$D1 }, \
                          2 { "pm_trb_handler() return" }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "pm_trb_handler: unknown function" ` ($mode)` } \
                   }, \
            0x2000 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          1 { "pm_trb_mx_sw_handler():\tcalled for" " trb="$D1 }, \
                          2 { "pm_trb_mx_sw_handler() return" }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "pm_trb_mx_sw_handler: unknown function" ` ($mode)` } \
                   }, \
            0x2400 { $mode & 0x03F0, \
                   0x0000 { $mode & 0x000F, \
                          1 { "ep_slih():\tcalled for" " fullsavea="$D1 }, \
                          2 { "ep_slih() return" }, \
                          0 { "ep_slih():\tcalled for" }, \
                          \* { "unknown number" } \
                          }, \
                   \*     { "ep_slih: unknown function" ` ($mode)` } \
                   }, \
            \* {   "unknown module " ` ($mode)` } \
            }, \
        \* { "not generic" }
355 1.0 "PDIAGEX"                                             \
	{{ $dummy = X2 }}                                       \
        A4 W2 "arg1="XW "arg2=" XW "arg3=" XW
102B 1.0 "@AHAFS VFS and VNODE operations" \
	HT & 0x4000, \
	0x4000 { \
		$D1, \
		0x11  { "parse_buf() buf is " G16 $HL%S1 }, \
		0x2C  { "ahafs_create() name is " G16 $HL%S1 }, \
		0x38  { "ahafs_lookup() name is " G16 $HL%S1 }, \
		0x3B  { "ahafs_mkdir() name is " G16 $HL%S1 }, \
		0x49  { "ahafsGetNewNodeType() suffix is " G16 $HL%S1 } \
		$BREAK \
	} \
	$HD, \
	0x01  { "ahafs_rdwr enter " vnp=$D1 rw=$D2 flags=$D3 vattrp=$D4 }, \
	0x02  { "ahafs_rdwr exit " \
		$D1, \
		0x00  { "succeeded." aha_type=$D2 rw=$D3 }, \
		0x01  { "ERROR: invalid vnp or NULL uiop." rc=EINVAL vp=$D2 uiop=$D3 }, \
		0x02  { "ERROR:" rc=$D2 aha_type=$D3 rw=$D4 } }, \
	0x03  { "ahafsFileReadUio_evProdsList enter " uiop=$D1 }, \
	0x05  { "ahafsFileReadUio_evProdsList exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: negative uio_offset." rc=EINVAL uio_offset=$D2 }, \
		0x06  { "returns." rc=$D2 kern_rc=$D3 }, \
		0x10000  { "succeeded. uio_offset >= bufSz." uio_offset=$D2 bufSz=$D3 kern_rc=$D4 } }, \
	0x06  { "ahafsMonFileReadUio enter " anp=$D1 uiop=$D2 }, \
	0x07  { "ahafsMonFileReadUio " \
		$D1, \
		0x00  { "sleep interrupted." rc=$D2 }, \
		0x01  { anp=$D2 matched_slot_p=$D3 } }, \
	0x08  { "ahafsMonFileReadUio exit " \
		$D1, \
		0x00  { }, \
		0x10000  { "succeeded. matched_slot_p is NULL." pid=$D2 }, \
		0x10001  { "returned." anp=$D2 rc=$D3 } }, \
	0x09  { "ahafsCopyOutBuf enter " evInfo=$D1 uiop=$D2 }, \
	0x0A  { "ahafsCopyOutBuf exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: uiomove() failed. ev_next_read < end. " rc=$D2 }, \
		0x02  { "ERROR: uiomove() failed. uio_resid > 0 && end != ev_bufev_buf" rc=$D2 }, \
		0x03  { "ERROR:" rc=$D2 }, \
		0x10000  { "succeeded. ev_next_read == ev_next_write and no data in buf" }, \
		0x10001  { "succeeded. ev_next_read < end" }, \
		0x10002  { "succeeded. uio_resid > 0 && end != ev_bufev_buf" }, \
		0x10003  { "succeeded." } }, \
	0x0B  { "ahafsMonFileWriteUio enter " anp=$D1 uio=$D2 crp=$D3 }, \
	0x0C  { "ahafsMonFileWriteUio exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: AHANODE_DELETE_PENDING is set." rc=ESTALE aha_flags=$D2 }, \
		0x02  { "ERROR: negative length." rc=EINVAL length=$D2 }, \
		0x03  { "ERROR: length too big." rc=EINVAL length=$D2 AHAFS_MAX_WRITEBUF_LEN=$D3 }, \
		0x04  { "ERROR: negative uio_offset." rc=EINVAL uio_offset=$D2 }, \
		0x05  { "ERROR: wrBuf malloc failed." rc=ENOMEM size=$D2 }, \
		0x07  { "ERROR: avail_slot_p is registering." rc=EBUSY avail_slot_p=$D2 }, \
		0x08  { "ERROR: uiomove() failed." rc=$D2 }, \
		0x0A  { "ERROR: avail_slot_p is monitoring." rc=EBUSY avail_slot_p=$D2 }, \
		0x0B  { "ERROR: type/parameters mismatch." rc=EINVAL anp=$D2 mf_evprod_caps=$D3 whenToNotify=$D4 }, \
		0x0C  { "ERROR: invalid threshold." rc=EINVAL anp=$D2 flags=$D3 mf_evprod_caps=$D4 }, \
		0x0D  { "ERROR: Remote Notify but not enabled." rc=EINVAL anp=$D2 }, \
		0x0E  { "ERROR: Remote Notify but cluster inactive." rc=EINVAL anp=$D2 }, \
		0x0F  { "ERROR: tmp_buf malloc failed." rc=ENOMEM size=$D2 }, \
		0x10000  { "succeeded. notifyCnt is 0" new_slot=$D2 unregister=$D3 notify=$D4 }, \
		0x10001  { "succeeded." unregister=$D2 notify=$D3 } }, \
	0x0E  { "ahafsStrtouint64 enter " buf=$D1 value=$D2 }, \
	0x0F  { "ahafsStrtouint64 exit " \
		$D1, \
		0x00  { "succeeded." value=$D2 }, \
		0x01  { "ERROR: empty string." rc=EINVAL } }, \
	0x10  { "parse_buf enter " buf=$D1 len=$D2 wrInfo=$D3 }, \
	0x11  { }, \
	0x12  { "parse_buf exit " rc=$D1 }, \
	0x13  { "ahafs_readdir_readdir enter " vnp=$D2 uiop=$D3 crp=$D4 }, \
	0x14  { "ahafs_readdir_readdir " \
		$D1, \
		0x00  { vnp=$D2 aha_type=$D3 uiop=$D4 }, \
		0x01  { uio_offset=$D2 uio_resid=$D3 } }, \
	0x15  { "ahafs_readdir_readdir exit " rc=$D1 vnp=$D2 }, \
	0x16  { "ahafsReaddirAll enter " anp=$D1 uiop=$D2 crp=$D3 }, \
	0x17  { "ahafsReaddirAll exit " rc=$D1 offiset=$D2 }, \
	0x18  { "ahafsCreateDirent enter " buf=$D1 name=$D2 ino=$D3 offset=$D4 }, \
	0x19  { }, \
	0x1A  { "ahafsCreateDirent exit " d_offset=$D1 d_ino=$D2 d_reclen=$D3 }, \
	0x1B  { "ahafsReadDirents enter " \
		$D1, \
		0x00  { anp=$D1 offset=$D2 resid=$D3 tbytes=$D4 }, \
		0x01  { slot=$D1 boff=$D2 } }, \
	0x1D  { "ahafsReadDirents exit " \
		$D1, \
		0x10003  { offset=$D2 resid=$D3 tbytes=$D4 }, \
		0x10004  { slot=$D2 boff=$D3 } }, \
	0x1E  { "ahafs_select enter " vnp=$D1 corl=$D2 reqevents=$D3 rtneventsp=$D4 }, \
	0x1F  { "ahafs_select " \
		$D1, \
		0x00  { anp=$D2 }, \
		0x01  { anp=$D2 selectId=$D3 } }, \
	0x20  { "ahafs_select exit " \
		$D1, \
		0x00  { "return." rc=$D2 anp=$D3 rtneventsp=$D4 }, \
		0x01  { "ERROR: invalid vnp." rc=EINVAL vnp=$D2 }, \
		0x02  { "ERROR: AHANODE_DELETE_PENDING." rc=ESTALE anp=$D2 aha_flags=$D3 }, \
		0x03  { "ERROR: not a monitor file." rc=ESTALE anp=$D2 aha_type=$D3 }, \
		0x04  { "ERROR: busy registering." rc=EBUSY anp=$D2 matched_slot_p=$D3 }, \
		0x05  { "ERROR: selreg() failed." rc=$D2 anp=$D3 }, \
		0x06  { "ERROR: invalid parameters." rc=EINVAL anp=$D3 } }, \
	0x21  { "ahafs_nosys" }, \
	0x22  { "ahafs_access enter " vnp=$D1 mode=$2 who=$D3 crp=$D4 }, \
	0x23  { "ahafs_access exit " \
		$D1, \
		0x00  { "succeeded." }, \
		0x01  { "ERROR: invalid vnp." rc=EINVAL vnp=$D2 }, \
		0x02  { "ERROR:." rc=$D2 mode=$D3 aha_mode=$D4 who=$D5 } }, \
	0x24  { "ahafs_open enter " vnp=$D1 flag=$2 ext=$D3 vinfop=$D4 crp=$D5 }, \
	0x25  { "ahafs_open " anp=$D1 aha_type=$D2 flag=$D3 }, \
	0x26  { "ahafs_open exit " rc=$D1 }, \
	0x27  { "ahafs_close enter " vnp=$D1 flag=$D2 vinfo=$D3 crp=$D4 }, \
	0x28  { "ahafs_close exit " rc=$D1 }, \
	0x29  { "ahafs_seek enter " vp=$D1 offp=$D2 crp=$D3 }, \
	0x2A  { "ahafs_seek exit " rc=$D1 }, \
	0x2B  { "ahafs_create enter " dvp=$D1 flags=$2 name=$D3 mode=$D4 vinfo=$D5 }, \
	0x2C  { }, \
	0x2D  { }, \
	0x2E  { "ahafs_create exit " \
		$D1, \
		0x01  { "ERROR: umounting." rc=ESTALE dvp=$D2 }, \
		0x02  { "ERROR: invalid dvp." rc=EINVAL dvp=$D2 }, \
		0x03  { "ERROR: not a directory." rc=ENOTDIR dvp=$D2 }, \
		0x0C  { "ERROR: parent directory is being deleted." rc=ENOENT dvp=$D2 }, \
		0x0D  { "return." dvp=$D2 rc=$D3 } }, \
	0x2F  { "ahafs_remove enter " vp=$D1 dp=$2 name=$D3 crp=$D4 }, \
	0x30  { "ahafs_remove exit " \
		$D1, \
		0x00  { "return." rc=$D2 }, \
		0x01  { "ERROR: invalid vp/dvp." rc=EINVAL vp=$D2 dvp=$D3 } }, \
	0x31  { "ahafs_hold enter " vnp=$D1 }, \
	0x32  { "ahafs_hold " vnp=$D1 v_count=$D2 caller=$D3 caller2=$D4 caller3=$D5 }, \
	0x33  { "ahafs_hold exit " \
		$D1, \
		0x00  { "succeeded." }, \
		0x01  { "ERROR: invalid vnp." rc=EINVAL vnp=$D2 } }, \
	0x34  { "ahafs_rele enter " vnp=$D1 }, \
	0x35  { "ahafs_rele " vnp=$D1 v_count=$D2 caller=$D3 caller2=$D4 caller3=$D5 }, \
	0x36  { "ahafs_rele exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: invalid vnp." rc=EINVAL vnp=$D2 } }, \
	0x37  { "ahafs_lookup enter " dvnp=$D1 name=$D2 flag=$D3 vattrp=$D4 crp=$D5 }, \
	0x38  { }, \
	0x39  { "ahafs_lookup exit " \
		$D1, \
		0x00  { "return." dvnp=$D2 rc=$D3 }, \
		0x01  { "ERROR: unmounting." rc=ESTALE dvnp=$D2 }, \
		0x02  { "ERROR: invalid dvnp." rc=EINVAL dvnp=$D2 } }, \
	0x3A  { "ahafs_mkdir enter " dvnp=$D1 name=$D2 mode=$D3 crp=$D4 }, \
	0x3B  { }, \
	0x3C  { "ahafs_mkdir exit " rc=$D1 }, \
	0x3D  { "ahafs_rmdir enter " vp=$D1 dp=$D2 name=$D3 crp=$D4 }, \
	0x3E  { "ahafs_rmdir exit " rc=$D1 }, \
	0x3F  { "ahafs_getattr enter " vnp=$D1 vattrp=$D2 crp=$D3 }, \
	0x40  { "ahafs_getattr exit ERROR: invalid vnp." rc=EINVAL vnp=$D2 }, \
	0x41  { "ahafs_setattr enter " vnp=$D1 op=$D2 arg1=$D3 arg2=$D4 arg3=$D5 }, \
	0x42  { "ahafs_setattr exit " \
		$D1, \
		0x00  { "return." rc=$D2 }, \
		0x01  { "ERROR: invalid vnp." rc=EINVAL vnp=$D2 } }, \
	0x43  { "ahafs_getacl enter " vp=$D1 uiop=$D2 crp=$D3 }, \
	0x44  { "ahafs_getacl exit " \
		$D1, \
		0x00  { "succeeded" }, \
		0x01  { "ERROR: invalid vp." rc=EINVAL vp=$D2 } }, \
	0x45  { "ahafs_setacl enter " vp=$D1 uiop=$D2 crp=$D3 }, \
	0x46  { "ahafs_setacl exit " \
		$D1, \
		0x00  { "succeeded" }, \
		0x01  { "ERROR: invalid vp." rc=EINVAL vp=$D2 } }, \
	0x47  { "ahafs_fsync exit" \
		$D1, \
		0x00  { "succeeded" }, \
		0x01  { "ERROR: invalid vp." rc=EINVAL vp=$D2 } }, \
	0x48  { "ahafs_ahafsGetNewNodeType enter " name=$D1 default_type=$D2 }, \
	0x49  { }, \
	0x4A  { "ahafs_ahafsGetNewNodeType exit " \
		$D1, \
		0x10000  { "AHA_MONITOR_FACTORY" }, \
		0x10001  { "AHA_MONITOR" }, \
		0x10002  { "AHA_EVPROD_LIST" }, \
		0x10003  { "default_type" } }, \
	0x4B  { "ahafs_mount enter " vfsp=$D1 crp=$D2 }, \
	0x4C  { }, \
	0x4D  { "ahafs_mount exit " \
		$D1, \
		0x00  { "succeeded" }, \
		0x06  { "ERROR: ahafsNodeCreate() failed." rc=$D2 vfsp=$D3 }, \
		0x07  { "ERROR: ahafs_evprods() 1 failed." rc=$D2 kern_rc=$D3 vfsp=$D4 }, \
		0x08  { "ERROR: buf malloc 1 failed." rc=ENOMEM size=$D2 vfsp=$D3 }, \
		0x09  { "ERROR: buf malloc 2 failed." rc=ENOMEM size=$D2 vfsp=$D3 }, \
		0x0A  { "ERROR: ahafs_evprods() 2 failed." rc=$D2 kern_rc=$D3 vfsp=$D4 }, \
		0x0B  { "ERROR: ahafsCreateMonFactory() 2 failed." rc=$D2 vfsp=$D3 } }, \
	0x4E  { "ahafs_unmount enter " vfsp=$D1 flags=$D2 crp=$D3 }, \
	0x4F  { "ahafs_unmount exit " \
		$D1, \
		0x00  { "return" rc=$D2 }, \
		0x10000  {  "succeeded. no ahafs mounts." } }, \
	0x50  { "ahafs_root enter " vfsp=$D1 vnpp=$D2 crp=$D3 }, \
	0x51  { "ahafs_root exit " \
		$D1, \
		0x00  { "succeeded" vnp=$D2 }, \
		0x01  { "ERROR: VFS_SHUTDOWN" rc=ESTALE vfsp=$D2 } }, \
	0x52  { "ahafs_vget"}, \
	0x53  { "ahafs_statfs enter " vfsp=$D1 statfsp=$D2 crp=$D3 }, \
	0x54  { "ahafs_statfs exit" }, \
	0x55  { "ahafs_sync" rc=ENOSYS }, \
	0x56  { "ahafs_cntl" rc=ENOSYS }, \
	0x57  { "ahafs_quotactl" rc=ENOSYS }
102C 1.0 "@AHAFS: Event Management" \
	HT & 0x4000, \
	0x4000 { \
		$D1, \
		0x12  { "ahafsEvMonChkAccess() pathname is " G16 $HL%S1 } \
		$BREAK \
	} \
	$HD, \
	0x01  { "ahafsRegisterEvent enter " anp=$D1 slot_p=$D2 }, \
	0x02  { "ahafsRegisterEvent registration done." }, \
	0x03  { "ahafsRegisterEvent exit " \
		$D1, \
		0x00  { "succeeded." anp=$D2 }, \
		0x01  { "ERROR: anp is stale." rc=ESTALE aha_flags=$D2 }, \
		0x02  { "ERROR: " rc=$D2 anp=$D3 } }, \
	0x04  { "ahafsUnregisterEvent enter " anp=$D1 }, \
	0x05  { "ahafsUnregisterEvent " \
		$D1, \
		0x00  { "anp not found" }, \
		0x01  { "unregister is true" } }, \
	0x06  { "ahafsUnregisterEvent exit " }, \
	0x07  { "ahafsHtabInsertEntry enter " anp=$D1 opqid=$D2 opqid2=$D3 gid=$D4 }, \
	0x08  { "ahafsHtabInsertEntry exit " \
		$D1, \
		0x10000  { "ahaNode already exists" entry=$D2 }, \
		0x10001  { "take one off of the free list" entry=$D2 } }, \
	0x09  { "ahafsHtabFindAndRemove enter " anp=$D1 opqid=$D2 remove_all=$D3 }, \
	0x0A  { "ahafsHtabFindAndRemove " \
		$D1, \
		0x00  { "another ahaNode with the same opqid " return_anp=$D2 }, \
		0x01  { "found it " entry=$D2 } }, \
	0x0B  { "ahafsHtabFindAndRemove exit " return_anp=$D2 }, \
	0x0C  { "ahafsEvMonEnable enter " anp=$D1 thresh_hi=$D2 thresh_lo=$D3 update_type=$D4 }, \
	0x0D  { "ahafsEvMonEnable " \
		$D1, \
		0x00  { "evMonInfo : " evm_threshType=$D2 evm_thresholdLo=$D3 evm_thresholdHi=$D4 }, \
		0x01  { "Event already occurred. " update_type=$D2 evMonInfo.evm_curValue=$D3 thresh_hi=$D4 thresh_lo=$D5 } }, \
	0x0E  { "ahafsEvMonEnable exit " \
		$D1, \
		0x00  { "succeeded." opqid=$D2 opqid2=$D3 gid=$D4 curVal=$D5 }, \
		0x01  { "ERROR: update without evProds threshold value." rc=EINVAL mf_evprod_caps=$D2 update_type=$D3 anp=$D4 }, \
		0x02  { "ERROR: state/value are both on/off." rc=EINVAL isState=$D2 isValue=$D3 anp=$D4 }, \
		0x03  { "ERROR: ahafs_evprods() with AHAFS_EVMON_CHK_THRESH" rc=$D2 kern_rc=$D3 anp=$D4 }, \
		0x04  { "ERROR: hash entry existed. " rc=EEXIST anp=$D2 }, \
		0x05  { "ERROR: ahafs_evprods() with AHAFS_EVMON_ENABLE" rc=$D2 kern_rc=$D3 anp=$D4 } }, \
	0x0F  { "ahafsEvMonDisable enter " anp=$D1 opqid=$D2 opqid2=$D3 update_type=$D4 }, \
	0x10  { "ahafsEvMonDisable exit " kern_rc=$D1 anp=$D2 opqid=$D3 }, \
	0x11  { "ahafsEvMonChkAccess enter " pathname=$D1 mf_data=$D2 }, \
	0x12  { }, \
	0x13  { "ahafsEvMonChkAccess exit " \
		$D1, \
		0x01  { "ERROR: AHAFS_EVPROD_UNAVAILABLE in progress." aha_flags=$d2 }, \
		0x02  { "ERROR: ahafs_evprods() " kern_rc=$D2 } }, \
	0x14  { "ahafs_prod_callback enter " cb_evProdId=$D1 cb_flag=$D2 cb_opgId=$D3 cb_evGid=$D4 cb_curValue=$D5 }, \
	0x15  { "ahafs_prod_callback exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: cbFnInfo is NULL." rc=EINVAL }, \
		0x02  { "ERROR: bad cb_version." rc=EINVAL cb_version=$D2 }, \
		0x05  { "ERROR: Remote Event requested but not enabled." mf_data=$D2 }, \
		0x10000  { "succeeded, Remote Event. " } }, \
	0x16  { "ahafsInitHtab enter " mf_data=$D1 n_entries=$D2 }, \
	0x17  { "ahafsInitHtab exit " \
		$D1, \
		0x00  { "succeeded." mf_htab=$D2 }, \
		0x01  { "ERROR: mf_htab malloc failed. " rc=ENOMEM size=$D2 } }, \
	0x18  { "ahafsFreeHtab enter " mf_data=$D1 mf_htab=$D2 }, \
	0x1A  { "ahafsHtabAllocEntry enter " mf_data=$D1 }, \
	0x1B  { "ahafsHtabAllocEntry exit " \
		$D1, \
		0x00  { "succeeded." mf_data=$D2 entry=$D3 opq_numFree=$D4 opq_numEntries=$D5 }, \
		0x01  { "ERROR: opq_numEntries >= mf_htabSize." rc=ENOSPC opq_numEntries=$D2 mf_htabSize=$D3 }, \
		0x02  { "ERROR: entry malloc failed. " rc=ENOMEM size=$D2 } }, \
	0x1C  { "ahafsHtabFreeEntry " mf_data=$D1 entry=$D2 opq_numFree=$D3 opq_numEntries=$D4 }, \
	0x1D  { "ahafsProcessCallback enter " mf_data=$D1 cbFnInfo=$D2 }, \
	0x1E  { "ahafsProcessCallback exit " }, \
	0x1F  { "ahafsEventNotifyOne enter " anp=$D1 sel_slotp=$D2 cbFnInfo=$D3 mf_ed=$D4 }, \
	0x20  { "ahafsEventNotifyOne " \
		$D1, \
		0x00  { "AHANODE_DELETE_PENDING set "  aha_flags=$D2 }, \
		0x01  { "ev_seq_num >= ev_notify_cnt " ev_seq_num=$D2 ev_notify_cnt=$D3 }, \
		0x03  { "ahafsEventNotifyOne packet send fail" rc=$D2 } }, \
	0x21  { "ahafsEventNotifyOne exit " \
		$D1, \
		0x00  { "returns " \
			$D2, \
			0x00  { "FALSE" }, \
			0x01  { "TRUE" } }, \
		0x01  { "Remote Event. returns TRUE" } }, \
	0x22  { "ahafsProcessNotification " anp=$D2 sel_slotp=$D3 ev_pid=$D4 ev_flags=$D5 }, \
	0x23  { "ahafsEventNotifyAll enter " anp=$D2 cbFnInfo=$D3 mf_ed=$D4 }, \
	0x24  { "ahafsEventNotifyAll exit " \
		$D1, \
		0x00  { "returns FALSE" }, \
		0x01  { "returns TRUE" } }, \
	0x25  { "ahafsEventSearchAndNotify enter " anp=$D1 cbFnInfo=$D2 mf_ed=$D3 }, \
	0x26  { "ahafsEventSearchAndNotify exit " \
		$D1, \
		0x10000  { "new_thresh_mon != old_thresh_mon, return TRUE" new_thresh_mon=$D2 old_thresh_mon=$D3 }, \
		0x10001  { "thresh_lo != old_thresh_lo, return TRUE" thresh_lo=$D2 old_thresh_lo=$D3 }, \
		0x10002  { "thresh_hi != old_thresh_hi, return TRUE" thresh_hi=$D2 old_thresh_hi=$D3 }, \
		0x10003  { "return FALSE" } }
102D 1.0 "@AHAFS LFS Code" \
	HT & 0x4000, \
	0x4000 { \
		$D1, \
		0x06  { "aha_evprod_register() name is " G16 $HL%S1 }, \
		0x07  { "aha_evprod_register() dirName is " G16 $HL%S1 }, \
		0x08  { "aha_evprod_get() name is " G16 $HL%S1 }, \
		0x1E  { "get_localFs_info() fsName is " G16 $HL%S1 }, \
		0x23  { "aha_process_vnop() name is " G16 $HL%S1 }, \
		0x29  { "aha_process_rename() nm is " G16 $HL%S1 }, \
		0x2A  { "aha_process_rename() tnm is " G16 $HL%S1 } \
		$BREAK \
	} \
	$HD, \
	0x02  { "ahafs_initialize enter " buf=$D1 AHAFS_LOADED=$D2 AHAFS_INITIALIZED=$D3 }, \
	0x03  { "ahafs_initialize exit " rc=$D1 }, \
	0x04  { "ahafs_uninitialize" }, \
	0x05  { "ahafs_evprod_register enter " name=$D1 dirName=$D2 func=$D3 size=$D4 caps=$D5 }, \
	0x06  { }, \
	0x07  { }, \
	0x08  { "ahafs_evprod_register exit " \
		$D1, \
		0x00  { "succeed." }, \
		0x03  { "ERROR: name too long." rc=EINVAL_LFS_AHAFS_EVPROD_REGISTER namelen=$D2 }, \
		0x06  { "ERROR: white space in name." rc=EINVAL_LFS_AHAFS_EVPROD_REGISTER }, \
		0x0A  { "ERROR: evprod existed." rc=EEXIST_LFS_AHAFS_EVPROD_REGISTER }, \
		0x0C  { "ERROR: maxed out ahafs_global_id." rc=ENOSPC_LFS_AHAFS_EVPROD_REGISTER size=$D2 }, \
		0x0D  { "ERROR: bad parameters." rc=EINVAL_LFS_AHAFS_EVPROD_REGISTER } }, \
	0x0B  { "aha_evprod_unreg enter " remove_id=$D1}, \
	0x0C  { "aha_evprod_unreg exit " \
		$D1, \
		0x00  { "succeeded." }, \
		0x01  { "ERROR: evp not registered." rc=ENOENT_LFS_AHAFS_EVPROD_UNREG } }, \
	0x0D  { "aha_evprod_get enter " name=$D1 id=$D2 evProd=$D3 }, \
	0x0E  { }, \
	0x0F  { "aha_evprod_get exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: invalid parameters." rc=EINVAL_LFS_AHAFS_GET_EVPROD name=$D2 id=$D3 }, \
		0x02  { "ERROR: evProd not found." rc=EINVAL_LFS_AHAFS_GET_EVPROD }, \
		0x10000 { "succeeded." evProd=$D2 }, \
		0x10001 { "succeeded by id." evProd=$D2 } }, \
	0x10  { "aha_evprods enter " cmd=$D1 buf=$D2 bufSz=$D3 }, \
	0x12  { "aha_evprods exit " \
		$D1, \
		0x00  { }, \
		0x03  { "ERROR: buf is NULL " rc=EEEE000096258005 cmd=4 }, \
		0x04  { "ERROR: bad evp_version " rc=EEEE000096258005 evp_version=$D2 cmd=4 }, \
		0x06  { "ERROR: buf is NULL " rc=EEEE000096258005 cmd=$D3}, \
		0x07  { "ERROR: bad evp_version " rc=EEEE000096258005 evp_version=$D2 cmd=$D3 }, \
		0x08  { "ERROR: aha_evp_func() failed " rc=$D2 cmd=$D3 }, \
		0x0A  { "ERROR: buf is NULL " rc=EEEE000096258005 cmd=10 }, \
		0x0B  { "ERROR: bad evp_version " rc=EEEE000096258005 evp_version=$D2 cmd=10 }, \
		0x0E  { "ERROR: buf is NULL " rc=EEEE000096258005 cmd=11 }, \
		0x0F  { "ERROR: bad evp_version " rc=EEEE000096258005 evp_version=$D2 cmd=11 }, \
		0x11  { "ERROR: buf is NULL " rc=EEEE000096258005 cmd=12 }, \
		0x13  { "ERROR: invalid cmd " rc=EEEE000096258005 cmd=$D2 }, \
		0x10003  { "succeeded." cmd=$D2 } }, \
	0x13  { "aha_cbfn_register enter " cbFn=$D1 }, \
	0x14  { "aha_cbfn_register exit " \
		$D1, \
		0x00  { "succeeded." }, \
		0x01  { "ERROR: refmon() failed " rc=$D2 } }, \
	0x15  { "aha_evprods_list enter " buf=$D1 bufSz=$D2 }, \
	0x16  { "aha_evprods_list exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: bufSz is NULL." rc=EEEE000096258006 }, \
		0x02  { "ERROR: bufSz < size." rc=EEEE00009C258007 bufSz=$D2 size=$D3 }, \
		0x10000  { "succeed. buf is NULL." size=$D2 }, \
		0x10001  { "succeed." size=$D2 } }, \
	0x17  { "aha_cbfn_wrapper enter " cbFnInfo=$D1 }, \
	0x18  { "aha_cbfn_wrapper exit " \
		$D1, \
		0x00  { "succeed." }, \
		0x01  { "ERROR: call to (*AHAFS_CBFN)() failed." rc=EEEE0000DA25801B rc1=$D2 AHAFS_CBFN=$D3 }, \
		0x02  { "ERROR: AHAFS_CBFN is NULL." rc=EEEE00009325800D } }, \
	0x19  { "ahafs_get_curthrd_info enter " curThrdInfo=$D1 }, \
	0x1A  { "ahafs_get_curthrd_info exit ERROR: curThrdInfo is NULL." rc=EEEE00009625800B }, \
	0x1B  { "aha_utilFs_register enter " cmd=$D1 evMonInfo=$D2 }, \
	0x1C  { "aha_utilFs_register exit " \
		$D1, \
		0x00  { }, \
		0x02  { "ERROR: cmd is 8, NULL vp/vfsp/ahafs_utilFs_num " rc=EEEE000082258012 vp=$D2 vfsp=$D3 ahafs_utilFs_num=$D4 }, \
		0x03  { "ERROR: cmd is 8, not monitored." rc=EEEE000082258012 vp=$D2 svfsp=$D3 ahafs_utilFs_num=$D4 }, \
		0x04  { "ERROR: cmd is "$D3" invalid thresholdHi." rc=EEEE00009625801C evm_thresholdHi=$D2 }, \
		0x05  { "ERROR: cmd is "$D3" invalid thresholdLo." rc=EEEE00009625801C evm_thresholdLo=$D2 }, \
		0x07  { "ERROR: cmd is 6, not monitored." rc=EEEE000082258012 }, \
		0x08  { "ERROR: cmd is 7, vfs is UNMOUNTING/UNMOUNTED." rc=EEEE0000B425801F svfsp=$D2 vmt_flags=$D3 }, \
		0x09  { "ERROR: invalid cmd." cmd=$D2 }, \
		0x10000 { "succeeded. cmd is 8" evm_threshType=$D2 }, \
		0x10001 { "succeeded. cmd is 5" }, \
		0x10003 { "succeeded. cmd is 6" fsRoot=$D2 }, \
		0x10004 { "succeeded. cmd is 7" svfsp=$D2 evm_threshType=$D3 evm_threshhold value=$D4 util=$D5 } }, \
	0x1E  { }, \
	0x1F  { "get_localFs_info exit " \
		$D1, \
		0x00  { "succeeded." fs_root=$D2 util=$D3 }, \
		0x01  { "ERROR: fsRoot is NULL." rc=EEEE000096258015 }, \
		0x02  { "ERROR: lookupname() failed." rc=$D2 }, \
		0x03  { "ERROR: not root." rc=EEEE000096258010 vp=$D2 }, \
		0x04  { "ERROR: ahafs not supported." rc=EEEE0000FC258016 vfsp=$D2 vfs_ahafsInfo=$D3 aha_version=$D4 } }, \
	0x20  { "aha_modFile_register enter " cmd=$D1 evMonInfo=$D2 evm_evProdId=$D3 }, \
	0x21  { "aha_modFile_register exit " \
		$D1, \
		0x00  { }, \
		0x01  { "ERROR: cmd is 9 " rc=EEEE0000ED258017 evm_evProdId=$D2 }, \
		0x02  { "ERROR: bad evm_opqId/evm_digest pair ", rc=EEEE000096258019 evm_evProdId=$D2 evm_opqId=$D3 evm_digest=$D4 }, \
		0x03  { "ERROR: bad file type. " rc=EEEE000096258019 evm_evProdId=$D2 v_vntype=$D3 }, \
		0x04  { "ERROR: file unregistered. " rc=EEEE000082258018 evm_evProdId=$D2 v_flag=$D3 }, \
		0x05  { "ERROR: cmd is 5. " rc=EINVAL evm_evProdId=$D2 }, \
		0x06  { "ERROR: lookupname() failed. " evm_evProdId=$D2 rc=$D3 cmd=$D4 }, \
		0x07  { "ERROR: VNOP_ACCESS() failed. " evm_evProdId=$D2 rc=$D3 cmd=$D4 }, \
		0x08  { "ERROR: this is a link. " rc=EEEE0000FC25801A evm_evProdId=$D2 cmd=$D3 }, \
		0x09  { "ERROR: this is namefs. " rc=EEEE0000FC25801A evm_evProdId=$D2 cmd=$D3 }, \
		0x0A  { "ERROR: this fs is remote. " rc=EEEE0000FC25801A evm_evProdId=$D2 cmd=$D3 }, \
		0x0B  { "ERROR: this is procfs or ahafs. " rc=EEEE0000FC25801A evm_evProdId=$D2 vfs_type=$D3 cmd=$D4 }, \
		0x0C  { "ERROR: not directory. " rc=EEEE0000FC25801A evm_evProdId=$D2 v_vntype=$D3 cmd=$D4 }, \
		0x0D  { "ERROR: cmd is 6 but not monitored. " rc=EEEE000082258018 evm_evProdId=$D2 }, \
		0x0E  { "ERROR: invalid command. " rc=EEEE000096258019 evm_evProdId=$D2 cmd=$D3 }, \
		0x10000  { "succeeded. event unregistered" evm_evProdId=$D2 }, \
		0x10001  { "succeeded. cmd is 4" evm_evProdId=$D2 }, \
		0x10002  { "succeeded. cmd is 6" evm_evProdId=$D2 }, \
		0x10003  { "succeeded. cmd is 7" evm_evProdId=$D2 } }, \
	0x23  { "aha_process_vnop enter " vp=$D1 evp_rc=$D2 name=$D3 crp=$D4 caller=$D5 }, \
	0x24  { }, \
	0x26  { "aha_process_umount enter " vfsp=$D1 }, \
	0x27  { "aha_process_umount exit " }, \
	0x28  { "aha_process_rename enter " ahafs_utilFs_num=$D1 ahafs_modFile_num=$D2 ahafs_modDir_num=$D3 v_vntype=$D4 }, \
	0x29  { }, \
	0x2A  { }, \
	0x2B  { "aha_process_rename exit " }, \
	0x2C  { "aha_svfs_init enter " svfsp=$D1 crp=$D2 }, \
	0x2D  { "aha_svfs_init exit " }
102E 1.0 "@AHAFS Miscellaneous Code" \
	HT & 0x4000, \
	0x4000 { \
		$D1, \
		0x46  { "ahafsNodeCreate() name is " G16 $HL%S1 }, \
		0x4C  { "ahafsGetBaseName() fullname is " G16 $HL%S1 } \
		$BREAK \
	} \
	$HD, \
	0x01  { "ahafsCfg enter " cmd=$D1 }, \
	0x02  { "ahafsCfg exit " \
		$D1, \
		0x00  { "succeeded." cmd=$D2 }, \
		0x01  { "ERROR: cmd=CFG_INIT(1) ahafs_initialize() failed." rc=$D2 kern_rc=$D3 }, \
		0x02  { "ERROR: cmd=CFG_INIT(1) gsaadd() failed." rc=$D2 }, \
		0x03  { "ERROR: cmd=CFG_INIT(1) pincode() failed." rc=$D2 }, \
		0x04  { "ERROR: cmd=CFG_TERM(2) ahafs mounts exist." rc=EBUSY aha_fsMounted=$D2 }, \
		0x05  { "ERROR: bad cmd" rc=EINVAL cmd=$D2 } }, \
	0x03  { "ahafsGfsInit" }, \
	0x04  { "ahafsGfsRtIn " caller=$D1 caller2=$D2 caller=$D3 }, \
	0x05  { "find_mf_data enter " evProdId=$D1 }, \
	0x06  { "find_mf_data exit " \
		$D1, \
		0x10000  { "succeeded. MF in deletion." anp=$D2 mfp=$D3 }, \
		0x10001  { "succeeded." mfp=$D2 } }, \
	0x07  { "ahafsCollectEventData enter " mf_ed=$D1 cbFnInfo=$D2 }, \
	0x08  { "ahafsCollectEventData " kern_rc=$D1 }, \
	0x09  { "ahafsCollectEventData exit succeeded." }, \
	0x0A  { "ahafsStkTrace enter " tmpBuf=$D1 bufSz=$D2 curThrd=$D3 flag=$D4 }, \
	0x0B  { "ahafsStkTrace " \
		$D1, \
		0x00  { "not enough room for svcInstr and NULL character." curLoc=$D2 len=$D3 }, \
		0x01  { "not enough room for lnbuf and NULL character." curLoc=$D2 len=$D3 }, \
		0x01  { "raschk_addr2sym() failed." rc=$D2 } }, \
	0x0C  { "ahafsStkTrace exit " \
		$D1, \
		0x00  { "return." rc=$D2 }, \
		0x01  { "ERROR: Sanity check failed." rc=EINVAL tmpBuf=$D2 bufSz=$D3 curThrd=$D4 flag=$D5 }, \
		0x02  { "ERROR: raschk_addr2sym() failed." rc=$D2 } }, \
	0x0D  { "ahafsDuplicateEvent enter " evInfo=$D1 head=$D2 len=$D3 }, \
	0x0E  { "ahafsDuplicateEvent exit " found=$D1 }, \
	0x0F  { "ahafsCopyEvent enter " evInfo=$D1 buf=$D2 head=$D3 ev_next_write=$D4 ev_next_read=$D5 }, \
	0x10  { "ahafsCopyEvent " \
		$D1, \
		0x00  { "(top_bytes + bottom_bytes) >= len" top_bytes=$D2 bottom_bytes=$D3 len=$D4 }, \
		0x01  { "ahafsFindNextEvent() returns NULL" evbuf=$D2 ev_next_read=$D3 ev_next_write=$D4 ev_last_event=$D5 }, \
		0x02  { top_bytes=$D2 bottom_bytes=$D3 len=$D4 } }, \
	0x11  { "ahafsCopyEvent exit " \
		$D1, \
		0x10000  { "succeeded. overflow" evbuf=$D2 ev_next_read=$D3 ev_next_write=$D4 ev_last_event=$D5 }, \
		0x10001  { "succeeded." evbuf=$D2 ev_next_read=$D3 ev_next_write=$D4 ev_last_event=$D5 } }, \
	0x12  { "ahafsFindSubstring enter " ev_buf=$D1 start=$D2 substr=$D3 substrLen=$D4 }, \
	0x13  { "ahafsFindSubstring exit " \
		$D1, \
		0x00  { "succeeded." head=$D2 }, \
		0x01  { "ERROR: bad p." p=$D2 ev_buf=$D3 ev_buf_len=$D4 }, \
		0x02  { "ERROR: returning NULL." } }, \
	0x14  { "ahafsFindNextEvent enter " evInfo=$D1 start=$D2 }, \
	0x15  { "ahafsFindNextEvent exit " \
		$D1, \
		0x10000  { "returns FALSE. head == evInfo->ev_next_write" }, \
		0x10001  { "returns " head=$D2 } }, \
	0x16  { "ahafsLogEvent enter " cbFnInfo=$D1 evInfo=$D2 mf_ed=$D3 }, \
	0x17  { "ahafsLogEvent " rc=$D1 }, \
	0x18  { "ahafsLogEvent exit " \
		$D1, \
		0x00  { "succeeded." ev_seq_num=$D2 }, \
		0x01  { "ERROR: invalid parameters." cbFnInfo=$D2 evInfo=$D3 mf_ed=$D4 } }, \
	0x19  { "ahafsLogExceptionEvent enter " evInfo=$D1 evp_rc=$D2 curVal=$D3 }, \
	0x1A  { "ahafsLogExceptionEvent exit " ev_seq_num=$D1 }, \
	0x1B  { "ahafsRemoveBranch enter " root_anp=$D1 }, \
	0x1C  { "ahafsRemoveBranch " anp=$D2 v_count=$D3 aha_count=$D4 }, \
	0x1D  { "ahafsRemoveBranch exit " \
		$D1, \
		0x00  { "aha_type == AHA_ROOT" }, \
		0x01  { "returns" } }, \
	0x1E  { "ahafsGroupRemove enter " mf_data=$D1 cbFnInfo=$D2 gid=$D3 cb_flag=$D4 }, \
	0x1F  { "ahafsGroupRemove exit" }, \
	0x20  { "ahafsFindSelSlot enter " anp=$D1 pid=$D2 type_of_match=$D3 slot_p=$D4 }, \
	0x21  { "ahafsFindSelSlot exit " \
		$D1, \
		0x00  { "succeeded." ev_slot_number=$D2 matched_slot_p=$D3 }, \
		0x01  { "ERROR: type_of_match == AHA_EVINFO_AVAILABLE && aha_sze > 512" anp=$D2 aha_size=$D3 }, \
		0x03  { "ERROR: matched_slot_p is NULL." anp=$D2 } }, \
	0x22  { "ahafsGetUniqueId enter" }, \
	0x23  { "ahafsGetUniqueId exit " \
		$D1, \
		0x10000  { "succeeded." unique_id=$D2 }, \
		0x10001  { "ERROR: " unique_id=$D2 } }, \
	0x24  { "ahafsPutUniqueId enter " unique_id=$D1 }, \
	0x26  { "ahafsMfHold " mf_anp=$D1 aha_count=$D2 caller=$D3 caller2=$D4 caller3=$D5 }, \
	0x27  { "ahafsMfRele enter " mf_anp=$D1 aha_count=$D2 caller=$D3 caller2=$D4 caller3=$D5 }, \
	0x28  { "ahafsMfRele exit " \
		$D1, \
		0x00  { "succeeded. last release" mf_anp=$D2 }, \
		0x01  { "succeeded." mf_anp=$D2 } }, \
	0x29  { "ahafsNodeInit enter " \
		$D1, \
		0x00  { anp=$D2 type=$D3 mode=$D4 uid=$D5 }, \
		0x01  { gid=$D2 mf_anp=$D3 pathname=$D4 dvp=$D5 } }, \
	0x2B  { "ahafsNodeInit exit " \
		$D1, \
		0x00  { "succeeded." anp=$D2 }, \
		0x01  { "ERROR: negative unique_id." rc=ENOSPC unique_id=$D2 }, \
		0x02  { "return." rc=$D2 } }, \
	0x2C  { "ahafsNodeUninit enter " anp=$D1 }, \
	0x2D  { "ahafsNodeUninit exit " anp=$D1 }, \
	0x2E  { "ahafsQVnodeToVfs enter " vnp=$D1 }, \
	0x2F  { "ahafsQVnodeToVfs exit " }, \
	0x30  { "ahafsDeqVnodeFromVfs enter " vnp=$D1 }, \
	0x31  { "ahafsDeqVnodeFromVfs exit " }, \
	0x32  { "ahafsInactivateVnode enter " vnp=$D1 anp_locked=$D2 anp=$D3 aha_type=$D4 }, \
	0x33  { "ahafsInactivateVnode exit " \
		$D1, \
		0x00  { "return." anp=$D2 rc=$D3 }, \
		0x01  { "ERROR: aha_type == AHA_ROOT." rc=EBADF anp=$D2 } }, \
	0x34  { "ahafsAllocDataArea enter " anp=$D1 }, \
	0x35  { "ahafsAllocDataArea exit " \
		$D1, \
		0x00  { "succeeded." anp=$D2 }, \
		0x01  { "ERROR: pda->next malloc failed." rc=ENOMEM size=$D2 } }, \
	0x36  { "ahafsDeallocDataAreas enter " anp=$D1 heap=$D2 }, \
	0x38  { "ahafsDeallocDataAreas exit" }, \
	0x39  { "ahafsFindAvailDirSlot enter " anp=$D1 }, \
	0x3A  { "ahafsFindAvailDirSlot exit " \
		$D1, \
		0x00  { "returns " pdir_list=$D2 }, \
		0x01  { "returns NULL" rc=$D2 } }, \
	0x3B  { "ahafsCreateDirEntry enter " anp_p=$D1 anp=$D2 name=$D3 }, \
	0x3C  { "ahafsCreateDirEntry exit succeeded." }, \
	0x3D  { "ahafsRemoveDirEntry enter " anp_p=$D1 anp=$D2 }, \
	0x3E  { "ahafsRemoveDirEntry exit succeeded." }, \
	0x3F  { "ahafsFindDirEntryByName enter " anp=$D1 name=$D2 dir_slot_per_data_area=$D3 }, \
	0x40  { "ahafsFindDirEntryByName exit " \
		$D1, \
		0x00  { "returns " pdir_list=$D2 "pdir_list+i"=$D3 }, \
		0x01  { "returns NULL." } }, \
	0x41  { "ahafsFindDirEntryByNode enter " danp=$D1 anp=$D2 DIR_SLOTS_PER_DATA_AREA=$D3 }, \
	0x42  { "ahafsFindDirEntryByNode exit " \
		$D1, \
		0x00  { "returns " pdir_list=$D2 }, \
		0x01  { "returns NULL." } }, \
	0x43  { "ahafsGetNextUnvisitedNode enter " anp=$D1 }, \
	0x44  { "ahafsGetNextUnvisitedNode exit " \
		$D1, \
		0x00  { "returns " de_anp=$D2 }, \
		0x01  { "returns NULL 1." }, \
		0x02  { "returns NULL 2." } }, \
	0x45  { "ahafsNodeCreate enter " dvnp=$D1 type=$D2 mf_anp=$D3 pathname=$D4 heap_ptr=$D5 }, \
	0x46  { "ahafsNodeCreate_name " }, \
	0x48  { "ahafsNodeCreate exit " rc=$D1 vnp=$D2 }, \
	0x49  { "ahafsGetVattr enter " anp=$D2 vattrp=$D3 }, \
	0x4A  { "ahafsGetVattr exit succeeded" }, \
	0x4B  { "ahafsGetBaseName enter" }, \
	0x4C  { "ahafsGetBaseName_name " }, \
	0x4D  { "ahafsGetBaseName exit succeeded." }, \
	0x4E  { "ahafsGetNodePath enter " anp=$D1 str=$D2 max_length_str=$D3 root_type=$D4 }, \
	0x4F  { "ahafsGetNodePath_name " }, \
	0x50  { "ahafsGetNodePath exit " rc=$D1 }, \
	0x51  { "ahafsGetMonFactory enter " anp=$D1 }, \
	0x52  { "ahafsGetMonFactory exit " \
		$D1, \
		0x01  { "succeeded. aha_type == AHA_MONITOR_FACTORY" danp=$D2 }, \
		0x02  { "ERROR: return NULL" } }, \
	0x53  { "ahafsPrepend_string enter " str1=$D1 str=$D2 max_length_str=$D3 }, \
	0x54  { "ahafsPrepend_string exit " \
		$D1, \
		0x00  { }, \
		0x10001  { "succeeded." } }, \
	0x55  { "ahafsDoChown enter " anp=$D1 tflag=$D2 newuid=$D3 newgid=$D4 crp=$D5 }, \
	0x56  { "ahafsDoChown exit " \
		$D1, \
		0x00  { "succeeded" }, \
		0x01  { "ERROR: !mine && !privileged." rc=EPERM uid=$D2 aha_uid=$D3 }, \
		0x02  { "ERROR: !privileged." rc=EPERM newuid=$D2 aha_uid=$D3 }, \
		0x03  { "ERROR: !privileged && not group member." rc=EPERM newgid=$D2 aha_gid=$D3 } }, \
	0x57  { "ahafsChkFsBusy " \
		$D1, \
		0x00  { "return busy 1. v_count != 0" }, \
		0x01  { "return busy 2. v_count != 0" }, \
		0x02  { "return not busy." } }, \
	0x58  { "ahafsCreateMonFactory enter " buf=$D1 len=$D2 }, \
	0x5A  { "ahafsCreateMonFactory exit " \
		$D1, \
		0x00  { }, \
		0x02  { "ERROR: whafs_evprods() failed." rc=$D2 kern_rc=$D3 }, \
		0x03  { "ERROR: numMonFactories >= AHAFS_MAX_MONFACTORIES." rc=ENOSPC numMonFactories=$D2 }, \
		0x04  { "ERROR: ahafsNodeCreate() failed." rc=$D2 }, \
		0x05  { "ERROR: ahafsCreateMFNode() failed." rc=$D2 }, \
		0x10000 { "succeeded. unmounting." }, \
		0x10001 { "return." rc=$r2 } }, \
	0x5B  { "ahafsCreateMFNode enter " evProdInfo=$D1 evpName=$D2 dvp=$D3 danp=$D4 crp=$D5 }, \
	0x5C  { "ahafsCreateMFNode exit " \
		$D1, \
		0x00  { "succeeded." }, \
		0x01  { "ERROR: ahafsNodeCreate() failed." rc=$D2 }, \
		0x02  { "return." rc=$D2 } }, \
	0x5D  { "ahafsAllocTmpEventData enter " mfp=$D1 }, \
	0x5E  { "ahafsAllocTmpEventData exit " \
		$D1, \
		0x00  { "succeeded." }, \
		0x01  { "FAILED." rc=ENOMEM } }

630 1.0 "@vfc_clientdd" O2 A8.8 "d1=" X8 " d2=" X8 " d3=" X8 " d4=" X8
339 1.0 'ATM SIGNALING-DD -' \
      {{$HB = X2}}  \
    HB,\
    1 { `ATMDD removed from component dump A4.4` },\
    2 { `ATMDD Component Dump Table adding A4.4 name $D2 Addr $D3 len $D4` },\
    3 { `ATMDD Component Dump Table add exit A4.4` },\
    4 { `ATMDD Component Dump Table deleting A4.4 name $D2 Addr $D3 len $D4` },\
    5 { `ATMDD Watchdog entered A4.4 watchdog ptr %D2` },\
    6 { `ATMDD Watchdog exit A4.4` },\
    7 { `ATMDD Config UIOMOVE failure A4.4 with cmd $D2` },\
    8 { `ATMDD Config ns_attach failure A4.4 with ret $D2` },\
    9 { `ATMDD Config copyout failed A4.4 with ret $D2` },\
    a { `ATMDD queue marksendpending bad correl A4.4 returning $D2 lock $D3` },\
    b { `ATMDD queue marksendpending for 128 A4.4 correl $D2 card addr $D3` },\
    c { `ATMDD queue clearsendpending for 128 A4.4 correl $D2` },\
    d { `ATMDD queue marksendpending for 2K A4.4 correl $D2` },\
    e { `ATMDD queue clearsendpending for 2K A4.4 correl $D2` },\
    f { `ATMDD queue marksendpending fail for 128 A4.4 correl $D2 card $D3`},\
    10{ `ATMDD queue marksendpending fail for 2K A4.4 correl $D2` },\
    11{ `ATMDD queue marksendpending done A4.4 slot $D2` },\
    12{ `ATMDD atmqueue map send buffer Begin A4.4 mbufp $D2` },\
    13{ `ATMDD atmqueue map send buffer end A4.4 mbufp $D2 len $D3` },\
    14{ `ATMDD atmqueue clear send pending beg A4.4 correl $D2` },\
    15{ `ATMDD atmqueue clear send pending end A4.4` },\
    1a{ `ATMDD atmqueue refresh receive buffer pool beg A4.4 ` },\
    1b{ `ATMDD atmqueue refresh receive buffer pool end A4.4 loaded $D2 buffs` },\
    1c{ `ATMDD atmqueue fill receive buffer pool beg A4.4 ` },\
    1d{ `ATMDD atmqueue fill receive buffer pool end A4.4 loaded $D2 buffs ` },\
    1e{ `ATMDD atmqueue get receive buffer pool info beg A4.4 index $D2 ` },\
    1f{ `ATMDD atmqueue get receive buffer pool info end A4.4 ` },\
    22{ `ATMDD atmqueue set rec buf to reuse A4.4 index $D2 ` },\
    23{ `ATMDD atmqueue set rec buf to reuse A4.4 ` },\
    24{ `ATMDD atmqueue send direct 128 A4.4  card $D2 ` },\
    25{ `ATMDD atmqueue clear send pending A4.4  correl $D2 size $D3 card $D4` },\
    26{ `ATMDD atmqueue send direct A4.4 card_addr $D2 card $D3` },\
    27{ `ATMDD atmqueue clear direct A4.4 correl $D2 size $D3 card $D4` },\
    28{ `ATMDD atmqueue init direct A4.4 card addr $D2 ` },\
    29{ `ATMDD atmqueue init direct A4.4 ` },\
    2a{ `ATMDD atmqueue gather xmit direct A4.4 mbptr $D2 correl $D3 handle $D4` },\
    2b{ `ATMDD atmqueue gather xmit direct A4.4 frag addr $D2 len $D3 ` },\
    2c{ `ATMDD atmqueue gather xmit direct A4.4 ` },\
    2d{ `ATMDD atm output A4.4 mbufp $D2 handle $D3 ` },\
    2e{ `ATMDD atm_output not our buffer A4.4 ` },\
    2f{ `ATMDD clear send pending A4.4 ERROR duplicate correl $D2` },\
    32{ `ATMDD freshup receive A4.4 Error mgetclust failed` },\
    33{ `ATMDD get recv info A4.4 Error mgetclust failed` },\
    34{ `ATMDD clear send direct A4.4 Unable to clear $D2 size $D3` },\
    35{ `ATMDD loss of light A4.4 ` },\
    36{ `ATMDD light regained A4.4 ` },\
    37{ `ATMDD atm_output bad correl A4.4 ` },\
    38{ `ATMDD atm_output A4.4 ` },\
    39{ `ATMDD atm_handler A4.4 p_dev_ptr $D2 card $D3 ` },\
    3a{ `ATMDD atm_handler A4.4 p_dev_ptr $D2 card $D3 ` },\
    3b{ `ATMDD proc_intr A4.4 p_dev_ptr $D2 card $D3 ` },\
    3c{ `ATMDD proc_intr A4.4 p_dev_ptr $D2 card $D3 ` },\
    3d{ `ATMDD proc_intr A4.4 p_dev_ptr $D2 card $D3 exception code $D4 ` },\
    3e{ `ATMDD atm_intr A4.4 p_dev_ptr $D2 card $D3 ` },\
    3f{ `ATMDD atm_intr A4.4 p_dev_ptr $D2 card $D3 rc $D4 ` },\
    301{ `ATMDD atm_initintr A4.4 p_dev_ptr $D2 card $D3 ` },\
    302{ `ATMDD atm_initintr A4.4 p_dev_ptr $D2 card $D3 ` },\
    303{ `ATMDD atm_disableintr A4.4 p_dev_ptr $D2 card $D3 ` },\
    304{ `ATMDD atm_disableintr A4.4 p_dev_ptr $D2 card $D3 ` },\
    305{ `ATMDD atm_handlecardrsp A4.4 p_dev_ptr $D2 card $D3 ` },\
    306{ `ATMDD atm_handlecardrsp A4.4 p_dev_ptr $D2 card $D3 ` },\
    307{ `ATMDD atm_deqhandler A4.4 p_dev_ptr $D2 card $D3 state $D4 ` },\
    308{ `ATMDD atm_deqhandler A4.4 p_dev_ptr $D2 card $D3 state $D4 ` },\
    309{ `ATMDD atm_deqhandler configuring A4.4 p_dev_ptr $D2 card $D3 state $D4 ` },\
    30a{ `ATMDD atm_deqhandler configured A4.4 p_dev_ptr $D2 card $D3 rsp $D4 ` },\
    30b{ `ATMDD atm_deqhandler open/limbo A4.4 p_dev_ptr $D2 card $D3 rsp $D4 ` },\
    30c { `ATMDD atm_deliver cmd  A4.4 bad corr $D1 resp $D2 cardnum $D3` },\
    30d { `ATMDD LOGERROR A4.4 cardnum $D1 errid $D2 line $D3` },\
    30e { `ATMDD LOGERROR A4.4 parm1 $D1 parm2 $D2 parm3 $D3` },\
    30f { `ATMDD LOGERROR A4.4 done` },\
    311 { `ATMDD atmqueue map send buffer copy A4.4 new mbufp $D2 numbufs $D3` },\
    312 { `ATMDD atmqueue map send buf prep A4.4 nextlen $D2 numbufs $D3` },\
    313 { `ATMDD atmqueue map send buffer ours A4.4 new mbufp $D2 numbufs $D3 data $D4` },\
    315 { `ATMDD atmmbuf flush A4.4 mbufp $D2 addr $D3 size $D4` },\
    316 { `ATMDD atmmbuf flush A4.4 mbufp $D2 channelid $D3 busaddr $D4` },\
    317 { `ATMDD atmmbuf alloc A4.4 mbufp $D2 data $D3 len $D4` },\
    42 { `ATM_FAST_WRITE_BEGIN` },\
    43 { `ATM_FAST_WRITE_END` },\
    44 { `ATM_WRITE_BEGIN` },\
    45 { `ATM_WRITE_END` },\
    46 { `ATM_DEQHANDLER_BEGIN` },\
    47 { `ATM_DEQHANDLER_END` },\
    48 { `ATM_READ_BEGIN` },\
    49 { `ATM_READ_END` },\
    4a { `ATM_OPENPVC_BEGIN` },\
    4b { `ATM_OPENPVC_END` },\
    4c { `ATM_CLOSEPVC_BEGIN` },\
    4d { `ATM_CLOSEPVC_END` },\
    4e { `ATM_GETSTATS_BEGIN` },\
    4f { `ATM_GETSTATS_END` },\
    50 { `ATM_OPEN_BEGIN` },\
    51 { `ATM_OPEN_END` },\
    52 { `ATM_CLOSE_BEGIN` },\
    53 { `ATM_CLOSE_END` },\
    54 { `ATM loss of light - cable pulled....` },\
    55 { `ATM regained light - cable replaced....` },\
    150 { `SVCDD Data received from link; enqueuing in SVC data queue` },\
    151 { `SVCDD Command enqueued in SVC cmd queue` },\
    152 { `SVCDD responding to query data queue` },\
    153 { `SVCDD responding to query cmd queue command` },\
    154 { `SVCDD receive call` },\
    155 { `SVCDD place call ack` },\
    156 { `SVCDD disconnect call` $D1, 1 "Network Cause", \
                                       2 "SVC Cause",   \
                                       3 "SVC Mem Exhausted",  \
                                       4 "Network Down" ` cause code ` $D2 }, \
    157 { `SVCDD responding query complete` },\
    158 { `SVCDD given SVC Xmit req` },\
    159 { `SVCDD given ILMI Xmit req` },\
    160 { `SVCDD xmit complete` },\
    161 { `SVCDD enqueueing place call cmd` },\
    162 { `SVCDD enqueueing connection status cmd` },\
    163 { `SVCDD enqueueing receive call ack cmd` },\
    164 { `SVCDD enqueueing terminate daemon cmd` },\
    165 { `SVCDD enqueueing hangup call` },\
    166 { `ATMDD call to place_call failed with a rc 0x`X4 },\
    167 { `ATMSVCDM disconnect due to place call failure return code 0x`X4 },\
    168 { `ATMSVCDM disconnect due to receive call ack failure return code 0x`X4 },\
    169 { `ATMSVCDM enter timer critical section aborted` },\
    170 { `ATMDD atmfastwrite unable to get new small or med correlator` },\
    171 { `ATMDD atmfastwrite unable to get a new large correlator` },\
    172 { `ATMDD atmwrite unable to get new correlator` },\
    173 { `ATMDD m_get or m_getclust failed` },\
    174 { `ATMSVCD started a daemon for instance ` $D1 },\
    200 { "ricintr errno" X1 "card" O2 X1 "logpt:"X4  },\
    201 { "ricintr read head" X1 "card" O2 X1 "head:"X4  },\
    202 { "ricintr write tailerrno" X1 "card" O2 X1 "tail:"X4  },\
    203 { `calling nid with incoming call` },\
    204 { `cm_process_incall called` },\
    205 { `enqueuing openincoming scb` },\
    206 { `receive call e_handel not in assigned state` },\
    603c {" ILMI[" HB "] instance=" "0x"X4 " "          "State Change. New state = " O3 "0x"X1 },\
    6082 {" ILMI[" HB "] instance=" "0x"X4 " "            "Local ATM address no longer registered: " "0x"X4 "0x"X4 "0x"X4 "0x"X4 },\
    6081 {" ILMI[" HB "] instance=" "0x"X4 " "      "Local ATM address successfully registered: " "0x"X4 "0x"X4 "0x"X4 "0x"X4 },\
    9c00 {" SVC[" HB "] instance=" "0x"X4 " "             "Q93B_protocol config support failed; rc=" "0x"X4 },\
    9c01 {" SVC[" HB "] instance=" "0x"X4 " "         "Q93B_protocol couldn't construct memory manager" },\
    9c02 {" SVC[" HB "] instance=" "0x"X4 " "       "Q93B_protocol couldn't construct a member class" },\
    9c16 {" SVC[" HB "] instance=" "0x"X4 " "        "Q93B_protocol failed to construct status msg; rc=" "0x"X4 " this-> " "0x"X4 },\
    9c17 {" SVC[" HB "] instance=" "0x"X4 " "        "Q93B_protocol generate network message(status) failed; rc=" "0x"X4 },\
    9c19 {" SVC[" HB "] instance=" "0x"X4 " "       "Q93B_protocol failed to send status msg; SAAL rc=" "0x"X4 },\
    9c1c {" SVC[" HB "] instance=" "0x"X4 " "     "Q93B_protocol failed to construct release complete msg; rc=" "0x"X4 " this-> " "0x"X4 },\
    9c1d {" SVC[" HB "] instance=" "0x"X4 " "     "Q93B_protocol generate network message(release comp) failed; rc=" "0x"X4 },\
    9c1f {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol failed to send release complete msg; SAAL rc=" "0x"X4 },\
    9c28 {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol failed to set timer 317" },\
    9c29 {" SVC[" HB "] instance=" "0x"X4 " "          "Q93B_protocol failed to construct restart message; rc=" "0x"X4 },\
    9c2a {" SVC[" HB "] instance=" "0x"X4 " "            "Q93B_protocol received really bad restart msg; parse network message rc=" "0x"X4 },\
    9c2d {" SVC[" HB "] instance=" "0x"X4 " "     "Q93B_protocol received restart with restart_ind IE missing; parse network message rc=" "0x"X4 },\
    9c22 {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol failed to construct restart ack msg; rc=" "0x"X4 },\
    9c21 {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol generate network message(restart ack) failed; rc=" "0x"X4 },\
    9c23 {" SVC[" HB "] instance=" "0x"X4 " "   "Q93B_protocol failed to send restart ack msg; SAAL rc=" "0x"X4 },\
    9c3d {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol failed to place call; no ILMI address available; ILMI rc=" "0x"X4 },\
    9c3e {" SVC[" HB "] instance=" "0x"X4 " " "Q93B_protocol failed to construct outgoing call object; rc=" "0x"X4 " this-> " "0x"X4 },\
    9c40 {" SVC[" HB "] instance=" "0x"X4 " " "Q93B_protocol failed to add call ref to table during place call" },\
    9c53 {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol received bad setup msg; rc=" "0x"X4 " this-> " "0x"X4 },\
    9c54 {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol failed to construct incoming call object; rc=" "0x"X4 " this-> " "0x"X4 },\
    9c56 {" SVC[" HB "] instance=" "0x"X4 " " "Q93B_protocol failed to get connection handle; rc=" "0x"X4 },\
    9c58 {" SVC[" HB "] instance=" "0x"X4 " "          "Q93B_protocol preparse message failed; rc=" O3 "0x"X1 },\
    9c59 {" SVC[" HB "] instance=" "0x"X4 " "      "Q93B_protocol preparse failure with header: " "0x"X4 "0x"X4 "0x"X4 "0x"X4 },\
    9c5a {" SVC[" HB "] instance=" "0x"X4 " "     "Q93B_protocol preparse failure; bad length; call state=" O3 "0x"X1 },\
    9c5b {" SVC[" HB "] instance=" "0x"X4 " " "Q93B_protocol preparse failure; status msg constructor failed; rc=" "0x"X4 " this-> " },\
    9c62 {" SVC[" HB "] instance=" "0x"X4 " " "Q93B_protocol failed to remove callRef=" "0x"X4 "/flag=" "0x"X4 " from delete pending list" },\
    9681 {" SVC[" HB "] instance=" "0x"X4 " "        "Memory allocation failure: SVC component" },\
    9680 {" SVC[" HB "] instance=" "0x"X4 " "   "Duplicate deallocation of memory: SVC component" },\
    9621 {" SVC[" HB "] instance=" "0x"X4 " "        "Attempt to instantiate multiple q93b_memory components" },\
    9625 {" SVC[" HB "] instance=" "0x"X4 " "           "memory manager coherence failure" },\
    9682 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9683 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9684 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9685 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9686 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9687 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9688 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9689 {" SVC[" HB "] instance=" "0x"X4 " "  "memory manager coherence failure" },\
    9690 {" SVC[" HB "] instance=" "0x"X4 " "       "memory manager coherence failure" },\
    9691 {" SVC[" HB "] instance=" "0x"X4 " "       "memory manager coherence failure" },\
    9c26 {" SVC[" HB "] instance=" "0x"X4 " "      "Q93B_protocol received a restart with header: " "0x"X4 "0x"X4 "0x"X4 "0x"X4 },\
    9c32 {" SVC[" HB "] instance=" "0x"X4 " "     "Q93B_protocol adding leaf; conn handle=" U4 " leaf handle=" U4 },\
    9c35 {" SVC[" HB "] instance=" "0x"X4 " "  "Q93B_protocol hanging up call; conn handle=" U4 " reason=" "0x"X4 },\
    9c38 {" SVC[" HB "] instance=" "0x"X4 " "  "Q93B_protocol hanging up leaf; conn handle=" U4 " leaf handle=" U4 },\
    9c3b {" SVC[" HB "] instance=" "0x"X4 " "   "Q93B_protocol placing call; conn handle=" O2 U2 " conn type=" "0x"X4 " pcall_parms-> " "0x"X4 },\
    9c46 {" SVC[" HB "] instance=" "0x"X4 " "    "Q93B_protocol disconnecting call; conn handle=" O2 U2 " reason=" "0x"X4 " cause code=" "0x"X4 },\
    8f71 {" SAAL[" HB "] instance=" "0x"X4 " "        "CODE A: unsolicited/inappropriate pdu (sd pdu); state=IDLE" },\
    8f72 {" SAAL[" HB "] instance=" "0x"X4 " "        "CODE A: unsolicited/inappropriate pdu (sd pdu); state=MULT" },\
    8f51 {" SAAL[" HB "] instance=" "0x"X4 " "    "CODE B: unsolicited/inappropriate pdu (bgn pdu); state=OGREPND" },\
    8f54 {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE C: unsolicited/inappropriate pdu (bgak pdu); state=IDLE" },\
    8f56 {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE C: unsolicited/inappropriate pdu (bgak pdu); state=MULT" },\
    8f55 {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE C: unsolicited/inappropriate pdu (bgak pdu); state=OGREPND" },\
    8f58 {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE D: unsolicited/inappropriate pdu (bgrej pdu); state=IDLE" },\
    8f5b {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE D: unsolicited/inappropriate pdu (bgrej pdu); state=MULT" },\
    8f59 {" SAAL[" HB "] instance=" "0x"X4 " "  "CODE D: unsolicited/inappropriate pdu (bgrej pdu); state=OGRSPND" },\
    8f5a {" SAAL[" HB "] instance=" "0x"X4 " "  "CODE D: unsolicited/inappropriate pdu (bgrej pdu); state=OGREPND" },\
    8f5c {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE D: unsolicited/inappropriate pdu (bgrej pdu); state=DATRDY" },\
    8f62 {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE F: unsolicited/inappropriate pdu (endak pdu); state=MULT" },\
    8f60 {" SAAL[" HB "] instance=" "0x"X4 " "  "CODE F: unsolicited/inappropriate pdu (endak pdu); state=OGRSPND" },\
    8f61 {" SAAL[" HB "] instance=" "0x"X4 " "  "CODE F: unsolicited/inappropriate pdu (endak pdu); state=OGREPND" },\
    8f63 {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE F: unsolicited/inappropriate pdu (endak pdu); state=DATRDY" },\
    8f65 {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE G: unsolicited/inappropriate pdu (poll pdu); state=IDLE" },\
    8f66 {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE G: unsolicited/inappropriate pdu (poll pdu); state=MULT" },\
    8f74 {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE H: unsolicited/inappropriate pdu (stat pdu); state=IDLE" },\
    8f75 {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE H: unsolicited/inappropriate pdu (stat pdu); state=MULT" },\
    8f80 {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE I: unsolicited/inappropriate pdu (ustat pdu); state=IDLE" },\
    8f81 {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE I: unsolicited/inappropriate pdu (ustat pdu); state=MULT" },\
    8f69 {" SAAL[" HB "] instance=" "0x"X4 " "        "CODE J: unsolicited/inappropriate pdu (rs pdu); state=IDLE" },\
    8f6a {" SAAL[" HB "] instance=" "0x"X4 " "        "CODE J: unsolicited/inappropriate pdu (rs pdu); state=MULT" },\
    8f6b {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE J: unsolicited/inappropriate pdu (rs pdu); state=OGREPND" },\
    8f6d {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE K: unsolicited/inappropriate pdu (rsak pdu); state=IDLE" },\
    8f6f {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE K: unsolicited/inappropriate pdu (rsak pdu); state=MULT" },\
    8f6e {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE K: unsolicited/inappropriate pdu (rsak pdu); state=OGREPND" },\
    8f87 {" SAAL[" HB "] instance=" "0x"X4 " "        "CODE L: unsolicited/inappropriate pdu (er pdu); state=IDLE" },\
    8f88 {" SAAL[" HB "] instance=" "0x"X4 " "        "CODE L: unsolicited/inappropriate pdu (er pdu); state=MULT" },\
    8f89 {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE L: unsolicited/inappropriate pdu (er pdu); state=OGREPND" },\
    8f8b {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE M: unsolicited/inappropriate pdu (erak pdu); state=IDLE" },\
    8f8c {" SAAL[" HB "] instance=" "0x"X4 " "      "CODE M: unsolicited/inappropriate pdu (erak pdu); state=MULT" },\
    8f8e {" SAAL[" HB "] instance=" "0x"X4 " "     "CODE O: connection establishment unsuccessful: no response to bgn pdu(s); state=MULT" },\
    8f8f {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE O: connection release unsuccessful: no response to end pdu(s); state=OGDPND" },\
    8fa3 {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE P: connection failure: no response to poll pdu(s); state=OGDPND" },\
    8f67 {" SAAL[" HB "] instance=" "0x"X4 " "    "CODE Q: n(s) error (poll pdu); state=DATRDY" },\
    8f76 {" SAAL[" HB "] instance=" "0x"X4 " "    "CODE R: n(ps) error (stat pdu); state=DATRDY" },\
    8f77 {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE S: n(r) error (stat pdu); state=DATRDY" },\
    8f78 {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE S: first list element is invalid (stat pdu); state=DATRDY" },\
    8f79 {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE S: ending list element is invalid (stat pdu); state=DATRDY" },\
    8f7a {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE S: sd pdu not found (stat pdu); state=DATRDY" },\
    8f7b {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE S: subsequent list element is invalid (stat pdu); state=DATRDY" },\
    8f82 {" SAAL[" HB "] instance=" "0x"X4 " "  "CODE T: n(r) error (ustat pdu); state=DATRDY" },\
    8f83 {" SAAL[" HB "] instance=" "0x"X4 " "  "CODE T: first list element is invalid (ustat pdu); state=DATRDY" },\
    8f84 {" SAAL[" HB "] instance=" "0x"X4 " "  "CODE T: ending list element is invalid (ustat pdu); state=DATRDY" },\
    8f41 {" SAAL[" HB "] instance=" "0x"X4 " "           "CODE U: pdu length violation (alignment error)" },\
    8f42 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (max size exceeded)" },\
    8f43 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (bgn pdu)" },\
    8f44 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (bgak pdu)" },\
    8f45 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (end pdu)" },\
    8f46 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (endak pdu)" },\
    8f47 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (rs pdu)" },\
    8f48 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (rsak pdu)" },\
    8f49 {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (bgrej pdu)" },\
    8f4a {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (sd pdu)" },\
    8f4b {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (er pdu)" },\
    8f4c {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (poll pdu)" },\
    8f4d {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (stat pdu)" },\
    8f4e {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (ustat pdu)" },\
    8f4f {" SAAL[" HB "] instance=" "0x"X4 " "          "CODE U: pdu length violation (erak pdu)" },\
    8f7c {" SAAL[" HB "] instance=" "0x"X4 " "    "CODE V: sd pdu(s) have been retransmitted (stat pdu); state=DATRDY, count=" U4 },\
    8f85 {" SAAL[" HB "] instance=" "0x"X4 " "   "CODE V: sd pdu(s) have been retransmitted (ustat pdu); state=DATRDY, count=" U4 },\
    8f7d {" SAAL[" HB "] instance=" "0x"X4 " "    "CODE W: credit has been depleted (stat pdu); state=DATRDY" },\
    8f7e {" SAAL[" HB "] instance=" "0x"X4 " "    "CODE X: credit has been obtained (stat pdu); state=DATRDY" },\
    870f {" SAAL[" HB "] instance=" "0x"X4 " "                        "unknown timeout: timer id is invalid" },\
    8f50 {" SAAL[" HB "] instance=" "0x"X4 " "            "unknown pdu: pdu type is invalid" },\
    8f97 {" SAAL[" HB "] instance=" "0x"X4 " "                   "unexpected timeout: connection control timer" },\
    8fa2 {" SAAL[" HB "] instance=" "0x"X4 " "                   "unexpected timeout: keep alive timer" },\
    8fae {" SAAL[" HB "] instance=" "0x"X4 " "                   "unexpected timeout: no response timer" },\
    8fb9 {" SAAL[" HB "] instance=" "0x"X4 " "                   "unexpected timeout: poll timer" },\
    8fc4 {" SAAL[" HB "] instance=" "0x"X4 " "                   "unexpected timeout: idle timer" },\
    8e42 {" SAAL[" HB "] instance=" "0x"X4 " "             "svc message discarded: length greater than maximum allowed (tx)" },\
    8e43 {" SAAL[" HB "] instance=" "0x"X4 " "             "svc message discarded: out of transmit buffers (tx)" },\
    8e4f {" SAAL[" HB "] instance=" "0x"X4 " "       "message discarded: length greater than maximum allowed (rx)" },\
    80f1 {" SAAL[" HB "] instance=" "0x"X4 " "       "connection established (confirm); count=" O2 U2 },\
    80f2 {" SAAL[" HB "] instance=" "0x"X4 " "       "connection established (resync indicate)" },\
    80f3 {" SAAL[" HB "] instance=" "0x"X4 " "      "connection established (indicate); count=" O2 U2 },\
    80f4 {" SAAL[" HB "] instance=" "0x"X4 " "       "connection established (resync confirm)" },\
    80f5 {" SAAL[" HB "] instance=" "0x"X4 " "      "connection established (recovery indicate)" },\
    80f6 {" SAAL[" HB "] instance=" "0x"X4 " "     "connection released (confirm)" },\
    80f7 {" SAAL[" HB "] instance=" "0x"X4 " "    "connection released (indicate); est_allowed=" O3 U1 },\
    a100 {" TIMER[" HB "] instance=" "0x"X4 " " "Memory allocation failure: TIMER component" },\
    a101 {" TIMER[" HB "] instance=" "0x"X4 " "       "TIMER supply of timer elements have been exhausted" },\
    a102 {" TIMER[" HB "] instance=" "0x"X4 " "                   "TIMER acquisition of config parm failed" },\
         \* {  unknown subhook \$$HD \$$ERROR }
33A 1.1 "@if_at" \
        "IF_AT: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
3A0 1.1 "@atmcm" \
        "ATMCM: " W1  A4.8 W2 "d1=" XW " d2=" XW " d3=" XW
590 1.1 "ATM DdMain trc, " \
      {{$HB = X2}}  \
        {{$adapt = $HD & 0x000000FF}}  \
        {{$component = $HD & 0x00000F00}} \
    $component, \
      0100 {"DD,     ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0300 {"Daemon, ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
         \* {  Unknown ATM subhook. Hook Id= \$$HD \$$ERROR }
591 1.1 "ATM ERROR trc,  " \
      {{$HB = X2}}  \
        {{$adapt = $HD & 0x000000FF}}  \
        {{$component = $HD & 0x00000F00}} \
    $component, \
      0100 {"DD,     ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0300 {"Daemon, ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0700 {"ILMI,   ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0900 {"SVC,    ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0A00 {"QSAAL,  ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
         \* {  Unknown ATM subhook. Hook Id= \$$HD \$$ERROR }
592 1.1 "ATM Common trc, " \
      {{$HB = X2}}  \
        {{$adapt = $HD & 0x000000FF}}  \
        {{$component = $HD & 0x00000F00}} \
    $component, \
      0100 {"DD,     ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0300 {"Daemon, ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0700 {"ILMI,   ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0900 {"SVC,    ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0A00 {"QSAAL,  ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
         \* {  Unknown ATM subhook. Hook Id= \$$HD \$$ERROR }
593 1.1 "ATM ILMI trace, " \
      {{$HB = X2}}  \
        {{$adapt = $HD & 0x000000FF}}  \
        {{$component = $HD & 0x00000F00}} \
    $component, \
      0700 {"ILMI,   ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
         \* {  Unknown ATM subhook. Hook Id= \$$HD \$$ERROR }
594 1.1 "ATM QSAAL trc,  " \
      {{$HB = X2}}  \
        {{$adapt = $HD & 0x000000FF}}  \
        {{$component = $HD & 0x00000F00}} \
    $component, \
      0A00 {"QSAAL,  ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
         \* {  Unknown ATM subhook. Hook Id= \$$HD \$$ERROR }
595 1.0 "ATM SVC trace,  " \
      {{$HB = X2}}  \
        {{$adapt = $HD & 0x000000FF}}  \
        {{$component = $HD & 0x00000F00}} \
    $component, \
      0100 {"DD,     ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
      0900 {"SVC,    ad=" $adapt ": "X4" "X4" "X4" "X4" "X4" "},\
         \* {  Unknown ATM subhook. Hook Id= \$$HD \$$ERROR }
4A4 1.0 "@RPCSEC_GSS: rpcsec.so routines" \
	$HD%D1, \
	1 { "__rpc_gss_seccreate:entry" }, \
	2 { "__rpc_gss_seccreate:__rpc_gss_qop_to_num failed " err=$D1 sys=$D2 }, \
	3 { "__rpc_gss_seccreate:__rpc_gss_mech_to_oid failed " err=$D1 sys=$D2 }, \
	4 { "__rpc_gss_seccreate:gss_import_name failed " maj=$D1 min=$D2 }, \
	5 { "__rpc_gss_seccreate:malloc failed" }, \
	6 { "__rpc_gss_seccreate:rpc_gss_seccreate_pvt failed " maj=$D1 min=$D2 }, \
	7 { "__rpc_gss_seccreate:requested service not supported" }, \
	8 { "__rpc_gss_seccreate:exiting successfully" }, \
	9 { "rpc_gss_seccreate_pvt:entry" }, \
	10 { "rpc_gss_seccreate_pvt:starting new token" }, \
	11 { "rpc_gss_seccreate_pvt:gss_init_sec_context failed " maj=$D1 min=$D2 }, \
	12 { "rpc_gss_seccreate_pvt:rpc call failed " stat=$D1 }, \
	13 { "rpc_gss_seccreate_pvt:gss_accept_sec_context failed " maj=$D1 min=$D2 }, \
	14 { "rpc_gss_seccreate_pvt:null context handle" }, \
	15 { "rpc_gss_seccreate_pvt:mismatched context handle" }, \
	16 { "rpc_gss_seccreate_pvt:unexpected token" }, \
	17 { "rpc_gss_seccreate_pvt:no token" }, \
	18 { "rpc_gss_seccreate_pvt:exiting successfully" }, \
	19 { "rpc_gss_seccreate_pvt:exiting unsuccessfully" }, \
	20 { "rpc_gss_seccreate_pvt:no memory for handle" }, \
	21 { "rpc_gss_seccreate_pvt:no memory for token" }, \
	22 { "rpc_gss_set_defaults:entry " service=$D1 }, \
	23 { "rpc_gss_set_defaults:bad service " service=$D1 }, \
	24 { "rpc_gss_set_defaults:__rpc_gss_oid_to_mech failed " }, \
	25 { "rpc_gss_set_defaults:__rpc_gss_qop_to_num failed " }, \
	26 { "rpc_gss_set_defaults:exiting successfully " }, \
	27 { "marshall_creds:entry " vers=$D1 proc=$D2 seq=$D3 serv=$D4 }, \
	28 { "marshall_creds:__xdr_rpc_gss_creds failed " }, \
	29 { "marshall_creds:xdr_opaque_auth failed " }, \
	30 { "marshall_creds:exiting successfully " }, \
	31 { "marshall_verf:entry " vers=$D1 proc=$D2 seq=$D3 serv=$D4 }, \
	32 { "marshall_verf:not established case " exitcode=$D1 }, \
	33 { "marshall_verf:gss_sign failed " maj=$D1 min=$D2 }, \
	34 { "marshall_verf:established case " exitcode=$D1 }, \
	35 { "rpc_gss_marshall:entry " }, \
	36 { "rpc_gss_marshall:xdr_opaque_auth failed " }, \
	37 { "rpc_gss_marshall:exiting successfully " }, \
	38 { "rpc_gss_nextverf " }, \
	39 { "rpc_gss_validate:entry " }, \
	40 { "rpc_gss_validate:context not established " }, \
	41 { "rpc_gss_validate:gss_verify failed " maj=$D1 min=$D2 }, \
	42 { "rpc_gss_validate:exiting successfully " }, \
	43 { "rpc_gss_refresh:entry " vers=$D1 proc=$D2 seq=$D3 serv=$D4 }, \
	44 { "rpc_gss_refresh:data " why=$D1 est=$D2 iscon=$D3 }, \
	45 { "rpc_gss_refresh:not established " }, \
	46 { "rpc_gss_refresh:exiting successfully " }, \
	47 { "rpc_gss_refresh:rpc_gss_seccreate_pvt failed " }, \
	48 { "rpc_gss_refresh:exiting unsuccessfully " }, \
	49 { "rpc_gss_destroy:entry " }, \
	50 { "rpc_gss_destroy:exit " }, \
	51 { "rpc_gss_destroy_pvt:entry " }, \
	52 { "rpc_gss_destroy_pvt:informing server " }, \
	53 { "rpc_gss_destroy_pvt:destroying locally " }, \
	54 { "rpc_gss_destroy_pvt:destroying creds " }, \
	55 { "rpc_gss_destroy_pvt:destroying name " }, \
	56 { "rpc_gss_destroy_pvt:exit " }, \
	57 { "__rpc_gss_wrap:entry " buflen=$D1 }, \
	58 { "__rpc_gss_wrap:invalid context " }, \
	59 { "__rpc_gss_wrap:established " seqnum=$D1 }, \
	60 { "__rpc_gss_wrap:temp XDR_PUTBYTES failed " }, \
	61 { "__rpc_gss_wrap:marshall_creds failed " }, \
	62 { "__rpc_gss_wrap:marshall_verf failed " }, \
	63 { "__rpc_gss_wrap:real XDR_PUTBYTES failed " }, \
	64 { "__rpc_gss_wrap:no encryption " res=$D1 }, \
	65 { "__rpc_gss_wrap:encryption " res=$D1 }, \
	66 { "__rpc_gss_unwrap:entry " est=$D1 ser=$D2 }, \
	67 { "__rpc_gss_unwrap:no encryption " res=$D1 }, \
	68 { "__rpc_gss_unwrap:encryption " res=$D1 }, \
	69 { "__rpc_gss_max_data_length:entry " est=$D1 ser=$D2 len=$D3 }, \
	70 { "__rpc_gss_max_data_length:unable to determine " }, \
	71 { "__rpc_gss_max_data_length:returning " len=$D1 }, \
	72 { "__rpc_gss_max_get_error:entry " }, \
	73 { "__rpc_gss_max_get_error:returning " err=$D1 sys=$D2 }, \
	74 { "__rpc_gss_err:entry " }, \
	75 { "__rpc_gss_err:main thread " }, \
	76 { "__rpc_gss_err:_thr_keycreate failed " }, \
	77 { "__rpc_gss_err:calloc thread " }, \
	78 { "__rpc_gss_err:_thr_setspecific failed " }, \
	79 { "__rpc_gss_err:exiting with new memory " }, \
	80 { "__rpc_gss_err:exiting with old memory " }, \
	81 { "ctx_cleanup:entry " }, \
	82 { "ctx_cleanup:exit " }, \
	83 { "__rpc_gss_set_server_parms:entry " init=$D1 max=$D2 size=$D3 }, \
	84 { "__rpc_gss_set_server_parms:exit " }, \
	85 { "shift_bits:entry " bits=$D1 }, \
	86 { "shift_bits:exit " }, \
	87 { "check_seq:entry " seq=$D1 clseq=$D2 }, \
	88 { "check_seq:exceeds maximum " }, \
	89 { "check_seq:exceeds last seen " }, \
	90 { "check_seq:outside window " }, \
	91 { "check_seq:already seen " }, \
	92 { "check_seq:exiting successfully " }, \
	93 { "__rpc_gss_make_principal:entry " }, \
	94 { "__rpc_gss_make_principal:unable to allocate memory " }, \
	95 { "__rpc_gss_make_principal:exiting successfully " }, \
	96 { "set_client_principal:entry " }, \
	97 { "set_client_principal:gss_export_name failed " maj=$D1 min=$D2 }, \
	98 { "set_client_principal:exiting " res=$D1 }, \
	99 { "__rpc_gss_set_callback:entry " }, \
	100 { "__rpc_gss_set_callback:null callback " }, \
	101 { "__rpc_gss_set_callback:unable to allocate list entry " }, \
	102 { "__rpc_gss_set_callback:exiting successfully " }, \
	103 { "do_callback:entry " prog=$D1 vers=$D2 }, \
	104 { "do_callback:callback found " }, \
	105 { "do_callback:callback not found " }, \
	106 { "do_callback:exiting " res=$D1 }, \
	107 { "__rpc_gss_getcred:entry " }, \
	108 { "__rpc_gss_getcred:__rpc_gss_mech_to_oid failed " }, \
	109 { "__rpc_gss_getcred:gsscred_name_to_unix_cred failed " res=$D1}, \
	110 { "__rpc_gss_getcred:gss_get_group_info failed " res=$D1 }, \
	111 { "__rpc_gss_getcred:exiting " }, \
	112 { "__svcrpcsec_gss:entry " }, \
	113 { "__svcrpcsec_gss:zero-length cred " }, \
	114 { "__svcrpcsec_gss:__xdr_rpc_gss_creds failed" }, \
	115 { "__svcrpcsec_gss:bad service " service=$D1 }, \
	116 { "__svcrpcsec_gss:non-null context handle " }, \
	117 { "__svcrpcsec_gss:unable to create client " }, \
	118 { "__svcrpcsec_gss:null context handle " }, \
	119 { "__svcrpcsec_gss:unable to get client client " }, \
	120 { "__svcrpcsec_gss:stale client " }, \
	121 { "__svcrpcsec_gss:data request to nonestablished client " }, \
	122 { "__svcrpcsec_gss:init request to established client " }, \
	123 { "__svcrpcsec_gss:svc_getargs failed " }, \
	124 { "__svcrpcsec_gss:gss_accept_sec_context " maj=$D1 min=$D2 }, \
	125 { "__svcrpcsec_gss:gss_accept_sec_context after refresh " maj=$D1 min=$D2 }, \
	126 { "__svcrpcsec_gss:rpc_gss_refresh_svc_cred failed " }, \
	127 { "__svcrpcsec_gss:__rpc_gss_oid_to_mech failed " }, \
	128 { "__svcrpcsec_gss:set_client_principal failed " }, \
	129 { "__svcrpcsec_gss:gss failure " maj=$D1 min=$D2 }, \
	130 { "__svcrpcsec_gss:set_response_verf failed " }, \
	131 { "__svcrpcsec_gss:check_verf failed " }, \
	132 { "__svcrpcsec_gss:do_callback failed " }, \
	133 { "__svcrpcsec_gss:qop changed " }, \
	134 { "__svcrpcsec_gss:check_seq failed " stale=$D1 }, \
	135 { "__svcrpcsec_gss:set_response_verf failed " }, \
	136 { "__svcrpcsec_gss:gss procedure " proc=$D1 }, \
	137 { "__svcrpcsec_gss:not data or destroy " }, \
	138 { "__svcrpcsec_gss:service has changed " client=$D1 cred=$D2 }, \
	139 { "__svcrpcsec_gss:exiting successfully " }, \
	140 { "__svcrpcsec_gss:exiting unsuccessfully " ret=$D1 }, \
	141 { "check_verf:entry" }, \
	142 { "check_verf:exiting " maj=$D1 min=$D2 }, \
	143 { "set_response_verf:entry " }, \
	144 { "set_response_verf:gss_sign failed " maj=$D1 min=$D2 }, \
	145 { "set_response_verf:exiting successfully " }, \
	146 { "create_client:entry " }, \
	147 { "create_client:unable to allocate space for client " }, \
	148 { "create_client:too many clients " }, \
	149 { "create_client:exiting successfully " }, \
	150 { "insert_client:entry " }, \
	151 { "insert_client:exiting " contexts=$D1 }, \
	152 { "get_client:entry " key=$D1 }, \
	153 { "get_client:stale " }, \
	154 { "get_client:exiting " cl=$D1 }, \
	155 { "find_client:entry " key=$D1 }, \
	156 { "find_client:exiting " cl=$D1 }, \
	157 { "destroy_client:entry " key=$D1 }, \
	158 { "destroy_client:exiting " contexts=$D1 }, \
	159 { "sweep_clients:entry " }, \
	160 { "sweep_clients:exiting " }, \
	161 { "drop_lru_client:entry " }, \
	162 { "drop_lru_client:exiting " }, \
	163 { "find_svc_cred:entry " prog=$D1 vers=$D2 }, \
	164 { "find_svc_cred:no list to search " }, \
	165 { "find_svc_cred:exiting successfully " }, \
	166 { "find_svc_cred:exiting unsuccessfully " }, \
	167 { "__rpc_gss_set_svc_name:entry " }, \
	168 { "__rpc_gss_set_svc_name:__rpc_gss_mech_to_oid failed " }, \
	169 { "__rpc_gss_set_svc_name:gss_import_name failed " maj=$D1 min=$D2 }, \
	170 { "__rpc_gss_set_svc_name:gss_add_cred " maj=$D1 min=$D2 }, \
	171 { "__rpc_gss_set_svc_name:exiting successfully " }, \
	172 { "__rpc_gss_set_svc_name:exiting successfully on dup " }, \
	173 { "__rpc_gss_set_svc_name:exiting successfully after refresh " }, \
	174 { "__rpc_gss_set_svc_name:rpc_gss_refresh_svc_cred failed " }, \
	175 { "__rpc_gss_set_svc_name:exiting unsuccessfully on add fail" }, \
	176 { "__rpc_gss_set_svc_name:unable to allocate new cred " }, \
	177 { "__rpc_gss_set_svc_name:gss_acquire_cred failed " maj=$D1 min=$D2 }, \
	178 { "__rpc_gss_set_svc_name:unable to allocate server name " }, \
	179 { "__rpc_gss_set_svc_name:exiting successfully " }, \
	180 { "rpc_gss_refresh_svc_cred:entry " }, \
	181 { "rpc_gss_refresh_svc_cred:gss_acquire_cred failed " maj=$D1 min=$D2 }, \
	182 { "rpc_gss_refresh_svc_cred:exiting successfully " }, \
	183 { "svc_rpc_gss_wrap:entry " }, \
	184 { "svc_rpc_gss_wrap:no encryption " res=$D1 }, \
	185 { "svc_rpc_gss_wrap:encryption " res=$D2 }, \
	186 { "svc_rpc_gss_unwrap:entry " }, \
	187 { "svc_rpc_gss_unwrap:no encryption " res=$D1 }, \
	188 { "svc_rpc_gss_unwrap:encryption " res=$D2 }, \
	189 { "__rpc_gss_svc_max_data_length:entry " }, \
	190 { "__rpc_gss_svc_max_data_length:returning 0 " }, \
	191 { "__rpc_gss_svc_max_data_length:returning " $D1 }, \
	192 { "gss_get_group_info:entry " uid=$D1 }, \
	193 { "gss_get_group_info:IDtouser failed " }, \
	194 { "gss_get_group_info:getuserattr for pgrp failed " }, \
	195 { "gss_get_group_info:getgroupattr failed for pgrp " }, \
	196 { "gss_get_group_info:getuserattr for groups failed " }, \
	197 { "gss_get_group_info:unable to allocate gid array " }, \
	198 { "gss_get_group_info:getgroupattr failed " }, \
	199 { "gss_get_group_info:exiting " }, \
	200 { "gsscred_name_to_unix_cred:entry " }, \
	201 { "gsscred_name_to_unix_cred:gss_display_name failed " maj=$D1 }, \
	202 { "gsscred_name_to_unix_cred:unable to allocate name space " }, \
	203 { "gsscred_name_to_unix_cred:getpwnam_r failed " res=$D1 }, \
	204 { "gsscred_name_to_unix_cred:exiting " res=$D1 }, \
	205 { "__xdr_gss_buf:entry " }, \
	206 { "__xdr_gss_buf:exiting successfully " }, \
	207 { "__xdr_gss_buf:exiting unsuccessfully " }, \
	208 { "__xdr_rpc_gss_creds:entry " }, \
	209 { "__xdr_rpc_gss_creds:exiting unsuccessfully " }, \
	210 { "__xdr_rpc_gss_creds:exiting successfully " }, \
	211 { "__xdr_rpc_gss_init_arg:entry " }, \
	212 { "__xdr_rpc_gss_init_arg:exiting unsuccessully " }, \
	213 { "__xdr_rpc_gss_init_arg:exiting successfully " }, \
	214 { "__xdr_rpc_gss_init_res:entry " }, \
	215 { "__xdr_rpc_gss_init_res:exiting unsuccessully " }, \
	216 { "__xdr_rpc_gss_init_res:exiting successfully " }, \
	217 { "__rpc_gss_wrap_data:entry " }, \
	218 { "__rpc_gss_wrap_data:unable to allocate buffer " }, \
	219 { "__rpc_gss_wrap_data:unable to XDR sequence number " }, \
	220 { "__rpc_gss_wrap_data:unable to serialize args " }, \
	221 { "__rpc_gss_wrap_data:gss_seal failed " maj=$D1 min=$D2 }, \
	222 { "__rpc_gss_wrap_data:unable to encrypt args " }, \
	223 { "__rpc_gss_wrap_data:gss_sign failed " maj=$D1 min=$D2 }, \
	224 { "__rpc_gss_wrap_data:bad service " }, \
	225 { "__rpc_gss_wrap_data:unable to xdr in_buf " }, \
	226 { "__rpc_gss_wrap_data:unable to xdr out_buf " }, \
	227 { "__rpc_gss_wrap_data:exiting " res=$D1 }, \
	228 { "__rpc_gss_unwrap_data:entry " }, \
	229 { "__rpc_gss_unwrap_data:__xdr_gss_buf failed " }, \
	230 { "__rpc_gss_unwrap_data:gss_unseal failed " maj=$D1 min=$D2 }, \
	231 { "__rpc_gss_unwrap_data:bad conf or qop " conf=$D1 qop=$D2 qopcheck=$D3 }, \
	232 { "__rpc_gss_unwrap_data:unable to get checksum " }, \
	233 { "__rpc_gss_unwrap_data:gss_verify failed " maj=$D1 min=$D2 }, \
	234 { "__rpc_gss_unwrap_data:bad qop " qop=$D1 qopcheck=$D2 }, \
	235 { "__rpc_gss_unwrap_data:unable to XDR sequence number " }, \
	236 { "__rpc_gss_unwrap_data:sequence number mismatch " s1=$D1 s2=$D2 }, \
	237 { "__rpc_gss_unwrap_data:unable to deserialize args " }, \
	238 { "__rpc_gss_unwrap_data:exiting successfully " }, \
	239 { "__rpc_gss_unwrap_data:exiting unsuccessfully " }, \
	240 { "__find_max_data_length:entry " len=$D1 }, \
	241 { "__find_max_data_length:no encryption " }, \
	242 { "__find_max_data_length:exiting " size=$D1 }, \
	243 { "__find_max_data_length:gss_wrap_size_limit failed " maj=$D1 min=$D2 }, \
	244 { "__rpc_gss_mech_to_oid:entry " }, \
	245 { "__rpc_gss_mech_to_oid:mechanism not known " }, \
	246 { "__rpc_gss_mech_to_oid:exiting successfully " }, \
	247 { "__rpc_gss_oid_to_mech:entry " }, \
	248 { "__rpc_gss_oid_to_mech:exiting successfully " }, \
	249 { "__rpc_gss_oid_to_mech:unknown oid " }, \
	250 { "__rpc_gss_qop_to_num:entry " }, \
	251 { "__rpc_gss_qop_to_num:unknown mechanism " }, \
	252 { "__rpc_gss_qop_to_num:exiting successfully " qop=$D1 }, \
	253 { "__rpc_gss_qop_to_num:unknown qop " }, \
	254 { "__rpc_gss_num_to_qop:entry " qop=$D1 }, \
	255 { "__rpc_gss_num_to_qop:unknown mechanism " }, \
	256 { "__rpc_gss_num_to_qop:exiting successfully " }, \
	257 { "__rpc_gss_num_to_qop:unknown qop " }, \
	258 { "__rpc_gss_svc_to_num:entry " }, \
	259 { "__rpc_gss_svc_to_num:unknown service " }, \
	260 { "__rpc_gss_svc_to_num:exiting successfully " svc=$D1 }, \
	261 { "__rpc_gss_num_to_svc:entry " svc=$D1 }, \
	262 { "__rpc_gss_num_to_svc:exiting " res=$D1 }, \
	263 { "__rpc_gss_get_principal_name:entry " }, \
	264 { "__rpc_gss_get_principal_name:null user " }, \
	265 { "__rpc_gss_get_principal_name:__rpc_gss_mech_to_oid failed " }, \
	266 { "__rpc_gss_get_principal_name:gss_import_name failed " maj=$D1 min=$D2 }, \
	267 { "__rpc_gss_get_principal_name:gss_canonicalize_name failed " maj=$D1 min=$D2 }, \
	268 { "__rpc_gss_get_principal_name:gss_export_name failed " maj=$D1 min=$D2 }, \
	269 { "__rpc_gss_get_principal_name:unable to allocate principal " }, \
	270 { "__rpc_gss_get_principal_name:exiting successully " }, \
	271 { "__rpc_gss_get_mechanisms " }, \
	272 { "__rpc_gss_get_mech_info:entry" }, \
	273 { "__rpc_gss_get_mech_info:unknown mechanism " }, \
	274 { "__rpc_gss_get_mech_info:exiting successfully " }, \
	275 { "__rpc_gss_get_versions:entry " }, \
	276 { "__rpc_gss_get_versions:exiting successfully " hi=$D1 lo=$D2 }, \
	277 { "__rpc_gss_is_installed:entry " }, \
	278 { "__rpc_gss_is_installed:null mechanism " }, \
	279 { "__rpc_gss_is_installed:__rpc_gss_get_mechanisms failed " }, \
	280 { "__rpc_gss_is_installed:exiting successfully " }, \
	281 { "__rpc_gss_is_installed:exiting unsuccessfully " }, \
	282 { "gsscred_name_to_unix_cred:foreign realm " }
211 1.0 "@NFS: Client VNOP read/write routines" \
        $HD%D1, \
       1  { "NFS_READ     " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       2  { "NFS_WRITE    " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       3  { "NFS3_READ    " \
                $D2, \
                0  { vp=$D1 uio_offset=$D3 uio_resid=$D4 starttimer(0x211,$D1) }, \
                1  { vp=$D1 uio_offset=$D3 error=$D4 endtimer(0x211,$D1) }, \
                2  {    r_flags=$D3 vci_flags=$D4 }, \
                \* { D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 } }, \
       4  { "NFS3_WRITE   " \
                $D2, \
                0  { vp=$D1 uio_offset=$D5 uio_resid=$D3 starttimer(0x211,$D1) }, \
                1  { vp=$D1 uio_offset=$D5 uio_resid=$D3 error=$D4 endtimer(0x211,$D1) }, \
                2  {    r_flags=$D3 vci_minpout=$D4 vci_maxpout=$D5}, \
                3  { rp=$D1 flush_vp failed error=$D3 }, \
		4  { recover_async_error failed }, \
		5  { nfs3getattr failed }, \
		6  { start offset too large start_offset=$D3 }, \
		7  { bad offset start_offset=$D3 end_offset=$D4 }, \
		8  { writing past ulimit }, \
		9  { end offset too large end_offset=$D3 }, \
                \* { D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 } }, \
       5  { "NFS3WRITE    " \
		$D2, \
		0  { vp=$D1 count=$D3 offset=$D4 how=$D5 starttimer(0x211,$D1) }, \
		1  { bad dtype=$D3 vp=$D1 endtimer(0x211,$D1) }, \
		2  { rfs3call failed vp=$D1 error=$D3 endtimer(0x211,$D1) }, \
		3  { server wrote too much wrote=$D3 requested $D4 vp=$D1 \
					endtimer(0x211,$D1) }, \
		4  { server did not commit to stable storage stab_com=$D3 vp=$D1 \
					endtimer(0x211,$D1) }, \
		5  { vp=$D1 error=$D3 endtimer(0x211,$D1) } }, \
       6  { "NFS3READ     " \
		$D2, \
		0  { nfs3read enter vp=$D1 count=$D3 base=$D4 offset=$D5 starttimer(0x211,$D1) }, \
		1  { nfs3read exit vp=$D1 count=$D3 offset=$D4 error=$D5 endtimer(0x211,$D1) } }, \
       7  { "NFS3_READDIRPLUS " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       8  { "NFS3_BIO     " \
		$D1%D1, \
		0  { bp=$D2 rnode=$D3%X4 how=$D4 starttimer(0x211,$D2) }, \
		1  { bp->flags=$D2 bp->blkno=$D3%X4 bp->count=$D4 }, \
		2  { dead mount }, \
		3  { protection fault bp=$D2 rp=$D3%X4 endtimer(0x211,$D2) }, \
		4  { bio work vnode=$D2 work=$D3 count=$D4 block=$D5 }, \
		5  { bio baddr bp=$D2 baddr=$D3 }, \
		6  { vnode=$D2%X4 r_size=$D3$D4 r_modaddr=$D5 }, \
		7  { offset=$D2$D3 rem=$D4$D5 }, \
		8  { r_modaddr=$D2$D3 count=$D4$D5 }, \
		9  { file was truncated endtimer(0x211,$D2) }, \
		10 { write result: vp=$D2 r_error=$D3 error=$D4 count=$D5 }, \
		11 { purge attrcache: rp=$D2 }, \
		12 { write done: bp=$D2 b_flags=$D3 b_error=$D4 }, \
		13 { exit: ibp=$D2 bp=$D3 rp=$D4 error=$D5 endtimer(0x211,$D2) } }, \
       9  { "NFS3_BINVAL  " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       10 { "NFS3_ASYSTART" D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       11 { "NFS3_ASYWKUP " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       12 { "NFS3_ASYOP   " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       13 { "NFS3_ASYSTOP " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       14 { "NFS3_ASYNC_STOP " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       15 { "NFS3_WRITERP " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       16 { "NFS3_FLUSHVP " \
		$D2%D1,	\
		0  { vp=$D1 r_sid=$D3 v_flags=$D4 rap=$D5 starttimer(0x211,$D1) }, \
		1  { r_size=$D3 v_count=$D4 r_error=$D5 }, \
		2  { bad offset or length vnode=$D1 offset=$D3 length=$D4 }, \
		3  { offset too big offset=$D3 r_size=$D4 }, \
		4  { flushing pages vnode=$D1 numpages=$D3 r_size=$D4 }, \
		5  { flushing index vnode=$D1 indx=$D3 incrpage=$D4 numpages=$D5 }, \
		6  { vms_iowait error path=$D1 werror=$D3 r_size=$D4 r_error=$D5 }, \
		7  { done flushing pages vnode=$D1 indx=$D3 r_size=$D4 end=$D5 }, \
		8  { flush cancelled vnode=$D1 }, \
		9  { flush whole file vnode=$D1 numpages=$D3 r_error=$D4 }, \
		10 { aborting flush vnode=$D1 r_size=$D3 r_error=$D4 }, \
		11 { flush file vnode=$D1 numpages=$D3 firstpage=$D4 r_flags=$D5 }, \
		12 { clearing RRECOVER and RHAVEVERF }, \
		13 { exit reterror=$D3 r_size=$D4 r_flags=$D5 endtimer(0x211,$D1) } }, \
       17 { "NFS3_ERROR   " instance=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       18 { "NFS3_RECOVERY" vp=$D1 D2=D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       19 { "NFS3_COMMIT  " \
		$D1, \
		0  { vp=$D2 offset=$D3 count=$D4 recover=$D5 starttimer(0x211,$D2) }, \
		1  { hostcall failed error=$D3 endtimer(0x211,$D2) }, \
		2  { exit vp=$D2 error=$D3 offset=$D4 count=$D5 endtimer(0x211,$D2) }, \
		3  { verifier mismatch error=$D3 endtimer(0x211,$D2) } }, \
       22 { "NFS_STRATEGY " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       33 { "NFS_BIO      " D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       328 { "NFS3_UTILITY" $D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }, \
       \* { `mode=$HD` D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
212 1.0 "@NFS: Client VNOP routines" \
	$HOOKENV, \
	32  { \
        	HT & 0x7, \
			0 { \
			$D1%D4, \
			2  { "NFS_LOOKUP     " G8 $HD%S1 }, \
			32 { "NFS3_LOOKUP    " G8 $HD%S1 }, \
			9  { "NFS_CREATE     " G8 $HD%S1 }, \
			10 { "NFS_REMOVE     " G8 $HD%S1 }, \
			11 { "NFS_LINK       " G8 $HD%S1 }, \
			12 { "NFS_RENAME  from: " G8 $HD%S1 }, \
			4108 { "NFS_RENAME  to:   " G8 $HD%S1 }, \
			13 { "NFS_MKDIR      " G8 $HD%S1 }, \
			14 { "NFS_RMDIR      " G8 $HD%S1 }, \
			316 { "NFS_SYMLINK from: " G8 $HD%S1 }, \
			0x1010 { "NFS_SYMLINK to:   " G8 $HD%S1 }, \
			\* { `NFS_VOPS genmode=$D1` } \
			$BREAK \
		} }, \
	64 { \
		HT & 0X4000, \
		0x4000 { \
			$D1%D4, \
			2  { "NFS_LOOKUP     " G16 $HL%S1 }, \
			32 { "NFS3_LOOKUP    " G16 $HL%S1 }, \
			9  { "NFS_CREATE     " G16 $HL%S1 }, \
			10 { "NFS_REMOVE     " G16 $HL%S1 }, \
			11 { "NFS_LINK       " G16 $HL%S1 }, \
			12 { "NFS_RENAME  from: " G16 $HL%S1 }, \
			4108 { "NFS_RENAME  to:   " G16 $HL%S1 }, \
			13 { "NFS_MKDIR      " G16 $HL%S1 }, \
			14 { "NFS_RMDIR      " G16 $HL%S1 }, \
			316 { "NFS_SYMLINK from: " G16 $HL%S1 }, \
			0x1010 { "NFS_SYMLINK to:   " G16 $HL%S1 }, \
			\* { `NFS_VOPS genmode=$D1` } \
			$BREAK \
		} } \
	$HD%D1, \
	1  { "NFS_SELECT     " vnode=$D1 }, \
	31 { "NFS3_SELECT    " vnode=$D1 }, \
	2  { "NFS_LOOKUP     " \
		$D1, \
		0  { "directory vnode " $D2%X4 }, \
		1  { "from dnlc " \
			$D2, \
			0  { "file not found" }, \
			\* { lookuppninstall2($D2) vnode=$D2 } \
		     vnode=$D2%X4 error=$D3 }, \
		2  { "from server " \
			$D2, \
			0  { "file not found" }, \
			\* { lookuppninstall2($D2) vnode=$D2 } \
		     vnode=$D2 error=$D3 } }, \
        32 { "NFS3_LOOKUP     " \
                $D1, \
                0  { "directory vnode " $D2%X4 name=$D3 starttimer(0x212,$D2) }, \
                1  { "from dnlc " \
                        $D2, \
                        0  { "file not found" }, \
                        \* { lookuppninstall2($D2) vnode=$D2 } \
                     vnode=$D2%X4 error=$D3 dvp=$D4 name=$D5 endtimer(0x212,$D4) }, \
                2  { "from server " \
                        $D2, \
                        0  { "file not found" }, \
                        \* { lookuppninstall2($D2) vnode=$D2 } \
                     vnode=$D2%X4 error=$D3 dvp=$D4 name=$D5 endtimer(0x212,$D4) } }, \
        3  { "NFS_OPEN       " \
		$D2, \
		0  { vnode=$D1 enter v_count=$D3 }, \
		1  { vnode=$D1 exit v_count=$D3 error=$D4 } }, \
        33 { "NFS3_OPEN      " \
		$D2, \
		0  { vnode=$D1 enter v_count=$D3 starttimer(0x212, $D1) }, \
		1  { vnode=$D1 exit v_count=$D3 error=$D4 endtimer(0x212,$D1) }, \
		2  { vnode=$D1 file in CIO: oflags=$D3 r_flags=$D4 error=$D5 }, \
		3  { vnode=$D1 file out of DIO mode: oflags=$D3 r_flags=$D4 }, \
		4  { vnode=$D1 can not open in CIO: oflags=$D3 r_flags=$D4 error=$D5 }, \
		5  { vnode=$D1 file now in CIO/DIO: oflags=$D3 r_flags=$D4 }, \
		6  { vnode=$D1 increment r_diocnt: oflags=$D3 r_flags=$D4 r_diocnt=$D5 }, \
		7  { vnode=$D1 flush prior to DIO/CIO: oflags=$D3 r_flags=$D4 error=$D5 }, \
		8  { vnode=$D1 getattr failed error=$D3 } }, \
        4  { "NFS_CLOSE      " \
		$D2, \
		0  { vnode=$D1 enter v_count=$D3 \
			flag=$D4%X4 r_error=$D5 }, \
		1  { vnode=$D1 sync error=$D3 r_error=$D4 }, \
		2  { vnode=$D1 exit v_count=$D4 error=$D3 } }, \
        34 { "NFS3_CLOSE     " \
		$D2, \
		0  { vnode=$D1 enter v_count=$D3 flag=$D4%X4 \
				r_error=$D5 starttimer(0x212,$D1) }, \
		1  { vnode=$D1 sync error=$D3 r_error=$D4 }, \
		2  { vnode=$D1 exit v_count=$D4 error=$D3 endtimer(0x212,$D1) }, \
		3  { vnode=$D1 back in DIO mode: oflags=$D3 r_flags=$D4 }, \
		4  { vnode=$D1 out of DIO/CIO mode: oflags=$D3 r_flags=$D4 } }, \
        5  { "NFS_IOCTL      " vnode=$D1 }, \
        35 { "NFS3_IOCTL     " vnode=$D1 }, \
        6  { "NFS_GETATTR    " \
		$D2, \
		0  { vnode=$D1 flags=$D4%X4 va_mask=$D5%X4 }, \
		1  { vnode=$D1 va_size=$D3 error=$D4 \
			 r_error=$D5 } }, \
        36 { "NFS3_GETATTR   " \
		$D2, \
		0  { vnode=$D1 flags=$D4%X4 va_mask=$D5%X4 starttimer(0x212,$D1) }, \
		1  { vnode=$D1 va_size=$D3 error=$D4 \
			 r_error=$D5 endtimer(0x212,$D1) } }, \
        7  { "NFS_SETATTR    " \
		$D2, \
		0  { vnode=$D1 mask=$D3%X4 flags=$D5%X4 }, \
		1  { vnode=$D1 exit size=$D3 error=$D5 }, \
		2  { vnode=$D1 setattr r_count=$D3 \
			flags=$D5%X4 } }, \
	37 { "NFS3_SETATTR   " \
		$D2, \
		0  { vnode=$D1 mask=$D3%X4 flags=$D5%X4 starttimer(0x212,$D1) }, \
		1  { vnode=$D1 exit size=$D3 error=$D5 endtimer(0x212,$D1) }, \
		2  { vnode=$D1 setattr3 r_count=$D3 \
                        flags=$D5%X4 } }, \
        8  { "NFS_ACCESS     " \
		$D2, \
		0  { vnode=$D1 mode=$D3%X4 flags=$D3%X4 }, \
		1  { vnode=$D1 exit mode=$D3%X4 error=$D5 } }, \
        38 { "NFS3_ACCESS    " \
		$D2, \
		0  { vnode=$D1 mode=$D3%X4 who=$D3%D4 starttimer(0x212,$D1) }, \
		1  { vnode=$D1 exit mode=$D3%X4 error=$D4 endtimer(0x212,$D1) } }, \
        9  { "NFS_CREATE     " \
		$D1, \
		0  { directory vnode=$D2%X4 exclusive=$D3 }, \
		1  { "file exists " \
			$D2, \
			0  { "file not found" }, \
			\* { lookuppninstall2($D2) vnode=$D2 } \
		     error=$D4 }, \
		2  { "from server " \
			$D2, \
			0  { "file not found" }, \
			\* { lookuppninstall2($D2) vnode=$D2 } \
		     error=$D3 } }, \
        39 { "NFS3_CREATE    " \
		$D1, \
		0  { directory vnode=$D2 name=$D5 exclusive=$D3 starttimer(0x212,$D2) }, \
		1  { "file exists " \
			$D2, \
			0  { "file not found" }, \
			\* { lookuppninstall2($D2) vnode=$D2 } \
		     error=$D3 dvp=$D4 name=$D5 endtimer(0x212,$D2) }, \
		2  { "from server " \
			$D2, \
			0  { "file not found" }, \
			\* { lookuppninstall2($D2) vnode=$D2 } \
		     error=$D3 dvp=$D4 name=$D5 endtimer(0x212,$D2) } }, \
        10 { "NFS_REMOVE     " \
		$D1, \
		0  { lookup failed error=$D2 }, \
		1  { permission failure v_count=$D2 }, \
		2  { lookuppninstall($D2) vnode=$D2 \
			v_count=$D3 error=$D4 } },\
        310 { "NFS3_REMOVE    " \
		$D1, \
		0  { lookup failed error=$D2 dvp=$D3 name=$D4 endtimer($TID,$D3) }, \
		1  { permission failure dvp=$D2 name=$D3 vp=$D4 endtimer($TID,$D2) }, \
		2  { vnode=$D2 dvp=$D3 error=$D4 name=$D5 endtimer($TID,$D3) },\
		3  { nfs3_remove enter dvp=$D2 starttimer($TID,$D2) } }, \
        11 { "NFS_LINK       " \
		$D1, \
		0  { tdv vnode=$D2 \
		     sdv vnode=$D2 }, \
		1  { tdv vnode=$D2 error=$D3 } },\
        311 { "NFS3_LINK      " \
		$D1, \
		0  { tdv vnode=$D2 \
		     sdv vnode=$D3 name=$D4 starttimer(0x212,$D2) }, \
		1  { hostcall failed tdvp=$D2 error=$D3 name=$D4 svp=$D5 endtimer(0x212,$D2) },\
		2  { tdv vnode=$D2 error=$D3 name=$D4 svp=$D5 endtimer(0x212,$D2) } },\
        12 { "NFS_RENAME     " \
		$D1, \
		0  { old vnode=$D2%X4 newvnode=$D3%X4 }, \
		1  { error=$D2 } }, \
        312 { "NFS3_RENAME    " \
		$D1, \
		0  { oldvnode=$D2 newvnode=$D3 starttimer(0x212,$D2) }, \
		1  { error=$D2 oldvnode=$D3 endtimer(0x212,$D3) }, \
		2  { file is dot or dotdot odvp=$D2 ndvp=$D3 error=$D4 }, \
		3  { target vp is covered nvp=$D2 error=$D3 }, \
		4  { source file does not exist odvp=$D2 oldname=$D3 }, \
		5  { file type mismatch odvp=$D2 oldname=$D3 }, \
		6  { link to tmpname failed ndvp=$D2 newname=$D3 }, \
		7  { server call failed error=$D2 }, \
		8  { server error error=$D2 odvp=$D3 ndvp=$D4 newname=$D5 } }, \
        13 { "NFS_MKDIR      " \
		$D1, \
		0  { directory vnode=$D2%X4 }, \
		1  { vnode=$D2%X4 error=$D3 } }, \
        313 { "NFS3_MKDIR     " \
		$D1, \
		0  { directory vnode=$D2 starttimer(0x212,$D2) }, \
		1  { vp=$D2 error=$D3 dvp=$D4 name=$D5 endtimer(0x212,$D4) }, \
		2  { hostcall failed dvp=$D2 error=$D3 name=$D4 endtimer(0x212,$D2) }, \
		3  { lookup failed dvp=$D2 error=$D3 name=$D4 endtimer(0x212,$D2) }, \
		4  { getattr failed vp=$D2 error=$D3 dvp=$D4 name=$D5 endtimer(0x212,$D4) } }, \
        14 { "NFS_RMDIR      " \
		$D1, \
		0  { vp=$D2%X4 dvp=$D3%X4 cdir=$D4%X4 }, \
		1  { error=$D2 } }, \
        314 { "NFS3_RMDIR     " \
		$D1, \
		0  { dvp=$D2 cdir=$D3 name=$D4 starttimer(0x212,$D2) }, \
		1  { error=$D2 dvp=$D3 name=$D4 endtimer(0x212,$D2) }, \
		2  { lookup failed error=$D2 dvp=$D3 name=$D4 endtimer(0x212,$D3) }, \
		3  { removing current directory error=$D2 dvp=$D3 name=$D4 endtimer(0x212,$D3) }, \
		4  { servercall failed error=$D2 dvp=$D3 name=$D4 endtimer(0x212,$D3) } }, \
        15 { "NFS_READDIR    " \
		$D1, \
		0  { vnode=$D2 cookie=$D3 }, \
		1  { vnode=$D2 error=$D3 } }, \
        315 { "NFS3_READDIR   " \
		$D1, \
		0  { vnode=$D2 cookie=$D3 starttimer(0x212, $D2) }, \
		1  { vnode=$D2 error=$D3 endtimer(0x212, $D2) }, \
		2  { "purged readdir cache" }, \
		3  { "did not purge readdir cache" }, \
		4  { "large dir - purged readdir cache" } }, \
        16 { "NFS_SYMLINK    " \
		$D1, \
		0  { vnode=$D2 }, \
		1  { vnode=$D2 error=$D3 } }, \
        316 { "NFS3_SYMLINK   " \
		$D1, \
		0  { vnode=$D2 starttimer(0x212,$D2) }, \
		1  { vnode=$D2 error=$D3 lnm=$D4 tnm=$D5 endtimer(0x212,$D2) } }, \
        17 { "NFS_READLINK   " \
		$D1, \
		0  { vnode=$D2 }, \
		1  { vnode=$D2 error=$D3 } }, \
        317 { "NFS3_READLINK  " \
		$D1, \
		0  { vnode=$D2 starttimer(0x212,$D2) }, \
		1  { vnode=$D2 error=$D3 endtimer(0x212,$D2) } }, \
        18 { "NFS_FSYNC      " \
		$D1, \
		0  { vnode=$D2 syncflag=$D3 }, \
		1  { vnode=$D2 swap file }, \
		2  { vnode=$D2 error=$D3 } }, \
        318 { "NFS3_FSYNC     " \
		$D1, \
		0  { vnode=$D2 syncflag=$D3 starttimer(0x22,$D2) }, \
		1  { vnode=$D2 swap file endtimer(0x22,$D2) }, \
		2  { vnode=$D2 error=$D3 endtimer(0x22,$D2) } }, \
        19 { "NFS_INACTIVE   " \
		$D1, \
		0  { vnode=$D2 vcount=$D3 sid=$D4 rcount=$D5}, \
		1  { vnode=$D2 vfsnext=$D3%X4 vfsprev=$D4%X4 \
			unldvp=$D5%X4 }, \
		2  { vnode=$D2 exit } }, \
        319 { "NFS3_INACTIVE  " \
		$D1, \
		0  { vnode=$D2 vcount=$D3 sid=$D4 rcount=$D5 starttimer(0x212,$D2) }, \
		1  { vnode=$D2 vfsnext=$D3%X4 vfsprev=$D4%X4 \
			unldvp=$D5%X4 }, \
		2  { vnode=$D2 exit endtimer(0x212,$D2) } }, \
        20 { "NFS_BMAP       "  \
		$D1, \
		0  { vnode=$D2 flag=$D3 offset=$D4 length=$D5 }, \
		1  { vnode=$D2 error=$D3 sid=$D4 mwrcnt=$D5 } }, \
        320 { "NFS3_BMAP      "  \
		$D1, \
		0  { vnode=$D2 mflag=$D3 fflag=$D4 starttimer(0x212,$D2) }, \
		1  { vnode=$D2 error=$D3 sid=$D4 mwrcnt=$D5 endtimer(0x212,$D2) }, \
		2  { vnode=$D2 offset=$D3 length=$D4 } }, \
        21 { "NFS_BADOP" }, \
        321 { "NFS3_BADOP" }, \
        22 { "NFS_STRATEGY   " vnode=$D2 code=$D1 }, \
	23 { "NFS_LOCKCTL    " vnode=$D1 locktype=$D2%X4 start=$D3 \
				len=$D4 pid=$D5%D4}, \
        24 { "NFS_NOOP" }, \
        324 { "NFS3_NOOP" }, \
        26 { "NFS_CMP" }, \
        326 { "NFS3_CMP" }, \
	40  { "NFS_DNLC_ENTER " \
		$D1, \
		0  { vnode=$D2 v_count=$D4 doingcache=$D5 }, \
		1  { vnode=$D2 v_count=$D4 exitspot=$D5} }, \
	41  { "NFS_DNLC_LOOKUP " \
		$D1, \
		0  { vnode=$D2 doingcache=$D4 }, \
		1  { vnode=$D2 vnode=$D3 \
			exitspot=$D5 } }, \
	42  { "NFS_DNLC_REMOVE " \
		$D1, \
		0  { vnode=$D2 doingcache=$D4 }, \
		1  { vnode=$D3 removing vnode=$D2 } },\
	43  { "NFS_DNLC_PURGE " \
		$D1, \
		0  { enter doingcache=$D2 }, \
		1  { exit } }, \
	44  { "NFS_DNLC_PURGE_VP " \
		$D1, \
		0  { vnode=$D2 doingcache=$D3 }, \
		1  { vnode=$D2 exit } }, \
	45  { "NFS_DNLC_PURGE_VFSP " \
		$D1, \
		0  { vfsp=$D2%X4 count=$D3 doingcache=$D4 }, \
		1  { vfsp=$D2%X4 n=$D3 } }, \
	46  { "NFS_DNLC_UPDATE_ENTER " \
		$D1, \
		0  { vnode=$D2 v_count=$D4 doingcache=$D5 }, \
		1  { vnode=$D2 v_count=$D4 exitspot=$D5} }, \
	327 { "NFS3_PATHCONF " \
		$D1, \
		0  { vnode=$D2 bufp=$D3%X4 starttimer(0x212,$D2) }, \
		1  { vnode=$D2 error=$D3 endtimer(0x212,$D2) } }, \
	328 { "NFS3_UTILITY " d1=$D1%X4 d2=$D2%X4 d3=$D3%X4 \
		d4=$D4%X4 d5=$D5%X4 }, \
	329 { "NFS_FSYNC_RANGE " \
		$D1, \
		0  { vnode=$D2 off=$D3 range=$D4 }, \
		1  { vnode=$D2 error=$D3} },\
	350 { "NFS3_MOUNT " \
		$D1%D1, \
		0  { vfsp=$D2 vnode=$D3 starttimer(0x212,$D2) }, \
		1  { not superuser vfsp=$D2 vnode=$D3 endtimer(0x212,$D2) }, \
		2  { not a directory vfsp=$D2 vnode=$D3 endtimer(0x212,$D2) }, \
		3  { getargs error vfsp=$D2 vnode=$D3 error=$D4 endtimer(0x212,$D2) }, \
		4  { syncaddr error vfsp=$D2 vnode=$D3 error=$D4 }, \
		5  { nfs3rootvp error vfsp=$D2 vnode=$D3 error=$D4 }, \
		6  { invalid retrans vfsp=$D2 vnode=$D3 }, \
		7  { invalid timeo vfsp=$D2 vnode=$D3 }, \
		8  { invalid rsize vfsp=$D2 vnode=$D3 }, \
		9  { invalid wsize vfsp=$D2 vnode=$D3 }, \
		10 { vfsaddlist failed vfsp=$D2 vnode=$D3 error=$D4 }, \
		11 { mount exit vfsp=$D2 vnode=$D3 error=$D4 endtimer(0x212,$D2) } }, \
	351 { "NFS3_UMOUNT " \
		$D1%D1, \
		0  { vfsp=$D2 starttimer(0x212,$D2) }, \
		1  { not superuser vfsp=$D2 endtimer(0x212,$D2) }, \
		2  { mount busy vfsp=$D2 endtimer(0x212,$D2) }, \
		3  { vfsrmlist failed vfsp=$D2 error=$D3 endtimer(0x212,$D2) }, \
		4  { forced umount vfsp=$D2 endtimer(0x212,$D2) }, \
		5  { umount vfsp=$D2 endtimer(0x212,$D2) } }, \
	352 { "NFS3_STATVFS " \
		$D1%D1, \
		0  { vfsp=$D2 mi=$D3 starttimer(0x212,$D2) }, \
		1  { vfsp=$D2 mi=$D3 which=$D4 error=$D5 endtimer(0x212,$D2) } }, \
	353 { "NFS_ALLOC_PDT " \
		$D1%D1, \
		0  { start np=$D2 strategy=$D3 starttimer(0x212,$D2) }, \
		1  { alloc failed np=$D2 strategy=$D3 error=$D4 endtimer(0x212,$D2) }, \
		2  { too much pdt np=$D2 strategy=$D3 error=$D4 endtimer(0x212,$D2) }, \
		3  { can not pin np=$D2 strategy=$D3 error=$D4 endtimer(0x212,$D2) }, \
		4  { vm_mount failed np=$D2 strategy=$D3 error=$D4 endtimer(0x212,$D2) }, \
		5  { end np=$D2 strategy=$D3 error=$D4 endtimer(0x212,$D2) } }, \
	354 { "NFS_PDT_HOLD " np=$D1 ref=$D2 }, \
	355 { "NFS_PDT_RELE " \
		$D1%D1, \
		0  { start np=$D2 ref=$D3 vers=$D4 starttimer(0x212,$D2) }, \
		1  { invalid vers np=$D2 error=$D3 vers=$D4 endtimer(0x212,$D2) }, \
		2  { no free np=$D2 ref=$D3 vers=$D4 endtimer(0x212,$D2) }, \
		3  { free np=$D2 strategy=$D3 vers=$D4 endtimer(0x212,$D2) }, \
		4  { not in list np=$D2 strategy=$D3 error=$D4 endtimer(0x212,$D2) } }, \
	356 { "NFS_GET_PDT " \
		$D1%D1, \
		0  { start np=$D2 vers=$D3 starttimer(0x212,$D2) }, \
		1  { invalid vers np=$D2 vers=$D3 error=$D4 endtimer(0x212,$D2) }, \
		2  { alloc failed np=$D2 vers=$D3 error=$D4 endtimer(0x212,$D2) }, \
		3  { end np=$D2 vers=$D3 error=$D4 endtimer(0x212,$D2) } }, \
	357 { "NFS_IP_EQUAL " }, \
	358 { "NFS_SERV_HOLD " ns=$D1 ns_ref=$D2 }, \
	359 { "NFS_SERV_RELE " \
		$D1%D1, \
		0  { start np=$D2 ns_ref=$D3 vers=$D4 starttimer(0x212,$D2) }, \
		1  { invalid vers np=$D2 error=$D3 vers=$D4 endtimer(0x212,$D2) }, \
		2  { no free np=$D2 ns_ref=$D3 vers=$D4 endtimer(0x212,$D2) }, \
		3  { free np=$D2 ns_pdt=$D3 vers=$D4 endtimer(0x212,$D2) }, \
		4  { not in list np=$D2 ns_pdt=$D3 vers=$D4 endtimer(0x212,$D2) } }, \
	360 { "NFS_GET_SERV " \
		$D1%D1, \
		0  { start vers=$D2 addr=$D3 ns=$D4 starttimer(0x212,$D3) }, \
		1  { invalid vers vers=$D2 addr=$D3 ns=$D4 error=$D5 endtimer(0x212,$D3) }, \
		2  { alloc failed vers=$D2 addr=$D3 ns=$D4 error=$D5 endtimer(0x212,$D3) }, \
		3  { get_pdt failed vers=$D2 addr=$D3 ns=$D4 error=$D5 endtimer(0x212,$D3) }, \
		4  { end vers=$D2 addr=$D3 ns=$D4 endtimer(0x212,$D3) } }, \
	361 { "NFS_VMM_REGISTER " pid=$D1 }, \
	362 { "NFS_VMM_UNREGISTER " pid=$D1 }, \
	363 { "NFS_AM_BIOD " pid=$D1 res=$D2 }, \
	400 { "NFS3_CNTL " \
		$D1%D1, \
		0  { start vfs=$D2 cmd=$D3 arg=$D4 argsize=$D5 starttimer(0x212,$D2) }, \
		1  { rmnt const failed vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) }, \
		2  { rmnt adjust failed vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) }, \
		3  { end vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) }, \
		4  { bad cmd vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) } }, \
	401 { "NFS_REMOUNT " }, \
	402 { "NFS_V3_ADJ_ARGS " \
		$D1%D1, \
		0  { start args=$D2 error=$D3 starttimer(0x212,$D2) }, \
		1  { timeo bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		2  { retrans bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		3  { rsize bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		4  { wsize bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		5  { syncaddr bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		6  { copyin64 bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		7  { copyinstr64 bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		8  { netname bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		\* { end args=$D2 error=$D3 endtimer(0x212,$D2) } }, \
	403 { "NFS_V3_REMOUNT " \
		$D1%D1, \
		0  { start vfsp=$D2 vmtp=$D3 starttimer(0x212, $D2) }, \
		\* { end vfsp=$D2 vmtp=$D3 endtimer(0x212, $D2) } }, \
	450 { "swapnfs_config " \
		$D1%D1, \
		0  { "start" device=$D2 cmd=$D3 }, \
		1  { "failed at init_keys()" rc=$D2 }, \
		2  { "failed at setup_swap_file()" rc=$D2 }, \
		3  { "failed at devswadd()" rc=$D2 }, \
		4  { "failed at pincode()" rc=$D2 }, \
		5  { "failed with EINVAL" cmd=$D2 }, \
		6  { "succeeded." } }, \
	451 { "setup_swap_file " \
		$D1%D1, \
		0  { "start" uiop=$D2 device=$D3 }, \
		1  { "failed. uiop is NULL" }, \
		2  { "failed. xmalloc iov_len failed." size=$D2 }, \
		3  { "failed. v4 xmalloc hostname failed." size=$D2 }, \
		4  { "failed. v4 xmalloc swapfilename failed." size=$D2 }, \
		5  { "failed. bad type." type=$D2 }, \
		6  { "failed. v6 xmalloc hostname failed." size=$D2 }, \
		7  { "failed. v6 xmalloc swapfilename failed." size=$D2 }, \
		8  { "failed." }, \
		9  { "failed. creatp() failed." rc=$D2 }, \
		10 { "failed. initp() failed." rc=$D2 }, \
		11 { "succeeded." vfsp_return=$D2 } }, \
	452 { "nfs_config_swap_dev " \
		$D1%D1, \
		0  { "start" device=$D2 }, \
		1  { "failed. pool is NULL" }, \
		2  { "failed at nfs_swapvp()" }, \
		3  { "failed. vp is NULL" }, \
		4  { "succeeded." vfsp_swap_devices=$D2 } }, \
	453 { "nfs_swapvp " \
		$D1%D1, \
		0  { "start" vfsp=$D2 vers=$D3 }, \
		1  { "failed with EINVAL" sin_family=$D2 }, \
		2  { "failed with EINVAL" vers=$D2 }, \
		3  { "failed @3 with EINVAL" }, \
		4  { "failed with ENOMEM pathlen" size=$D2 }, \
		5  { "failed @5 with EINVAL" }, \
		6  { "failed at second mountnfs()" rc=$D2 }, \
		7  { "failed at first nfsrootvp()" rc=$D2 }, \
		8  { "failed at nfs_lookup()" rc=$D2 }, \
		9  { "failed at first mountnfs()" rc=$D2 }, \
		10 { "failed at nfs_serv_get()" rc=$D2 }, \
		11 { "failed at second nfsrootvp()" rc=$D2 }, \
		12 { "succeeded." } }, \
	454 { "nfs4_setup_swap_file " \
		$D1%D1, \
		0  { "start" vfsp=$D2 }, \
		1  { "failed with ENOMEM mip" size=$D2 }, \
		2  { "failed with ENOMEM fsidp" size=$D2 }, \
		3  { "failed with ENOMEM f_locp" size=$D2 }, \
		4  { "failed with ENOMEM f_serv" size=$D2 }, \
		5  { "failed with ENOMEM f_path" size=$D2 }, \
		6  { "failed with ENOMEM servp" size=$D2 }, \
		7  { "failed at nfs4pathlookup()" rc=$D2 }, \
		8  { "failed at makenfs4node()" rc=$D2 }, \
		9  { "succeeded." } }, \
        \* { `NFS_VOPS mode=$HD` }
213 1.0 "@NFS: Server read/write services" \
{{ \
nfsseqno(seqno) \
`seqno=$seqno%D1` \
}} \
        $HD%D1, \
        1  { "RFS_READ       " }, \
        2  { "RFS_WRITE      " }, \
        3  { "RFS3_READ      " }, \
        4  { "RFS3_WRITE     " }, \
        5  { "RFS4_READ      " }, \
        6  { "RFS4_WRITE     " }, \
        \* { `NFS_RFS mode=$HD` $BREAK } \
        nfsseqno($D1) vnode=$D2 $D2 `count=0x$D3  offset=0x$D4`
214 1.0 "@NFS: Server services" \
	$HOOKENV, \
	32 { \
        	HT & 0x07, \
		0 { \
		$D1, \
			5      { "RFS_LOOKUP     " G8 $HD%S1 }, \
			8      { "RFS_CREATE     " G8 $HD%S1 }, \
			9      { "RFS_REMOVE     " G8 $HD%S1 }, \
			0x000A { "RFS_RENAME  from: " G8 $HD%S1 }, \
			0x100A { "RFS_RENAME  to:   " G8 $HD%S1 }, \
			0b     { "RFS_LINK       " G8 $HD%S1 }, \
			0x000C { "RFS_SYMLINK from: " G8 $HD%S1 }, \
			0x100C { "RFS_SYMLINK to:   " G8 $HD%S1 }, \
			0d     { "RFS_MKDIR      " G8 $HD%S1 }, \
			0e     { "RFS_RMDIR      " G8 $HD%S1 }, \
			\*     { `RFS_VOPS genmode=$D1` } \
			$BREAK \
		} }, \
	64 { \
		HT & 0X4000, \
        	0x4000 { \
		$D1, \
			5      { "RFS_LOOKUP     " G16 $HL%S1 }, \
			8      { "RFS_CREATE     " G16 $HL%S1 }, \
			9      { "RFS_REMOVE     " G16 $HL%S1 }, \
			0x000A { "RFS_RENAME  from: " G16 $HL%S1 }, \
			0x100A { "RFS_RENAME  to:   " G16 $HL%S1 }, \
			0b     { "RFS_LINK       " G16 $HL%S1 }, \
			0x000C { "RFS_SYMLINK from: " G16 $HL%S1 }, \
			0x100C { "RFS_SYMLINK to:   " G16 $HL%S1 }, \
			0d     { "RFS_MKDIR      " G16 $HL%S1 }, \
			0e     { "RFS_RMDIR      " G16 $HL%S1 }, \
			\*     { `RFS_VOPS genmode=$D1` } \
			$BREAK \
		} } \
	$HD%D1, \
	1  { "RFS_NULL       " nfsseqno($D1) }, \
	2  { "RFS_GETATTR    " nfsseqno($D1) vnode=$D2 vnode=$D2 }, \
	3  { "RFS_SETATTR    " nfsseqno($D1) vnode=$D2 vnode=$D2 }, \
	4  { "RFS_ERROR" }, \
	5  { "RFS_LOOKUP     " nfsseqno($D1) directory= vnode=$D2 vnode=$D2 }, \
	133 { "RFS_LOOKUP     " nfsseqno($D1) lookuppninstall2($D2) object=vnode=$D2 vnode=$D2 \
		error=$D3%E1 }, \
	6  { "RFS_READLINK   " nfsseqno($D1) vnode=$D2 }, \
	8  { "RFS_CREATE     " nfsseqno($D1) directory=vnode=$D2 }, \
	136  { "RFS_CREATE     " lookuppninstall2($D1) file=vnode=$D1 error=$D2%E1 vnode=$D1 }, \
	9  { "RFS_REMOVE     " nfsseqno($D1) vnode=$D2 }, \
	10 { "RFS_RENAME     " nfsseqno($D1) from dir=vnode=$D2 to dir=vnode=$D3 }, \
	138 { "RFS_RENAME     " from file=vnode=$D1 lookuppninstall2($D2) to file=vnode=$D2 }, \
	11 { "RFS_LINK       " nfsseqno($D1) vnode=$D2 vnode=$D3 }, \
	12 { "RFS_SYMLINK    " nfsseqno($D1) vnode=$D2 }, \
	13 { "RFS_MKDIR      " nfsseqno($D1) vnode=$D2 }, \
	14 { "RFS_RMDIR      " nfsseqno($D1) vnode=$D2 }, \
	15 { "RFS_READDIR    " nfsseqno($D1) vnode=$D2 }, \
	16 { "RFS_STATFS     " nfsseqno($D1) vnode=$D2 }, \
	30 { "NFS_LOCKFH     " vnode=$D1 locktype=$D2%X4 \
		start=$D3 len=$D4 pid=$D5%D4}, \
	33 { "RFS3_OPERR     " \
		$D1%D1, \
		0  { guard check failed vp=$D2 }, \
		1  { cannot set attributes vp=$D2 }, \
		2  { name is NULL }, \
		3  { access not allowed by export}, \
		4  { name not found dvp=$D2 name=$D3 }, \
		5  { cannot get attributes vp=$D2 }, \
		6  { object is not a symlink vp=$D2 }, \
		7  { object is not a regular file vp=$D2 }, \
		8  { out of mbufs }, \
		9  { no write data provided }, \
		10 { no file mode specified }, \
		11 { object is not a directory vp=$D2 }, \
		12 { user permission error vp=$D2 } }, \
	\* { "UNKNOWN HOOK ID " }
215 1.0 "@NFS: Server dispatch" \
{{ \
nfsdispcode(code1,code2) \
$code1, \
        2 { \
        $code2, \
        0  { NULL }, \
        1  { GETATTR }, \
        2  { SETATTR }, \
        4  { LOOKUP }, \
        5  { READLINK }, \
        6  { READ }, \
        8  { WRITE }, \
        9  { CREATE }, \
        0a { REMOVE }, \
        0b { RENAME }, \
        0c { LINK }, \
        0d { SYMLINK }, \
        0e { MKDIR }, \
        0f { RMDIR }, \
        10 { READDIR }, \
        11 { STATFS }, \
        \* { $code1%D1 } \
        }, \
        3 { \
        $code2, \
        0  {RFS3_NULL        }, \
        1  {RFS3_GETATTR     }, \
        2  {RFS3_SETATTR     }, \
        3  {RFS3_LOOKUP      }, \
        4  {RFS3_ACCESS      }, \
        5  {RFS3_READLINK    }, \
        6  {RFS3_READ        }, \
        7  {RFS3_WRITE       }, \
        8  {RFS3_CREATE      }, \
        9  {RFS3_MKDIR       }, \
        0a {RFS3_SYMLINK     }, \
        0b {RFS3_MKNOD       }, \
        0c {RFS3_REMOVE      }, \
        0d {RFS3_RMDIR       }, \
        0e {RFS3_RENAME      }, \
        0f {RFS3_LINK        }, \
        10 {RFS3_READDIR     }, \
        11 {RFS3_READDIRPLUS }, \
        12 {RFS3_FSSTAT      }, \
        13 {RFS3_FSINFO      }, \
        14 {RFS3_PATHCONF    }, \
        15 {RFS3_COMMIT      }, \
        \* { $code1%D1 }\
        } \
}} \
        $HD%D1, \
        1  { "RFS_DISP_ENTRY " nfsseqno($D1) client=sinaddr($D2) \
                starttimer(0x215,$D1) \
        }, \
        2  { "RFS_DISP_EXIT  " nfsseqno($D1) client=sinaddr($D2) vers=$D3 nfsdispcode($D3,$D4) \
                endtimer(0x215,$D1) \
        }, \
        \* { `RFS_DISPATCH mode=$HD` }
216 1.0 "@NFS: Client call" \
        $HD%D1, \
        1  { \
                "NFS_CALL_ENTRY " nfsseqno($D1) server=sinaddr($D2) \
                starttimer(0x216,$D1) \
        }, \
        2  { \
                "NFS_CALL_EXIT  " nfsseqno($D1) server=sinaddr($D2) \
                endtimer(0x216,$D1) \
        }, \
	4  { "CLNTTCP_CREATE_ENTRY        " addr=$D1 prog=$D2 vers=$D3 retry=$D4 cred=$D5  }, \
        5  { "CLNTTCP_CREATE_EXIT         " CLIENT=$D1                                     }, \
        6  { "CLNTTCP_INIT_ENTRY          " CLIENT=$D1 addr=$D2 prog=$D3 vers=$D4 cred=$D5 }, \
        7  { "CLNTTCP_INIT_EXIT           "                                                }, \
        8  { "CLNTTCP_DESTROY             " CLIENT=$D1                                     }, \
        9  { "CLNTTCP_CALLIT_ENTRY        " CLIENT=$D1 proc=$D2 xid=$D3                    }, \
        10 { "CLNTTCP_CALLIT_EXIT         " return code=$D1                                }, \
        11 { "CLNTRTCM_CREATE_ENTRY       " svcaddr=$D1 prog=$D2 vers=$D3                  }, \
        12 { "CLNTRTCM_CREATE             "                                                }, \
        13 { "CLNTRTCM_CREATE_EXIT        " rtcm=$D1					   }, \
        14 { "CLNTRTCM_HOLD               " rtcm=$D1 refcnt=$D2                            }, \
        15 { "CLNTRTCM_RELE               " rtcm=$D1 refcnt=$D2                            }, \
        16 { "CLNTRTCM_SEND_ENTRY         " rtcm=$D1 CLIENT=$D2 mbuf=$D3                   }, \
        17 { "CLNTRTCM_CONN_ENTRY         " rtcm=$D1                                       }, \
        18 { "CLNTRTCM_CONN_EXIT          " return code=$D1                                }, \
        19 { "CLNTRTCM_SEND_EXIT          " return code=$D1                                }, \
        20 { "CLNTRTCM_SORECV_ENTRY       "                                                }, \
        21 { "CLNTRTCM_SORECV_EXIT        " return code=$D1                                }, \
        22 { "CLNTRTCM_RECV_ENTRY         " rtcm=$D1 CLIENT=$D2 time_out=$D3               }, \
        23 { "CLNTRTCM_RECV_EXIT          " reply present for xid=$D1                      }, \
        24 { "CLNTRTCM_RECV_EXIT_1        " return code=$D1                                }, \
        25 { "CLNTRTCM_RECV_EXIT_2        " xid=$D1                                        }, \
        26 { "CLNTRTCM_RECV_EXIT_3        "                                                }, \
        27 { "CLNTRTCM_RECV_EXIT_4        " return code=$D1                                }, \
        28 { "CLNTRTCM_CLNTDATA           " tid=$D1 xid=$D2                                }, \
        29 { "SERVXID_IN                  " xid=$D1                                        }, \
        30 { "SERVXID_OUT                 " xid=$D1                                        }, \
        31 { "CLNTRTCM_BADXID             " rtcm=$D1 xid=$D2                               }, \
        32 { "CLNTRTCM_SHORT_MLEN         " rtcm=$D1 xid=$D2                               }, \
        33 { "CLNTRTCM_RCV_XID            " rtcm=$D1 xid=$D2                               }, \
        34 { "CLNTRTCM_NOT_LAST_FRAG      " rtcm=$D1                                       }, \
        35 { "CLNTRTCM_CANTRCVMORE        " rtcm=$D1 sock=$D2                              }, \
        36 { "CLNTRTCM_SND_XID            " rtcm=$D1 xid=$D2                               }, \
        37 { "CLNTRTCM_SOCLOSE            " rtcm=$D1                                       }, \
        38 { "TCPSERV_TOLITTLE_DATA       " len=$D1 sb_cc=$D2                              }, \
        39 { "TCPSERV_NO_DATA             " len=$D1 sb_cc=$D2                              }, \
        40 { "CLNTRTCM_DUP_REPLY          " rtcm=$D1 xid=$D2                               }, \
	41 { "SERV_SOSEND                 " xid=$D1 sock=$D2 spint=$D3                     }, \
	42 { "CLNTRTCM_PULLUP             " mark=$D1 m_len=$D2 m_pkthdr_len=$D3            }, \
	43 { "CLNTRTCM_SND_EXIT           " listener failed rtcm=$D1 rc=$D2                }, \
	44 { "CLNTRTCM_SND_EXIT           " data without sending rtcm=$D1 start_rc=$D2     }, \
	\* { `NFS CALL mode=$HD` }
217 1.0 "@NFS: RPC Debug" \
        $HD%D1, \
	1   { "KDES_CREATE_FAIL_1          "						},\
	2   { "KDES_CREATE_FAIL_2          "						},\
	3   { "KDES_CREATE_FAIL_3          "						},\
	4   { "KDES_MARSHAL_FAIL           "						},\
	5   { "KDES_VALIDATE_FAIL_1        "						},\
	6   { "KDES_VALIDATE_FAIL_2        "						},\
	7   { "KDES_REFRESH_FAIL_1         "						},\
	8   { "KDES_REFRESH_FAIL_2         "						},\
	9   { "KDES_RTIME_FAIL_SEND        "						},\
	10  { "KDES_RTIME_FAIL_RECV        "						},\
	11  { "KRPC_UDPCREATE_FAIL_1       "						},\
	12  { "KRPC_UDPCREATE_FAIL_2       " error=$D1					},\
	13  { "KRPC_UDPCREATE_FAIL_3       " error=$D1					},\
	14  { "KRPC_KURECVFROM_1           "						},\
	15  { "KRPC_KURECVFROM_2           " len=$D1					},\
	16  { "KRPC_SVCAUTH_U              "						},\
	17  { "KRPC_SVCKUDP_SEND           "						},\
	18  { "KRPC_SVCKUDP_DUPMEM         "						},\
	19  { "KRPC_SVCKUDP_DUPNUMBER      "						},\
	20  { "KRPC_XDRMBUF_1              " mark=$D1 mbuf=$D2%X4 m_next/i=$D3%X4 m_len/high=$D4 x_handy/0=$D5	},\
	21  { "KRPC_XDRMBUF_2              "						},\
	22  { "KRPC_XDRMBUF_3              "						},\
	23  { "KRPC_XDRMBUF_4              "						},\
	24  { "NFSSRV_SETSOCK              "						},\
	25  { "NFSSRV_BADPROC              "						},\
	26  { "NFSSRV_BADVERS              "						},\
	27  { "NFSSRV_BADGETARGS           "						},\
	28  { "NFSSRV_WEAKAUTH             "						},\
	29  { "NFSSRV_BADFREEARGS          "						},\
	30  { "NFSSRV_BADSENDREPLY         "						},\
	31  { "NFSSRV_UNPRIVPORT           "						},\
	32  { "KRPC_MBUF_GET_FAIL          "						},\
	33  { "NFSCLNT_MNT_REGMIN          "						},\
	34  { "NFSCLNT_MNT_REGMAX          "						},\
	35  { "NFSCLNT_MNT_DIRMIN          "						},\
	36  { "NFSCLNT_MNT_DIRMAX          "						},\
	37  { "NFSCLNT_KLMLCK_1            "						},\
	38  { "NFSCLNT_KLMLCK_2            "						},\
	39  { "NFSCLNT_KLMLCK_3            "						},\
	40  { "NFSCLNT_KLMLCK_4            "						},\
	41  { "NFSCLNT_KLMLCK_5            "						},\
	42  { "NFSCLNT_AUTHGET_DESFAIL     "						},\
	43  { "NFSCLNT_AUTHGET_UNKNOWN     "						},\
	44  { "NFSCLNT_AUTHFREE_UNKNOWN    "						},\
	45  { "NFSSRVACL_BADSENDREPLY      "						},\
	46  { "NFSSRVACL_BADFREEARGS       "						},\
	47  { "NFSSRV_RFSGETBAD0           "						},\
	48  { "NFSSRV_RFSGETBAD1           "						},\
	49  { "NFSSRV_RFSGETBAD2           "						},\
	50  { "NFSSRV_INPROGRESS           "						},\
	51  { "NFSSRV_BADDUPSTAT           "						},\
	52  { "NFSSRV_NULLRECV             "						},\
	53  { "NFSSRV_BADLEN               "						},\
	54  { "NFSSRV_BADXDRCALL           "						},\
	55  { "NFSCLNT_BADATTACH           "						},\
	56  { "NFSCLNT_BADENCODE           "						},\
	57  { "NFSCLNT_CANTSEND            "						},\
	58  { "NFSCLNT_EINTR               "						},\
	59  { "NFSCLNT_RCTIMEOUT           "						},\
	60  { "NFSCLNT_RCBADXID            "						},\
	61  { "NFSCLNT_RCRETRANS           "						},\
	62  { "NFSCLNT_RCBADCALL           "						},\
	63  { "NFSCLNT_BADCLGET            "						},\
	64  { "NFSCLNT_CLNTCALLBAD         "						},\
	65  { "CLNTTLI_KCREAT_BADCFG       "						},\
	66  { "CLNTCLTS_NOMBUFS            "						},\
	67  { "SVCGEN_BAD_TRANSPORT        "						},\
	68  { "KRPC_SVCKTCP_SEND           "						},\
	69  { "KRPC_NOT_LAST_FRAG          " len=$D1 so=$D2%X4                          },\
	70  { "KRPC_SVC_LISTEN_SO_FAIL     "						},\
	71  { "KRPC_RTCMCREATE_FAIL_1      "						},\
	72  { "KRPC_RTCMCREATE_FAIL_2      " error=$D1					},\
	73  { "KRPC_RTCMCREATE_FAIL_3      " rc=$D1					},\
	74  { "NFSSRV_BAD_PERFORM_SM_DSB   "						},\
	75  { "RTCM_CONNECT_WAIT           " time=$D1					},\
	76  { "NFSCLNT_BADDECODE           "						},\
	77  { "NFSCLNT_ERROR               " error=$D1 xid=$D2				},\
	78  { "CLNTTCP_CREATE_FAIL         "						},\
	79  { "CLNTTCP_INIT_FAIL           "						},\
	80  { "CLNTTCP_CALL_FAIL           "						},\
	81  { "CLNTRTCM_SOR_FAIL           " rc=$D1					},\
	82  { "CLNTRTCM_SOR_FAIL_1         " rc=$D1					},\
	83  { "CLNTRTCM_SOR_FAIL_2         "						},\
	84  { "CLNTRTCM_SOR_FAIL_3         " rc=$D1					},\
	85  { "CLNTRTCM_SOR_FAIL_4         " mark=$D1 m_len=$D2 len=$D3 m_next=$D4 uio_resid=$D5 },\
	86  { "KRPCTCP_SOSND_ERROR         " rc=$D1 sock=$D1 xid=$D3			},\
	87  { "KRPC_MBUFGET_FAIL_READ      " size=$D1 ifp=$D2 xprt=$D3			},\
	88  { "CLNTKUDP_SOSENDFAIL         " error=$D1 proc=$D2                         },\
	89  { "SVC_CONNECT_FAILED          " error=$D1                                  },\
	90  { "KRPC_SORESERVE_FAILED0      "                                            },\
	91  { "KRPC_XDRREPLY_INLINE        "                                            },\
	92  { "KRPC_XDRREPLY_FAIL1         " direction=$D1 xid=$D2                      },\
	93  { "KRPC_XDRREPLY_FAIL2         " rpstat=$D1 xid=$D2                         },\
	94  { "KRPC_XDRREPLY_FAIL3         "                                            },\
	95  { "KRPC_XDRREPLY_FAIL4         " xid=$D1 len=$D2 flavor=$D3                 },\
	96  { "KRPC_XDRREPLY_FAIL5         "                                            },\
	97  { "KRPC_XDRREPLY_FAIL6         "                                            },\
	98  { "KRPC_XDRREPLY_SUCCESS       "                                            },\
	99  { "KRPC_XDRREPLY_PROG_MIS      "                                            },\
	100 { "KRPC_XDRREPLY_FAIL7         "                                            },\
	101 { "KRPC_XDRREPLY_FAIL8         "                                            },\
	102 { "CLNTRTCM_SOR_FAIL_5         "                                            },\
	103 { "NFS_MAX_CONNECTS_TOO_LOW    " d1=$D1                                     },\
	104 { "KRPC_MAYB_NOT_LAST_FRAG     "  len=$D1 so=$D2%X4                         },\
	105 { "XDRMBUF_GETLONG_X_BASE      "                                            },\
	106 { "XDRMBUF_GETLONG_EMPTY_MBUF  "						},\
	107 { "KRPC_SPINTQ_FULL            " 						},\
	108 { "KRPC_SET_RFC1323_FAIL       " socket=$D1%X4 sosetopt_error=$D2		},\
	109 { "KRPC_XDRMBUF_PB_EXT         " D1=$D1 uiomove error=$D2			},\
	110 { "KRPC_XDRMBUF_GB_EXT         " D1=$D1 uiomove error=$D2			},\
	111 { "KRPC_XDRMEM_PB_EXT          " D1=$D1 uiomove error=$D2			},\
	112 { "KRPC_XDRMEM_GB_EXT          " D1=$D1 uiomove error=$D2			},\
	113 { "KRPC_RTCM_START_LISTENER    " enter rtcm=$D1 timeout=$D2                 },\
	114 { "KRPC_RTCM_START_LISTENER    " no listener rtcm=$D1 state=$D2             },\
	115 { "KRPC_RTCM_START_LISTENER    " trb alloc failed rtcm=$D1                  },\
	116 { "KRPC_RTCM_START_LISTENER    " thread info alloc failed rtcm=$D1          },\
	117 { "KRPC_RTCM_START_LISTENER    " connection wait rtcm=$D1 state=$D2         },\
	118 { "KRPC_RTCM_START_LISTENER    " wakeup rtcm=$D1 rc=$D2                     },\
	119 { "KRPC_RTCM_START_LISTENER    " exit ok rtcm=$D1                           },\
	120 { "KRPC_RTCM_LISTEN            " enter rtcm=$D1                             },\
	121 { "KRPC_RTCM_LISTEN            " connect returned rtcm=$D1 rc=$D2           },\
	122 { "KRPC_RTCM_LISTEN            " giving up rtcm=$D1                         },\
	123 { "KRPC_RTCM_LISTEN            " quiting rtcm=$D1 state=$D2                 },\
	124 { "KRPC_RTCM_LISTEN            " exit rtcm=$D1                              },\
	125 { "KRPC_RTCM_RECV              " soreceive failed rtcm=$D1 rc=$D2           },\
	126 { "KRPC_RTCM_RSVPORT           " toggle reserved port enter rtcm=$D1        },\
	127 { "KRPC_RTCM_RSVPORT           " toggle reserved port exit rtcm=$D1         },\
	128 { "KRPC_NFSCLNT_BAD_CALL       " status=$D1 errno=$D2                       },\
	129 { "KRPC_TCP_CALLIT_ERROR       " location=$D1 error=$D2                     },\
	\*  { `NFS RPC DEBUG mode=$HD` }
218 1.0 "@NFS: rpc.lockd hooks" \
	$HD%D1, \
	1  { "LOCKD_KLM_PROG    " proc=$D1%D4 pid=$D2%D4 cookie=$D3%D4 port=$D4 }, \
	2  { "LOCKD_NLM_REQUEST " proc=$D1%D4 from sinaddr($D2) cookie=$D3%D4 pid=$D4%D4 }, \
	3  { "LOCKD_NLM_RESULTS " proc=$D1%D4 from sinaddr($D2) cookie=$D3%D4 result=$D4 }, \
	4  { "LOCKD_KLM_REPLY   " proc=$D1%D4 stat=$D2 port=$D3 }, \
	5  { "LOCKD_NLM_REPLY   " proc=$D1%D4 to sinaddr($D2) stat=$D3 cookie=$D4%D4 }, \
	6  { "LOCKD_NLM_CALL    " proc=$D1%D4 cookie=$D2%D4 pid=$D3%D4 retransmit=$D4 }, \
	7  { "LOCKD_CALL_UDP    " to sinaddr($D4) proc=$D1%D4 program=$D2%D4 version=$D3%D4 }, \
	\* { `LOCKD CALL mode=$HD` }
2D9 1.0 "@NFS: krpc network hooks" \
        $HD%D1, \
        1   { "CLNT_KUDP_SOCLOSE           " CLIENT=$D1 sock=$D2			}, \
        2   { "RTCM_SOCLOSE_1              " rtcm=$D1 state=$D2 sock=$D3 rc=$D4		}, \
        3   { "RTCM_CM_CLOSE               " rtcm=$D1					}, \
        4   { "RTCM_SOCLOSE_2              " rtcm=$D1 state=$D2 sock=$D3 rc=$D4		}, \
        5   { "RTCM_SOCLOSE_3              " rtcm=$D1 state=$D2 sock=$D3 rc=$D4		}, \
        6   { "RTCM_SOCLOSE_4              " rtcm=$D1 state=$D2 sock=$D3 rc=$D4		}, \
        7   { "RTCM_SOCLOSE_5              " rtcm=$D1 state=$D2 sock=$D3 rc=$D4		}, \
        8   { "RTCM_SOCLOSE_6              " rtcm=$D1 state=$D2 sock=$D3 rc=$D4         }, \
        9   { "RTCM_SOCLOSE_7              " rtcm=$D1 state=$D2 sock=$D3 rc=$D4         }, \
        10  { "SP_SOCLOSE                  " spint=$D1 sock=$D2 type=$D3 raddr=$D4      }, \
        11  { "SVCUDP_SOCLOSE              " xprt=$D1 sock=$D2                          }, \
        12  { "SVCTCP_SOCLOSE              " xprt=$D1 alt sock=$D2                      }, \
	13  { "CLNTUDP_CREATE              " sock=$D1                                   }, \
	14  { "RTCM_SOCREATE               " rtcm=$D1 sock=$D2                          }, \
	15  { "RTCM_CONNECT                " rtcm=$D1 sock=$D2  raddr=$D3 port=$D4      }, \
	16  { "KRPC_SSP_CLOSE1             " sock=$D1 state=$D2 raddr=$D3               }, \
	17  { "KRPC_SSP_CLOSE2             " sock=$D1 state=$D2 raddr=$D3               }, \
	18  { "KRPC_SSP_CLOSE3             " sock=$D1 state=$D2 raddr=$D3               }, \
	19  { "SVC_NEW_CONNECT             " newsock=$D1 raddr=$D2 sockpint=$D3         }, \
	\* { `NFS NET mode=$HD` }
3AF 1.0 "@NFS: cachefs hooks" \
        $HD%D1, \
        1   { "IN_CFS_OPEN		" vpp=$D1 flag=$D2		 		}, \
        2   { "OUT_CFS_OPEN		" exit=$D1 error=$D2 dbgval=$D3 vp=$D4		}, \
	3  { "IN_CFS_CLOSE		" vpp=$D1 flag=$D2 count=$D3 offset=$D4		},\
	4  { "OUT_CFS_CLOSE		" exit=$D1 error=$D2 backvp=$D3	vp=$D4		},\
	5  { "IN_CFS_READ		" vp=$D1 uiop=$D2 ioflag=$D3			},\
	6  { "OUT_CFS_READ		" exit=$D1 dbgval1=$D2 dbgval2=$D3 vp=$D4	},\
	7  { "IN_CFS_WRITE		" vp=$D1 uio_offset=$D2 uio_resid=$D3 c_flags=$D4 limit=$D5 },\
	8  { "OUT_CFS_WRITE		" exit=$D1 error=$D2 dbgval=$D3	vp=$D4		},\
	9  { "IN_CFS_CHARGE_PAGE	" cp=$D1 offset=$D2 				},\
	10  { "OUT_CFS_CHARGE_PAGE	" exit=$D1 dbgval=$D2 cp=$D3 offset=$D4         },\
	11  { "IN_CFS_WRITE_PAGE	" vp=$D1 uio_offset=$D2 uio_resid=$D3 c_size=$D4 tcount=$D5 },\
	12  { "OUT_CFS_WRITE_PAGE	" exit=$D1 error=$D2 dbgval1=$D3 dbgval2=$D4 dbgval3=$D5 },\
	13  { "IN_CFS_PUSH		" vp=$D1 flags=$D2 vfs_flags=$D3 p_offset=$D4	},\
	14  { "OUT_CFS_PUSH		" exit=$D1 error=$D2	                        },\
	15  { "IN_CFS_IOCTL		" vp=$D1 cmd=$D2 arg=$D3 flag=$D4		},\
	16  { "OUT_CFS_IOCTL		" error=$D1 vp=$D2 cmd=$D3                      },\
	17  { "IN_CFS_GETATTR		" vp=$D1 flags=$D2	                        },\
	18  { "OUT_CFS_GETATTR		" error=$D1 va_size=$D2 va_fsid=$D3 vp=$D4	},\
	19  { "IN_CFS_SETATTR		" vp=$D1 flags=$D2 mask=$D3			},\
	20  { "OUT_CFS_SETATTR		" exit=$D1 error=$D2 vp=$D3			},\
	21  { "IN_CFSACCESS		" mode=$D1 type=$D2				},\
	22  { "OUT_CFSACCESS		" exit=$D1 error=$D2 cp=$D3			},\
	23  { "IN_CFS_ACCESS		" vp=$D1 mode=$D2 flags=$D3			},\
	24  { "OUT_CFS_ACCESS		" error=$D1 vp=$D2				},\
	25  { "IN_CFS_READLINK		" vp=$D1 v_type=$D2 md_flags=$D3 c_flags=$D4 fs_flags=$D5 },\
	26  { "OUT_CFS_READLINK		" exit=$D1 error=$D2 vp=$D3			},\
	27  { "IN_CFS_FSYNC		"						},\
	28  { "OUT_CFS_FSYNC		"						},\
	29  { "IN_SYNC_METADATA		" cp=$D1 c_flags=$D2				},\
	30  { "OUT_SYNC_METADATA	" exit=$D1 error=$D2 cp=$D3			},\
	31  { "IN_CFS_INACTIVE_QUEUE	" vp=$D1 c_flags=$D2 c_backvp=$D3 v_count=$D4	},\
	32  { "OUT_CFS_INACTIVE_QUEUE	" error=$D1 vp=$D2				},\
	33  { "IN_CFS_INACTIVE		" vp=$D1 c_flags=$D2 md_flags=$D3		},\
	34  { "OUT_CFS_INACTIVE		" exit=$D1 dbgval=$D2 vp=$D3			},\
	35  { "IN_CFS_INITSTATE		" c_frontvp=$D1 c_flags=$D2 c_backvp=$D3 type=$D4 alloc=$D5 },\
	36  { "OUT_CFS_INITSTATE	" exit=$D1 error=$D2 cp=$D3			},\
	37  { "IN_CFS_LOOKUP		" c_flags=$D1 c_frontvp=$D2 fg_flags=$D3 md_flags=$D4 c_usage=$D5 },\
	38  { "OUT_CFS_LOOKUP		" exit=$D1 error=$D2 dvp=$D3 name=$D4		},\
	39  { "IN_CFS_LOOKUP_BACK	" c_backvp=$D1 md_flags=$D2 c_flags=$D3 fg_flags=$D4 d_offset=$D5 },\
	40  { "OUT_CFS_LOOKUP_BACK	" exit=$D1 error=$D2 dvp=$D3 name=$D4		},\
	41  { "IN_CFS_CREATE_NON_LOCAL	" dcp=$D1 c_flags=$D2 md_flags=$D3 exclusive=$D4 mode=$D5 },\
	42  { "OUT_CFS_CREATE_NON_LOCAL	" exit=$D1 error=$D2 dcp=$D3 name=$D4		},\
	43  { "IN_CFS_CREATE		" dvp=$D1 v_type=$D2 v_rdev=$D3 c_fileno=$D4 cr_uid=$D5 },\
	44  { "OUT_CFS_CREATE		" exit=$D1 error=$D2 dvp=$D3 name=$D4		},\
	45  { "IN_CFS_REMOVE		" dvp=$D1 fs_cache->c_flags=$D2 dcp->c_flags=$D3},\
	46  { "OUT_CFS_REMOVE		" exit=$D1 error=$D2 dbgval=$D3 dvp=$D4 name=$D5	},\
	47  { "IN_CFS_LINK		" tdvp=$D1 svp=$D2 fs_cache->c_flags=$D3 tdcp->c_flags=$D4		},\
	48  { "OUT_CFS_LINK		" exit=$D1 error=$D2 svp=$D3 tdvp=$D4 name=$D5	},\
	49  { "IN_CFS_RENAME		" fs_cache->c_flags=$D1 odcp->c_flags=$D2 ndcp->c_flags=$D3			},\
	50  { "OUT_CFS_RENAME		" exit=$D1 error=$D2 odvp=$D3 onm=$D4 ndvp=$D5	},\
	51  { "IN_CFS_MKDIR		" dvp=$D1 fs_cache->c_flags=$D2 dcp->c_flags=$D3			},\
	52  { "OUT_CFS_MKDIR		" exit=$D1 error=$D2 dvp=$D3 name=$D4		},\
	53  { "IN_CFS_RMDIR		" dvp=$D1 fs_cache->c_flags=$D2 dcp->c_flags=$D3			},\
	54  { "OUT_CFS_RMDIR		" exit=$D1 error=$D2 dvp=$D3 name=$D4		},\
	55  { "IN_CFS_SYMLINK		" dvp=$D1 fs_cache->c_flags=$D2 dcp->c_flags=$D3			},\
	56  { "OUT_CFS_SYMLINK		" exit=$D1 dbgval=$D2 dvp=$D3 lnm=$D4 tnm=$D5	},\
	57  { "IN_CFS_READDIR		" vp=$D1 fs_cache->c_flags=$D2 dcp->c_flags=$D3 md_flags=$D4 fg_flags=$D5 },\
	58  { "OUT_CFS_READDIR		" exit=$D1 error=$D2 vp=$D3			},\
        59  { "IN_CFS_READDIR_BACK		"					}, \
	60  { "OUT_CFS_READDIR_BACK	" error=$D1					},\
	61  { "IN_CFS_FID		" fidp->fid_len=$D1 md_cookie.fid_len=$D2	},\
	62  { "OUT_CFS_FID		" error=$D1 vp=$D2				},\
	63  { "IN_CFS_RWLOCK		" v_type=$D1 write_lock=$D2			},\
	64  { "OUT_CFS_RWLOCK		" exit=$D1					},\
	65  { "IN_CFS_RWUNLOCK		" v_type=$D1 					},\
	66  { "OUT_CFS_RWUNLOCK		" exit=$D1					},\
	67  { "IN_CFS_GET_PAGE		" v_flag=$D1 off=$D2 len=$D3 c_flags=$D4 c_size=$D5 },\
	68  { "OUT_CFS_GET_PAGE		" exit=$D1 error=$D2 vp=$D3 off=$D4 len=$D5	},\
	69  { "IN_CFS_GETAPAGE		" c_flags=$D1 fg_flags=$D2 off=$D3 len=$D4 fileno=$D5 },\
	70  { "OUT_CFS_GETAPAGE		" exit=$D1 error=$D2 vp=$D3 off=$D4 len=$D5	},\
	71  { "IN_CFS_PUTPAGE		" vfs_flag=$D1 off=$D2 len=$D3 flags=$D4 c_size=$D5 },\
	72  { "OUT_CFS_PUTPAGE		" exit=$D1 error=$D2				},\
	73  { "IN_CFS_MAP		" off=$D1 len=$D2 flags=$D3 v_flag=$D4 v_type=$D5 },\
	74  { "OUT_CFS_MAP		" exit=$D1 error=$D2 vp=$D3 off=$D4 len=$D5	},\
	75  { "IN_CFS_FRLOCK		" cmd=$D1 offset=$D2 flag=$D3 whence=$D4 },\
	76  { "OUT_CFS_FRLOCK		" exit=$D1 error=$D2 vp=$D3 offset=$D4 cmd=$D5	},\
	77  { "IN_CFS_SPACE		" cmd=$D1 flag=$D2 offset=$D3 l_len=$D4 l_start=$D5 },\
	78  { "OUT_CFS_SPACE		" exit=$D1 error=$D2 vp=$D3 offset=$D4		},\
	79  { "IN_CFS_PIN		" c_flags=$D1					},\
	80  { "OUT_CFS_PIN		" error=$D1 vp=$D2				},\
	81  { "IN_CFS_PIN_LOCKED	" md_flags=$D1 c_flags=$D2 fg_flags=$D3 v_type=$D4 va_size=$D5 },\
	82  { "OUT_CFS_PIN_LOCKED	" exit=$D1 error=$D2 vp=$D3			},\
	83  { "IN_CFS_UNPIN		" fg_flags=$D1 md_flags=$D2 c_flags=$D3		},\
	84  { "OUT_CFS_UNPIN		" exit=$D1 error=$D2 vp=$D3			},\
	85  { "IN_CFS_CONVERT_MOUNT	" cm_op=$D1					},\
	86  { "OUT_CFS_CONVERT_MOUNT	" exit=$D1 error=$D2				},\
	87  { "IN_CFS_SETSECATTR	" flag=$D1 c_flags=$D2 c_backvp=$D3		},\
	88  { "OUT_CFS_SETSECATTR	" error=$D1 vp=$D2				},\
	89  { "IN_CFS_GETSECATTR	" flag=$D1 c_flags=$D2 c_backvp=$D3		},\
	90  { "OUT_CFS_GETSECATTR	" error=$D1 vp=$D2				},\
	91  { "IN_FLGRP_CREATE		" fgsize=$D1 fileno=$D2 fg_flags=$D3		},\
	92  { "OUT_FLGRP_CREATE		" fg_fileno=$D1 fg_headersize=$D2 fg_filesize=$D3 fg_flags=$D4		},\
	93  { "IN_FLGRP_DESTROY		" fg_attrvp=$D1 fg_header=$D2 fg_flags=$D3 fg_dirvp=$D4		},\
	94  { "OUT_FLGRP_DESTROY	" exit=$D1 error=$D2 fgp=$D3			},\
	95  { "IN_FLGRP_ALLOCATEATTR	" fg_flags=$D1                                  },\
	96  { "OUT_FLGRP_ALLOCATEATTR	" exit=$D1 error=$D2 fgp=$D3			},\
	97  { "IN_FLGRP_HOLD		" fg_flags=$D1 fg_count=$D2			},\
	98  { "OUT_FLGRP_HOLD		" fg_flags=$D1                                  },\
	99  { "IN_FLGRP_RELE		" fg_flags=$D1 fg_count=$D2			},\
	100  { "OUT_FLGRP_RELE		" fg_count=$D1                                  },\
	101  { "IN_FLGRP_FFHOLD		" fg_flags=$D1 fg_count=$D2 fg_fileno=$D3 ach_nffs=$D4		},\
	102  { "OUT_FLGRP_FFHOLD	" exit=$D1 error=$D2 fgp=$D3			},\
	103  { "IN_FLGRP_FFRELE		" fg_flags=$D1 fg_dirvp=$D2 fg_count=$D3 ach_nffs=$D4 ach_count=$D5 },\
	104  { "OUT_FLGRP_FFRELE	" exit=$D1 fgp=$D2 error=$D3			},\
	105  { "IN_FLGRP_SYNC		" fg_flags=$D1 ach_nffs=$D2 ach_count=$D3	},\
	106  { "OUT_FLGRP_SYNC		" exit=$D1 error=$D2 fgp=$D3			},\
	107  { "IN_FLGRP_READ_METAD	" fg_flags=$D1 fileno=$D2 fg_fileno=$D3		},\
	108  { "OUT_FLGRP_READ_METAD	" exit=$D1 error=$D2 fgp=$D3			},\
	109  { "IN_FLGRP_CREATE_METAD	" fg_flags=$D1 fileno=$D2 fg_fileno=$D3 opt_fgsize=$D4		},\
	110  { "OUT_FLGRP_CREATE_METAD	" exit=$D1 error=$D2 fgp=$D3			},\
	111  { "IN_FLGRP_WRITE_METAD	" fg_flags=$D1 fileno=$D2 fg_fileno=$D3 ach_nblks=$D4		},\
	112  { "OUT_FLGRP_WRITE_METAD	" exit=$D1 error=$D2 fgp=$D3 fileno=$D4		},\
	113  { "IN_FLGRP_DESTROY_METAD	" fg_flags=$D1 fileno=$D2 fg_headersize=$D3 ach_count=$D4		},\
	114  { "OUT_FLGRP_DESTROY_METAD	" exit=$D1 error=$D2 fgp=$D3 fileno=$D4		},\
	115  { "IN_FLGRP_LIST_FIND	" fgsize=$D1 fileno=$D2				},\
	116  { "OUT_FLGRP_LIST_FIND	" fileno=$D1					},\
        117  { "IN_FLGRP_LIST_ADD		"					}, \
	118  { "OUT_FLGRP_LIST_ADD	" fgp->fg_next=$D1				},\
        119  { "IN_FLGRP_LIST_REMOVE		"					}, \
	120  { "OUT_FLGRP_LIST_REMOVE	" found=$D1					},\
	121  { "IN_FLGRP_LIST_GC	" fg_count=$D1					},\
        122  { "OUT_FLGRP_LIST_GC		"					}, \
	123  { "IN_FLGRP_SETUP		" fg_flags=$D1 ach_nff=$D2 fg_count=$D3 flags=$D4 dolru=$D5 },\
	124  { "OUT_FLGRP_SETUP		" fg_flags=$D1					},\
        125  { "IN_FLGRP_LIST_EN_CACH_RO"                                               }, \
        126  { "OUT_FLGRP_LIST_EN_CACH_RO"                                              }, \
        127  { "IN_FLGRP_LIST_EN_CACH_RW"                                               }, \
        128  { "OUT_FLGRP_LIST_EN_CACH_RW"                                              }, \
	129  { "IN_FLGRP_DIR_FIND	" fg_flags=$D1 fg_fileno=$D2 ach_nffs=$D3	},\
	130  { "OUT_FLGRP_DIR_FIND	" error=$D1					},\
	131  { "IN_FLGRP_ATTR_FIND	" fg_flags=$D1 fg_fileno=$D2 fg_headersize=$D3 ach_nffs=$D4 fg_count=$D5 },\
	132  { "OUT_FLGRP_ATTR_FIND	" exit=$D1 error=$D2 fgp=$D3			},\
	133  { "IN_FLGRP_DIR_CREATE	" fg_flags=$D1 fg_fileno=$D2			},\
	134  { "OUT_FLGRP_DIR_CREATE	" exit=$D1 error=$D2 fgp=$D3			},\
	135  { "IN_FLGRP_ATTR_CREATE	" fg_flags=$D1 fg_fileno=$D2 fg_headersize=$D3	},\
	136  { "OUT_FLGRP_ATTR_CREATE	" exit=$D1 error=$D2 fgp=$D3			},\
	137  { "I_FLGRP_FILENO_TOSLOT	" fileno=$D1 fg_fileno=$D2 opt_fgsize=$D3	},\
	138  { "O_FLGRP_FILENO_TOSLOT	" exit=$D1 dbgval=$D2 fgp=$D3 fileno=$D4	},\
	139  { "I_FLGRP_WRITE_SPACE	" offset=$D1 cnt=$D2				},\
	140  { "O_FLGRP_WRITE_SPACE	" error=$D1 vp=$D2 offset=$D3 cnt=$D4		},\
        141  { "IN_CACHE_CREATE		"						},\
	142  { "OUT_CACHE_CREATE	" exit=$D1 dbgval=$D2				},\
	143  { "IN_CACHE_DESTROY	" wq_thread_count=$D1 c_flags=$D2		},\
        144  { "OUT_CACHE_DESTROY	"						},\
	145  { "IN_CACHE_ACTIVE_RO	" c_flags=$D1 c_usage.cu_flags=$D2		},\
	146  { "OUT_CACHE_ACTIVE_RO	" exit=$D1 error=$D2 cachep=$D3	cdvp=$D4	},\
	147  { "IN_CACHE_ACTIVE_RW	" c_flags=$D1                                  	},\
        148  { "OUT_CACHE_ACTIVE_RW	" 						},\
	149  { "IN_CACHE_DIRTY		" c_flags=$D1 c_usage.cu_flags=$D2 lockit=$D3	},\
	150  { "OUT_CACHE_DIRTY		" error=$D1					},\
	151  { "IN_CACHE_RESSYNC	" c_flags=$D1 c_lru_idents=$D2 c_lru_ptrs=$D3	},\
	152  { "OUT_CACHE_RESSYNC	" exit=$D1 error=$D2 cachep=$D3			},\
	153  { "IN_CACHE_SYNC		" c_flags=$D1 c_usage.cu_flags=$D2		},\
	154  { "OUT_CACHE_SYNC		" exit=$D1					},\
	155  { "IN_CACHE_UNIQUE		" c_flags=$D1 c_usage.cu_flags=$D2 c_unique=$D3	},\
	156  { "OUT_CACHE_UNIQUE	" exit=$D1 dbgval=$D2 				},\
	157  { "IN_CREATE_FRONTFILE	" fg_flags=$D1 c_flags=$D2 c_fileno=$D3 va_nodeid=$D4		},\
	158  { "OUT_CREATE_FRONTFILE	" exit=$D1 error=$D2 fgp=$D3 cp=$D4		},\
	159  { "IN_REMOVE_FRONTFILE	" md_flags=$D1 fileno=$D2			},\
	160  { "OUT_REMOVE_FRONTFILE	" exit=$D1 fgp=$D2 fileno=$D3			},\
	161  { "IN_GET_FRONTFILE	" md_flags=$D1 c_flags=$D2 v_type=$D3 v_count=$D4		},\
	162  { "OUT_GET_FRONTFILE	" exit=$D1 error=$D2 cp=$D3			},\
	163  { "IN_INVAL_OBJECT		" c_flags=$D1 c_frontvp=$D2 md_frontblocks=$D3 va_type=$D4 c_usage=$D5 },\
	164  { "OUT_INVAL_OBJECT	" exit=$D1 cp=$D2				},\
	165  { "IN_NOCACHE		" c_flag=$D1 c_fileno=$D2			},\
        166  { "OUT_NOCACHE		"						},\
	167  { "IN_CHECK_ALLOCMAP	" c_flags=$D1 c_fileno=$D2 off=$D3		},\
	168  { "OUT_CHECK_ALLOCMAP	" exit=$D1					},\
	169  { "IN_UPDATE_ALLOCMAP	" off=$D1 size=$D2 c_flags=$D3 c_metadata.md_flags=$D4 c_size=$D5 },\
	170  { "OUT_UPDATE_ALLOCMAP	" exit=$D1					},\
	171  { "IN_POPULATE		" c_flags=$D1 off=$D2 popsize=$D3		},\
	172  { "OUT_POPULATE		" exit=$D1 error=$D2 cp=$D3			},\
	173  { "IN_CLUSTER_ALLOCMAP	" c_flags=$D1 off=$D2 c_metadata.md_allocents=$D3 c_size=$D4		},\
	174  { "OUT_CLUSTER_ALLOCMAP	" exit=$D1 popoffp=$D2 popsizep=$D3		},\
	175  { "IN_CACHE_SYMLINK	" c_flags=$D1 c_metadata.md_flags=$D2 c_fileno=$D3 },\
	176  { "OUT_CACHE_SYMLINK	" error=$D1 cp=$D2				},\
	177  { "IN_GETBACKVP		" cp=$D1 c_flags=$D2 c_fileno=$D3 v_type=$D4		},\
	178  { "OUT_GETBACKVP		" cp=$D1 c_backvp=$D2 error=$D3			},\
        179  { "IN_GETCOOKIE		"						},\
	180  { "OUT_GETCOOKIE		" error=$D1 vp=$D2				},\
	181  { "IN_ASYNC_START		" wq_head=$D1 wq_halt_request=$D2 wq_thread_count=$D3 wq_keepone=$D4 wq_length=$D5 },\
	182  { "OUT_ASYNC_START		" wq_length=$D1 wq_thread_count=$D2		},\
	183  { "IN_ASYNC_HALT		" wq_keepone=$D1 wq_thread_count=$D2 wq_length=$D3 },\
	184  { "OUT_ASYNC_HALT		" error=$D1 qp=$D2				},\
	185  { "IN_ADD_QUEUE		" wq_thread_count=$D1 wq_length=$D2 wq_length=$D3 },\
	186  { "OUT_ADD_QUEUE		" exit=$D1 error=$D2				},\
	187  { "IN_ASYNC_PUTPAGE	" cp_off=$D1 cp_len=$D2 cp_flags=$D3 c_ioflags=$D4 c_nio=$D5 },\
        188  { "OUT_ASYNC_PUTPAGE	"						}, \
	189  { "IN_DO_REQ		" cfs_cmd=$D1					},\
        190  { "OUT_DO_REQ		"						},\
	191  { "IN_KMEM_ALLOC		" size=$D1 flag=$D2				},\
        192  { "OUT_KMEM_ALLOC		" 						},\
	193  { "IN_KMEM_ZALLOC		" size=$D1 flag=$D2				},\
        194  { "OUT_KMEM_ZALLOC		" 						},\
	195  { "IN_KMEM_FREE		" size=$D1					},\
        196  { "OUT_KMEM_FREE		" 						},\
	197  { "IN_KSTAT_SNAPSHOT	" enter_num=$D1 gc_count=$D2 gc_time=$D3 gc_before=$D4 gc_after=$D5 },\
        198  { "OUT_KSTAT_SNAPSHOT	" 						},\
        199  { "IN_CATC			"						},\
	200  { "OUT_CATC		" exit=$D1					},\
	201  { "IN_GET_CFS_WORK		" enter_num=$D1 dbgval=$D2			},\
	202  { "OUT_GET_CFS_WORK	" exit=$D1					},\
	203  { "IN_THROW_ARGS		" what=$D1					},\
	204  { "OUT_THROW_ARGS		" exit=$D1 error=$D2 caller=$D3			},\
	205  { "IN_CFS_ADDFREE		" cp=$D1 fscp=$D2				},\
	206  { "OUT_CFS_ADDFREE		" cp=$D1 c_backvp=$D2				},\
	207  { "IN_CFS_REMFREE		" cp=$D1 c_backvp=$D2				},\
	208  { "OUT_CFS_REMFREE		" cp=$D1 c_backvp=$D2				},\
	209  { "IN_CFS_ADDHASH		" cp=$D1 fscp=$D2				},\
	210  { "OUT_CFS_ADDHASH		" cp=$D1 fscp=$D2				},\
	211  { "IN_CFS_REMHASH		" cp=$D1 fscp=$D2				},\
	212  { "OUT_CFS_REMHASH		" cp=$D1 fscp=$D2 found=$D3			},\
	213  { "IN_CFS_CFIND	" fscp=$D1 fileno=$D2					},\
	214  { "OUT_CFS_CFIND	" fscp=$D1 cp=$D2 found=$D3				},\
	215  { "IN_CFS_INACTIVATE	" cp=$D1 fscp=$D2				},\
	216  { "OUT_CFS_INACTIVATE	" fscp=$D1					},\
	217  { "IN_CFS_INITCNODE	" cp=$D1 fscp=$D2				},\
	218  { "OUT_CFS_INITCNODE	" cp=$D1 fscp=$D2 error=$D3			},\
	219  { "IN_CFS_MAKECNODE	" fileno=$D1 fscp=$D2				},\
	220  { "OUT_CFS_MAKECNODE	" cp=$D1 fscp=$D2 error=$D3 trcex=$D4		},\
	221  { "IN_CFS_MOUNT	" vfsp=$D1 						},\
	222  { "OUT_CFS_MOUNT	" vfsp=$D1 error=$D2					},\
	223  { "IN_CFS_UNMOUNT	" vfsp=$D1						},\
	224  { "OUT_CFS_UNMOUNT	" vfsp=$D1 error=$D2					},\
	225  { "IN_CFS_SYNC	" gfsp=$D1 						},\
	226  { "OUT_CFS_SYNC	" gfsp=$D1						},\
	227  { "IN_CFS_VGET	" vfsp=$D1 						},\
	228  { "OUT_CFS_VGET	" vfsp=$D1 vp=$D2 error=$D3 xspot=$D4			},\
	229  { "IN_CFS_STATVFS	" vfsp=$D1 						},\
	230  { "OUT_CFS_STATVFS	" vfsp=$D1 errno=$D2					},\
	231  { "CFS_VMM         " D1=$D1 D2=$D2 D3=$D3 D4=$D4				},\
	240  { "IN_CFS_INIT_FID		" fscp=$D1 					},\
	241  { "OUT_CFS_INIT_FID	" exit=$D1 fscp=$D2 errno=$D3			},\
	242  { "IN_CFS_FID_HASH		" fid=$D1 					},\
	243  { "OUT_CFS_FID_HASH	" fid=$D1 hash=$D2				},\
	244  { "IN_CFS_ADD_FID		" fidp=$D1 vp=$D2				},\
	245  { "OUT_CFS_ADD_FID		" exit=$D1 new/errno=$D2 tmp_vp=$D3		},\
	246  { "IN_CFS_RM_FID_VP	" fscp=$D1 vp=$D2				},\
	247  { "OUT_CFS_RM_FID_VP	" fscp=$D1 vp=$D2 rm=$D3			},\
	248  { "IN_CFS_RM_FID		" fscp=$D1 vp=$D2				},\
	249  { "OUT_CFS_RM_FID		" fscp=$D1 vp=$D2 rm=$D3			},\
	250  { "IN_CFS_FIND_FID		" fscp=$D1 fidp=$D2				},\
	251  { "OUT_CFS_FIND_FID	" fscp=$D1 fidp=$D2 vp=$D3			},\
	252  { "IN_CFS_PURGE_FID	" vfsp=$D1					},\
	253  { "OUT_CFS_PURGE_FID	" vfsp=$D1					},\
	254  { "PROXY_CFS_FID		" vp=$D1 f=$D2 cr=$D3				},\
	255  { "PROXY_CFS_STALE		"						},\
	256  { "IN_CFS_FSCACHE_SETUP	" fscp=$D1 fsid=$D2 namep=$D3 optp=$D4 setflags=$D5	},\
	257  { "OUT_CFS_FSCACHE_SETUP	" where=$D1 fscp=$D2 errno=$D3			},\
	258  { "IN_CFS_CREATE_EDGE	" fscdirvp=$D1 evpp=$D2				},\
	259  { "OUT_CFS_CREATE_EDGE	" fscdirvp=$D1 evpp=$D2 errno=$D3		},\
	260  { "IN_CFS_FSCACHE_SYNC	" fscp=$D1					},\
	261  { "OUT_CFS_FSCACHE_SYNC	" fscp=$D1					},\
	262  { "IN_CFS_FSCACHE_SYNC_UM	" fscp=$D1					},\
	263  { "OUT_CFS_FSCACHE_SYNC_UM	" fscp=$D1					},\
	264  { "IN_CFS_FLCKINIT		"						},\
	265  { "OUT_CFS_FLCKINIT	"						},\
	266  { "IN_CFS_FLOCK_ALLOC	" frlock=$D1					},\
	267  { "OUT_CFS_FLOCK_ALLOC	" t=$D1						},\
	268  { "IN_CFS_FLOCK_FREE	" fr=$D1 frlock=$D2				},\
	269  { "OUT_CFS_FLOCK_FREE	" fl=$D1 frlock=$D2				},\
	270  { "IN_CFS_INS_FLOCK	" lck_list=$D1 lckdat=$D2 fl=$D3 gp=$D4		},\
	271  { "OUT_CFS_INS_FLOCK	" exit=$D1 sf/new=$D2				},\
	272  { "IN_CFS_DEL_FLOCK	" lck_list=$D1 fl=$D2				},\
	273  { "OUT_CFS_DEL_FLOCK	"						},\
	274  { "IN_CFS_REG_FLOCK	" ld=$D1 flp=$D2				},\
	275  { "OUT_CFS_REG_FLOCK	" regntype=$D1					},\
	276  { "IN_CFS_FLOCK_ADJ	" where=$D1 D2=$D2 D3=$D3 D4=$D4		},\
	277  { "OUT_CFS_FLOCK_ADJ	" where=$D1 ret_val=$D2 l_type=$D3 ld=$D4	},\
	278  { "IN_CFS_UNLOCKED		" flp=$D1 lckdat=$D2 s=$D3 e=$D4		},\
	279  { "OUT_CFS_UNLOCKED	" where=$D1 s=$D2 e=$D3	l_start=$D4 error=$D5		},\
	280  { "IN_CFS_CHK_LOCK		" flp=$D1 lckdat=$D2				},\
	281  { "OUT_CFS_CHK_LOCK	" where=$D1					},\
	282  { "IN_CFS_BLOCKED		" flp=$D1 lckdat=$D2 insrt=$D3 gp=$D4		},\
	283  { "OUT_CFS_BLOCKED		" where=$D1 f=$D2				},\
	284  { "IN_CFS_ULCK_ALL		" gp=$D1 unlock_fcn=$D2 unlock_id=$D3		},\
	285  { "OUT_CFS_ULCK_ALL	" locked=$D1					},\
	286  { "IN_CFS_RECLOCK		" where=$D1 D2=$D2 D3=$D3 D4=$D4		},\
	287  { "OUT_CFS_RECLOCK		" where=$D1 errno=$D2 gp=$D3 size=$D4 offset=$D5	},\
	288  { "IN_CFS_CONVOFF		" size=$D1 offset=$D2 lckdat=$D3 whence=$D4	},\
	289  { "OUT_CFS_CONVOFF		" where=$D1					},\
	290  { "IN_CFS_DEADLOCK		" flp=$D1 lockdat=$D2				},\
	291  { "OUT_CFS_DEADLOCK	" where=$D1					},\
	292  { "IN_CFS_LCK_WKUP		" lp=$D1 retry_func=$D2				},\
	293  { "OUT_CFS_LCK_WKUP	"						},\
	294  { "IN_CFS_FLOCK_GROW	"						},\
	295  { "OUT_CFS_FLOCK_GROW	" grow=$D1					},\
	296  { "IN_CFS_ASYNCIOSTART	" head=$D1 halt=$D2 count=$D3 keep=$D4 length=$D5	},\
	297  { "OUT_CFS_ASYNCIOSTART	" length=$D1 count=$D2				},\
	298  { "IN_CFS_ADDIOQUEUE	" count=$D1 length=$D2 rp=$D3 qp=$D4		},\
	299  { "OUT_CFS_ADDIOQUEUE	" where=$D1 errno=$D2				},\
	300  { "CFS_MKMNTDEV_EDGE	" vfsp=$D1 val=$D2				},\
	301  { "IN_CFS_VGET_EDGE	" vfsp=$D1 fidp=$D2				},\
	302  { "OUT_CFS_VGET_EDGE	" vfsp=$D1 *vpp=$D2 error=$D3 where=$D4		},\
	303  { "IN_CFS_HOLD_GN_CNT	" vp=$D1 flags=$D2				},\
	304  { "OUT_CFS_HOLD_GN_CNT	" where=$D1 rd=$D2 wr=$D3 ex=$D4		},\
	305  { "IN_CFS_RELE_GN_CNT	" vp=$D1 flags=$D2				},\
	306  { "OUT_CFS_RELE_GN_CNT	" where=$D1 rd=$D2 wr=$D3 ex=$D4		},\
	307  { "CFS_FSYNC_RANGE	"							},\
	308  { "IN_CFS_FSYNC_OFFSET	" vp=$D1 flag=$D2 flag=$D3 flag=$D4		},\
	309  { "OUT_CFS_FSYNC_OFFSET	" where=$D1 errno=$D2 vp=$D3			},\
	310  { "IN_CFS_CREATE_EDGE_FID	" cp=$D1 fidp=$D2				},\
	311  { "OUT_CFS_CREATE_EDGE_FID	" where=$D1 errno=$D2				},\
	312  { "IN_CFS_FID_EDGE		" len=$D1 len=$D2				},\
	313  { "OUT_CFS_FID_EDGE	" errno=$D1					},\
	314  { "CFS_UNLOCK		" efl=$D1 cfsulck=$D2				},\
	315  { "IN_CFS_HANDLE_ULCK	" vp=$D1 offset=$D2 cmd=$D3 type=$D4		},\
	316  { "OUT_CFS_HANDLE_ULCK	" where=$D1 type=$D2 errno=$D3 vp=$D4		},\
	317  { "IN_CFS_HANDLE_LCK_T	" vp=$D1 offset=$D2 cmd=$D3 type=$D4		},\
	318  { "OUT_CFS_HANDLE_LCK_T	" where=$D1 type=$D2 errno=$D3 vp=$D4		},\
	319  { "IN_CFS_FINFO		" vp=$D1					},\
	320  { "OUT_CFS_FINFO		" errno=$D1 vp=$D2				},\
	321  { "CFS_WRITE_LCK		" cp=$D1					},\
	322  { "CFS_WRITE_ULCK		" cp=$D1					},\
	323  { "IN_CFS_WRITE_FID_EDGE	" cp=$D1					},\
	324  { "OUT_CFS_WRITE_FID_EDGE	" where=$D1 errno=$D2 cp=$D3			},\
	325  { "IN_CFS_LAST_CLOSE	" vp=$D1 flags=$D2				},\
	326  { "OUT_CFS_LAST_CLOSE	" where=$D1					},\
	327  { "IN_CFS_ADD_PROXY_FILE	" cp=$D1 remove=$D2				},\
	328  { "OUT_CFS_ADD_PROXY_FILE	" where=$D1 new=$D2 remove=$D3			},\
	329  { "IN_CFS_RM_PROXY_FILE	" cp=$D1 rm=$D2					},\
	330  { "OUT_CFS_RM_PROXY_FILE	" cp=$D1					},\
	331  { "IN_CFS_PURGE_PROXY_FILE	" fscp=$D1					},\
	332  { "OUT_CFS_PURGE_PROXY_FILE	" fscp=$D1 num=$D2			},\
	333  { "IN_CFS_INIT_PROXY_FILE	" fscp=$D1 dvp=$D2				},\
	334  { "OUT_CFS_INIT_PROXY_FILE	" where=$D1 error=$D2 fscp=$D3 num=$D4		},\
	335  { "IN_CFS_FILL_PROXY_FILE	" fscp=$D1 count=$D2 buf=$D3			},\
	336  { "OUT_CFS_FILL_PROXY_FILE	" error=$D1 fscp=$D2 count=$D3 buf=$D4		},\
	337  { "IN_CFS_INS_PROXY_FILE	" fscp=$D1 new=$D2				},\
	338  { "OUT_CFS_INS_PROXY_FILE	" fs_num_proxy_file=$D1				},\
	339  { "IN_CFS_CREATE_EDGE_S	" fscp=$D1 fn=$D2 mfn=$D3 create=$D4		},\
	340  { "OUT_CFS_CREATE_EDGE_S	" where=$D1 error/edge=$D2			},\
	341  { "IN_CFS_GET_FSCACHE	" dcp=$D1 fn=$D2 nm=$D3 bkvp=$D4		},\
	342  { "OUT_CFS_GET_FSCACHE	" where=$D1 fscp/error=$D2			},\
	343  { "IN_CFS_GET_P_EDGE	" cp=$D1 edge=$D2				},\
	344  { "OUT_CFS_GET_P_EDGE	" where=$D1 mfn/error=$D2			},\
	345  { "IN_CFS_COMMIT_AIX	" bp=$D1 vp=$D2 off=$D3 len=$D4 cr=$D5		},\
	346  { "OUT_CFS_COMMIT_AIX	" w=$D1 cp=$D2 uid/off=$D3 ruid/len=$D4		},\
	347  { "IN_CFS_COMMIT		" vp=$D1 off=$D2 len=$D3 cr=$D4 bp=$D5		},\
	348  { "OUT_CFS_COMMIT		" w=$D1 vp=$D2 off=$D3 len=$D4 err=$D5		},\
	349  { "IN_CFS_GET_BKVP_NOC	"						},\
	350  { "OUT_CFS_GET_BKVP_NOC	"						},\
	351  { "IN_CFS_MAP_LLOFF	" off=$D1 len=$D2 f=$D3 vf=$D4 vt=$D5		},\
	352  { "OUT_CFS_MAP_LLOFF	" w=$D1 err=$D2 vp=$D3 off=$D4 len=$D5		},\
	\* { `NFS NET mode=$HD` }
3B0 1.0 "@AutoFS: Client VNOP read/write routines" \
        $HD%D1, \
        1  { "MOUNT " vfsp=$D2 vp=$D3 uap=$D4 cr=$D5 }, \
	2  { "MOUNT_ARGSZ " datalen=$D1 args_size=$D2 vfsp=$D3}, \
        3  { "MOUNT_ERROUT " vfsp=$D1 rootvp=$D2 error=$D3 }, \
        4  { "MOUNT_EXIT " \
	      $D1%D1, \
	      0 {makefnnode error vfsp=$D2 fnip=$D3 fi_path=$D4 cr=$D5 }, \
	      1 {mount exit vfsp=$D2 rootvp=$D3 fnip=$D4 } }, \
        5  { "MOUNT_PREM " }, \
        6  { "UNMOUNT " vfsp=$D1 fnip=$D2 }, \
        7  { "UNMOUNT_EXIT " \
	      $D1%D1, \
	      0 {unmount_autofs failed rvp=$D2 vfsp=$D3 rc=$D4 }, \
	      1 {unmount exit(manual) vfsp=$D2 }, \
	      2 {dirents are active fnp=$D2 v_mvfsp=$D3 v_count=$D4 }, \
	      3 {unmount exit vfsp=$D2 } }, \
        8  { "UNMOUNT_PERM " }, \
        9  { "UNMOUNT_VCOUNT " v_count=$D1 }, \
        10 { "I_ACCESS " mode=$D1 flags=$D2 cr_uid=$D3 an_uid=$D4 an_mode=$D5 }, \
        11 { "I_AUTODIR_LOOKUP " v_type=$D1 hrestime=$D2 }, \
        12 { "I_AUTO_DIRENTER " dap=$D1 ap=$D2 }, \
        13 { "I_BUSY " mntflags=$D1 dirs=$D2 refs=$D3 adjust=$D4 }, \
        14 { "I_CALL_AUTOMOUNTD " ai_path=$D1 ac_name=$D2 ai_direct=$D3 an_mntflags=$D4 }, \
        15 { "I_CREATE " vfsmountedhere=$D1 mode=$D2 }, \
        16 { "I_DO_MOUNT " ai_path=$D1 name=$D2 an_mntflags=$D3 }, \
        17 { "I_DO_UNMOUNT " mntflags=$D1 vfsmountedhere=$D2 }, \
        18 { "I_FORCE_REMOUNT " nm=$D1 v_flag=$D2 }, \
        19 { "I_FREEAUTONODE " freautonode_count=$D1 anode_count=$D2 }, \
        20 { "I_GETATTR " nodeid=$D1 size=$D2 type=$D3 mode=$D4 vfs_dev=$D5 }, \
        21 { "I_GET_HIER_MOUNTS " }, \
        22 { "I_INACTIVE " count=$D1 size=$D2 }, \
        23 { "I_LOOKUP_ENTRY " flags=$D1 pid=$D2%P4 dvp=$D3 hrestime=$D4 }, \
        24 { "I_LOOKUP_INFO " path=$D1 vfsmountedhere=$D2 dirents=$D3 mntflags=$D4 need_mount=$D5 }, \
        25 { "I_MAKEAUTONODE " type=$D1 cr_uid=$D2 cr_gid=$D3 makeautonode_count=$D4 anode_cnt=$D5 }, \
        26 { "I_MAKE_UNMOUNTED_L " an_name=$D1 vfsmountedhere=$D2 }, \
        27 { "I_MKDIR " vfsmountedhere=$D1 namelen=$D2 }, \
        28 { "I_READDIR " need_mount=$D1 vfsmountedhere=$D2 dirents=$D3 mntflags=$D4 }, \
        29 { "I_REMOVE " dvp=$D1 vfsmountedhere=$D2 }, \
        30 { "I_RENAME " o_vfsmountedhere=$D1 n_vfsmountedhere=$D2 }, \
        31 { "I_RMDIR " vfsmountedhere=$D1 namelen=$D2 }, \
        32 { "I_RM_AUTONODE " vfsmountedhere=$D1 v_count=$D2 refmin=$D3 an_mntflags=$D4 an_name=$D5 }, \
        33 { "I_RM_HIERARCHY " dap=$D1 ap=$D2 }, \
        34 { "I_RWLOCK " write_lock=$D1 }, \
        35 { "I_SEND_UNMOUNT_REQ " }, \
        36 { "I_SYMLINK " vfsmountedhere=$D1 }, \
        37 { "I_UNMOUNT_HIERARCHY " mntflags=$D1 ref_time=$D2 mount_to=$D3 time_now=$D4%T4 an_name=$D5 }, \
        38 { "I_XDR_UMOUNTR " x_op=$D1 }, \
        39 { "O_ACCESS_BAD " }, \
        40 { "O_ACCESS_OK " }, \
        41 { "O_AUTODIR_LOOKUP " D1=$D1 error=$D2 }, \
        42 { "O_AUTO_DIRENTER " D1=$D1 error=$D2 }, \
        43 { "O_BUSY " D1=$D1 return=$D2 }, \
        44 { "O_CALL_AUTOMOUNTD " D1=$D1 error=$D2 }, \
        45 { "O_CREATE_EXIT " error=$D1 }, \
        46 { "O_CREATE_NO_VFS " }, \
        47 { "O_CREATE_VFS_ROOT " error=$D1 }, \
        48 { "O_DO_MOUNT " D1=$D1 error=$D2 }, \
        49 { "O_DO_UNMOUNT " }, \
        50 { "O_FORCE_REMOUNT " error=$D1 }, \
        51 { "O_FREEAUTONODE " }, \
        52 { "O_GETATTR " }, \
        53 { "O_GET_HIER_MOUNTS " vfs_dev=$D1 }, \
        54 { "O_INACTIVE_EXIT " }, \
        55 { "O_INACTIVE_VCOUNT " count=$D1 }, \
        56 { "O_LOOKUP_ANDIR " }, \
        57 { "O_LOOKUP_ENOSYS " }, \
        58 { "O_LOOKUP_EXIT " error=$D1 }, \
        59 { "O_LOOKUP_INTR " }, \
        60 { "O_LOOKUP_MNT " error=$D1 }, \
        61 { "O_LOOKUP_MNTERR " error=$D1 }, \
        62 { "O_LOOKUP_OK_DOT " }, \
        63 { "O_LOOKUP_OK_DOTDOT " }, \
        64 { "O_LOOKUP_SPMKDIR " }, \
        65 { "O_LOOKUP_UMINTR " }, \
        66 { "O_LOOKUP_VFSROOT " error=$D1 }, \
        67 { "O_LOOKUP_VFSROOT_1 " error=$D1 }, \
        68 { "O_LOOKUP_VOPACC " error=$D1 }, \
        69 { "O_LOOKUP_VOPLKU " error=$D1 }, \
        70 { "O_LOOKUP_VOPLKU_1 " error=$D1 }, \
        71 { "O_MAKEAUTONODE " vp=$D1 }, \
        72 { "O_MAKE_UNMOUNTED_L " }, \
        73 { "O_MKDIR_DOT " }, \
        74 { "O_MKDIR_EXIT " error=$D1 }, \
        75 { "O_MKDIR_LOOKUP " error=$D1 }, \
        76 { "O_MKDIR_NOTSPECIAL " }, \
        77 { "O_MKDIR_VACC " error=$D1 }, \
        78 { "O_MKDIR_VFS_ROOT " error=$D1 }, \
        79 { "O_READDIR_EXIT " error=$D1 }, \
        80 { "O_READDIR_INTR " }, \
        81 { "O_READDIR_IOVCNT " }, \
        82 { "O_READDIR_MNT " error=$D1 }, \
        83 { "O_READDIR_VFSROOT " error=$D1 }, \
        84 { "O_READDIR_VRDIR " error=$D1 }, \
        85 { "O_READDIR_WAITMNT " error=$D1 }, \
        86 { "O_REMOVE_EXIT " error=$D1 }, \
        87 { "O_REMOVE_NO_VFS " }, \
        88 { "O_REMOVE_VFS_ROOT " error=$D1 }, \
        89 { "O_RENAME_EXIT " error=$D1 }, \
        90 { "O_RENAME_NO_VFS " }, \
        91 { "O_RENAME_VFS_ROOT1 " error=$D1 }, \
        92 { "O_RENAME_VFS_ROOT2 " error=$D1 }, \
        93 { "O_RMDIR_BAD " error=$D1 }, \
        94 { "O_RMDIR_DOT " }, \
        95 { "O_RMDIR_DOTDOT " }, \
        96 { "O_RMDIR_EXIT " }, \
        97 { "O_RMDIR_LKUP " error=$D1 }, \
        98 { "O_RMDIR_NOTSPECIAL " }, \
        99 { "O_RMDIR_VFS_ROOT " error=$D1 }, \
        100 { "O_RMDIR_VRMDIR " error=$D1 }, \
        101 { "O_RM_AUTONODE " D1=$D1 }, \
        102 { "O_RM_HIERARCHY " }, \
        103 { "O_RWLOCK " }, \
        104 { "O_SEND_UNMOUNT_REQ " D1=$D1 error=$D2 }, \
        105 { "O_SYMLINK_EXIT " error=$D1 }, \
        106 { "O_SYMLINK_NO_VFS " }, \
        107 { "O_SYMLINK_VFS_ROOT " error=$D1 }, \
        108 { "O_UNMOUNT_HIERARCHY " D1=$D1 }, \
        109 { "O_XDR_UMOUNTR " D1=$D1 return=$D2 }, \
        110 { "INKER_MOUNT " uap=$D1 vp=$D2 }, \
        111 { "INKER_MOUNT_ROOT " error=$D1 }, \
        112 { "INKER_VFS_MOUNT " vfsp=$D1 vp=$D2 uap=$D3 kcred=$D4 error=$D5 }, \
        113 { "INKER_MOUNT_EXIT " \
	    $D1%D1, \
	      0 {vnode vp=$D2 already locked uap=$D3  }, \
	      1 {v_vfsmountedhere=$D2 FS is mounted on vnode vp=$D3 uap=$D4 }, \
	      2 {vmount error uap=$D2 vp=$D3 vfsp=$D4 error=$D5 } }, \
        114 { "INKER_MOUNT_PERM " }, \
        115 { "AUTOFS_TEST2 " error=$D1 data=$D2 args=$D3 vfsp=$D4 }, \
        116 { "MOUNT_ERROR " vfsp=$D1 error=$D2 }, \
        117 { "UNMOUNT_BUSY " fn_dirents=$D1 }, \
        118 { "ROOT " vfsp=$D1 vpp=$D2 }, \
        119 { "STATVFS " \
	      $D1%D1, \
		0 {vfsp=$D2 }, \
		1 {statvfs exit vfsp=$D2 sbp=$D3} }, \
        120 { "MOUNT_PERM " }, \
        122 { "SYMLINK " dvp=$D1 lnknm=$D2 tva=$D3 tnm=$D4 cred=$D5 }, \
        123 { "SYMLINK_DONE " \
		$D1%D1, \
		0 {trigger mount failed dvp=$D2 tva=$D3 tnm=$D4 error=$D5 }, \
		1 {symlink create error dvp=$D2 tnm=$D3 error=$D4 trc=$D5 }, \
		2 {Symlink exit dvp=$D2 } }, \
        124 { "READLINK_DONE " \
		$D1%D1, \
		0 {ReadLink error vp=$D2 error=$D3 trc=$D4}, \
		1 {ReadLink exit vp=$D2 } }, \
        125 { "INACTIVE " vp=$D1 v_count=$D2 fn_linkcnt=$D3 cred=$d4 }, \
        126 { "INACTIVE_DONE " vp=$D1 v_count=$D2 fn_linkcnt=$D3 }, \
        127 { "TRIG_MOUNT " vp=$D1 cred=$D2 newvp=$D3 fnp=$D4 fnip=$D5 }, \
        128 { "TRIG_MOUNT_DONE " \
		$D1%D1, \
		0 {Trigger mount error vp=$D2 error=$D2 trc=$D4 }, \
		1 {Trigger mount exit vp=$D2 trc=$D3 } }, \
        129 { "SETATTR " vp=$D1 vap=$D2 flags=$D3 cred=$D4 }, \
        130 { "SETATTR_DONE " \
		$D1%D1, \
		0 {trigger mount failed vp=$D2 cred=$D3 error=$D4 }, \
		1 {Setattr error vp=$D2 cred=$D3 error=$D4 trc=$D5}, \
		2 {Setattr exit vp=$D2 } }, \
        131 { "ACCESS " vp=$D1 mode=$D2 flags=$D3 cred=$D4 tid=$D5 }, \
        132 { "ACCESS_DONE " \
		$D1%D1, \
		0 {trigger mount failed vp=$D2 error=$D3 }, \
		1 {autofs mount of namefs symlinks vp=$D2 newvp=$D3 err=$D4 }, \
		2 {Access error vp=$D2 error=$D3 trc=$D4}, \
		3 {Access exit vp=$D2 } }, \
        133 { "LOOKUP " dvp=$D1 nm=$D2 vpp=$D3 fi_map=$D4 flags=$D5}, \
        134 { "LOOKUP_TOP " dvp=$D1 dfnp=$D2 }, \
        135 { "LOOKUP_EXIT " \
		$D1%D1, \
		0 {VOP_ACCESS error dvp=$D2 *vpp=$D3 nm=$D4 error=$D5 }, \
		1 {nm=$D2 is a current directory dvp=$D3 *vpp=$D4 }, \
		2 {nm=$D2 is a parent directory dvp=$D3 *vpp=$D4 pdfnp=$D5}, \
		3 {wait4mount error dvp=$D2 dfnp=$D3 nm=$D4 error=$D5}, \
		4 {v_vfsmountedhere=$D2 FS is mounted on dvp=$D3 err=$D4}, \
		5 {Create failed for fn_dirents dfnip=$D2 dfnp=$D3 error=$D4} , \
		6 {Created node for fn_dirents dfnip=$D2 dfnp=$D3 fnp=$D4} , \
		7 {Create failed dfnip=$D2 dfnp=$D3 error=$D4}, \
		8 {Created node dfnip=$D2 dfnp=$D3 fnp=$D4}, \
		9 {Lookup exit error=$D3}, \
		10 {wait4mount error dvp=$D2 dfnp=$D3 nm=$D4 error=$D5} , \
		11 {Got the requested fnnode fnp=$D2 *vpp=$D3} , \
		12 {Lookup error nm=$D2 *vpp=$D3 error=$D4 trc=$D5}, \
		13 {Lookup exit nm=$D2 *vpp=$D3} }, \
        136 { "CREATE " dvp=$D1 nm=$D2 va=$D3 mode=$D4 }, \
        137 { "CREATE_DONE " \
		$D1%D1, \
		0 {trigger mount failed dvp=$D2 nm=$D3 error=$D4 }, \
		1 {create error dvp=$D2 nm=$D3 error=$D4 trc=$D5}, \
		2 {create exit dvp=$D2 nm=$D3} }, \
        138 { "REMOVE " dvp=$D1 nm=$D2 cred=$D3 } , \
        139 { "REMOVE_DONE " \
		$D1%D1, \
		0 {trigger mount failed dvp=$D2 nm=$D3 error=$D4 }, \
		1 {remove error dvp=$D2 nm=$D3 error=$D4 trc=$D5}, \
		2 {remove exit dvp=$D2 nm=$D3} }, \
        140 { "LINK " tdvp=$D1 svp=$D2 nm=$D3 cred=$D4 }, \
        141 { "LINK_DONE " \
		$D1%D1, \
		0 {trigger mount failed tdvp=$D2 svp=$D3 nm=$D4 error=$D5 }, \
		1 {autonode link error tdvp=$D2 svp=$D3 nm=$D4 error=$D5 }, \
		2 {Read only FS tdvp=$D2 svp=$D3 nm=$D4 error=$D5 }, \
		3 {svp=$D2 is not autonode tdvp=$D3 nm=$D4 error=$D5 }, \
		4 {Link error tdvp=$D2 svp=$D3 nm=$D4 error=$D5 }, \
		5 {Link exit tdvp=$D2 svp=$D3 nm=$D4 } }, \
        142 { "RENAME " odvp=$D1 onm=$D2 ndvp=$D3 nnm=$D4 cr=$D5 }, \
        143 { "RENAME_DONE " \
		$D1%D1, \
		0 {trigger mount failed odvp=$D2 onm=$D3 nnm=$D4 error=$D5 }, \
		1 {autonode rename error odvp=$D2 onm=$D3 nnm=$D4 error=$D5 }, \
		2 {trigger mount real FS failed ndvp=$D2 onm=$D3 nnm=$D4 error=$D5 }, \
		3 {target can't be autonode ndvp=$D2 onm=$D3 nnm=$D4 error=$D5 }, \
		4 {Read only FS ndvp=$D2 onm=$D3 nnm=$D4 error=$D5 }, \
		5 {Rename error ndvp=$D2 onm=$D3 nnm=$D4 error=$D5 }, \
		6 {Rename exit ndvp=$D2 onm=$D3 nnm=$D4 } }, \
        144 { "MKDIR " dvp=$D1 nm=$D2 va=$D3 vpp=$D4 cred=$D5 }, \
        145 { "MKDIR_DONE " \
		$D1%D1, \
		0 {trigger mount failed dvp=$D2 nm=$D3 va=$D4 error=$D5 }, \
		1 {mkdir error dvp=$D2 nm=$D3 trc=$D4 error=$D5 }, \
		2 {mkdir exit dvp=$D2 nm=$D3 va=$D4} }, \
        146 { "RMDIR " dvp=$D1 nm=$D2 cdir=$D3 cred=$D4}, \
        147 { "RMDIR_DONE " \
		$D1%D1, \
		0 {trigger mount failed dvp=$D2 nm=$D3 cdir=$D4 error=$D5 }, \
		1 {rmdir error dvp=$D2 nm=$D3 trc=$D4 error=$D5 }, \
		2 {rmdir exit dvp=$D2 nm=$D3 cdir=$D4} }, \
        148 { "READDIR " vp=$D1 uiop=$D2 cred=$D3 offset=$D4 }, \
        149 { "READDIR_EINVAL " iovcnt=$D1 }, \
        150 { "READDIR_DONE " \
		$D1%D1, \
		0 {VOP_LOOKUP failed vp=$D2 cred=$D3 error=$D4 }, \
		1 {VFS_ROOT error vp=$D2 vp->v_mvfsp=$D3 cred=$D4 error=$D5 }, \
		2 {VOP_READDIR error vp=$D2 vp->v_mvfsp=$D3 nvp=$D4 error=$D5 }, \
		3 {VOP_READDIR success vp=$D2 vp->v_mvfsp=$D3 nvp=$D4 }, \
		4 {auto_calldaemon failed fnip=$D2 status=$D3 error=D4 trc2=$D5 }, \
		5 {empty directory fnip=$D2 fnp=$D3 status=D4 trc2=$D5 }, \
		6 {alloclen < data vp=$D2 alloccnt=$D3 datalen=$D4 error=$D5 }, \
		7 {alloclen < data and outcnt vp=$D2 alloccnt=$D3 datalen=$D4 outcnt=$D5 }, \
		8 {Readdir error vp=$D2 error=$D3 trc=$D4 }, \
		9 {Readdir exit vp=$D2 } }, \
        151 { "POLL " vp=$D1 }, \
        152 { "PATHCONF " vp=$D1 cmd=$D2 valp=$D3 cr=$D4 }, \
        153 { "OPEN " vpp=$D1 flag=$D2 cred=$D3 }, \
        154 { "GETATTR " vp=$D1 vap=$D2 flags=$D3 cred=$D4 }, \
        155 { "GETATTR_DONE " }, \
        156 { "READLINK " vp=$D1 uiop =$D2 cr=$3 }, \
        157 { "FREEFNNODE " fnp=$D1 vp=$D2 v_count=$D3%D1 caller=$D4 caller2=$D5 }, \
        158 { "FREEFNNODE_DONE " fnnode_cnt=$D1 }, \
        159 { "DISCONNECT " dfnp=$D1 fnp=$D2 }, \
        160 { "DISCONNECT_DONE " \
		$D1%D1, \
	      	0 {vp=$D2 vp->v_vfsmounted=$D3 dfnp=$D4 fnp=$D5 }, \
	      	1 {Not in dirent list fnp=$D2 dfnp=$D3} , \
	      	2 {disconnect exit fnp=$D2 dfnp=$D3} }, \
        161 { "ENTER " dfnp=$D1 name=$D2 fnpp=$D3 cred=$D4 }, \
        162 { "ENTER_DONE " \
		$D1%D1, \
	      	0 {makefnnode error dvp=$D2 dvp->v_vfsp=$D3 name=$D4 cred=$D5 }, \
	      	1 {fnnode created fnp=$D2 } }, \
        163 { "SEARCH " dfnp=$D1 name=$D2 fnpp=$D3 cred=$D4 }, \
        164 { "SEARCH_DONE " \
		$D1%D1, \
	      	0 {Not directory dvp=$D2 dvp->v_type=$D3 }, \
	      	1 {search error dfnp=$D2 name=$D3 error=$D4}, \
	      	2 {search exit dfnp=$D2 name=$D3 } }, \
        165 { "GETMNTPNT " dvp=$D1 path=$D2 mvpp=$D3 cred=$D4 }, \
        166 { "GETMNTPNT_DONE " \
		$D1%D1, \
	      	0 {getmntpnt error dvp=$D2 path=$D3, error=$D4, trc=$D5 }, \
	      	1 {getmntpnt exit dvp=$D2 path=$D3} }, \
        167 { "INKER_UMOUNT " vfsp=$D1 }, \
        168 { "INKER_UMOUNT_DONE " \
		$D1%D1, \
	      	0 {inkernel unmnt error vfsp=$D2 error=$D3 }, \
	      	1 {inkrnel unmnt exit vfsp=$D2 } }, \
        169 { "TRIGGERS " fnp=$D1 alp=$D2 }, \
        170 { "TRIGGERS_BUSY " fnp=$D1 nfnp=$D2 }, \
        171 { "TRIGGERS_BUSY_DONE " \
		$D1%D1, \
	      	0 {triggers busy error fnp=$D2 error=$D3 trc=$D4 }, \
	      	1 {triggers busy exit fnp=$D2 } }, \
        172 { "TRIGGERS_DONE " \
		$D1%D1, \
	      	0 {inkernel unmnt error tvp=$D2 vfsp=$D3 error=$D4 }, \
	      	1 {unmnt triggers success vfsp=$D2 } }, \
        173 { "UNMOUNT_NODE " vfsp=$D1 }, \
        174 { "UNMOUNT_NODE_DONE " \
		$D1%D1, \
	      	0 {umnt node error vfsp=$D2 error=$D3 trc=$D4 }, \
	      	1 { umnt node exit vfsp=$D2 } }, \
        175 { "AUTO_NODE " vp=$D1 }, \
        176 { "AUTO_NODE_DONE " \
		$D1%D1, \
	      	0 {Check auto node error vp=$D2 error=$D3 }, \
	      	1 {Check auto node exit vp=$D2 } }, \
        177 { "UNMOUNT_ROOT " rootvp=$D1 }, \
        178 { "UNMOUNT_ROOT_DONE " \
		$D1%D1, \
	      	0 {umnt root node error rootvp=$D2 error=$D3 }, \
	      	1 {umnt root node exit rootvp=$D2 } }, \
        180 { "UNMOUNT_TREE_NAME " fn_name=$D1 }, \
        181 { "UNMOUNT_TREE_DONE " \
		$D1%D1, \
	      	0 {cant unmount nfs nodes tvp=$D2 error=$D3}, \
		1 {vp=$D2 error=$D3}, \
		2 {connection dropped vp=$D2 fi_path=$D3 error=$D4}, \
		3 {can't remount triggers fnp=$D2 error=$D3}, \
		4 {unmount_tree exit tid=$D2} }, \
        182 { "DO_UNMOUNT " }, \
        183 { "UNMOUNT_THREAD " }, \
        184 { "UNMOUNT_THR_FAIL " }, \
        185 { "NULL_REQ " fnip=$D1 cred=$D2 hard=$D3 }, \
        186 { "NULL_REQ_DONE " \
		$D1%D1, \
	      	0 {NULL request error fnip=$D2 error=$D3}, \
	      	1 {NULL request exit fnip=$D2 } }, \
        187 { "LOOKUP_REQ " fnip=$D1 key=$D2 cred=$D3 }, \
        188 { "LOOKUP_REQ_DONE " \
		$D1%D1, \
	      	0 {Lookup request error fnip=$D2 key=$D3 error=$D4 trc=$D5}, \
	      	1 {Lookup request exit fnip=$D2 key=$D3 trc=$D4} }, \
        189 { "MOUNT_REQ " fnip=$D1 key=$D2 cred=$D3}, \
        190 { "MOUNT_REQ_DONE " \
		$D1%D1, \
	      	0 {Mount request error fnip=$D2 key=$D3 error=$D4 trc=$D5}, \
	      	1 {Mount request exit fnip=$D2 key=$D3 trc=$D4} }, \
        191 { "POSTMOUNT_REQ " m=$D1 devid=$D2 fnip=$D3 hard=$D4 cred=$D5 }, \
        192 { "POSTMOUNT_REQ_DONE " error=$D1}, \
        193 { "SEND_UMOUNT_REQ " fnip=$D1 ul=$D2 cred=$D3 }, \
        194 { "SEND_UMOUNT_REQ_DONE " \
		$D1%D1, \
	      	0 {send umnt request error fnip=$D2 error=$D3 }, \
	      	1 {send umnt request exit fnip=$D2 } }, \
        195 { "POST_UMOUNT_REQ " }, \
        196 { "POST_UMOUNT_REQ_DONE " }, \
        197 { "PERFORM_ACT " dfnip=$D1 dfnp=$D2 alp=$D3 cred=$D4 }, \
        198 { "PERFORM_ACT_DONE " \
		$D1%D1, \
	      	0 {AuFS mntpt exists mfnp=$D2 }, \
	      	1 {mntpnt create failed dfnp=$D2 mntpnt=$D3 error=$D4 }, \
	      	2 {getmntpnt error dvp=$D2 mntpnt=$D3 error=$D4 }, \
	      	3 {mntpnt mvp=$D2 is symlink v_type=$D3 }, \
	      	4 {inkernel mount failed m=$D2 mvp=$D3 global_path=$D4 error=$D5 }, \
	      	5 {perform actions error dfnip=$D2 dfnp=$D3 error=$D4 }, \
	      	6 {perform actions exit dfnip=$D2 dfnp=$D3 } }, \
        199 { "PERFROM_LINK " fnp=$D1 linkp=$D2 cred=$D3 }, \
        200 { "DO_UNMOUNT_THR_FAIL " }, \
        201 { "WAIT4MOUNT " fnp=$D1 lock=$D2 thread_id=$D3}, \
        202 { "WAIT4MOUNT_DONE " \
		$D1%D1, \
	      	0 {Not waiting to finish operation fnp=$D2}, \
	      	1 {wait4mount error fnp=$D2 error=$D3 }, \
	      	2 {wait4mount exit fnp=$D2 } }, \
        203 { "LOOKUP_AUX " fnp=$D1 name=$D2 cred=$D3 }, \
        204 { "LOOKUP_AUX_DONE " \
		$D1%D1, \
	      	0 {Lookup_aux error fnp=$D2 name=$D3 error=$D4 trc=$D5}, \
	      	1 {Lookup_aux exit fnp=$D2 name=$D3 trc=$D4} }, \
        205 { "MOUNT_THREAD " argsp=$D1 threadid=$D2 }, \
        206 { "MOUNT_THREAD_STOP " \
		$D1%D1, \
	      	0 {Mount thread error fnip=$D2 tid=$D3 error=$D4 trc=$D5}, \
	      	1 {Mount_thread exit fnip=$D2 tid=$D3 trc=$D4} }, \
        207 { "NEW_MOUNT_THREAD " fnp=$D1 name=$D2 cred=$D3 }, \
        208 { "NEW_MOUNT_THREAD_DONE " thr_success=$D1 }, \
        209 { "CALLDEAMON " fnip=$D1 which=$D2 xdrargs=$D3 cred=$D4 thread_id=$D5 }, \
        210 { "CALLDEAMONPORT " error=$D1 }, \
        211 { "CALLDEAMON_ENOENT " D1=$D1 status=$D2 }, \
        212 { "CALLDEAMON_DONE " \
		$D1%D1, \
	      	0 {call_daemon error fnip=$D2 which=$D3 error=$D4 trc=$D5}, \
	      	1 {call_daemon exit fnip=$D2 which=$D3 trc=$D4} }, \
        213 { "POSTUMOUNT_REQ " fnip=$D1 ul=$D2 cred=$D3 hard=$D4}, \
        214 { "POSTUMOUNT_REQ_DONE " error=$D1 }, \
        215 { "UNMOUNT_TREE " }, \
        216 { "START_UM_THR " }, \
        217 { "FREEFNNODE2 " fnp=$D1 fn_linkcnt=$D2 fn_dirents=$D3 fn_parent=$D4 fn_size=$D5}, \
        218 { "UNMOUNT_ROOT2 " fnp=$D1 vp=$D2 v_count=$D3%D1 caller=$D4 caller2=$D5}, \
        219 { "INACTIVE2 " fnp=$D1 vp=$D2 v_count=$D3%D1 caller=$D4 caller2=$D5}, \
        220 { "INACTIVE3 " fnp=$D1 vp=$D2 v_count=$D3%D1 caller=$D4 caller2=$D5}, \
        221 { "HOLD " vp=$D1 v_count=$D2 caller=$D3 caller2=$D4 caller3=$D5}, \
        222 { "RELE " vp=$D1 v_count=$D2 caller=$D3 caller2=$D4 caller3=$D5}, \
        223 { "UNMOUNT2 " fnp=$D1 vp=$D2 v_count=$D3%D1 caller=$D4 caller2=$D5 }, \
        224  { "VMNTINIT " \
	      $D1%D1, \
	      0 {vp=$D2 map=$D3 mntpnt=$D4}, \
	      1 {vmount_init exit vmntp=$D2 args=$D3 vfsp=$D4 } }, \
        225  { "PATHNAME " \
	      $D1%D1, \
	      0 {vp=$D2 path=$D3 }, \
	      1 {pathname exit vp=$D2 path=$D3 } }, \
        226  { "AUFS_CLNT " \
	      $D1%D1, \
	      0 {cmd=$D2 p=$D3 size=$D4 }, \
	      1 {invalid size unit cmd=$D2 p=$D3 size=$D4 }, \
	      2 {Not a root user cmd=$D2 p=$D3 cr=$D4 cr->cr_uid=$D5 }, \
	      3 {Set mount timeout error cmd=$D2 p=$D3 size=$D4 error=$D5 }, \
	      4 {Get mount timeout error cmd=$D2 p=$D3 size=$D4 error=$D5 }, \
	      5 {Set unmnt timer error cmd=$D2 p=$D3 size=$D4 error=$D5 }, \
	      6 {umnt timer error cmd=$D2 p=$D3 size=$D4 timer=$D5 }, \
	      7 {Get umnt timer error cmd=$D2 p=$D3 size=$D4 error=$D5 }, \
	      8 {Set automountd daemon PID error in 64bit size=$D2 error=$D3}, \
	      9 {Set automountd daemon PID error in 32bit size=$D2 error=$D3}, \
	      10 {Get automountd PID error in 64bit size=$D2 error=$D3 }, \
	      11 {Get automountd PID error in 32bit size=$D2 error=$D3 }, \
	      12 {Get AUFS DBG error cmd=$D2 p=$D3 size=$D4 error=$D5 }, \
	      13 {Set AUFS DBG error cmd=$D2 p=$D3 size=$D4 error=$D5 }, \
	      14 {Autofs clnt exit cmd=$D2 p=$D3 size=$D4 }, \
	      15 {clnt exit with bad size cmd=$D2 p=$D3 size=$D4 trc=$D5} }, \
        227  { "AUTO RELE EXIT " \
	      $D1%D1, \
	      0 {vp=$D2 vcnt=$D3 caller1=$D4 caller2=$D5 }, \
	      1 {vp=$D2 vcnt=$D3 caller1=$D4 caller2=$D5 } }, \
        228  { "PATHCONF DONE " \
	      $D1%D1, \
	      0 {Pathconf error vp=$D2 cmd=$D3 valp=$D4 error=$D5 }, \
	      1 {Pathconf exit vp=$D2 cmd=$D3 valp=$D4 } }, \
        229  { "OPEN DONE " \
	      $D1%D1, \
	      0 {Open error vp=$D2 flag=$D3 cred=$D4 error=$D5 }, \
	      1 {Open exit vp=$D2 flag=$D3 cred=$D4 } }, \
        230  { "CHECK ACCESS " \
	      $D1%D1, \
	      0 {Check Access fnp=$D2 }, \
	      1 {Thread=$D1 is creaded fnnode fnp=$D2 }, \
	      2 {Thread=$D1 is creaded fnnode fnp=$D2 }, \
	      3 {Check Access exit fnp=$D2 } }, \
        231  { "TRIGGERS UNLOCK " \
	      $D1%D1, \
	      0 {Triggers unlock fnp=$D2 }, \
	      1 {Triggers unlck exit fnp=$D2 } }, \
        232  { "CHECK DIRENT MOUNTED " fnp=$D1 }, \
       \* { `mode=$HD` D1=$D1 D2=$D2 D3=$D3 D4=$D4 D5=$D5 }
410 1.0 "@NFS Version 4 Client State" \
	$HD%D1, \
	1 { "update_renew_time " srvp=$D1 last_renew=$D2 }, \
	2 { "allocate_state_info " rp=$D1 }, \
	3 { "free_state_info " rp=$D1 }, \
	4 { "update_state_info " rp=$D1 }, \
	10 { "fsid_hold enter " fsidp=$D1 flags=$D2 }, \
	11 { "  fsid_hold exit " fsidp=$D1 chage_count=$D2 }, \
	12 { "  fsid_hold interrupted " fsidp=$D1 }, \
	13 { "fsid_rele enter " fsidp=$D1 change_count=$D2 }, \
	20 { "start_state_change enter " rp=$D1 fsidp=$D2 }, \
	21 { "  start_state_change exit " rp=$D1 flags=$D2 }, \
	22 { "  start_state_change_nohold enterrupted " rp=$D1 }, \
	23 { "  start_state_chane_nohold exit " rp=$D1 }, \
	24 { "end_state_change  " rp=$D1 flags=$D2 }, \
	25 { "block_state_change enter " rp=$D1 flags=$D2 }, \
	26 { "  block_state_change interrupted " rp=$D1 }, \
	27 { "  block_state_change exit " rp=$D1 flags=$D2 }, \
	30 { "start_io enter" rp=$D1 }, \
	31 { "  start_io fsid hold interrupted " rp=$D1 }, \
	32 { "  start_io sleep interrupted " rp=$D1 }, \
	33 { "  start_io exit " rp=$D1 io_count=$D2 }, \
	34 { "end_io exit " rp=$D1 io_count=$D2 }, \
	35 { "deleg_flush_io enter " rp=$D1 }, \
	36 { "  deleg_flush_io_exit " rp=$D1 error=$D2 }, \
	40 { "get_client_owner " rp=$D1 owner_index=$D2 owner_val=$D3 }, \
	41 { "  get_client_owner exit old owner " rp=$D1 cop=$D2 owner_index=$D3 owner_val=$D4 }, \
	42 { "  get_client_owner exit new owner " rp=$D1 cop=$D2 owner_index=$D3 owner_val=$D4 }, \
	43 { "unlock_client_owner " cop=$D1 }, \
	44 { "invalidate_owner enter " rp=$D1 cop=$D2 }, \
	45 { "  invalidate_owner exit " cop=$D1 owner_val=$D2 }, \
	50 { "open_owner_delay enter " cop=$D1 status=$D2 vp=$D3 }, \
	51 { "  open_owner_delay fsidp reclaim " cop=$D1 vp=$D2 }, \
	52 { "  open_owner_delay too long " cop=$D1 vp=$D2 }, \
	53 { "  open_owner_delay interrupted " cop=$D1 vp=$D2 }, \
	54 { "  open_owner_delay exit " cop=$D1 vp=$D2 sleep=$D3 }, \
	60 { "get_lock_owner enter " rp=$D1 pid=$D2 }, \
	61 { "  get_lock_owner pid found " rp=$D1 pid=$D2 CLP=$D3 }, \
	62 { "  get_lock_owner active found " rp=$D1 pid=$D2 clp=$D3 }, \
	63 { "  get_lock_owner inactive found " rp=$D1 pid=$D2 clp=$D3 }, \
	64 { " get_lock_owner allocated " rp=$D1 pid=$D2 clp=$D3 }, \
	65 { "update_lock_owner " clp=$D1 }, \
	66 { "lock_owner_delay enter " clp=$D1 }, \
	67 { "  lock_owner_delay exit " clp=$D1 error=$D2 }, \
	70 { "get_io_stateid no state " rp=$D1 }, \
	71 { "get_io_stateid delegation sid " rp=$D1 }, \
	72 { "get_io_stateid lock sid " rp=$D1 }, \
	73 { "get_io_stateid open sid " rp=$D1 }, \
	80 { "state_call_server enter " fsidp=$D1 which=$D2 }, \
	81 { "  state_call_server no handle " fsidp=$D1 which=$D2 }, \
	82 { "  state_call_server exit " fsidp=$D1 which=$D2 rpcerr=$D3 }, \
	90 { "get_new_client_owner exit " fsidp=$D1 cop=$D2 }, \
	100 { "open_no_create enter " vp=$D1 dvp=$D2 fsidp=$D3 call_type=$D4 }, \
	101 { "  open_no_create enter " vp=$D1 access=$D2 deny=$D3 flags=$D4 r_flags=$D5 }, \
	102 { "  open_no_create call done " vp=$D1 error=$D1 }, \
	103 { "  open_no_create add deleg " vp=$D1 type=$D2 }, \
	104 { "  open_no_create exit " vp=$D1 error=$D2 r_flags=$D3 }, \
	110 { "open_create enter " dvp=$D1 fsidp=$D2 flags=$D3 access=$D4 }, \
	111 { "  open_create call done " dvp=$D1 error=$D2 rp=$D3 }, \
	112 { "  open_create add deleg " dvp=$D1 rp=$D2 type=$D3 }, \
	113 { "  open_create exit " dvp=$D1 rp=$D2 error=$D3 r_flags=$D4 }, \
	120 { "open_close enter " vp=$D1 r_flags=$D2 }, \
	121 { "  open_close call done " vp=$D1 error=$D2 }, \
	122 { "  open_close exit " vp=$D1 error=$D2 r_flags=$D3 }, \
	123 { "  open_close no server open " vp=$D1 }, \
	130 { "open_downgrade enter " vp=$D1 access=$D2 deny=$D3 r_flags=$D4 }, \
	131 { "  open_downgrade call done " vp=$D2 error=$D3 }, \
	132 { "  open_downgrade exit " vp=$D1 error=$D2 r_flags=$D3 }, \
	140 { "confirm_open enter " rp=$D1 cop=$D2 }, \
	141 { "  confirm_open call done " rp=$D1 error=$D2 }, \
	142 { "  confirm_open exit " rp=$D1 error=$D2 }, \
	150 { "open_reply enter " dvp=$D1 vp=$D2 epcerr=$D3 call_type=$D4 }, \
	151 { "  open_reply bump seqid " cop=$D1 next_seqid=$D2 }, \
	152 { "  open_reply non-state error " dvp=$D1 vp=$D2 error=$D3 }, \
	153 { "  open_reply state error " dvp=$D1 vp=$D2 error=$D3 }, \
	154 { "  open_reply open race " dvp=$D1 vp=$D2 }, \
	155 { "  open_reply no create fh " dvp=$D1 vp=$D2 }, \
	156 { "  open_reply no create attr " dvp=$D1 vp=$D2 }, \
	157 { "  open_reply no create rnode " dvp=$D1 vp=$D2 error=$D3 }, \
	158 { "  open_reply exit " dvp=$D1 vp=$D2 error=$D3 }, \
	160 { "set_create_attrs exit " status=$D1 }, \
	170 { "create_race enter " vp=$D1 }, \
	171 { "  create_race needed confirm " vp=$D1 }, \
	172 { "  create_race call done " vp=$D1 rpcerr=$D2 }, \
	173 { "  create_race exit " vp=$D1 }, \
	180 { "open_race enter " rp=$D1 }, \
	181 { "  open_race needed confirm " rp=$D1 }, \
	182 { "  open_race exit " rp=$D1 }, \
	183 { "  open_race bg old_" rp=$D1 }, \
	184 { "  open_race bg not regular old_" rp=$D1 }, \
	185 { "  open_race bg no open owner old_" rp=$D1 }, \
	186 { "  open_race bg no work needed old_" rp=$D1 }, \
	187 { "  open_race bg exit old_" rp=$D1 }, \
	188 { "close_ord enter old_" rp=$D1 }, \
	189 { "  close_ord exit old_" rp=$D1 }, \
	200 { "lock_lock enter " rp=$D1 pid=$D2 start=$D3 length=$D4 }, \
	201 { "  lock_lock enter " rp=$D1 type=$D2 reclaim=$D3 }, \
	202 { "  lock_lock call done " rp=$D1 rpcerr=$D2 error=$D3 }, \
	203 { "  lock_lock dead or bad locks " rp=$D1 }, \
	204 { "  lock_lock exit " rp=$D1 error=$D2 r_flags=$D3 }, \
	210 { "lock_unlock enter " rp=$D1 pid=$D2 start=$D3 length=$D4 }, \
	211 { "  lock_unlock call done " rp=$D1 rpcerr=$D2 error=$D3 }, \
	212 { "  lock_unlock exit " rp=$D1 error=$D2 r_flags=$D3 }, \
	213 { "  lock_unlock dead or bad locks " rp=$D1 r_flags=$D2 }, \
	220 { "lock_test enter " vp=$D1 pid=$D2 type=$D3 }, \
	221 { "  lock_test call done " vp=$D1 rpcerr=$D3 }, \
	222 { "  lock_test exit " vp=$D1 }, \
	230 { "release_lock_owner " rp=$D1 id=$D2 }, \
	300 { "add_delegation enter " rp=$D1 type=$D2 r_flags=$D3 create=$D4 }, \
	301 { "  add_delegation was recalled " rp=$D1 }, \
	302 { "  add_delegation nocreate exit " rp=$D1 r_flags=$D2 }, \
	303 { "  add_delegation create exit " rp=$D1 r_flags=$D2 }, \
	310 { "remove_delegation enter " rp=$D1 r_flags=$D2 }, \
	320 { "  remove_delegation no delegation " rp=$D1 r_flags=$D2 }, \
	321 { "  remove_delegation exit " rp=$D1 r_flags=$D2 }, \
	330 { "  return_delegation enter " rp=$D1 r_flags=$D2 }, \
	331 { "  return_delegation sync " rp=$D1 }, \
	332 { "  return_delegation in progress " rp=$D1 r_flags=$D2 }, \
	333 { "  return_delegation calling open " rp=$D1 access=$D2 deny=$D3 }, \
	334 { "  return_delegation call done " rp=$D1 rpcerr=$D2 status=$D3 }, \
	335 { "  return_delegation exit " rp=$D1 r_flags=$D2 }, \
	340 { "return_delegations_vfs enter " vfsp=$D1 }, \
	341 { "  return_delegations_vfs interrupted " vfsp=$D1 }, \
	342 { "  return_delegations_vfs return failed " vfsp=$D1 }, \
	343 { "  return_delegations_vfs exit " vfsp=$D1 }, \
	350 { "return_stale_delegations enter " srvp=$D1 }, \
	351 { "  return_state_delegations exit " srvp=$D1 }, \
	360 { "return_delegation_fh_sid enter " fsidp=$D1 }, \
	370 { "  return_delegation_on_close returning due to resources " rp=$D1 }, \
	380 { "return_delegation_admin enter " path=$D1 }, \
	381 { "  return_delegation_admin exit " error=$D1 }, \
	400 { "reclaim_fsid enter " fsidp=$D1 }, \
	401 { "  reclaim_fsid skipping file " fsidp=$D1 rp=$D2 }, \
	402 { "  reclaim_fsid adding file " fsidp=$D1 rp=$D2 }, \
	403 { "  reclaim_fsid scan complete " fsidp=$D1 count=$D2 }, \
	404 { "  reclaim_fsid ntm_start " fsidp=$D1 }, \
	405 { "  reclaim_fsid waiting " fsidp=$D1 reclaim_count=$D2 }, \
	406 { "  reclaim_fsid exit " fsidp=$D1 }, \
	407 { "  reclaim_fsid no files found " fsidp=$D1 }, \
	410 { "  recover_fsid_files enter " fsidp=$D1 }, \
	411 { "  recover_fsid_files file done " fsidp=$D1 rp=$D2 }, \
	412 { "  recover_fsid_files exit " fsidp=$D1 }, \
	420 { "recover_open_state enter " rp=$D1 r_flags=$D2 }, \
	421 { "  recover_open_state removing delegation " rp=$D1 }, \
	422 { "  recover_open_state calling open previous " rp=$D1 access=$D2 deny=$D3 }, \
	423 { "  recover_open_state open previous call done " rp=$D1 error=$D2 }, \
	424 { "  recover_open_state calling open null " rp=$D1 access=$D2 deny=$D3 }, \
	425 { "  recover_open_state open null call done " rp=$D1 error=$D2 }, \
	426 { "  recover_open_state no grace marking as bad " rp=$D1 }, \
	427 { "  recover_open_state exit " rp=$D1 r_flags=$D2 }, \
	428 { "  recover_open_state not opened " rp=$D1 }, \
	430 { "recover_lock_state enter " rp=$D1 grace=$D2 }, \
	431 { "  recover_lock_state calling lock " rp=$D1 }, \
	432 { "  recover_lock_state lock failed " rp=$D1 error=$D2 }, \
	433 { "  recover_lock_state start scan " rp=$D1 filocks=$D2 }, \
	434 { "  recover_lock_state local locking " rp=$D1 }, \
	435 { "  recover_lock_state exit " rp=$D1 r_flags=$D2 }, \
	440 { "recover_revoked_state enter " rp=$D1 r_flags=$D2 }, \
	441 { "  recover_revoked_state already done " rp=$D1 }, \
	442 { "  recover_revoked_state no state " rp=$D1 }, \
	443 { "  recover_revoked_state file changed marking bad " rp=$D1 }, \
	444 { "  recover_revoked_state open failed making bad " rp=$D1 }, \
	445 { "  recover_revoked_state exit " rp=$D1 r_flags=$D2 }, \
	800 { "nfs4_get_clientid_otw enter " fsid=$D1 }, \
	801 { "  nfs4_get_clientid_otw exit " fsid=$D2 error=$D3 place=$D1 }, \
	802 { "  nfs4_get_clientid_otw_error " fsid=$D2 error=$D3 place=$D1 }, \
	803 { "  nfs4_get_clientid_otw_auth_error " fsid=$D2 sec=$D3 place=$D1 }, \
	804 { "nfs4_renew enter " serv=$D1 }, \
	805 { "  nfs4_renew exit " serv=$D1 place=$D1 }, \
	806 { "  nfs4_renew error " error=$D1 place=$D2 }, \
	807 { "nfs4_get_clientid_data enter " addr=$D1 }, \
	808 { "  nfs4_get_clientid_data exit " addr=$D1 }, \
	809 { "nfs4_start_server_recovery enter " serv=$D1 }, \
	810 { "  nfs4_start_server_recovery in progress " serv=$D1 }, \
	811 { "  nfs4_start_server_recovery mark fsid " serv=$D1 fsid=$D2 }, \
	812 { "  nfs4_start_server_recovery exit " serv=$D2 place=$D1 }, \
	813 { "nfs4updateid enter " serv=$D1 }, \
	814 { "  nfs4updateid exit " serv=$D1 }, \
	815 { "nfs4_trash_id enter " addr=$D1 }, \
	816 { "  nfs4_trash_id error " addr=$D2 error=$D3 place=$D1 }, \
	817 { "  nfs4_trash_id bad rpc " addr=$D2 rpcerr=$D3 len=$D4 status=$D5 place=$D1 }, \
	818 { "  nfs4_trash_id exit " addr=$D2 place=$D1 }, \
	900 { "nfs4_callback enter " xprt=$D1 }, \
	901 { "  nfs4_callback null prog " xprt=$D1 }, \
	902 { "  nfs4_callback no proc " xprt=$D1 }, \
	903 { "  nfs4_callback minor version mismatch " xprt=$D1 }, \
	904 { "  nfs4_callback new op " cprt=$D1 op=$D2 }, \
	905 { "  nfs4_callback getattr " xprt=$D1 rp=$D2 }, \
	906 { "  nfs4_callback recall " xprt=$D1 rp=$D2 }, \
	907 { "  nfs4_callback reply sent " xprt=$D1 }, \
	908 { "  nfs4_callback exit " xprt=$D1 }, \
	910 { "callback_getattr enter " rp=$D1 }, \
	\*  { "unknown subhook " id=$HD%UW }
411 1.0 "@NFSv4 Client Data Management" \
	$HOOKENV, \
	32 { \
		HT & 0x7, \
		0 {  \
			$D1%D1, \
			1  { "target fsid : " G8 $HL%S1 }, \
			2  { "target vp : " G8 $HL%S1 }, \
			3  { "target name : " G8 $HL%S1 }, \
			4  { "target pathname : " G8 $HL%S1 }, \
			5  { "current server name : " G8 $HL%S1 }, \
			6  { "favored server name : " G8 $HL%S1 } \
			$BREAK \
		} }, \
	64 { \
		HT & 0x4000, \
		0x4000 {  \
			$D1%D1, \
			1  { "target fsid : " G16 $HL%S1 }, \
			2  { "target vp : " G16 $HL%S1 }, \
			3  { "target name : " G16 $HL%S1 }, \
			4  { "target pathname : " G16 $HL%S1 }, \
			5  { "current server name : " G16 $HL%S1 }, \
			6  { "favored server name : " G16 $HL%S1 } \
			$BREAK \
		} } \
	$HD%D1, \
	1 { "dm_moved_detected	" We got MOVED }, \
        2 { "dm_replication	" It is a REPLICATION fsid=$D1 }, \
	3 { "dm_waiting	" MOVING is in progress \
		$D1, \
		0  { We are in stateless call wait }, \
		1  { We are in state call no wait } }, \
	4 { "dm_interrupted 	" We got INTERRUPTED }, \
	5 { "dm_processing 	" Thats handle the MOVED error }, \
	6 { "dm_put_request 	" Put in MOVE request fsid=$D1 }, \
	7 { "dm_get_fs_loc 	" Getting the FS_LOCATIONS4 vp=$D1 nm=$D2 \
		$D3, \
		0  { We are not in the middle of MOVE }, \
		1  { We are in the middle of MOVE } }, \
	8 { "dm_got_fs_loc	" Got the FS_LOCATIONS4 error=$D1 fslp=$D2 }, \
	9 { "dm_pro_fs_loc	" Processing FS_LOCATIONS4 fslp=$D1 serv=$D2 prefer=$D3 flag=$D4 }, \
	10 { "dm_no_fs_loc	" There is no FS_LOCATIONS4 }, \
	11 { "dm_no_cur	" There is no current server }, \
	12 { "dm_d_p_fs_loc	" Done processing FS_LOCATIONS4 }, \
	13 { "dm_move_done	" \
		$D2, \
		0  { MOVE triggerred error=$D1 }, \
		1  { MOVE done error=$D1 } }, \
	14 { "dm_referral	" It is a REFERRAL fsid=$D1 rootvp=$D2 }, \
	15 { "dm_migration	" It is a MIGRATION fsid=$D1 f_locp=$D2 }, \
	16 { "dm_renew_fs_loc	" Renewing FS_LOCATIONS fsidp=$D1 }, \
	17 { "dm_renew_not_yet	" Not Yet fsid renew time=$D1 time=$D2 }, \
	18 { "dm_same	" They are the same }, \
	19 { "dm_new_time	" New time time=$D1 }, \
	20 { "dm_n4bg_move	" N4BG handling MOVE fsid=$D1 }, \
	21 { "dm_waiting_state	" N4BG waiting for state }, \
	22 { "dm_move_type	" MOVE type is \
		$D1, \
		0  { REPLICATION }, \
		1  { REFERRAL }, \
		2  { Automatic Failover On First Contact}, \
		3  { MIGRATION } }, \
	23 { "dm_waiting_state	" N4BG MOVE done error=$D1 }, \
	24 { "dm_auto_move	" Automatic Failover On First Contact fsid=$D1 }, \
	25 { "dm_autodone	" Automatic Failover On First Contact done }, \
	26 { "dm_pick_server	" Picking Server fsid=$D1 favored=$D2 flag=$D3 }, \
	27 { "dm_trying_server	" Trying Server f_loc=$D1 }, \
	28 { "dm_lookup_path	" Looking up Path flags=$D1 }, \
	29 { "dm_no_good	" It is not compatible f_loc=$D1 }, \
	30 { "dm_got_one	" We found one f_loc=$D1 }, \
	31 { "dm_n4bg_ref	" We got the new rnode for referral vp=$D1 }, \
	32 { "dm_compare	" The new f_loc=$D1 is \
		$D3, \
		0  { not the same as the old f_loc=$D2 }, \
		1  { the same as the old f_loc=$D2 } }, \
	33 { "dm_move_old	" the current (old) f_loc=$D1 }, \
	34 { "dm_got_sid	" Got the server client id }, \
	35 { "dm_moved	" MOVE done last_move_seq=$D1 }, \
	36 { "dm_not_ready	" this f_loc=$D1 is on prohibation f_eligible=$D2 curtime=$D3 }, \
	37 { "dm_all_failed	" Tried all server and alll failed }, \
	38 { "dm_p_s_done	" Pick server done error=$D1 }, \
	39 { "dm_populate	" Populating the fsid=$D1 with new FS_LOCATIONS4 }, \
	40 { "dm_populate_2nd	" Automatic Fail over }, \
	41 { "dm_loop	" alread perform automatic fail over return ELOOP}, \
	42 { "dm_p_done	" Populating done error=$D1 }, \
	43 { "dm_h_p_move	" \
		$D1, \
		0  { Server response in time no REPLICATION }, \
		b  { Server did not response in time REPLICATION kicked in } \
			f_start=$D2 start=$D3 end=$D4 }, \
	44 { "dm_enfs_moved	" REPLICATION needs to start return NFS4ERR_MOVED }, \
	45 { "dm_enfs_delay	" REPLICATION just finished need to retry }
482 1.0 "@RPCSEC client" \
	$HD%D1,	\
	1  { "out of memory " },  \
	2  { "auth structure not in building list " }, \
	3  { "already building auth structure " }, \
	4  { "auth structure already in cache " }, \
	5  { "must restart build " }, \
	6  { "must wait for existing structure " }, \
	7  { "rpc call returned " stat=$D1 }, \
	8  { "got null handle " }, \
	9  { "refreshing " }, \
	10 { "xdr failed " }, \
	11 { "bad sequence number " }, \
	12 { "getmic result " maj=$D1 min=$D2 }, \
	13 { "verifymic result " maj=$D1 min=$D2 }, \
	14 { "wrap result " maj=$D1 min=$D2 }, \
	15 { "unwrap result " maj=$D1 min=$D2 }, \
	16 { "init result " maj=$D1 min=$D2 }, \
	17 { "server failure " maj=$D1 min=$D2 }
483 1.0 "@RPCSEC server" \
	$HD%D1,	\
	1  { "getting free entry" },  \
	2  { "got entry from list "  handle=$D1 }, \
	3  { "got entry from idle "  handle=$D1 }, \
	4  { "got entry from alloc "  handle=$D1 }, \
	5  { "got entry from purge "  handle=$D1 }, \
	6  { "no free entries to get " }, \
	7  { "unable to fill credential " }, \
	8  { "building verifier " }, \
	9  { "reply was too long " rlen=$D1 }, \
	10 { "verifying headers " }, \
	11 { "credential too short " clen=$D1 }, \
	12 { "bad handle " }, \
	13 { "credential too long " }, \
	14 { "bad sequence number " seqnum=$D1 }, \
	15 { "out of memory " }, \
	16 { "xdr function failed " }, \
	17 { "packet dropped by sequence number algorithm " }, \
	18 { "sending reply with integrity " }, \
	19 { "sending reply with privacy " }, \
	20 { "got a data request " service=$D1 }, \
	21 { "request was malformed " }, \
	22 { "sequence number already seen " }, \
	23 { "unable to set decoded arguments " }, \
	24 { "got a context creation request " proc=$D1 service=$D2 }, \
	25 { "context not found " }, \
	26 { "context already completed " }, \
	27 { "got destroy request " }, \
	28 { "got RPCSEC_GSS request " vers=$D1 proc=$D2 }, \
	29 { "getmic failed " maj=$D1 min=$D2 }, \
	30 { "verifymic failed " maj=$D1 min=$D2 }, \
	31 { "wrap failed " maj=$D1 min=$D2 }, \
	32 { "unwrap failed " maj=$D1 min=$D2 }, \
	33 { "accept failed " maj=$D1 min=$D2 }, \
	34 { "bad verf " flavor=$D1 }
484 1.0 "@NFS GSS Daemon" \
	$HD%D1, \
	1  { "Acquire credential enter "  uid=$D1 euid=$D2 pag=$D3 }, \
	2  { "Acquire credential exit "  exit=$D1 }, \
	3  { "Add credential enter "  uid=$D1 euid=$D2 pag=$D3 }, \
	4  { "Add credential exit "  exit=$D1 }, \
	5  { "Release credential enter "  uid=$D1 euid=$D2 pag=$D3 }, \
	6  { "Release credential exit "  exit=$D1 }, \
	7  { "Init security context enter "  uid=$D1 euid=$D2 pag=$D3 }, \
	8  { "Init security context exit "  exit=$D1 }, \
	9  { "Accept security context enter "  }, \
	10  { "Accept security context exit "  exit=$D1 }, \
	11  { "Delete security context enter "  }, \
	12  { "Delete security context exit "  exit=$D1 }, \
	13  { "Export security context enter "  }, \
	14  { "Export security context exit "  exit=$D1 }, \
	15  { "Get MIC enter "  }, \
	16  { "Get MIC exit "  exit=$D1 }, \
	17  { "Verify MIC enter "  }, \
	18  { "Verify MIC exit "  exit=$D1 }, \
	19  { "Wrap enter "  }, \
	20  { "Wrap exit "  exit=$D1 }, \
	21  { "Unwrap enter "  }, \
	22  { "Unwrap exit "  exit=$D1 }, \
	23  { "Inquire credential enter "  uid=$D1 }, \
	24  { "Inquire credential exit "  exit=$D1 }, \
	25  { "Credential handle "  handle=$D1 }, \
	26  { "Context handle "  handle=$D1 }
485 1.0 "@NFS KGSS" \
	$HD%D1, \
	1  { "Acquire credential enter "  uid=$D1 euid=$D2 pag=$D3%D8 }, \
	2  { "Acquire credential exit "  uid=$D1 euid=$D2 exit=$D3 }, \
	3  { "Add credential enter "  uid=$D1 euid=$D2 pag=$D3%D8 }, \
	4  { "Add credential exit "  uid=$D1 euid=$D2 exit=$D3 }, \
	5  { "Release credential enter "  uid=$D1 euid=$D2 pag=$D3%D8 }, \
	6  { "Release credential exit "  uid=$D1 euid=$D2 pag=$D3%D8 exit=$D4 }, \
	7  { "Init security context enter "  uid=$D1 euid=$D2 pag=$D3%D8 }, \
	8  { "Init security context exit "  uid=$D1 euid=$D2 pag=$D3%D8 exit=$D4 }, \
	9  { "Accept security context enter "  }, \
	10  { "Accept security context exit "  exit=$D1 }, \
	11  { "Delete security context enter "  }, \
	12  { "Delete security context exit "  exit=$D1 }, \
	13  { "Export security context enter "  }, \
	14  { "Export security context exit "  context=$D1 exit=$D2 }, \
	15  { "Get MIC enter "  }, \
	16  { "Get MIC exit "  context=$D1 exit=$D2 }, \
	17  { "Verify MIC enter "  }, \
	18  { "Verify MIC exit "  context=$D1 exit=$D2 }, \
	19  { "Wrap enter "  }, \
	20  { "Wrap exit "  context=$D1 exit=$D2 }, \
	21  { "Unwrap enter "  }, \
	22  { "Unwrap exit "  context=$D1 exit=$D2 }, \
	23  { "Inquire credential enter "  uid=$D1 }, \
	24  { "Inquire credential exit "  exit=$D1 }, \
	25  { "Credential handle "  handle=$D1 }, \
	26  { "Context handle "  handle=$D1 }, \
	27  { "Import security context enter "  }, \
	28  { "Import security context exit "  context=$D1 exit=$D2 }
488 1.0 "@NFSv4 Client VOPS" \
	$HOOKENV, \
	32 { \
		HT & 0x7, \
		0 {  \
			$D1%D1, \
			1  { "NFS4_LINK, link target " G8 $HL%S1 }, \
			2  { "NFS4_MKDIR, making " G8 $HL%S1 }, \
			3  { "NFS4_MKNOD, making " G8 $HL%S1 }, \
			4  { "NFS4_REMOVE, removing " G8 $HL%S1 }, \
			5  { "NFS4_RENAME, rename from " G8 $HL%S1 }, \
			6  { "NFS4_RMDIR, removing " G8 $HL%S1 }, \
			7  { "NFS4_LOOKUP, looking up " G8 $HL%S1 }, \
			10 { "NFS4_CREATE, creating " G8 $HL%S1 }, \
			39 { "NFS4_CREATE_ATTR, creating with attr " G8 $HL%S1 }, \
			48 { "NFS4_ACCESS_MISS, no access looking up " G8 $HL%S1 }, \
			49 { "NFS4_ACCESS_EXPIRED, access expired looking up " G8 $HL%S1 }, \
			50 { "NFS4_DNLC_MISS, dnlc miss looking up " G8 $HL%S1 }, \
			51 { "NFS4_LOOKUP1, looking up " G8 $HL%S1 }, \
			63 { "NFS4_NFS4CREATE, internal create " G8 $HL%S1 }, \
			67 { "NFS4_NFS4RENAME, internal rename from " G8 $HL%S1 }, \
			4101  { "NFS4_RENAME, rename to " G8 $HL%S1 }, \
			4163 { "NFS4_NFS4RENAME, internal rename to " G8 $HL%S1 } \
			$BREAK \
		} }, \
	64 { \
		HT & 0x4000, \
		0x4000 {  \
			$D1%D1, \
			1  { "NFS4_LINK, link target " G16 $HL%S1 }, \
			2  { "NFS4_MKDIR, making " G16 $HL%S1 }, \
			3  { "NFS4_MKNOD, making " G16 $HL%S1 }, \
			4  { "NFS4_REMOVE, removing " G16 $HL%S1 }, \
			5  { "NFS4_RENAME, rename from " G16 $HL%S1 }, \
			6  { "NFS4_RMDIR, removing " G16 $HL%S1 }, \
			7  { "NFS4_LOOKUP, looking up " G16 $HL%S1 }, \
			10 { "NFS4_CREATE, creating " G16 $HL%S1 }, \
			39 { "NFS4_CREATE_ATTR, creating with attr " G16 $HL%S1 }, \
			48 { "NFS4_ACCESS_MISS, no access looking up " G16 $HL%S1 }, \
			49 { "NFS4_ACCESS_EXPIRED, access expired looking up " G16 $HL%S1 }, \
			50 { "NFS4_DNLC_MISS, dnlc miss looking up " G16 $HL%S1 }, \
			51 { "NFS4_LOOKUP1, looking up " G16 $HL%S1 }, \
			63 { "NFS4_NFS4CREATE, internal create " G16 $HL%S1 }, \
			67 { "NFS4_NFS4RENAME, internal rename from " G16 $HL%S1 }, \
			4101  { "NFS4_RENAME, rename to " G16 $HL%S1 }, \
			4163 { "NFS4_NFS4RENAME, internal rename to " G16 $HL%S1 } \
			$BREAK \
		} } \
	$HD%D1, \
	1 { "NFS4_LINK	" \
		$D1, \
		0  { trcpt $D1%D1 start target vp=$D2 parent=$D3 name=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 name is not utf8 EINVAL dp=$D2 vp=$D3 name=$D4 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 fsid is read only EROFS }, \
		3  { trcpt $D1%D1 fsid does not support link EOPNOTSUPP vp=$D2 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 fs of parent is "!=" target EOPNOTSUPP dp=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 done new vp=$D2 name=$D3 error=$D4 dp=$D5 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 done new vp=$D2 v_count=$D3 error=$D4 dp=$D5 endtimer($TID,$HD%D1) } }, \
	2 { "NFS4_MKDIR	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 name=$D3 mode=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 name is not utf8 EINVAL name=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 fsid is read only EROFS endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 done error=$D2 } dvp=$D3 name=$D4 endtimer($TID,$HD%D1) }, \
	3 { "NFS4_MKNOD	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 name=$D3 mode=$D4 dev=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 name is not utf8 EINVAL name=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 fsid is read only EROFS endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 mknod on VDIR or VNON error=$D2 mode=$D3 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) } }, \
	4 { "NFS4_REMOVE	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D3 target vp=$D2 name=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fsid is read only EROFS endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 lookup failed error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 target is a VDIR EPERM dvp=$D2 name=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 remove interrupted dvp=$D2 name=$D3 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) } }, \
	5 { "NFS4_RENAME	" \
		$D1, \
		0  { trcpt $D1%D1 start source=$D2 name=$D3 target=$D4 tname=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 name is not utf8 EINVAL tname=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 source fsid is read only EROFS endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 target fsid is read only EROFS endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	6 { "NFS4_RMDIR	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D3 target vp=$D2 name=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 name is not utf8 EINVAL }, \
		2  { trcpt $D1%D1 fsid is read only EROFS endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 lookup failed error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 target is current directory EINVAL dvp=$D2 name=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 it is not a VDIR ENOTDIR dvp=$D2 name=$D3 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 done error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) } }, \
	7 { "NFS4_LOOKUP	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 name=$D3 flags=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 name is not utf8 EINVAL }, \
		2  { trcpt $D1%D1 lookup failed error=$D2 dvp=$D3 name=$D4 }, \
		3  { trcpt $D1%D1 done error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) } }, \
	8 { "NFS4_FID	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 filehandle too long fidlen=$D2 fhlen=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done fh=$D2 fid=$D3 endtimer($TID,$HD%D1) } }, \
	9 { "NFS4_OPEN	" \
		$D1, \
		0  { trcpt $D1%D1 open start vp=$D2 flags=$D3 ext=$D4 vinfop=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 open failed nolargefiles EOVERFLOW r_size=$D2 flags=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 open fialed fsid is read only EROFS vp=$D2 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 open failed vp is VDIR EISDIR vp=$D2 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 open failed access failed vp=$D2 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 open failed setattr failed error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 open done error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 open failed check_dio_cio failed error=$D2 rp=$D3 endtimer($TID,$HD%D1) }, \
		8  { trcpt $D1%D1 open failed start_state_change failed error=$D2 rp=$D3 endtimer($TID,$HD%D1) }, \
		9  { trcpt $D1%D1 open failed error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		a  { trcpt $D1%D1 open succeed error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		b  { trcpt $D1%D1 open cid=$D2 rs_rdcnt=$D3 rs_wrcnt=$D4 rs_excnt=$D5 }, \
		c  { trcpt $D1%D1 open call_server=$D2 gn_rdcnt=$D3 gn_wrcnt=$D4 gn_excnt=$D5 }, \
		d  { trcpt $D1%D1 open rdcnt diff=$D2 wrcnt diff=$D3 excnt diff=$D4 } }, \
	10 { "NFS4_CREATE	" \
		$D1, \
		0  { trcpt $D1%D1 start NOT SUPPORTED ENOSYS } }, \
	11 { "NFS4_HOLD	" \
		$D1, \
		0  { trcpt $D1%D1 vp=$D2 v_count=$D3%D1 caller=vnop_hold caller2=$D4 caller3=$D5 }, \
		1  { trcpt $D1%D1 vp=$D2 v_count=$D3%D1 caller=makenfs4node caller2=$D4 caller3=$D5 } }, \
	12 { "NFS4_RELE	" \
		$D1, \
		0  { trcpt $D1%D1 vp=$D2 v_count=$D3%D1 caller=vnop_rele caller2=$D4 caller3=$D5 }, \
		1  { trcpt $D1%D1 vp=$D2 v_count=$D3%D1 caller=nfs4_rele caller2=$D4 caller3=$D5 }, \
		2  { trcpt $D1%D1 vp=$D2 v_count=0 caller=$D3 caller2=$D4 caller3=$D5 }, \
		3  { trcpt $D1%D1 vp=$D2 v_count=$D3%D1 caller=makenfs4node caller2=$D4 caller3=$D5 } }, \
	13 { "NFS4_CLOSE	" \
		$D1, \
		0  { trcpt $D1%D1 close start vp=$D2 flags=$D3 vinfo=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 close no NAMED_OPEN_MAGIC do not need close vinfo=$D2 }, \
		2  { trcpt $D1%D1 close done error=$D2 vp=$D3 endtimer($TID,$HD%D1) },  \
		3  { trcpt $D1%D1 close cid=$D2 rs_rdcnt=$D3 rs_wrcnt=$D4 rs_excnt=$D5 },  \
		4  { trcpt $D1%D1 close rsp=$D2 gn_rdcnt=$D3 gn_wrcnt=$D4 gn_excnt=$D5 },  \
		5  { trcpt $D1%D1 close rdcnt diff=$D2 wrcnt diff=$D3 excnt diff=$D4 } },  \
	14 { "NFS4_MAP	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 len=$D3 off=$D4 flag=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 off+len invalid ENXIO off=$D2 len=$D3 maxfsize=$D4 vp=$D5 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 off+len too big EFBIG off=$D2 len=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 off or off+len is invalid ENXIO off=$D2 len=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 vp is not VREG ENODEV v_type=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 NOAC is on EAGAIN r_flags=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 dio/cio check failure error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 getting seg vp=$D2 }, \
		8  { trcpt $D1%D1 seg=$D3 error=$D2 }, \
		9  { trcpt $D1%D1 gn_mwrcnt=$D2 v_count=$D3 }, \
		a  { trcpt $D1%D1 done vp=$D2 error=$D3 seg=$D4 gn_mwrcnt=$D5 }, \
		b  { trcpt $D1%D1 done1 v_count=$D2 endtimer($TID,$HD%D1) } }, \
	15 { "NFS4_UNMAP	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 flag=$D3 gn_mwrcnt=$D4 r_vh=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 v_count=$D2 }, \
		2  { trcpt $D1%D1 done vp=$D2 gn_mwrcnt=$D3 r_vh=$D4 v_count=$D5 endtimer($TID,$HD%D1) } }, \
	16 { "NFS4_ACCESS	" \
		$D1, \
		0  { trcpt $D1%D1 start v$D2 mode=$D3 who=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 nfs4_validate_caches failed error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 \
			$D2%D1, \
				0  { from access cache passed }, \
				13 { from access cache deny } \
		     nfs4_check_access returns error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 from server done error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 who is not self vp=$D2 who=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 EROFS vp=$D2 endtimer($TID,$HD%D1) } }, \
	17 { "NFS4_GETATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 vap=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	18 { "NFS4_SETATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 op=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 arg1=$D2 arg2=$D3 arg3=$D4 }, \
		2  { trcpt $D1%D1 bad op op=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 vp=$D2 mask=$D3 &va=$D4 mask=$D5 }, \
		4  { trcpt $D1%D1 mask "==" AT_NOSET EINVAL mask=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 not the owner EPERM vp=$D2 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 cr_uid=$D2 r_attr.va_uid=$D3 }, \
		7  { trcpt $D1%D1 EPERM flags=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		8  { trcpt $D1%D1 nfs4_access failed vp=$D2 &va=$D3 error=$D4 endtimer($TID,$HD%D1) }, \
		9  { trcpt $D1%D1 done vp=$D2 &va=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	19 { "NFS4_FCLEAR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 flags=$D3 off=$D4 len=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 off+len < 0 EINVAL off=$D2 len=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 len is too big EFBIG }, \
		3  { trcpt $D1%D1 len is too big EFBIG len=$D2 max=$D3 }, \
		4  { trcpt $D1%D1 &ui=$D2 }, \
		5  { trcpt $D1%D1 &ui=$D2 error=$D3 vp=$D4 }, \
		6  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	20 { "NFS4_FSYNC	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 flags=$D3 vinfo=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 swapvp vp=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 after sync error=$D2 }, \
		3  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	21 { "NFS4_FTRUNC	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 flags=$D3 len=$D4 vinfo=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 XPG failed EFBIG len=$D2 ulimit=$D3 }, \
		2  { trcpt $D1%D1 EFBIG len=$D2 f_maxfsize=$D3 flags=$D4 }, \
		3  { trcpt $D1%D1 fsid is read only EROFS f_flag=$D2 }, \
		4  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	22 { "NFS4_RDWR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 op=$D3 flags=$D4 uiop=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fsid is read only EROFS f_flag=$D2 }, \
		2  { trcpt $D1%D1 error=$D2 vattrp=$D3 }, \
		3  { trcpt $D1%D1 done error=$D3 endtimer($TID,$HD%D1) } }, \
	23 { "NFS4_READ	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 off=$D3 resid=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 vp is not VREG v_type=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 resid is 0 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 off EFBIG ioflags=$D2 off=$D3 f_maxfsize=$D4 vp=$D5 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 off+resid is invalid resid=$D2 off=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 done resid=$D2 off=$D3 error=$D4 vp=$D5 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1    r_flags=$D3 vci_flags=$D4 } }, \
	24 { "NFS4_WRITE	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 resid=$D3 off=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 vp is not VREG v_type=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 resid "==" 0 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 fsid is read only EROFS f_flag=$D2 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 write error error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 nfs4getattr failed error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 off EFBIG ioflags=$D2 off=$D3 f_maxfsize=$D4 vp=$D5 endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 off+resid is EINVAL off=$D2 len+resid=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		8  { trcpt $D1%D1 EFBIG vp=$D2 endtimer($TID,$HD%D1) }, \
		9  { trcpt $D1%D1 EFBIG off+resid=$D2 f_maxfsize=$D3 ioflags=$D4 vp=$D5 endtimer($TID,$HD%D1) }, \
		a  { trcpt $D1%D1 vp=$D2 off=$D3 resid=$D4 ioflags=$D5 }, \
		b  { trcpt $D1%D1 create seg error=$D2 r_sid=$D3 rp=$D4 }, \
		c  { trcpt $D1%D1 nocache }, \
		d  { trcpt $D1%D1 vp=$D2 off=$D3 len=$D4 }, \
		e  { trcpt $D1%D1 done vp=$D2 resid=$D3 error=$D4 off=$D5 endtimer($TID,$HD%D1) }, \
		f  { trcpt $D1%D1    r_flags=$D3 vci_minpout=$D4 vci_maxpout=$D5} }, \
	25 { "NFS4_LOCKCTL	" }, \
	26 { "NFS4_IOCTL	" vp=$D1 cmd=$D2 arg=$D3 flags=$D4 ext=$D5 }, \
	27 { "NFS4_READLINK	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 uiop=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fsid does EOPNOTSUPP symlink f_flags=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 vp is not VLNK EINVAL v_type=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 uiomove vp=$D2 error=$D3 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1  done vp=$D2 error=$D3 endtimer($TID,$HD%D1) } }, \
	28 { "NFS4_SELECT	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 which=$D3 req=$D4 rt=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 ENOSYS func=$D2 } }, \
	29 { "NFS4_SYMLINK	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 name=$D3 link=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fsid is read only EROFS f_flag=$D2 dvp=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 fsid does EOPNOTSUPP symlink f_flags=$D2 dvp=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 done error=$D2 dvp=$D3 name=$D4 link=$D5 endtimer($TID,$HD%D1) } }, \
	30 { "NFS4_READDIR	"}, \
	31 { "NFS4_STRATEGY	" ENOSYS vp=$D1 bp=$D2 }, \
	32 { "NFS4_REVOKE	" EOPNOTSUPP vp=$D1 cmd=$D2 flags=$D3 vattrp=$D4 }, \
	33 { "NFS4_GETACL	" }, \
	34 { "NFS4_SETACL	" }, \
	35 { "NFS4_GETPCL	" }, \
	36 { "NFS4_SETPCL	" }, \
	37 { "NFS4_SEEK	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 off=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 vp is VDIR vp=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 offset is invalid EINVAL off=$D2 f_maxfsize=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	38 { "NFS4_FSYNC_RANGE	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 flags=$D3 vinfo=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 off=$D2 len=$D3 }, \
		2  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	39 { "NFS4_CREATE_ATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 flags=$D3 name=$D4 vap=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 vcf=$D2 vinfop=$D3 }, \
		2  { trcpt $D1%D1 no type or mode EINVAL mask=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 vap is not VREG va_type=$D2 dvp=$D3 name=$D4 error=$D5 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 vinfop "==" NULL EINVAl dvp=$D2 name=$D3 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 xmemout failed EINVAL error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 done error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) } }, \
	40 { "NFS4_FINFO	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 cmd=$D3 bufp=$D4 len=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 cmd "!=" FI_PATHCONF EINVAL }, \
		2  { trcpt $D1%D1 init_compound_args failed error=$D2 vp=$D3 }, \
		3  { trcpt $D1%D1 add_putfh failed error=$D2 vp=$D3 }, \
		4  { trcpt $D1%D1 getsec failed error=$D2 vp=$D3 }, \
		5  { trcpt $D1%D1 rfs4call failed error=$D2 vp=$D3 }, \
		6  { trcpt $D1%D1 retry }, \
		7  { trcpt $D1%D1 nfs4expiredfh error=$D2 }, \
		8  { trcpt $D1%D1 FHEXPIRED error=$D2 }, \
		9  { trcpt $D1%D1 nfs4_handle_putfh_wrongsec error=$D2 }, \
		a  { trcpt $D1%D1 WRONGSEC error=$D2 }, \
		b  { trcpt $D1%D1 unknown error error=$D2 }, \
		c  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		d  { trcpt $D1%D1 FI_DIOCAP exit endtimer($TID,$HD%D1) }, \
		e  { trcpt $D1%D1 FI_KDM_FHANDLE exit endtimer($TID,$HD%D1) }, \
		f  { trcpt $D1%D1 FI_KDM_MOUNT exit endtimer($TID,$HD%D1) } }, \
	41 { "NFS4_MAP_LLOFF	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 off=$D3 len=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 vp=$D2 addr=$D3 mflags=$D4 }, \
		2  { trcpt $D1%D1 off+len is ENXIO off=$D2 len=$D3 max=$D4 vp=$D5 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 off+len is EFBIG off=$D2 len=$D3 fflags=$D4 vp=$D5 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 sign off+len < 0 ENXIO off=$D2 len=$D3 vp=$D4 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 vp is not VREG ENODEV v_type=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 NOAC is on EAGAIN vp=$D2 endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 create sid error=$D2 r_sid=$D3 vp=$D4 }, \
		8  { trcpt $D1%D1 done vp=$D2 error=$D3 r_sid=$D4 gn_mwrcnt=$D5 endtimer($TID,$HD%D1) }, \
		9  { trcpt $D1%D1 dio cio error vp=$D2 endtimer($TID,$HD%D1) } }, \
	42 { "NFS4_READDIR_EOFP	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 uiop=$D3 eofp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 vp=$D2 nfs4_ncookie=$D3 }, \
		2  { trcpt $D1%D1 NOAC }, \
		3  { trcpt $D1%D1 no NOAC }, \
		4  { trcpt $D1%D1 nothing to read vp=$D2 }, \
		5  { trcpt $D1%D1 interruped vp=$D2 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 interruped vp=$D2 endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 error in rdc vp=$D2 error=$D3 endtimer($TID,$HD%D1) }, \
		8  { trcpt $D1%D1 \
			$D2, \
				0  { from readdir cache }, \
				1  { from server } \
		     eof is true in rdc vp=$D2 error=$D3 endtimer($TID,$HD%D1) }, \
		9  { trcpt $D1%D1 \
			$D2, \
				0  { from readdir cache }, \
				1  { from server } \
		     nfs_async_readdir vp=$D2 error=$D3 endtimer($TID,$HD%D1) }, \
		a  { trcpt $D1%D1 \
			$D2, \
				0  { from readdir cache }, \
				1  { from server } \
		     done vp=$D2 error=$D3 endtimer($TID,$HD%D1) }, \
		b  { trcpt $D1%D1 do_nfs4readdir failed vp=$D2 error=$D3 endtimer($TID,$HD%D1) } }, \
	43 { "NFS4_RDWR_ATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 rw=$D3 ff=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 uiop=$D2 vi=$D3 }, \
		2  { trcpt $D1%D1 nfs4_getattr error=$D2 }, \
		3  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	44 { "NFS4_MEMCNTL	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 cmd=$D3 arg=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 F_ATTINFO endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 F_DETACH endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 F_ATTACH rc=$D2 vp=$D3 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 default vp=$D2 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 done rc=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	45 { "NFS4_CHECK_ACCESS	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 access=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 !ATTRCACHE_VALID NFS4ERR_EXPIRED endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done acp=$D2 \
			$D3, \
				0  { access cache hit not expired }, \
				\* { access cache hit expired } \
			 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 NFS4ERR_ACCESS acp=$D2 allowed=$D3 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 NFS4ERR_NOENT endtimer($TID,$HD%D1) } }, \
	46 { "NFS4_UPDATE_ACCESS	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 known=$D3 allowed=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 !ATTRCACHE_VALID NFS4ERR_EXPIRED endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done without allocate endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 can not allocate NFS4ERR_RESOURCE endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 allocated and done endtimer($TID,$HD%D1) } }, \
	47 { "NFS4_SETATTR2	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 vap=$D3 flags=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fsid is read only EROFS f_flag=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done error=$D2 rp=$D3 endtimer($TID,$HD%D1) } }, \
	48 { "NFS4_ACCESS_MISS	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 nm=$D3 lookupp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done !FH4_PERSISTENT vpp=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done dnlc hit vp=$D2 error=$D3 }, \
		3  { trcpt $D1%D1 done vpp=$D2 error=$D3 dvp=$D4 name=$D5 endtimer($TID,$HD%D1) } }, \
	49 { "NFS4_ACCESS_EXPIRED	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 nm=$D3 lookupp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 !FH4_PERSISTENT }, \
		2  { trcpt $D1%D1 dnlc hit vp=$D2 error=$D3 }, \
		3  { trcpt $D1%D1 done vpp=$D2 error=$D3 dvp=$D4 name=$D5 endtimer($TID,$HD%D1) } }, \
	50 { "NFS4_DNLC_MISS	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 nm=$D3 lookupp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 not utf8 name=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done vpp=$D2 error=$D3 dvp=$D4 name=$D5 endtimer($TID,$HD%D1) } }, \
	51 { "NFS4_LOOKUP1	" \
		$D1, \
		0  { trcpt $D1%D1 start dvp=$D2 nm[0]=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 *nm "==" '\0' vpp=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 dvp is not VDIR dvp=$D2 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 nfs4_access failed error=$D2 dvp=$D3 name=$D4 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 nm "==" . vpp=$D2 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 nfs4_validate_caches failed error=$D2 dvp=$D3 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 \
			$D3, \
				0  { dnlc positive hit }, \
				\* { dnlc negative hit } endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 no access vpp=$D2 }, \
		8  { trcpt $D1%D1 error=$D2 }, \
		9  { trcpt $D1%D1 from server done vpp=$D2 error=$D3 dvp=$D4 name=$D5 endtimer($TID,$HD%D1) } }, \
	52 { "NFS4_WRITERP	" \
		$D1, \
		0  { trcpt $D1%D1 start rp=$D2 off=$D3 resid=$D4 tcount=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 vp=$D2 off=$D3 resid=$D4 r_size=$D5 }, \
		2  { trcpt $D1%D1 vm_uio vp=$D2 error=$D3 resid=$D4 r_size=$D5 }, \
		3  { trcpt $D1%D1 noac startp=$D2 pcount=$D3 old_off=$D4 off=$D5 }, \
		4  { trcpt $D1%D1 done vp=$D2 resid=$D3 off=$D4 error=$D5 endtimer($TID,$HD%D1) } }, \
	53 { "NFS4_COMMIT	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 off=$D3 count=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 recover=$D2 recoververf=$D3 }, \
		2  { trcpt $D1%D1 vp=$D2 off=$D3 count=$D4 recover=$D5 }, \
		3  { trcpt $D1%D1 done error=$D2 vp=$D3 off=$D4 count=$D5 endtimer($TID,$HD%D1) } }, \
	54 { "NFS4_NFS4WRITE	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 count=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 base+off=$D2 stab+count=$D3 }, \
		2  { trcpt $D1%D1 vp=$D2 r_flags=$D3 off=$D4 stab_comm=$D5 }, \
		3  { trcpt $D1%D1 done vp=$D2 count=$D3 base+off=$D4 error=$D5 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done error $D2 vp=$D3 count=$D4 base+off=$D5 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 stale rnode rp=$D2 flags=$D3 endtimer($TID,$HD%D1) } }, \
	55 { "NFS4_COPY_MBUF	" \
		$D1, \
		0  { trcpt $D1%D1 start m=$D2 base=$D3 len=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done m=$D2 base=$D3 len=$D4 endtimer($TID,$HD%D1) } }, \
	56 { "NFS4_NFS4READ	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 count=$D3 base=$D4 off=$D5$D6 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 count=$D3 base+off=$D4 error=$D5 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 stale rnode rp=$D2 r_flags=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 read interrupted vp=$D2 endtimer($TID,$HD%D1) } }, \
	57 { "NFS4_READ_NC	" \
		$D1, \
		0  { trcpt $D1%D1 start rp=$D2 resid=$D3 off=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done resid=$D2 off=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	58 { "NFS4_READLINK_CACHED	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 error=$D3 contents=$D4 endtimer($TID,$HD%D1) } }, \
	59 { "NFS4_NFS4READLINK	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 uiop=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 uiop=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	60 { "NFS4_DO_NFS4READDIR	" \
		$D1, \
		0  { trcpt $D1%D1 start rp=$D2 rdc=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done rp=$D2 rdc=$D3 error=$D4 }, \
		2  { trcpt $D1%D1 rp=$D2 rdc=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	61 { "NFS4_RWLOCK	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 write_lock=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 write_lock=$D3 endtimer($TID,$HD%D1) } }, \
	62 { "NFS4_RWUNLOCK	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 write_lock=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 write_lock=$D3 endtimer($TID,$HD%D1) } }, \
	63 { "NFS4_INACTIVE	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 v_count=$D3 r_sid=$D4 r_count=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 vp=$D2 next=$D3 prev=$D4 r_unldvp=$D5 }, \
		2  { trcpt $D1%D1 vp=$D2 v_count=$D3%D1 caller2=$D4 caller3=$D5 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 done vp=$D2 endtimer($TID,$HD%D1) } }, \
	64 { "NFS4_NFS4CREATE	" \
		$D1, \
		0  { trcpt $D1%D1 start parent=$D2 vap=$D3 name=$D4 link=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done parent=$D2 vap=$D3 name=$D4 error=$D5 endtimer($TID,$HD%D1) } }, \
	65 { "NFS4_BP_COMMIT	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 bp=$D3 len=$D4 off=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 iodone bp=$D2 b_flags=$D3 b_error=$D4 off=$D5 }, \
		2  { trcpt $D1%D1 done vp=$D2 bp=$D3 error=$D4 off=$D5 endtimer($TID,$HD%D1) } }, \
	66 { "NFS4_BIO	" \
		$D1, \
		0  { trcpt $D1%D1 start b_vp=$D2 bp=$D3 stab_comm=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 b_flags=$D2 b_blkno=$D3 b_bcount=$D4 }, \
		2  { trcpt $D1%D1 EXCEPT_EOF bp=$D2 vp=$D3 flags=$D4 error=$D5 }, \
		3  { trcpt $D1%D1 EXCEPT_EOF bp=$D2 vp=$D3 flags=$D4 error=$D5 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 B_PFPROT bp=$D2 vp=$D3 flags=$D4 error=$D5 }, \
		5  { trcpt $D1%D1 r_count=$D2 vp=$D3 flags=$D4 error=$D5 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 vp=$D2 b_work=$D3 b_bcount=$D4 lldbtob=$D5 }, \
		7  { trcpt $D1%D1 bp=$D2 vp=$D3 baddr=$D4 }, \
		8  { trcpt $D1%D1 vp=$D2 rsize=$D3$D4 modaddr=$D5 }, \
		9  { trcpt $D1%D1 off=$D2$D3 rem=$D4$D5 }, \
		a  { trcpt $D1%D1 modaddr=$D2$D3 count=$D4$D5 }, \
		b  { trcpt $D1%D1 vp=$D2 r_erro=$D3 error=$D4 count=$D5 }, \
		c  { trcpt $D1%D1 rp=$D2 r_attrp=$D3 vap=$D4 }, \
		d  { trcpt $D1%D1 b_vp=$D2 b_work=$D3 b_bcount=$D4 b_baddr=$D5 }, \
		e  { trcpt $D1%D1 iodone bp=$D2 b_flags=$D3 b_error=$D4 }, \
		f  { trcpt $D1%D1 bp=$D2 b_flags=$D3 error=$D4 }, \
		10 { trcpt $D1%D1 vp=$D2 r_flags=$D3 r_error=$D4 endtimer($TID, $HD%D1) }, \
		11 { trcpt $D1%D1 file truncated while in use vp=$D2 endtimer($TID,$HD%D1) } }, \
	67 { "NFS4_BMAP	" }, \
	68 { "NFS4_NFS4RENAME	" \
		$D1, \
		0  { trcpt $D1%D1 start odvp=$D2 onm=$D3 cr=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 ndvp=$D2 nnm=$D3 cr=$D4 }, \
                2  { trcpt $D1%D1 over error=$D2 odvp=$D3 onm=$D4 nnm=$D5 endtimer($TID,$HD%D1) }, \
                3  { trcpt $D1%D1 done error=$D2 odvp=$D3 onm=$D4 nnm=$D5 endtimer($TID,$HD%D1) } }, \
	69 { "NFS4_IO_STATEID	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 sidp=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 interruped vp=$D2 sidp=$D3 }, \
		2  { trcpt $D1%D1 found it vp=$D2 sidp=$D3 }, \
		3  { trcpt $D1%D1 done vp=$D2 sidp=$D3 endtimer($TID,$HD%D1) } }, \
	70 { "NFS4_GETXACL	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2%XW controlFlags upper32=$D3%X4 lower32=$D4%X4}, \
		1  { trcpt $D1%D1 aclType upper32=$D2%X4 lower32=$D3%X4 }, \
		2  { trcpt $D1%D1 done error=$D2 aclType upper32=$D3%X4 lower32=$D4%X4 vp=$D5 }, \
		3  { trcpt $D1%D1 size=$D2%DW mode=$D3%X4 },\
		4  { trcpt $D1%D1 start nfs4_getxAclNFS4 get NFS4 acl }, \
		5  { trcpt $D1%D1 end nfs4_getxAclNFS4 error=$D2 vp=$D3 }, \
		6  { trcpt $D1%D1 start nfs4_getxAclAIXC get AIXC acl }, \
		7  { trcpt $D1%D1 end nfs4_getxAclAIXC error=$D2 vp=$D3 } }, \
	71 { "NFS4_SETXACL	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2%XW controlFlags upper32=$D3%X4 lower32=$D4%X4 mode=$D5}, \
		1  { trcpt $D1%D1 aclType upper32=$D2%X4 lower32=$D3%X4 size=$D4%DW}, \
		2  { trcpt $D1%D1 done error=$D2 vp=$D3 }, \
		3  { trcpt $D1%D1 start nfs4_setxAclNFS4 set NFS4 acl }, \
		4  { trcpt $D1%D1 end nfs4_setxAclNFS4 error=$D2 vp=$D3 }, \
		5  { trcpt $D1%D1 start nfs4_setxAclAIXC set AIXC acl }, \
		6  { trcpt $D1%D1 end nfs4_setxAclAIXC error=$D2 vp=$D3 } }, \
	72 { "NFS4_EIO          "  id=$D1%DW iar=$D2 caller2=$D3 caller3=$D4 }, \
	73 { "NFS4RENAME_OTW    " \
		$D1, \
		0  { trcpt $D1%D1 start odvp=$D2 onm=$D3 cr=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 ndvp=$D2 nnm=$D3 cr=$D4 }, \
		2  { trcpt $D1%D1 done error=$D2 odvp=$D3 onm=$D4 nnm=$D5 endtimer($TID,$HD%D1) } }
489 1.0 "@NFSv4 Client VFSOPS" \
	{{ \
	sec2auth(sec) \
		$sec%D1, \
			0	{ AUTH_NONE }, \
			1	{ AUTH_SYS }, \
			2	{ AUTH_SHORT }, \
			3	{ AUTH_DES }, \
			4	{ AUTH_KERB }, \
			6	{ RPCSEC_GSS }, \
			390003	{ AUTH_KERB5 }, \
			390003	{ AUTH_KERB5I }, \
			390003	{ AUTH_KERB5P } \
	}} \
	$HD%D1, \
	1 { "NFS4_INIT	" \
		$D1, \
		0  { trcpt $D1%D1 start gfsp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done gfsp=$D2 error=$D3 endtimer($TID,$HD%D1) } }, \
	2 { "NFS4_RNODE_NULL	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	3 { "NFS4_REPLICATE	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 fattr=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 supported=$D2 bitmap4_val=$D3 tmp=$D4 }, \
		2  { trcpt $D1%D1 f_fs_type=$D2 fh_expire_type=$D3 }, \
		3  { trcpt $D1%D1 link mismatch }, \
		4  { trcpt $D1%D1 link mismatch }, \
		5  { trcpt $D1%D1 symlink mismatch }, \
		6  { trcpt $D1%D1 symlink mismatch }, \
		7  { trcpt $D1%D1 cansettime mismatch }, \
		8  { trcpt $D1%D1 cansettime mismatch }, \
		9  { trcpt $D1%D1 case insensitive mismatch }, \
		a  { trcpt $D1%D1 case insensitive mismatch }, \
		b  { trcpt $D1%D1 homogeneous mismatch }, \
		c  { trcpt $D1%D1 maxfilesize mismatch }, \
		d  { trcpt $D1%D1 maxread mismatch }, \
		e  { trcpt $D1%D1 maxwrite mismatch }, \
		f  { trcpt $D1%D1 done endtimer($TID,$HD%D1) }, \
		10 { trcpt $D1%D1 workp=$D2 }, \
		11 { trcpt $D1%D1 done current=$D2 endtimer($TID,$HD%D1) } }, \
	4 { "NFS4_UPDATEID	" \
		$D1, \
		0  { trcpt $D1%D1 start workp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	5 { "NFS4_PUTFH	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 sec=sec2auth($D3) starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	6 { "NFS4_PSEUDO	" \
		$D1, \
		0  { trcpt $D1%D1 start secinfo=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 not RPCSEC_GSS flavor=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 AUTH_KERB5 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 AUTH_KERB5I endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 AUTH_KERB5P endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 NOSEC endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 NOSEC endtimer($TID,$HD%D1) } }, \
	7 { "NFS4_GETCOMMONSEC	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 name=$D3 seclist=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done error=$D2 vp=$D3 name=$D4 endtimer($TID,$HD%D1) } }, \
	8 { "NFS4_NFS4GETSEC	" \
		$D1, \
		0  { trcpt $D1%D1 start workp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 error=$D2 }, \
		2  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	9 { "NFS4_FHLOOKUP	" \
		$D1, \
		0  { trcpt $D1%D1 start workp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	10 { "NFS4_ATTR_OTW	" \
		$D1, \
		0  { trcpt $D1%D1 start workp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 error=$D2 }, \
		2  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	11 { "NFS4_GET_PARENT_FSID	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 ino=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 ino=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	12 { "NFS4_PROCESS_ENTRY	" \
		$D1, \
		0  { trcpt $D1%D1 start rp=$D2 rdc=$D3 entries=$D4 size=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 nfs4_get_parent_fsid failed error=$D2 }, \
		2  { trcpt $D1%D1 done rp=$D2 rdc=$D3 entries=$D4 size=$D5 endtimer($TID,$HD%D1) } }, \
	13 { "NFS4_NEW_VERIFIER	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 vp=$D3 sec=sec2auth($D4) new=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 interrupted }, \
		2  { trcpt $D1%D1 readdir failed rdc->error=$D2 }, \
		3  { trcpt $D1%D1 new verifier fsidp=$D2 vp=$D3 sec=sec2auth($D4) new=$D5 }, \
		4  { trcpt $D1%D1 interrupted }, \
		5  { trcpt $D1%D1 readdir failed rdc->error=$D2 }, \
		6  { trcpt $D1%D1 done new verifier fsidp=$D2 vp=$D3 sec=sec2auth($D4) new=$D5 endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 fsidp=$D2 vp=$D3 sec=sec2auth($D4) new=$D5 }, \
		8  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	14 { "NFS4_READDIR_CACHED	" \
		$D1, \
		0  { trcpt $D1%D1 start workp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 workp=$D2 }, \
		2  { trcpt $D1%D1 done error=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	15 { "NFS4_NFS4READDIR	" \
		$D1, \
		0  { trcpt $D1%D1 start workp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 workp=$D2 }, \
		2  { trcpt $D1%D1 done workp=$D2 error=$D3 vp=$D4 endtimer($TID,$HD%D1) } }, \
	16 { "NFS4_DO_RENEW	" \
		$D1, \
		0  { trcpt $D1%D1 start idp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 CLNT_DEAD ESTALE }, \
		2  { trcpt $D1%D1 CLNT_DEAD ESTALE }, \
		3  { trcpt $D1%D1 renewed endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	17 { "NFS4_N4BG	" \
		$D1, \
		0  { trcpt $D1%D1 start starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	18 { "NFS4_UPDATE_FS_LOC	" \
		$D1, \
		0  { trcpt $D1%D1 start fs_loc=$D2 fsidp=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	19 { "NFS4_UPDATE_N4RP	" }, \
	20 { "NFS4_STALE_CLNTID	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done fsidp=$D2 error=$D3 endtimer($TID,$HD%D1) } }, \
	21 { "NFS4_REL_CLNTID	" \
		$D1, \
		0  { trcpt $D1%D1 start current=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 f_serv_objp "==" NULL }, \
		2  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	22 { "NFS4_FSID_DUP	" \
		$D1, \
		0  { trcpt $D1%D1 start old_fsid=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done new_fsid=$D2 endtimer($TID,$HD%D1) } }, \
	23 { "NFS4_GET_CLNTID	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 id=$D3 hold=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fsidp=$D2 id=$D3 hold=$D4 error=$D5 }, \
		2  { trcpt $D1%D1 no ipv4/v6 address EINVAL }, \
		3  { trcpt $D1%D1 interrupted }, \
		4  { trcpt $D1%D1 waited error=$D2 }, \
		5  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	24 { "NFS4_MOUNT	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 EPERM endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 ENOTDIR endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 get_nfs4_args failed error=$D2 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 get_nfs4_args failed error=$D2 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 get_nfs4_args failed error=$D2 endtimer($TID,$HD%D1) } }, \
	25 { "NFS4_ROOTVP	" \
		$D1, \
		0  { trcpt $D1%D1 start rtvpp=$D2 vfsp=$D3 argsp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 sync=$D2 shname=$d3 netname=$D4 nlen=$D5 }, \
		2  { trcpt $D1%D1 done rtvpp=$D2 vfsp=$D3 fsidp=$D4 error=$D5 endtimer($TID,$HD%D1) } }, \
	26 { "NFS4_ROOT	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 vpp=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vfsp=$D2 vpp=$D3 endtimer($TID,$HD%D1) } }, \
	27 { "NFS4_STATFSVP	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 vp=$D3 sbp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vfsp=$D2 vp=$D3 sbp=$D4 error=$D5 endtimer($TID,$HD%D1) } }, \
	28 { "NFS4_STATFS	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 sbp=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vfsp=$D2 rtvp=$D3 sbp=$D4 endtimer($TID,$HD%D1) } }, \
	29 { "NFS4_SYNC	" \
		$D1, \
		0  { trcpt $D1%D1 start gfsp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done gfsp=$D2 endtimer($TID,$HD%D1) } }, \
	30 { "NFS4_CNTL	" \
		$D1, \
		0  { start vfs=$D2 cmd=$D3 arg=$D4 argsize=$D5 starttimer(0x212,$D2) }, \
		1  { rmnt const failed vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) }, \
		2  { rmnt adjust failed vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) }, \
		3  { end vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) }, \
		4  { bad cmd vfs=$D2 cmd=$D3 arg=$D4 error=$D5 endtimer(0x212,$D2) } }, \
	31 { "NFS4_QUOTACTL	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 cmd=$D3 uid=$D4 arg=$D5 } }, \
	32 { "NFS4_BADOP	" \
		$D1, \
		0  { trcpt $D1%D1 start } }, \
	33 { "NFS4_FREE_FSID	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done fsidp=$D2 endtimer($TID,$HD%D1) } }, \
	34 { "NFS4_NFS4_ARGS	" \
		$D1, \
		0  { trcpt $D1%D1 start args=$D2 data=$D3 datalen=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done args=$D2 data=$D3 datalen=$D4 endtimer($TID,$HD%D1) } }, \
	35 { "NFS4_VGET	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 vpp=$D3 fidp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 rfind4 failed ESTALE endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 r_fsidp is NULL ESTALE endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 done vpp=$D2 endtimer($TID,$HD%D1) } }, \
	36 { "NFS4_UNMOUNT	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 flags=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 EBUSY endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 EINTR endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 vp=$D2 v_count=$D3 vfsp=$D4 }, \
		4  { trcpt $D1%D1 vp=$D2 v_count=$D3 vfsp=$D4 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	37 { "NFS4_2DIRENT	" \
		$D1, \
		0  { trcpt $D1%D1 start e=$D2 buf=$D3 error=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 no rddir error sup e=$D2 buf=$D3 error=$D5 }, \
		2  { trcpt $D1%D1 done e=$D2 buf=$D3 endtimer($TID,$HD%D1) } }, \
	38 { "NFS4_N4RP	" \
		$D1, \
		0  { trcpt $D1%D1 start starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	39 { "NFS4_ACLXCNTL	" \
		$D1, \
		0  { D1=$D1 start vfsp=$D2 vp=$D3 cmd=$D4 size=$D5 }, \
		1  { D1=$D1 done rc=$D2 vp=$D3 } }, \
	40 { "NFS4_GET_A_RNODE	" \
		$D1, \
		0  { trcpt $D1%D1 fh=$D2 vfsp=$D3 newnode=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fsidp=$D2 sec=$D3 cr=$D4 }, \
		2  { trcpt $D1%D1 fh is not null endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 found rp=$D2 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 found rp=$D2 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 got one rp=$D2 endtimer($TID,$HD%D1) } }, \
	41 { "NFS_V4_ADJ_ARGS " \
		$D1%D1, \
		0  { trcpt $D1%D1 start args=$D2 error=$D3 starttimer(0x212,$D2) }, \
		1  { trcpt $D1%D1 timeo bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		2  { trcpt $D1%D1 retrans bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		3  { trcpt $D1%D1 rsize bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		4  { trcpt $D1%D1 wsize bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		5  { trcpt $D1%D1 syncaddr bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		6  { trcpt $D1%D1 copyin64 bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		7  { trcpt $D1%D1 copyinstr64 bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		8  { trcpt $D1%D1 netname bad args=$D2 error=$D3 endtimer(0x212,$D2) }, \
		\* { trcpt $D1%D1 end args=$D2 error=$D3 endtimer(0x212,$D2) } }, \
	42 { "NFS_V4_REMOUNT " \
		$D1%D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 vmtp=$D3 starttimer(0x212, $D2) }, \
		\* { trcpt $D1%D1 end vfsp=$D2 vmtp=$D3 endtimer(0x212, $D2) } }
48A 1.0 "@NFSv4 Client MISCOPS" \
	$HOOKENV, \
	32 { \
		HT & 0x7, \
		0 {  \
			$D1%D1, \
			34 { "NFS4_GET_FSID, getting fsid for " G8 $HL%S1 }, \
			36 { "NFS4_LOOKUP_PATH, looking up " G8 $HL%S1 }, \
			37 { "NFS4_MAKENFS4NODE, making rnode for " G8 $HL%S1 }, \
			45 { "NFS4_PATHLOOKUP, looking up " G8 $HL%S1 }, \
			53 { "NFS4_FIND_FSID finding fsid for " G8 $HL%S1 } \
			$BREAK \
		} }, \
	64 { \
		HT & 0x4000, \
		0x4000 {  \
			$D1%D1, \
			34 { "NFS4_GET_FSID, getting fsid for " G16 $HL%S1 }, \
			36 { "NFS4_LOOKUP_PATH, looking up " G16 $HL%S1 }, \
			37 { "NFS4_MAKENFS4NODE, making rnode for " G16 $HL%S1 }, \
			45 { "NFS4_PATHLOOKUP, looking up " G16 $HL%S1 }, \
			53 { "NFS4_FIND_FSID finding fsid for " G16 $HL%S1 } \
			$BREAK \
		} } \
	{{ \
	sec2auth(sec) \
		$sec%D1, \
			0	{ AUTH_NONE }, \
			1	{ AUTH_SYS }, \
			2	{ AUTH_SHORT }, \
			3	{ AUTH_DES }, \
			4	{ AUTH_KERB }, \
			6	{ RPCSEC_GSS }, \
			390003	{ AUTH_KERB5 }, \
			390003	{ AUTH_KERB5I }, \
			390003	{ AUTH_KERB5P } \
	}} \
	$HD%D1, \
	1 { "NFS4_GET_UID_GID	" \
		$D1, \
		0  { trcpt $D1%D1 start ustr=$D2 gstr=$D3 flags=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done ustr=$D2 gstr=$D3 uid=$D5 gid=$D6 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 EINVAL }, \
		3  { trcpt $D1%D1 SERVERFAULT } }, \
	2 { "NFS4_GET_USER_GROUP_NAME	" \
		$D1, \
		0  { trcpt $D1%D1 start uid=$D2 gid=$D3 flags=$D4 stmp=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 ENOMEM }, \
		2  { trcpt $D1%D1 ENOMEM }, \
		3  { trcpt $D1%D1 SERVERFAULT }, \
		4  { trcpt $D1%D1 EINVAL }, \
		5  { trcpt $D1%D1 error unknown error=$D2 }, \
		6  { trcpt $D1%D1 done error=$D2 }, \
		7  { trcpt $D1%D1 id=$D2 name=$D3 }, \
		8  { trcpt $D1%D1 user=$D2 flags=$D3 stmp=$D4 }, \
		9  { trcpt $D1%D1 ENOMEM }, \
		a  { trcpt $D1%D1 ENOMEM }, \
		b  { trcpt $D1%D1 SERVERFAULT }, \
		c  { trcpt $D1%D1 EINVAL }, \
		d  { trcpt $D1%D1 error unknown error=$D2 }, \
		e  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	3 { "NFS4_UPDATE_TIME	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 endtimer($TID,$HD%D1) } }, \
	4 { "NFS4_TO_VATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 na=$D3 vap=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 get_uid_gid failed na=$D2 rc=$D3 }, \
		2  { trcpt $D1%D1 done rc=$D2 endtimer($TID,$HD%D1) } }, \
	5 { "NFS4_TO_FATTR4	" \
		$D1, \
		0  { trcpt $D1%D1 start vap=$D2 fa=$D3 flags=$D4 stmp=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 U/G ID2STR failed vap=$D2 fa=$D3 flags=$D4 rc=$D5 }, \
		2  { trcpt $D1%D1 UID2STR failed vap=$D2 fa=$D3 flags=$D4 rc=$D5 }, \
		3  { trcpt $D1%D1 GID2STR failed vap=$D2 fa=$D3 flags=$D4 rc=$D5 }, \
		4  { trcpt $D1%D1 done vap=$D2 fa=$D3 flags=$D4 rc=$D5 endtimer($TID,$HD%D1) } }, \
	6 { "NFS4_CACHE_CHECK	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 fattrp=$D3 seqp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 fattrp=$D3 seqp=$D4 endtimer($TID,$HD%D1) } }, \
	7 { "NFS4_NULL_ATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start attr=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 attr "==" NULL attr=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 attr "!=" NULL endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 attr "==" NULL attr=$D2 endtimer($TID,$HD%D1) } }, \
	8 { "NFS4_ATTRCACHE	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 na=$D3 seq=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fattr4_to_vattr failed vp=$D2 na=$D3 seq=$D4 error=$D5 }, \
		2  { trcpt $D1%D1 done vp=$D2 na=$D3 seq=$D4 error=$D5 endtimer($TID,$HD%D1) } }, \
	9 { "NFS4_POST_OP_ATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 attr=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 nfs4_attrcache failed vp=$D2 attr=$D3 error=$D4 }, \
		2  { trcpt $D1%D1 done vp=$D2 attr=$D3 endtimer($TID,$HD%D1) } }, \
	10 { "NFS4_VALIDATE_CACHES	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 ATTRCACHE_VALID vp=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 etimedout vp=$D2 }, \
		3  { trcpt $D1%D1 interrupted vp=$D2 }, \
		4  { trcpt $D1%D1 attribute valid vp=$D2 }, \
		5  { trcpt $D1%D1 done vp=$D2 error=$D3 endtimer($TID,$HD%D1) } }, \
	11 { "NFS4_ADDLIST4	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 ENOMEM vfsp=$D2 }, \
		2  { trcpt $D1%D1 done vfsp=$D2 endtimer($TID,$HD%D1) } }, \
	12 { "NFS4_RMLIST4	" \
		$D1, \
		0  { trcpt $D1%D1 start vfsp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 interrupted vfsp=$D2 }, \
		2  { trcpt $D1%D1 noent vfsp=$D2 list=$D3 type=$D4 }, \
		3  { trcpt $D1%D1 done vfsp=$D2 endtimer($TID,$HD%D1) } }, \
	13 { "NFS4_N4STHREAD	" \
		$D1, \
		0  { trcpt $D1%D1 start sargs=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done sargs=$D2 endtimer($TID,$HD%D1) } }, \
	14 { "NFS4_NFS4SYNC	" \
		$D1, \
		0  { trcpt $D1%D1 start gfsnum=$D2 flag=$D3 cr=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done gfsnum=$D2 flag=$D3 cr=$D4 error=$D5 endtimer($TID,$HD%D1) } }, \
	15 { "NFS4_NFS4SYNC_K	" \
		$D1, \
		0  { trcpt $D1%D1 start argsp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done argsp=$D2 endtimer($TID,$HD%D1) } }, \
	16 { "NFS4_NFS4GETATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 vap=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 etimedout vp=$D2 vap=$D3 }, \
		2  { trcpt $D1%D1 interrupted vp=$D2 vap=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 \
			$D2, \
				0  { from attribute cache }, \
				1  { from server } \
		     done vp=$D2 vap=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	17 { "NFS4_CHECK_DIR_CACHE	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 cinfo=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 change "==" after vp=$D2 cinfo=$D3 }, \
		2  { trcpt $D1%D1 done vp=$D2 cinfo=$D3 endtimer($TID,$HD%D1) } }, \
	18 { "NFS4_NFS4TSIZE	" \
		$D1, \
		0  { trcpt $D1%D1 start ttype=$D2 } }, \
	19 { "NFS4_TO_UNIX	" \
		$D1, \
		0  { trcpt $D1%D1 start errno=$D2 } }, \
	20 { "NFS4_GETERRNO4	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 status=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 unknown fsidp=$D2 status=$D3 }, \
		2  { trcpt $D1%D1 done fsidp=$D2 status=$D3 endtimer($TID,$HD%D1) } }, \
	21 { "NFS4_INIT_ARGS	" \
		$D1, \
		0  { trcpt $D1%D1 start num_args=$D2 args=$D3 argsp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 res=$D2 tags=$D3 stmp=$D4 }, \
		2  { trcpt $D1%D1 done stmp=$D2 endtimer($TID,$HD%D1) } }, \
	22 { "NFS4_PUT_MASK	" \
		$D1, \
		0  { trcpt $D1%D1 start mask=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done mask=$D2 endtimer($TID,$HD%D1) } }, \
	23 { "NFS4_ADD_PUTFH	" \
		$D1, \
		0  { trcpt $D1%D1 start argsp=$D2 vp=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done argsp=$D2 vp=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	24 { "NFS4_ADD_NVERIFY	" \
		$D1, \
		0  { trcpt $D1%D1 start argsp=$D2 vp=$D3 stmp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done argsp=$D2 vp=$D3 stmp=$D4 endtimer($TID,$HD%D1) } }, \
	25 { "NFS4_ADD_GETATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start argsp=$D2 stmp=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done argsp=$D2 stmp=$D3 endtimer($TID,$HD%D1) } }, \
	26 { "NFS4_GETSEC	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 sec=sec2auth($D3) starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 sec=sec2auth($D3) error=$D4 endtimer($TID,$HD%D1) } }, \
	27 { "NFS4_FH4FREE	" \
		$D1, \
		0  { trcpt $D1%D1 start fh4=$D2 } }, \
	28 { "NFS4_FH4CMP	" \
		$D1, \
		0  { trcpt $D1%D1 start dest=$D2 src=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 "==" dest=$D2 src=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 comparing dest=$D2 src=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 "!=" dest=$D2 src=$D3 endtimer($TID,$HD%D1) } }, \
	29 { "NFS4_RFIND4	" \
		$D1, \
		0  { trcpt $D1%D1 start fh=$D2 vfsp=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 found fh=$D2 vfsp=$D3 rp=$D4 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 not found fh=$D2 vfsp=$D3 endtimer($TID,$HD%D1) } }, \
	30 { "NFS4_PATH4_TO_STR	" \
		$D1, \
		0  { trcpt $D1%D1 start p=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done pathname=$D2 endtimer($TID,$HD%D1) } }, \
	31 { "NFS4_STRDUP4	" \
		$D1, \
		0  { trcpt $D1%D1 start str=$D2 sleep=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done str=$D2 sleep=$D3 rs=$D4 endtimer($TID,$HD%D1) } }, \
	32 { "NFS4_PATH4_CMP	" \
		$D1, \
		0  { trcpt $D1%D1 start p1=$D2 p2=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 "!=" p1=$D2 p2=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 "!=" p1=$D2 p2=$D3 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 "==" p1=$D2 p2=$D3 endtimer($TID,$HD%D1) } }, \
	33 { "NFS4_FS_LOC4	" \
		$D1, \
		0  { trcpt $D1%D1 start fs_lp=$D2 serv=$D3 flag=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done fs_lp=$D2 serv=$D3 flag=$D4 head=$D5 endtimer($TID,$HD%D1) } }, \
	34 { "NFS4_GET_FSID	" \
		$D1, \
		0  { trcpt $D1%D1 start fhp=$D2 dvp=$D3 dfsidp=$D4 f_idp=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 nm=$D2 }, \
		9  { trcpt $D1%D1 done fsidp=$D2 error=$D3 endtimer($TID,$HD%D1) } }, \
	35 { "NFS4_MAKE_RNODE4	" \
		$D1, \
		0  { trcpt $D1%D1 start fh=$D2 vfsp=$D3 free=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 newnode=$D2 }, \
		2  { trcpt $D1%D1 found vp=$D2 }, \
		3  { trcpt $D1%D1 found vp=$D2 }, \
		4  { trcpt $D1%D1 done vp=$D2 endtimer($TID,$HD%D1) } }, \
	36 { "NFS4_LOOKUP_PATH	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 vp=$D3 len=$D4 name=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done name=$D2 error=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done name=$D2 error=$D3 fsidp=$D2 vp=$D3 endtimer($TID,$HD%D1) } }, \
	37 { "NFS4_MAKENFS4NODE	" \
		$D1, \
		0  { trcpt $D1%D1 start fh=$D2 attr=$D3 vfsp=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 dvp=$D2 nm=$D3 fsidp=$D4 }, \
		2  { trcpt $D1%D1 start2 sec=sec2auth($D2) error=$D3 }, \
		3  { trcpt $D1%D1 get_uid_gid failed error=$D2 }, \
		4  { trcpt $D1%D1 done newnode "==" 2 vp=$D2 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 done got new fsidvp=$D2 error=$D3 errorp=$D4 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 done got new vp=$D2 error=$D3 errorp=$D4 endtimer($TID,$HD%D1) } }, \
	38 { "NFS4_RFS4CALL	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 proc=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 start1 xdrargs=$D2 argsp=$D3 }, \
		2  { trcpt $D1%D1 start2 xdrres=$D2 resp=$D3 }, \
		3  { trcpt $D1%D1 start3 douprintf=$D2 statusp=$D3 }, \
		4  { trcpt $D1%D1 start4 secflavor=$D2 which $D3 }, \
		5  { trcpt $D1%D1 NOSEC WRONGSEC }, \
		6  { trcpt $D1%D1 done geterrno4 rpcerror=$D2 endtimer($TID,$HD%D1) }, \
		7  { trcpt $D1%D1 done EACCES endtimer($TID,$HD%D1) }, \
		8  { trcpt $D1%D1 done status=$D2 statusp=$D3 endtimer($TID,$HD%D1) }, \
		9  { trcpt $D1%D1 done RPC_AUTHERROR WRONGSEC endtimer($TID,$HD%D1) }, \
		a  { trcpt $D1%D1 done RPC_ERROR rpcerror=$D2 endtimer($TID,$HD%D1) }, \
		b  { trcpt $D1%D1 done rpcerror=$D2 endtimer($TID,$HD%D1) } }, \
	39 { "NFS4_ADD_SETATTR	" \
		$D1, \
		0  { trcpt $D1%D1 start args=$D2 vap=$D3 flags=$D4 stmp=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done args=$D2 vap=$D3 flags=$D4 error=$d5 endtimer($TID,$HD%D1) } }, \
	40 { "NFS4_HAS_ATTR4	" \
		$D1, \
		0  { trcpt $D1%D1 start attr4=$D2 attrid=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 attrid=$D2 index=$D3 }, \
		2  { trcpt $D1%D1 attr4=$D2 attrid=$D3 bmap=$D4 }, \
		3  { trcpt $D1%D1 done mask=$D2 "bmap & mask"=$D3 endtimer($TID,$HD%D1) } }, \
	41 { "NFS4_RM_ATTR4	" \
		$D1, \
		0  { trcpt $D1%D1 start attr4=$D2 attrid=$D3 index=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done attr4=$D2 attrid=$D3 bmap=$D4 mask=$D5 endtimer($TID,$HD%D1) } }, \
	42 { "NFS4_ADD_ATTR4	" \
		$D1, \
		0  { trcpt $D1%D1 start attr4=$D2 attrid=$D3 index=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done attr4=$D2 attrid=$D3 bmap=$D4 mask=$D5 endtimer($TID,$HD%D1) } }, \
	43 { "NFS4_EXPIREDFH	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 putfh=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 putfh=$D3 error=$D4 endtimer($TID,$HD%D1) } }, \
	44 { "NFS4_PUT_SLASHES	" \
		$D1, \
		0  { trcpt $D1%D1 start str=$D2 len=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done str=$D2 len=$D3 endtimer($TID,$HD%D1) } }, \
	45 { "NFS4_PATHLOOKUP	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 name=$D3 len=$D4 fhp=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 fattrp=$D2 bpp=$D3 secp=$D4 stm=$D5 }, \
		2  { trcpt $D1%D1 not utf8 EINVAL }, \
		3  { trcpt $D1%D1 done sec=sec2auth($D2) fattrp=$D3 fhp=$D4 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done sec=sec2auth($D2) fattrp=$D3 fhp=$D4 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 done error=$D2 fsidp=$D3 name=$D4 endtimer($TID,$HD%D1) } }, \
	46 { "NFS4_FREE_F_LOC	" \
		$D1, \
		0  { trcpt $D1%D1 start p=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	47 { "NFS4_RELEASE_FSID	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 mnt=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 f_count > 1 done }, \
		2  { trcpt $D1%D1 f_count < 1 EINVAL }, \
		3  { trcpt $D1%D1 not in the list ENOENT endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done error=$D2 endtimer($TID,$HD%D1) } }, \
	48 { "NFS4_PUT_WORK	" \
		$D1, \
		0  { trcpt $D1%D1 start type=$D2 vp=$D3 ans=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	49 { "NFS4_GET_WORK	" \
		$D1, \
		0  { trcpt $D1%D1 start starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done tmp_work=$D2 endtimer($TID,$HD%D1) } }, \
	50 { "NFS4_PUTFH_WRONGSEC	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 error=$D3 endtimer($TID,$HD%D1) } }, \
	51 { "NFS4_VMM_INIT4	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done vp=$D2 type=$D3 m_xfer=$D4 mclust=$D5 endtimer($TID,$HD%D1) } }, \
	52 { "NFS4_REMOVE_FSID_SEARCH	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done f_count > 0 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	53 { "NFS4_FIND_FSID	" \
		$D1, \
		0  { trcpt $D1%D1 start name=$D2 args=$D3 vfsp=$D4 sleep=$D5 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 }, \
		2  { trcpt $D1%D1 ENOMEM }, \
		3  { trcpt $D1%D1 ENOMEM }, \
		4  { trcpt $D1%D1 done tmp=$D2 endtimer($TID,$HD%D1) } }, \
	54 { "NFS4_UPDATE_OPTS	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 args=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done fsidp=$D2 args=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done reset fsidp=$D2 args=$D3 endtimer($TID,$HD%D1) } }, \
	55 { "NFS4_SET_N4INFO	" \
		$D1, \
		0  { trcpt $D1%D1 start path=$D2 args=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done path=$D2 args=$D3 rc=$D4 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 start path=$D2 starttimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 done path=$D2 error=$D4 endtimer($TID,$HD%D1) } }, \
	56 { "NFS4_TO_OPTS	" \
		$D1, \
		0  { trcpt $D1%D1 start fsidp=$D2 args=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done fsidp=$D2 args=$D3 endtimer($TID,$HD%D1) } }, \
	57 { "NFS4_CP_OUT_FS_LOC	" \
		$D1, \
		0  { trcpt $D1%D1 start tmp=$D2 data=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 EFAULT }, \
		2  { trcpt $D1%D1 EFAULT }, \
		3  { trcpt $D1%D1 done data=$D2 endtimer($TID,$HD%D1) } }, \
	58 { "NFS4_CP_OUT_STR	" \
		$D1, \
		0  { trcpt $D1%D1 start str=$D2 data=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 EFAULT }, \
		2  { trcpt $D1%D1 EFAULT }, \
		3  { trcpt $D1%D1 done data=$D2 endtimer($TID,$HD%D1) } }, \
	59 { "NFS4_CP_OUT	" \
		$D1, \
		0  { trcpt $D1%D1 start tmp=$D2 data=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 EFAULT }, \
		2  { trcpt $D1%D1 EFAULT }, \
		3  { trcpt $D1%D1 EFAULT }, \
		4  { trcpt $D1%D1 EFAULT }, \
		5  { trcpt $D1%D1 done endtimer($TID,$HD%D1) } }, \
	60 { "NFS4_SIZE_ERROR	" \
		$D1, \
		0  { trcpt $D1%D1 start size=$D2 len=$D3 data=$D4 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 size < sizeof(len) EINVAL }, \
		2  { trcpt $D1%D1 EFAULT }, \
		3  { trcpt $D1%D1 done size=$D2 data=$D3 endtimer($TID,$HD%D1) } }, \
	61 { "NFS4_INFO	" \
		$D1, \
		0  { trcpt $D1%D1 start path=$D2 size=$D3 data=$D4 op=$D5  starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 done count=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done count=$D2 endtimer($TID,$HD%D1) }, \
		3  { trcpt $D1%D1 done count=$D2 endtimer($TID,$HD%D1) }, \
		4  { trcpt $D1%D1 done count=$D2 endtimer($TID,$HD%D1) }, \
		5  { trcpt $D1%D1 done count=-2 endtimer($TID,$HD%D1) }, \
		6  { trcpt $D1%D1 done error=$D2 count=-1 endtimer($TID,$HD%D1) } }, \
	62 { "NFS4_CACHE_ATTR_OTW_RESULT	" \
		$D1, \
		0  { trcpt $D1%D1 start vp=$D2 attr=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 error=$D2 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done vp=$D2 attr=$D3 endtimer($TID,$HD%D1) } }, \
	63 { "NFS4_GET_ROOT	" \
		$D1, \
		0  { trcpt $D1%D1 start root=$D2 cr=$D3 starttimer($TID,$HD%D1) }, \
		1  { trcpt $D1%D1 error=$D2 root=$D3 endtimer($TID,$HD%D1) }, \
		2  { trcpt $D1%D1 done error=$D2 root=$D3 endtimer($TID,$HD%D1) } }, \
	64 { "NFS4_RM_WORK      " \
		$D1, \
		0  { trcpt $D1%D1 workp=$D2 }, \
		1  { trcpt $D1%D1 workp=$D2 rc=$D3 } }, \
	65 { "NFS4_HANDLE_ERRORS   " \
		$D1, \
		0  { trcpt $D1%D1 vnode=$D2 status=$D3 caller2=$D4 caller3=$D5 } }, \
	66 { "NFS4_FSID_HOLD	" \
		$D1, \
		0  { trcpt $D1%D1 fsidp=$D2 f_ref=$D3 caller=$D4 caller2=$D5 }, \
		1  { trcpt $D1%D1 fsidp=$D2 f_ref=$D3 caller3=$D4 } }, \
	67 { "NFS4_FSID_RELE	" \
		$D1, \
		0  { trcpt $D1%D1 fsidp=$D2 f_ref=$D3 lock=$D4 }, \
		1  { trcpt $D1%D1 fsidp=$D2 caller=$D3 caller2=$D4 caller3=$D5 }, \
		2  { trcpt $D1%D1 fsidp=$D2 vp=$D3 }, \
		3  { trcpt $D1%D1 fsidp=$D2 f_ref=$D3 } }, \
	68 { "NFS4_GET_SYMLINK_FH " \
		$D1, \
		0  { trcrpt $D1%D1 fsidp=$D2 fhp=$D3 path=$D4 flags=$D5 }, \
		1  { trcrpt $D1%D1 sec=$D2 cr=$D3 }, \
		2  { trcrpt $D1%D1 init_compound_args() failed error=$D2 }, \
		3  { trcrpt $D1%D1 rfs4call() failed error=$D2 }, \
		4  { trcrpt $D1%D1 res_len != args_len args_len=$D2 res_len=$D3 }, \
		5  { trcrpt $D1%D1 name too long len=$D2 }, \
		6  { trcrpt $D1%D1 restart error=$D2 }, \
		7  { trcrpt $D1%D1 bad error=$D2 }, \
		8  { trcrpt $D1%D1 done } }, \
	69 { "NFS4_LOOKUP_FH " \
		$D1, \
		0  { trcrpt $D1%D1 fsidp=$D2 path=$D3 ifhp=$D4 ofhp=$D5 }, \
		1  { trcrpt $D1%D1 flags=$D2 secp=$D3 recur=$D4 fsid=$D5 }, \
		2  { trcrpt $D1%D1 cr=$D2 }, \
		3  { trcrpt $D1%D1 nfs4_lookup_rootfh() failed error=$D2 }, \
		4  { trcrpt $D1%D1 AF_FSIDNOTSAME }, \
		5  { trcrpt $D1%D1 ifhp is NULL }, \
		6  { trcrpt $D1%D1 path is null string }, \
		7  { trcrpt $D1%D1 init_compound_args() failed error=$D2 }, \
		8  { trcrpt $D1%D1 rfs4call() failed error=$D2 }, \
		9  { trcrpt $D1%D1 restart error=$D2 }, \
		10  { trcrpt $D1%D1 SYMLINK }, \
		11  { trcrpt $D1%D1 WRONGSEC }, \
		12  { trcrpt $D1%D1 MOVED no defer flags=$D2 }, \
		13  { trcrpt $D1%D1 bad res_len=$D2 }, \
		14  { trcrpt $D1%D1 nfs4_handle_pathname_moved() failed with restart or stale error=$D2 }, \
		15  { trcrpt $D1%D1 nfs4_handle_pathname_moved() failed other error=$D2 }, \
		16  { trcrpt $D1%D1 error=$D2 }, \
		17  { trcrpt $D1%D1 args_len=$D2 != res_len=$D3 }, \
		18  { trcrpt $D1%D1 bitmap mismatch bitmap4_len=$D2 bitmap4_val=$D3 }, \
		19  { trcrpt $D1%D1 nfs4_handle_pathname_symlink() failed with ERESTART }, \
		20  { trcrpt $D1%D1 nfs4_handle_pathname_symlink() failed with other error=$D2 }, \
		21  { trcrpt $D1%D1 nfs4_alloc_gap() failed with error=$D2 }, \
		22  { trcrpt $D1%D1 AF_FSIDNOTSAME flags=$D2 }, \
		23  { trcrpt $D1%D1 done } }, \
	70 { "NFS4_HANDLE_PN_SYMLINK " \
		$D1, \
		0  { trcrpt $D1%D1 fsidp=$D2 dfhp=$D3 lfhp=$D4 ofhp=$D5 }, \
		1  { trcrpt $D1%D1 flags=$D2 secp=$D3 recur=$D4 cr=$D5 }, \
		2  { trcrpt $D1%D1 too much recursion }, \
		3  { trcrpt $D1%D1 nfs4_get_symlink_fh() failed error=$D2 }, \
		4  { trcrpt $D1%D1 nfs4_lookup_fh() failed error=$D2 }, \
		5  { trcrpt $D1%D1 done } }, \
	71 { "NFS4_GETATTR_FH " \
		$D1, \
		0  { trcrpt $D1%D1 fsidp=$D2 ifhp=$D3 flags=$D4 bpp=$D5 }, \
		1  { trcrpt $D1%D1 secp=$D2 stm=$D3 fattrp=$D4 }, \
		2  { trcrpt $D1%D1 init_compound_args() failed error=$D2 }, \
		3  { trcrpt $D1%D1 rfs4call() failed error=$D2 }, \
		4  { trcrpt $D1%D1 MOVED nodefer }, \
		5  { trcrpt $D1%D1 restart }, \
		6  { trcrpt $D1%D1 WRONGSEC }, \
		7  { trcrpt $D1%D1 error=$D2 }, \
		8  { trcrpt $D1%D1 args_len=$D2 != res_len=$D3 }, \
		9  { trcrpt $D1%D1 bitmap mismatch bitmap4_len=$D2 bitmap4_val=$D3 }, \
		10  { trcrpt $D1%D1 done } }, \
	72 { "NFS4_LOOKUP_ROOTFH " \
		$D1, \
		0  { trcrpt $D1%D1 fsidp=$D2 ofhp=$D3 flags=$D4 secp=$D5 }, \
		1  { trcrpt $D1%D1 rfsid=$D2 cr=$D3 }, \
		2  { trcrpt $D1%D1 init_compound_args() failed error=$D2 }, \
		3  { trcrpt $D1%D1 rfs4call() failed error=$D2 }, \
		4  { trcrpt $D1%D1 EXPIRED }, \
		5  { trcrpt $D1%D1 SYMLINK }, \
		6  { trcrpt $D1%D1 WRONGSEC }, \
		7  { trcrpt $D1%D1 error=$D2 }, \
		8  { trcrpt $D1%D1 args_len=$D2 != res_len=$D3 }, \
		9  { trcrpt $D1%D1 bitmap mismatch bitmap4_len=$D2 bitmap4_val=$D3 }, \
		10  { trcrpt $D1%D1 done } }, \
	73 { "NFS4_ALLOC_GAP " \
		$D1, \
		0  { trcrpt $D1%D1 fsidp=$D2 }, \
		1  { trcrpt $D1%D1 ENOMEM size=$D2 }, \
		2  { trcrpt $D1%D1 ENOMEM size=$D2 }, \
		3  { trcrpt $D1%D1 done new=$D2 name=$D3 } }, \
	74 { "NFS4_FREE_GAP_LIST " \
		$D1, \
		0  { trcrpt $D1%D1 gap=$D2 }, \
		1  { trcrpt $D1%D1 gap=$D2 name=$D3 } }, \
	75 { "NFS4_GAP_2_STR " \
		$D1, \
		0  { trcrpt $D1%D1 gap=$D2 ng_next=$D3 }, \
		1  { trcrpt $D1%D1 done }, \
		2  { trcrpt $D1%D1 ENOMEM size=$D2 }, \
		3  { trcrpt $D1%D1 path=$D2 } }
48B 1.0 "@NFS: nfsrgyd" \
	HT & 0x7, \
	0 { \
		$D1, \
		0e  { "User: " G8 $HD%S1 }, \
		0f  { "Group: " G8 $HD%S1 }, \
		10  { "Principal: " G8 $HD%S1 }, \
		11  { "Hostname: " G8 $HD%S1 }, \
		\* { `str= ` G8 $HD%S1 } \
		$BREAK \
	} \
	$HD%D1, \
	01  { "nfsrgyd NULL op " }, \
	02  { "nfsrgyd Get Cred enter " auth_flavor=$D1%X4 }, \
	03  { "nfsrgyd Get Cred exit  " rc=$D1 uid=$D2%X4 gid=$D3%X4 num_groups=$D4%X4 }, \
	04  { "nfsrgyd IDs to Strings enter " flags=$D1%X4 uid=$D2%X4 gid=$D3%X4 auth_flavor=$D4%X4 }, \
	05  { "nfsrgyd IDs to Strings exit  " rc=$D1 user_len=$D2 group_len=$D3 }, \
	06  { "nfsrgyd Strings to IDs enter " flags=$D1%X4 }, \
	07  { "nfsrgyd Strings to IDs exit  " rc=$D1 uid=$D2%X4 gid=$D3%X4 }, \
	08  { "nfsrgyd Get Sec List enter " list_len=$D1%X4 }, \
	09  { "nfsrgyd Get Sec List exit " rc=$D1 list_len=$D2%X4 }, \
	0a  { "nfsrgyd Get CB Info enter " }, \
	0b  { "nfsrgyd Get CB Info exit " rc=$D1 }, \
	0c  { "nfsrgyd Host to IP enter " flags=$D1%X4 }, \
	0d  { "nfsrgyd Host to IP exit " rc=$D1 }
48C 1.0 "@NFS Name Registry Service" \
	$HOOKENV, \
	32 { \
	    HT & 0x7, \
	    0 { \
		$D1%D1, \
		13  { "User: " G8 $HD%S1 }, \
		14  { "Group: " G8 $HD%S1 }, \
		15  { "Principal: " G8 $HD%S1 }, \
		16  { "Hostname: " G8 $HD%S1 }, \
		\* { `str= ` G8 $HD%S1 } \
		$BREAK \
	    } \
	}, \
	64 { \
	    HT & 0x4000, \
	    0x4000 { \
		$D1%D1, \
		13  { "User: " G16 $HL%S1 }, \
		14  { "Group: " G16 $HL%S1 }, \
		15  { "Principal: " G16 $HL%S1 }, \
		16  { "Hostname: " G16 $HL%S1 }, \
		\* { `str= ` G16 $HL%S1 } \
		$BREAK \
	    } \
	} \
	$HD%D1, \
	01  { "NFS NRS IDs to Strings enter " flags=$D1%X4 uid=$D2%D1 gid=$D3%D1 }, \
	02  { "NFS NRS IDs to Strings exit  " rc=$D1 user_len=$D2%D1 group_len=$D3%D1 }, \
	03  { "NFS NRS Strings to IDs enter " flags=$D1%X4 }, \
	04  { "NFS NRS Strings to IDs exit  " rc=$D1 uid=$D2%D1 gid=$D3%D1 }, \
	05  { "NFS NRS Principal to Cred enter " flags=$D1%X4 auth_flavor=$D2%D1 }, \
	06  { "NFS NRS Principal to Cred exit  " principal=$D1 rc=$D2 }, \
	07  { "NFS NRS Get Sec List enter " flags=$D1%X4 list_len=$D2%D1 }, \
	08  { "NFS NRS Get Sec List exit  " rc=$D1 list_len=$D2%D1 }, \
	09  { "NFS NRS Get CB Info enter " flags=$D1%X4 principal_len=$D2%D1 }, \
	10  { "NFS NRS Get CB Info exit  " rc=$D1 principal_len=$D2%D1 }, \
	11  { "NFS NRS Get IP Addr enter " flags=$D1%X4 }, \
	12  { "NFS NRS Get IP Addr exit  " rc=$D1 }, \
	19  { "User name error  " user=$D1%XW }, \
	20  { "Group name error  " group=$D1%XW }, \
	21  { "Principal name error  " principal=$D1%XW }, \
	22  { "Host name error  " host=$D1%XW }, \
	23  { "Cannot contact rgyd  " error=$D1 }
48D 1.0 "@NFS Version 4 Server" \
{{ \
nfs4op(opnum) \
$opnum%D1, \
	3  { ACCESS }, \
	4  { CLOSE }, \
	5  { COMMIT }, \
	6  { CREATE }, \
	7  { DELEGPURGE }, \
	8  { DELEGRETURN }, \
	9  { GETATTR }, \
	10 { GETFH }, \
	11 { LINK }, \
	12 { LOCK }, \
	13 { LOCKT }, \
	14 { LOCKU }, \
	15 { LOOKUP }, \
	16 { LOOKUPP }, \
	17 { NVERIFY }, \
	18 { OPEN }, \
	19 { OPENATTR }, \
	20 { OPEN_CONFIRM }, \
	21 { OPEN_DOWNGRADE }, \
	22 { PUTFH }, \
	23 { PUTPUBFH }, \
	24 { PUTROOTFH }, \
	25 { READ }, \
	26 { READDIR }, \
	27 { READLINK }, \
	28 { REMOVE }, \
	29 { RENAME }, \
	30 { RENEW }, \
	31 { RESTOREFH }, \
	32 { SAVEFH }, \
	33 { SECINFO }, \
	34 { SETATTR }, \
	35 { SETCLIENTID }, \
	36 { SETCLIENTID_CONFIRM }, \
	37 { VERIFY }, \
	38 { WRITE }, \
	39 { RELEASE_LOCKOWNER }, \
	10044 { ILLEGAL }, \
        \* { $opnum } \
}} \
	"RFS4" \
	$HD%D1, \
	1  { "DISP_ENTRY    "  XID=$D1 client=sinaddr($D2) starttimer(0x48D,$D1) }, \
	2  { "Null Procedure "  XID=$D1 }, \
	3  { "Bad Procedure "  XID=$D1 proc=$D2 }, \
	4  { "COMPOUND4args bad XDR " XID=$D1 }, \
	5  { "Call State Init failed " XID=$D1 }, \
	6  { "Operation bad XDR " XID=$D1 op=nfs4op($D2) }, \
	7  { "Bad Operation " XID=$D1 op=nfs4op($D2) }, \
	8  { "Anonymous ID not allowed " XID=$D1 flavor=$D2 }, \
	9  { "XDR buffer too small for reply "  XID=$D1 }, \
	10 { "Invalid op combination " XID=$D1 }, \
	11 { "Call dropped - in progress " XID=$D1 }, \
	12 { "Duplicate call " XID=$D1 }, \
	13 { "Dup cache error " XID=$D1 dupstat=$D2 }, \
	14 { "DISP_OP_ENTER " XID=$D1 flags=$D2 "             " client=sinaddr($D4) op=nfs4op($D3) starttimer($D1,0x48D) }, \
	15 { "DISP_OP_EXIT  " XID=$D1 flags=$D2 status=$D3 client=sinaddr($D5) op=nfs4op($D4) endtimer($D1,0x48D) }, \
	16 { "DISP_EXIT     " XID=$D1 client=sinaddr($D2) endtimer(0x48D,$D1) }, \
	17 { "Resource error " XID=$D1 op=nfs4op($D2) location=$D3%X4 }, \
	18 { "Server fault " XID=$D1 location=$D2%X4 error=$D3 }, \
	19 { "Export enter " }, \
	20 { "Export exit " vnode=$D1%X4 error=$D2 }, \
	21 { "Unexport enter " }, \
	22 { "Unexport exit "  error=$D1 }, \
	23 { "Unexported " vp=$D1 pfsp=$D2 }, \
	24 { "DISP_OP_EXIT  " trcex=$D1 current vnode=$D2 }
493 1.0 "@NFSv4 State Manager" \
	"SM4 Norm  : " \
	$D1, \
	0x5343494200000000 { W1 A4.8 W2 "Set Clientid BEGIN :"  "args ptr=" XW}, \
	0x53434942         { W1 A4.8 W2 "Set Clientid BEGIN :"  "args ptr=" XW}, \
	0x5343494500000000 { W1 A4.8 W2 "Set Clientid END :"  "CR ptr=" XW  "CR LRU tail ptr=" XW  "CR ndx=" XW}, \
	0x53434945         { W1 A4.8 W2 "Set Clientid END :"  "CR ptr=" XW  "CR LRU tail ptr=" XW  "CR ndx=" XW}, \
	0x5343497000000000 { W1 A4.8 W2 "Set Clientid Previous Instance return :"  "rc= " XW  "CR ptr= " XW  "p_cr->state= " XW}, \
	0x53434970         { W1 A4.8 W2 "Set Clientid Previous Instance return :"  "rc= " XW  "CR ptr= " XW  "p_cr->state= " XW}, \
	0x5343434200000000 { W1 A4.8 W2 "Set Clientid Confirm BEGIN :"  "CLID verifier=" XW  "CLID ndx=" XW  "CLID gen=" XW}, \
	0x53434342         { W1 A4.8 W2 "Set Clientid Confirm BEGIN :"  "CLID verifier=" XW  "CLID ndx=" XW  "CLID gen=" XW}, \
	0x5343434500000000 { W1 A4.8 W2 "Set Clientid Confirm END :"  "rc=" XW  "CR ptr=" XW  "p_cr->state=" XW}, \
	0x53434345         { W1 A4.8 W2 "Set Clientid Confirm END :"  "rc=" XW  "CR ptr=" XW  "p_cr->state=" XW}, \
	0x526E774200000000 { W1 A4.8 W2 "Renew Clientid BEGIN :"  "verifier=" XW  "CR ndx=" XW  "CR gen=" XW}, \
	0x526E7742         { W1 A4.8 W2 "Renew Clientid BEGIN :"  "verifier=" XW  "CR ndx=" XW  "CR gen=" XW}, \
	0x526E774500000000 { W1 A4.8 W2 "Renew Clientid END :"  "rc=" XW  "CR ptr=" XW  "CR state= " XW}, \
	0x526E7745         { W1 A4.8 W2 "Renew Clientid END :"  "rc=" XW  "CR ptr=" XW  "CR state= " XW}, \
	0x5343724200000000 { W1 A4.8 W2 "Start Create BEGIN :"  "VFS ptr=" XW  "VFS cookie=" XW}, \
	0x53437242         { W1 A4.8 W2 "Start Create BEGIN :"  "VFS ptr=" XW  "VFS cookie=" XW}, \
	0x5343724500000000 { W1 A4.8 W2 "Start Create END :"  "CR ptr=" XW  "OO ptr=" XW  "open handle=" XW}, \
	0x53437245         { W1 A4.8 W2 "Start Create END :"  "CR ptr=" XW  "OO ptr=" XW  "open handle=" XW}, \
	0x4543724200000000 { W1 A4.8 W2 "End Create BEGIN :"  "Parent VNODE=" XW  "open handle=" XW  "file create state=" XW}, \
	0x45437242         { W1 A4.8 W2 "End Create BEGIN :"  "Parent VNODE=" XW  "open handle=" XW  "file create state=" XW}, \
	0x4543724500000000 { W1 A4.8 W2 "End Create END :"  "OO ptr=" XW  "OR ptr=" XW  "FR ptr=" XW}, \
	0x45437245         { W1 A4.8 W2 "End Create END :"  "OO ptr=" XW  "OR ptr=" XW  "FR ptr=" XW}, \
	0x534F704200000000 { W1 A4.8 W2 "Start Open BEGIN :"  "VFS ptr=" XW  "VFS cookie=" XW  "FID=" XW}, \
	0x534F7042         { W1 A4.8 W2 "Start Open BEGIN :"  "VFS ptr=" XW  "VFS cookie=" XW  "FID=" XW}, \
	0x534F704500000000 { W1 A4.8 W2 "Start Open END :"  "CR ptr=" XW  "OO ptr=" XW  "OO state=" XW}, \
	0x534F7045         { W1 A4.8 W2 "Start Open END :"  "CR ptr=" XW  "OO ptr=" XW  "OO state=" XW}, \
	0x454F704200000000 { W1 A4.8 W2 "End Open BEGIN :"  "VFS ptr=" XW  "VFS cookie=" XW  "open handle=" XW}, \
	0x454F7042         { W1 A4.8 W2 "End Open BEGIN :"  "VFS ptr=" XW  "VFS cookie=" XW  "open handle=" XW}, \
	0x454F704500000000 { W1 A4.8 W2 "End Open END :"  "OR ptr=" XW  "OO ptr=" XW  "XVFS cookie ptr=" XW}, \
	0x454F7045         { W1 A4.8 W2 "End Open END :"  "OR ptr=" XW  "OO ptr=" XW  "XVFS cookie ptr=" XW}, \
	0x4F65724200000000 { W1 A4.8 W2 "Open error BEGIN :"  "seqid=" XW  "error=" XW  "CLID ndx=" XW}, \
	0x4F657242         { W1 A4.8 W2 "Open error BEGIN :"  "seqid=" XW  "error=" XW  "CLID ndx=" XW}, \
	0x4F65724500000000 { W1 A4.8 W2 "Open error END :"  "CR ptr=" XW  "OO ptr=" XW  "OO open seqid=" XW}, \
	0x4F657245         { W1 A4.8 W2 "Open error END :"  "CR ptr=" XW  "OO ptr=" XW  "OO open seqid=" XW}, \
	0x424F704200000000 { W1 A4.8 W2 "Cleanup Open BEGIN :"  "handle=" XW  "error=" XW  "FID=" XW}, \
	0x424F7042         { W1 A4.8 W2 "Cleanup Open BEGIN :"  "handle=" XW  "error=" XW  "FID=" XW}, \
	0x424F704500000000 { W1 A4.8 W2 "Cleanup Open END :"  "CR ptr=" XW  "OO ptr=" XW  "OO open seqid=" XW}, \
	0x424F7045         { W1 A4.8 W2 "Cleanup Open END :"  "CR ptr=" XW  "OO ptr=" XW  "OO open seqid=" XW}, \
	0x4343724200000000 { W1 A4.8 W2 "Cleanup Create BEGIN :"  "handle=" XW  "error=" XW  "VFS=" XW}, \
	0x43437242         { W1 A4.8 W2 "Cleanup Create BEGIN :"  "handle=" XW  "error=" XW  "VFS=" XW}, \
	0x4343724300000000 { W1 A4.8 W2 "Cleanup Create trc pt cont :"  "Parent dir=" XW  "New file=" XW}, \
	0x43437243         { W1 A4.8 W2 "Cleanup Create trc pt cont :"  "Parent dir=" XW  "New file=" XW}, \
	0x4343724500000000 { W1 A4.8 W2 "Cleanup Create END :"  "XVFS ptr=" XW  "XVFS cookie ptr=" XW  "CR ptr=" XW}, \
	0x43437245         { W1 A4.8 W2 "Cleanup Create END :"  "XVFS ptr=" XW  "XVFS cookie ptr=" XW  "CR ptr=" XW}, \
	0x4F436E4200000000 { W1 A4.8 W2 "Open Confirm BEGIN :"  "FID=" XW  "VNODE=" XW  "STID ptr=" XW}, \
	0x4F436E42         { W1 A4.8 W2 "Open Confirm BEGIN :"  "FID=" XW  "VNODE=" XW  "STID ptr=" XW}, \
	0x4F436E4500000000 { W1 A4.8 W2 "Open Confirm END :"  "CR ptr=" XW  "OO ptr=" XW  "OR ptr=" XW}, \
	0x4F436E45         { W1 A4.8 W2 "Open Confirm END :"  "CR ptr=" XW  "OO ptr=" XW  "OR ptr=" XW}, \
	0x44776E4200000000 { W1 A4.8 W2 "Open Downgrade BEGIN :"  "FID=" XW  "VNODE=" XW  "stateid ptr=" XW}, \
	0x44776E42         { W1 A4.8 W2 "Open Downgrade BEGIN :"  "FID=" XW  "VNODE=" XW  "stateid ptr=" XW}, \
	0x44776E4500000000 { W1 A4.8 W2 "Open Downgrade END :"  "rc=" XW  "OO ptr=" XW  "OR ptr=" XW}, \
	0x44776E45         { W1 A4.8 W2 "Open Downgrade END :"  "rc=" XW  "OO ptr=" XW  "OR ptr=" XW}, \
	0x53494F4200000000 { W1 A4.8 W2 "Start I/O BEGIN :"  "args ptr=" XW  "FID ptr=" XW  "VNODE=" XW}, \
	0x53494F42         { W1 A4.8 W2 "Start I/O BEGIN :"  "args ptr=" XW  "FID ptr=" XW  "VNODE=" XW}, \
	0x53494F4500000000 { W1 A4.8 W2 "Start I/O END :"  "FR ptr=" XW  "OR ptr=" XW  "rc=" XW}, \
	0x53494F45         { W1 A4.8 W2 "Start I/O END :"  "FR ptr=" XW  "OR ptr=" XW  "rc=" XW}, \
	0x45494F4200000000 { W1 A4.8 W2 "End I/O BEGIN :"  "handle=" XW  "STID ndx=" XW  "STID gen=" XW}, \
	0x45494F42         { W1 A4.8 W2 "End I/O BEGIN :"  "handle=" XW  "STID ndx=" XW  "STID gen=" XW}, \
	0x45494F4500000000 { W1 A4.8 W2 "End I/O END :"  "FR ptr=" XW  "special STID=" XW  "rc=" XW}, \
	0x45494F45         { W1 A4.8 W2 "End I/O END :"  "FR ptr=" XW  "special STID=" XW  "rc=" XW}, \
	0x436C734200000000 { W1 A4.8 W2 "Close BEGIN :"  "VFS ptr=" XW  "FID=" XW  "VNODE=" XW}, \
	0x436C7342         { W1 A4.8 W2 "Close BEGIN :"  "VFS ptr=" XW  "FID=" XW  "VNODE=" XW}, \
	0x436C734500000000 { W1 A4.8 W2 "Close END :"  "CR ptr=" XW  "OO ptr=" XW  "OR ptr=" XW}, \
	0x436C7345         { W1 A4.8 W2 "Close END :"  "CR ptr=" XW  "OO ptr=" XW  "OR ptr=" XW}, \
	0x436C734300000000 { W1 A4.8 W2 "Close trc pt cont :"  "Stateid=" XW  "Seqid=" XW  "sm4_close_t=" XW}, \
	0x436C7343         { W1 A4.8 W2 "Close trc pt cont :"  "Stateid=" XW  "Seqid=" XW  "sm4_close_t=" XW}, \
	0x4C636B4200000000 { W1 A4.8 W2 "Lock BEGIN :"  "VNODE=" XW  "lock type=" XW  "reclaim=" XW}, \
	0x4C636B42         { W1 A4.8 W2 "Lock BEGIN :"  "VNODE=" XW  "lock type=" XW  "reclaim=" XW}, \
	0x4C636B3500000000 { W1 A4.8 W2 "Lock trc pt cont :"  "FID=" XW  "fid_ino=" XW  "fid_gen=" XW}, \
	0x4C636B35         { W1 A4.8 W2 "Lock trc pt cont :"  "FID=" XW  "fid_ino=" XW  "fid_gen=" XW}, \
	0x4C636B3600000000 { W1 A4.8 W2 "Lock trc pt cont :"  "File Mode=" XW  "sm4_lock_t=" XW  "locker4=" XW}, \
	0x4C636B36         { W1 A4.8 W2 "Lock trc pt cont :"  "File Mode=" XW  "sm4_lock_t=" XW  "locker4=" XW}, \
	0x4C636B3700000000 { W1 A4.8 W2 "Lock trc pt cont :"  "Offset=" XW}, \
	0x4C636B37         { W1 A4.8 W2 "Lock trc pt cont :"  "Offset=" XW}, \
	0x4C636B3800000000 { W1 A4.8 W2 "Lock trc pt cont :"  "Length=" XW}, \
	0x4C636B38         { W1 A4.8 W2 "Lock trc pt cont :"  "Length=" XW}, \
	0x4C636B4500000000 { W1 A4.8 W2 "Lock END :"  "rc=" XW  "FR ptr=" XW}, \
	0x4C636B45         { W1 A4.8 W2 "Lock END :"  "rc=" XW  "FR ptr=" XW}, \
	0x4C65724200000000 { W1 A4.8 W2 "Lock error BEGIN :"  "args=" XW  "error=" XW}, \
	0x4C657242         { W1 A4.8 W2 "Lock error BEGIN :"  "args=" XW  "error=" XW}, \
	0x4C65724500000000 { W1 A4.8 W2 "Lock error END :"  "rc=" XW  "bump=" XW}, \
	0x4C657245         { W1 A4.8 W2 "Lock error END :"  "rc=" XW  "bump=" XW}, \
	0x4C6B754200000000 { W1 A4.8 W2 "UnLock BEGIN :"  "VNODE=" XW  "lock type=" XW  "FID ptr=" XW}, \
	0x4C6B7542         { W1 A4.8 W2 "UnLock BEGIN :"  "VNODE=" XW  "lock type=" XW  "FID ptr=" XW}, \
	0X4C6B753700000000 { W1 A4.8 W2 "UnLock trc pt cont :"  "fid_ino=" XW  "fid_gen=" XW  "Seqid=" XW}, \
	0X4C6B7537         { W1 A4.8 W2 "UnLock trc pt cont :"  "fid_ino=" XW  "fid_gen=" XW  "Seqid=" XW}, \
	0X4C6B753800000000 { W1 A4.8 W2 "UnLock trc pt cont :"  "Offset=" XW}, \
	0X4C6B7538         { W1 A4.8 W2 "UnLock trc pt cont :"  "Offset=" XW}, \
	0X4C6B753900000000 { W1 A4.8 W2 "UnLock trc pt cont :"  "Length=" XW}, \
	0X4C6B7539         { W1 A4.8 W2 "UnLock trc pt cont :"  "Length=" XW}, \
	0x4C6B754500000000 { W1 A4.8 W2 "UnLock END :"  "rc=" XW  "OR ptr=" XW  "Lock Owner ptr=" XW}, \
	0x4C6B7545         { W1 A4.8 W2 "UnLock END :"  "rc=" XW  "OR ptr=" XW  "Lock Owner ptr=" XW}, \
	0x4C65754200000000 { W1 A4.8 W2 "UnLock error BEGIN :"  "args=" XW  "error=" XW}, \
	0x4C657542         { W1 A4.8 W2 "UnLock error BEGIN :"  "args=" XW  "error=" XW}, \
	0x4C65754500000000 { W1 A4.8 W2 "UnLock error END :"  "rc=" XW  "CR ptr=" XW  "LO ptr=" XW}, \
	0x4C657545         { W1 A4.8 W2 "UnLock error END :"  "rc=" XW  "CR ptr=" XW  "LO ptr=" XW}, \
	0x4C63544200000000 { W1 A4.8 W2 "Lock TEST BEGIN :"  "VNODE=" XW  "lock type=" XW}, \
	0x4C635442         { W1 A4.8 W2 "Lock TEST BEGIN :"  "VNODE=" XW  "lock type=" XW}, \
	0x4C63546400000000 { W1 A4.8 W2 "Lock TEST trc pt cont :"  "FID=" XW  "fid_ino=" XW  "fid_gen=" XW}, \
	0x4C635464         { W1 A4.8 W2 "Lock TEST trc pt cont :"  "FID=" XW  "fid_ino=" XW  "fid_gen=" XW}, \
	0x4C63546500000000 { W1 A4.8 W2 "Lock TEST trc pt cont :"  "File mode=" XW  "Offset=" XW}, \
	0x4C635465         { W1 A4.8 W2 "Lock TEST trc pt cont :"  "File mode=" XW  "Offset=" XW}, \
	0x4C63546600000000 { W1 A4.8 W2 "Lock TEST trc pt cont :"  "Length=" XW}, \
	0x4C635466         { W1 A4.8 W2 "Lock TEST trc pt cont :"  "Length=" XW}, \
	0x4C63544500000000 { W1 A4.8 W2 "Lock TEST END :"  "rc=" XW  "CR ptr=" XW  "LO ptr=" XW}, \
	0x4C635445         { W1 A4.8 W2 "Lock TEST END :"  "rc=" XW  "CR ptr=" XW  "LO ptr=" XW}, \
	0x726C6F4200000000 { W1 A4.8 W2 "Release Lockowner BEGIN :"  "args=" XW  "CR ndx=" XW  "CR gen=" XW}, \
	0x726C6F42         { W1 A4.8 W2 "Release Lockowner BEGIN :"  "args=" XW  "CR ndx=" XW  "CR gen=" XW}, \
	0x726C6F4500000000 { W1 A4.8 W2 "Release Lockowner END :"  "rc=" XW  "CR ptr=" XW  "release count=" XW}, \
	0x726C6F45         { W1 A4.8 W2 "Release Lockowner END :"  "rc=" XW  "CR ptr=" XW  "release count=" XW}, \
	0x5276664200000000 { W1 A4.8 W2 "Register VFS BEGIN :"  "VFS=" XW  "cookie=" XW}, \
	0x52766642         { W1 A4.8 W2 "Register VFS BEGIN :"  "VFS=" XW  "cookie=" XW}, \
	0x5276664500000000 { W1 A4.8 W2 "Register VFS END :"  "XVFS ptr=" XW  "Cookie ptr=" XW  "XVFS cookie count=" XW}, \
	0x52766645         { W1 A4.8 W2 "Register VFS END :"  "XVFS ptr=" XW  "Cookie ptr=" XW  "XVFS cookie count=" XW}, \
	0x5576664200000000 { W1 A4.8 W2 "Un-Register VFS BEGIN :"  "VFS=" XW  "cookie="XW  "force=" XW}, \
	0x55766642         { W1 A4.8 W2 "Un-Register VFS BEGIN :"  "VFS=" XW  "cookie="XW  "force=" XW}, \
	0x5576664500000000 { W1 A4.8 W2 "Un-Register VFS END :"  "XVFS cookies=" XW  "XVFS ptr=" XW  "force=" XW}, \
	0x55766645         { W1 A4.8 W2 "Un-Register VFS END :"  "XVFS cookies=" XW  "XVFS ptr=" XW  "force=" XW}, \
	0x434C534200000000 { W1 A4.8 W2 "Clear Statistics BEGIN :"  "sm4_stats=" XW}, \
	0x434C5342         { W1 A4.8 W2 "Clear Statistics BEGIN :"  "sm4_stats=" XW}, \
	0x434C534500000000 { W1 A4.8 W2 "Clear Statistics END :"  "sm4_stats=" XW}, \
	0x434C5345         { W1 A4.8 W2 "Clear Statistics END :"  "sm4_stats=" XW}, \
	0x476C744200000000 { W1 A4.8 W2 "Get Lease Time BEGIN :"}, \
	0x476C7442         { W1 A4.8 W2 "Get Lease Time BEGIN :"}, \
	0x476C744500000000 { W1 A4.8 W2 "Get Lease Time END :"  "lease time=" XW}, \
	0x476C7445         { W1 A4.8 W2 "Get Lease Time END :"  "lease time=" XW}, \
	0x7073734200000000 { W1 A4.8 W2 "Purge Stale State BEGIN :"  "VFS=" XW  "FID=" XW  "fid_ino=" XW}, \
	0x70737342         { W1 A4.8 W2 "Purge Stale State BEGIN :"  "VFS=" XW  "FID=" XW  "fid_ino=" XW}, \
	0x7073734500000000 { W1 A4.8 W2 "Purge Stale State END :"  "XVFS ptr=" XW  "FR ptr=" XW  "p_fr->state=" XW}, \
	0x70737345         { W1 A4.8 W2 "Purge Stale State END :"  "XVFS ptr=" XW  "FR ptr=" XW  "p_fr->state=" XW}, \
	0x77646A4200000000 { W1 A4.8 W2 "Work Item Do Job BEGIN :"  "work item=" XW  "type=" XW  "data ptr=" XW}, \
	0x77646A42         { W1 A4.8 W2 "Work Item Do Job BEGIN :"  "work item=" XW  "type=" XW  "data ptr=" XW}, \
	0x77646A4500000000 { W1 A4.8 W2 "Work Item Do Job END :"  "enque time=" XW  "completion time=" XW  "next wi=" XW}, \
	0x77646A45         { W1 A4.8 W2 "Work Item Do Job END :"  "enque time=" XW  "completion time=" XW  "next wi=" XW}, \
	0x636C6E3100000000 { W1 A4.8 W2 "Cleanup client :"  "CR ptr=" XW  "pend_cnt=" XW  "CR gen=" XW}, \
	0x636C6E31         { W1 A4.8 W2 "Cleanup client :"  "CR ptr=" XW  "pend_cnt=" XW  "CR gen=" XW}, \
	0x76726B4200000000 { W1 A4.8 W2 "Revoke VCM rights BEGIN :"  "handle=" XW  "rights=" XW  "FR ptr=" XW}, \
	0x76726B42         { W1 A4.8 W2 "Revoke VCM rights BEGIN :"  "handle=" XW  "rights=" XW  "FR ptr=" XW}, \
	0x76726B3100000000 { W1 A4.8 W2 "Revoke VCM rights trc cont :"  "p_fr->state=" XW  "flags=" XW  "tag=" XW}, \
	0x76726B31         { W1 A4.8 W2 "Revoke VCM rights trc cont :"  "p_fr->state=" XW  "flags=" XW  "tag=" XW}, \
	0x76726B4500000000 { W1 A4.8 W2 "Revoke VCM rights END :"  "rc=" XW  "p_fr->state=" XW  "p_fr->vcm_rights =" XW}, \
	0x76726B45         { W1 A4.8 W2 "Revoke VCM rights END :"  "rc=" XW  "p_fr->state=" XW  "p_fr->vcm_rights =" XW}, \
        \*                 { W1 A4.8 W2 "d1=" XW  "d2=" XW  "d3=" XW }
494 1.0 "@NFSv4 State Manager" \
	"SM4 ERROR : " \
	$D1, \
	0x496E693100000000 { W1 A4.8 W2 "SM4 Init :"}, \
	0x496E6931         { W1 A4.8 W2 "SM4 Init :"}, \
	0x54726D3100000000 { W1 A4.8 W2 "Terminate SM4 :"  "rc=" XW  "xvfs cookies=" XW}, \
	0x54726D31         { W1 A4.8 W2 "Terminate SM4 :"  "rc=" XW  "xvfs cookies=" XW}, \
	0x5343495800000000 { W1 A4.8 W2 "Set Clientid :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x53434958         { W1 A4.8 W2 "Set Clientid :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x6D63653100000000 { W1 A4.8 W2 "Mark CR expired :"  "CR ptr=" XW  "CR state=" XW}, \
	0x6D636531         { W1 A4.8 W2 "Mark CR expired :"  "CR ptr=" XW  "CR state=" XW}, \
	0x6763695800000000 { W1 A4.8 W2 "Set Security Info :"  "Line=" DW  "rc=" XW}, \
	0x67636958         { W1 A4.8 W2 "Set Security Info :"  "Line=" DW  "rc=" XW}, \
	0x5343433100000000 { W1 A4.8 W2 "Set Clientid Confirm :"  "rc=" XW}, \
	0x53434331         { W1 A4.8 W2 "Set Clientid Confirm :"  "rc=" XW}, \
	0x5343433200000000 { W1 A4.8 W2 "Set Clientid Confirm :"  "rc=" XW  "CR ptr=" XW  "CR state=" XW}, \
	0x53434332         { W1 A4.8 W2 "Set Clientid Confirm :"  "rc=" XW  "CR ptr=" XW  "CR state=" XW}, \
	0x5343435800000000 { W1 A4.8 W2 "Set Clientid Confirm :"  "Line=" DW  "rc=" XW  "CR ptr=" XW}, \
	0x53434358         { W1 A4.8 W2 "Set Clientid Confirm :"  "Line=" DW  "rc=" XW  "CR ptr=" XW}, \
	0x5343433300000000 { W1 A4.8 W2 "Set Clientid Confirm :"  "rc=" XW  "CR ptr=" XW  "CR state=" XW}, \
	0x53434333         { W1 A4.8 W2 "Set Clientid Confirm :"  "rc=" XW  "CR ptr=" XW  "CR state=" XW}, \
	0x526E773100000000 { W1 A4.8 W2 "Renew Clientid :"  "rc=" XW}, \
	0x526E7731         { W1 A4.8 W2 "Renew Clientid :"  "rc=" XW}, \
	0x526E773200000000 { W1 A4.8 W2 "Renew Clientid :"  "CR ptr=" XW  "Sec flavor=" XW  "UID=" XW}, \
	0x526E7732         { W1 A4.8 W2 "Renew Clientid :"  "CR ptr=" XW  "Sec flavor=" XW  "UID=" XW}, \
	0x4166723100000000 { W1 A4.8 W2 "Allocate FR :"  "rc=" XW  "CR Marker=" XW  "FR free cnt=" XW}, \
	0x41667231         { W1 A4.8 W2 "Allocate FR :"  "rc=" XW  "CR Marker=" XW  "FR free cnt=" XW}, \
	0x416F6F3700000000 { W1 A4.8 W2 "Allocate OO :"  "rc=" XW  "CR Marker=" XW  "OO free cnt=" XW}, \
	0x416F6F37         { W1 A4.8 W2 "Allocate OO :"  "rc=" XW  "CR Marker=" XW  "OO free cnt=" XW}, \
	0x416F723100000000 { W1 A4.8 W2 "Allocate OR :"  "rc=" XW  "CR Marker=" XW  "OR free cnt=" XW}, \
	0x416F7231         { W1 A4.8 W2 "Allocate OR :"  "rc=" XW  "CR Marker=" XW  "OR free cnt=" XW}, \
	0x4163723100000000 { W1 A4.8 W2 "Allocate CR :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x41637231         { W1 A4.8 W2 "Allocate CR :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x416C6F5800000000 { W1 A4.8 W2 "Allocate LO :"  "Line=" DW  "rc=" XW  "CR Marker=" XW}, \
	0x416C6F58         { W1 A4.8 W2 "Allocate LO :"  "Line=" DW  "rc=" XW  "CR Marker=" XW}, \
	0x5243495800000000 { W1 A4.8 W2 "Revoke Clientid :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x52434958         { W1 A4.8 W2 "Revoke Clientid :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x5243493500000000 { W1 A4.8 W2 "Revoke Clientid :"  "rc=" XW  "ndx=" XW  "offset=" XW}, \
	0x52434935         { W1 A4.8 W2 "Revoke Clientid :"  "rc=" XW  "ndx=" XW  "offset=" XW}, \
	0x5243493600000000 { W1 A4.8 W2 "Revoke Clientid :"  "rc=" XW  "CR gen=" XW  "clid gen=" XW}, \
	0x52434936         { W1 A4.8 W2 "Revoke Clientid :"  "rc=" XW  "CR gen=" XW  "clid gen=" XW}, \
	0x7276663100000000 { W1 A4.8 W2 "Revoke VFS :"  "rc=" XW  "xvfs hash=" XW}, \
	0x72766631         { W1 A4.8 W2 "Revoke VFS :"  "rc=" XW  "xvfs hash=" XW}, \
	0x7276663200000000 { W1 A4.8 W2 "Revoke VFS :"  "XVFS ptr=" XW  "cookie=" XW  "xvfs hash=" XW}, \
	0x72766632         { W1 A4.8 W2 "Revoke VFS :"  "XVFS ptr=" XW  "cookie=" XW  "xvfs hash=" XW}, \
	0x436C733200000000 { W1 A4.8 W2 "Close :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x436C7332         { W1 A4.8 W2 "Close :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x436C733300000000 { W1 A4.8 W2 "Close :"  "rc=" XW  "OO seqid=" XW  "seqid=" XW}, \
	0x436C7333         { W1 A4.8 W2 "Close :"  "rc=" XW  "OO seqid=" XW  "seqid=" XW}, \
	0x436C734F00000000 { W1 A4.8 W2 "Close :"  "Line=" DW  "OO ptr=" XW  "data=" XW}, \
	0x436C734F         { W1 A4.8 W2 "Close :"  "Line=" DW  "OO ptr=" XW  "data=" XW}, \
	0x436C735200000000 { W1 A4.8 W2 "Close :"  "Line=" DW  "OR ptr=" XW  "data=" XW}, \
	0x436C7352         { W1 A4.8 W2 "Close :"  "Line=" DW  "OR ptr=" XW  "data=" XW}, \
	0x436C734600000000 { W1 A4.8 W2 "Close :"  "Line=" DW  "FR ptr=" XW  "data=" XW}, \
	0x436C7346         { W1 A4.8 W2 "Close :"  "Line=" DW  "FR ptr=" XW  "data=" XW}, \
	0x436C735800000000 { W1 A4.8 W2 "Close :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x436C7358         { W1 A4.8 W2 "Close :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x5343725800000000 { W1 A4.8 W2 "Start Create :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x53437258         { W1 A4.8 W2 "Start Create :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x5343723200000000 { W1 A4.8 W2 "Start Create :"  "rc=" XW  "Parent dir=" XW  "New file=" XW}, \
	0x53437232         { W1 A4.8 W2 "Start Create :"  "rc=" XW  "Parent dir=" XW  "New file=" XW}, \
	0x5443725800000000 { W1 A4.8 W2 "End Create :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x54437258         { W1 A4.8 W2 "End Create :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x53494F3500000000 { W1 A4.8 W2 "Start IO :"  "rc=" XW  "OR ptr=" XW  "FR ptr=" XW}, \
	0x53494F35         { W1 A4.8 W2 "Start IO :"  "rc=" XW  "OR ptr=" XW  "FR ptr=" XW}, \
	0x53494F3200000000 { W1 A4.8 W2 "End IO :"  "FR ptr=" XW  "OR ptr=" XW  "rc=" XW}, \
	0x53494F32         { W1 A4.8 W2 "End IO :"  "FR ptr=" XW  "OR ptr=" XW  "rc=" XW}, \
	0x4C636B3100000000 { W1 A4.8 W2 "Lock :"  "rc=" XW}, \
	0x4C636B31         { W1 A4.8 W2 "Lock :"  "rc=" XW}, \
	0x4C636B3200000000 { W1 A4.8 W2 "Lock :"  "rc=" XW}, \
	0x4C636B32         { W1 A4.8 W2 "Lock :"  "rc=" XW}, \
	0x4C636B3300000000 { W1 A4.8 W2 "Lock :"  "rc=" XW}, \
	0x4C636B33         { W1 A4.8 W2 "Lock :"  "rc=" XW}, \
	0x4C636B3400000000 { W1 A4.8 W2 "Lock :"  "rc=" XW  "FID hash=" XW  "FR hash=" XW}, \
	0x4C636B34         { W1 A4.8 W2 "Lock :"  "rc=" XW  "FID hash=" XW  "FR hash=" XW}, \
	0x4C63543300000000 { W1 A4.8 W2 "Lock Test :"  "rc=" XW}, \
	0x4C635433         { W1 A4.8 W2 "Lock Test :"  "rc=" XW}, \
	0x4C63543400000000 { W1 A4.8 W2 "Lock Test :"  "rc=" XW}, \
	0x4C635434         { W1 A4.8 W2 "Lock Test :"  "rc=" XW}, \
	0x4C63543500000000 { W1 A4.8 W2 "Lock Test :"  "rc=" XW}, \
	0x4C635435         { W1 A4.8 W2 "Lock Test :"  "rc=" XW}, \
	0x4C63543600000000 { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "CR ptr=" XW}, \
	0x4C635436         { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "CR ptr=" XW}, \
	0x4C63546100000000 { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "CR ptr=" XW  "CR state=" XW}, \
	0x4C635461         { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "CR ptr=" XW  "CR state=" XW}, \
	0x4C63546200000000 { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "vnode=" XW  "LO ptr=" XW}, \
	0x4C635462         { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "vnode=" XW  "LO ptr=" XW}, \
	0x4C63546300000000 { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "Lock sysid=" XW  "Lock PID=" XW}, \
	0x4C635463         { W1 A4.8 W2 "Lock Test :"  "rc=" XW  "Lock sysid=" XW  "Lock PID=" XW}, \
	0x4C63545800000000 { W1 A4.8 W2 "Lock Test :"  "Line=" DW  "Conflicting CR=" XW  "Conflicting LO=" XW}, \
	0x4C635458         { W1 A4.8 W2 "Lock Test :"  "Line=" DW  "Conflicting CR=" XW  "Conflicting LO=" XW}, \
	0x4C63544300000000 { W1 A4.8 W2 "Lock Test :"  "Conflicting CR state=" XW  "Conflicting LO state=" XW}, \
	0x4C635443         { W1 A4.8 W2 "Lock Test :"  "Conflicting CR state=" XW  "Conflicting LO state=" XW}, \
	0x4C6B753100000000 { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B7531         { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B753200000000 { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B7532         { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B753300000000 { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B7533         { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B753400000000 { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B7534         { W1 A4.8 W2 "UnLock :"  "rc=" XW}, \
	0x4C6B753500000000 { W1 A4.8 W2 "UnLock :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4C6B7535         { W1 A4.8 W2 "UnLock :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4C6B753600000000 { W1 A4.8 W2 "UnLock :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4C6B7536         { W1 A4.8 W2 "UnLock :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4C6B754C00000000 { W1 A4.8 W2 "UnLock :"  "Line=" DW  "LO ptr=" XW  "LO state=" XW}, \
	0x4C6B754C         { W1 A4.8 W2 "UnLock :"  "Line=" DW  "LO ptr=" XW  "LO state=" XW}, \
	0x4C6B754600000000 { W1 A4.8 W2 "UnLock :"  "Line=" DW  "FR ptr=" XW  "data=" XW}, \
	0x4C6B7546         { W1 A4.8 W2 "UnLock :"  "Line=" DW  "FR ptr=" XW  "data=" XW}, \
	0x4C6B755800000000 { W1 A4.8 W2 "UnLock :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x4C6B7558         { W1 A4.8 W2 "UnLock :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x4C6B757300000000 { W1 A4.8 W2 "UnLock :"  "seqid=" XW  "LO seqid=" XW  "Previous op=" XW}, \
	0x4C6B7573         { W1 A4.8 W2 "UnLock :"  "seqid=" XW  "LO seqid=" XW  "Previous op=" XW}, \
	0x4C6B755300000000 { W1 A4.8 W2 "UnLock :"  "rc=" XW  "seqid=" XW  "LO seqid=" XW}, \
	0x4C6B7553         { W1 A4.8 W2 "UnLock :"  "rc=" XW  "seqid=" XW  "LO seqid=" XW}, \
	0x534F705800000000 { W1 A4.8 W2 "Start Open :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x534F7058         { W1 A4.8 W2 "Start Open :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x464F705800000000 { W1 A4.8 W2 "End Open :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x464F7058         { W1 A4.8 W2 "End Open :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x4F65725800000000 { W1 A4.8 W2 "Open Error :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x4F657258         { W1 A4.8 W2 "Open Error :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x434F703100000000 { W1 A4.8 W2 "Cleanup Open :"  "VFS ptr=" XW  "cookie=" XW  "rc=" XW}, \
	0x434F7031         { W1 A4.8 W2 "Cleanup Open :"  "VFS ptr=" XW  "cookie=" XW  "rc=" XW}, \
	0x4F436E3100000000 { W1 A4.8 W2 "Open Confirm :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4F436E31         { W1 A4.8 W2 "Open Confirm :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4F436E3200000000 { W1 A4.8 W2 "Open Confirm :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4F436E32         { W1 A4.8 W2 "Open Confirm :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x4F436E3300000000 { W1 A4.8 W2 "Open Confirm :"  "rc=" XW  "seqid=" XW  "OO seqid=" XW}, \
	0x4F436E33         { W1 A4.8 W2 "Open Confirm :"  "rc=" XW  "seqid=" XW  "OO seqid=" XW}, \
	0x4F436E5800000000 { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x4F436E58         { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x4F436E4F00000000 { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "OO ptr=" XW  "data=" XW}, \
	0x4F436E4F         { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "OO ptr=" XW  "data=" XW}, \
	0x4F436E5200000000 { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "OR ptr=" XW  "data=" XW}, \
	0x4F436E52         { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "OR=" XW  "data=" XW}, \
	0x4F436E4600000000 { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "FR=" XW  "data=" XW}, \
	0x4F436E46         { W1 A4.8 W2 "Open Confirm :"  "Line=" DW  "FR=" XW  "data=" XW}, \
	0x44776E3100000000 { W1 A4.8 W2 "Open Downgrade :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x44776E31         { W1 A4.8 W2 "Open Downgrade :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x44776E3200000000 { W1 A4.8 W2 "Open Downgrade :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x44776E32         { W1 A4.8 W2 "Open Downgrade :"  "rc=" XW  "Stateid ndx=" XW  "Stateid gen=" XW}, \
	0x44776E3300000000 { W1 A4.8 W2 "Open Downgrade :"  "rc=" XW  "seqid=" XW  "OO seqid=" XW}, \
	0x44776E33         { W1 A4.8 W2 "Open Downgrade :"  "rc=" XW  "seqid=" XW  "OO seqid=" XW}, \
	0x44776E5800000000 { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x44776E58         { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x44776E4F00000000 { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "OO ptr=" XW  "data=" XW}, \
	0x44776E4F         { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "OO ptr=" XW  "data=" XW}, \
	0x44776E5200000000 { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "OR ptr=" XW  "data=" XW}, \
	0x44776E52         { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "OR ptr=" XW  "data=" XW}, \
	0x44776E4600000000 { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "FR ptr=" XW  "data=" XW}, \
	0x44776E46         { W1 A4.8 W2 "Open Downgrade :"  "Line=" DW  "FR ptr=" XW  "data=" XW}, \
	0x7376723100000000 { W1 A4.8 W2 "VCM Register :"  "rc=" XW}, \
	0x73767231         { W1 A4.8 W2 "VCM Register :"  "rc=" XW}, \
	0x7675723100000000 { W1 A4.8 W2 "VCM UnRegister :"  "Num Cookies=" XW  "Force=" XW}, \
	0x76757231         { W1 A4.8 W2 "VCM UnRegister :"  "Num Cookies=" XW  "Force=" XW}, \
	0x7675723200000000 { W1 A4.8 W2 "VCM UnRegister :"  "Num Cookies=" XW  "Force=" XW  "rc=" XW}, \
	0x76757232         { W1 A4.8 W2 "VCM UnRegister :"  "Num Cookies=" XW  "Force=" XW  "rc=" XW}, \
	0x7647523100000000 { W1 A4.8 W2 "VCM Get Rights :"  "rc=" XW  "FR ptr=" XW  "Pending rights=" XW}, \
	0x76475231         { W1 A4.8 W2 "VCM Get Rights :"  "rc=" XW  "FR ptr=" XW  "Pending rights=" XW}, \
	0x7642433100000000 { W1 A4.8 W2 "VCM Begin Create :"  "rc=" XW  "VFS handle=" XW  "Parent FID=" XW}, \
	0x76424331         { W1 A4.8 W2 "VCM Begin Create :"  "rc=" XW  "VFS handle=" XW  "Parent FID=" XW}, \
	0x7642433200000000 { W1 A4.8 W2 "VCM Begin Create :"  "rc=" XW  "VFS handle=" XW  "Parent FID=" XW}, \
	0x76424332         { W1 A4.8 W2 "VCM Begin Create :"  "rc=" XW  "VFS handle=" XW  "Parent FID=" XW}, \
	0x7642433300000000 { W1 A4.8 W2 "VCM Begin Create :"  "rc=" XW  "VFS handle=" XW  "Parent FID=" XW}, \
	0x76424333         { W1 A4.8 W2 "VCM Begin Create :"  "rc=" XW  "VFS handle=" XW  "Parent FID=" XW}, \
	0x7645433100000000 { W1 A4.8 W2 "VCM End Create :"  "rc=" XW  "ctag=" XW  "FR ptr=" XW}, \
	0x76454331         { W1 A4.8 W2 "VCM End Create :"  "rc=" XW  "ctag=" XW  "FR ptr=" XW}, \
	0x7645433200000000 { W1 A4.8 W2 "VCM End Create :"  "rc=" XW  "ctag=" XW  "FR ptr=" XW}, \
	0x76454332         { W1 A4.8 W2 "VCM End Create :"  "rc=" XW  "ctag=" XW  "FR ptr=" XW}, \
	0x7645433300000000 { W1 A4.8 W2 "VCM End Create :"  "rc=" XW  "ctag=" XW  "FR ptr=" XW}, \
	0x76454333         { W1 A4.8 W2 "VCM End Create :"  "rc=" XW  "ctag=" XW  "FR ptr=" XW}, \
	0x7645433400000000 { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "FID ndx=" XW  "Flags=" XW}, \
	0x76454334         { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "FID ndx=" XW  "Flags=" XW}, \
	0x7645434300000000 { W1 A4.8 W2 "VCM End Create :"  "VCM op_handle=" XW  "FID ino=" XW  "FID gen=" XW}, \
	0x76454343         { W1 A4.8 W2 "VCM End Create :"  "VCM op_handle=" XW  "FID ino=" XW  "FID gen=" XW}, \
	0x7645433500000000 { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "Revoked=" XW  "Pending=" XW}, \
	0x76454335         { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "Revoked=" XW  "Pending=" XW}, \
	0x7645433600000000 { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "VCM op_handle=" XW  "Flags=" XW}, \
	0x76454336         { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "VCM op_handle=" XW  "Flags=" XW}, \
	0x7645433700000000 { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "FID ndx=" XW  "Flags=" XW}, \
	0x76454337         { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "FID ndx=" XW  "Flags=" XW}, \
	0x7645433800000000 { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "Held=" XW  "Pending=" XW}, \
	0x76454338         { W1 A4.8 W2 "VCM End Create :"  "FR ndx=" XW  "Held=" XW  "Pending=" XW}, \
	0x4B75663100000000 { W1 A4.8 W2 "Revoke VFS :"  "rc=" XW}, \
	0x4B756631         { W1 A4.8 W2 "Revoke VFS :"  "rc=" XW}, \
	0x5276663100000000 { W1 A4.8 W2 "Register VFS :"  "rc=" XW  "cookie jar=" XW  "XVFS ptr=" XW}, \
	0x52766631         { W1 A4.8 W2 "Register VFS :"  "rc=" XW  "cookie jar=" XW  "XVFS ptr=" XW}, \
	0x5276665800000000 { W1 A4.8 W2 "Register VFS :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x52766658         { W1 A4.8 W2 "Register VFS :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x5576665800000000 { W1 A4.8 W2 "UnRegister VFS :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x55766658         { W1 A4.8 W2 "UnRegister VFS :"  "Line=" DW  "rc=" XW  "data=" XW}, \
	0x5576664300000000 { W1 A4.8 W2 "UnRegister VFS cont :"  "Cookie=" XW}, \
	0x55766643         { W1 A4.8 W2 "UnRegister VFS cont :"  "Cookie=" XW}, \
	\*		{ W1 A4.8 W2 "d1=" XW  "d2=" XW  "d3=" XW}
495 1.0 "@NFSv4 State Manager" \
        "SM4 DEBUG : " W1 A4.8 W2 "d1=" XW  "d2=" XW  "d3=" XW
5BB 1.0 "@NFSv4 Dset support" \
	$HD%D1, \
	1 { " Entering rfs4_dset_notify " event=$D1 intId=$D2 evArg=$D3 }, \
	2 { " Entering rfs4_set_cs_dset_info " id=$D1 flags=$D2 setflags=$D3 }, \
	3 { " Info from call state " id=$D1 flags=$D2 }, \
	4 { " dset_prOpFindDset returned " rc=$D1 }, \
	5 { " Setting RFS4_MOVED " }, \
	6 { " Setting info " findflags=$D1 id=$D2 flags=$D3 ds_flags=$D4 }, \
	7 { " dset_prOpFindDset failed " rc=$D1 }, \
	8 { " Leaving rfs4_set_cs_dset_info " def=$D1 id=$D2 flags=$D3 rc=$D4 }, \
	9 { " Entering rfs4_set_filehandle_dset " vp=$D1 fhp=$D2 cs=$D3 node=$D4 }, \
	10 { " Leaving rfs4_set_filehandle_dset " where=$D1 rc=$D2 }, \
	11 { " rfs4_set_filehandle_dset error " where=$D1 vp=$D2 fhp=$D3 error=$D4 }, \
	12 { " usr dsid in cstate " id=$D1}, \
	13 { " Unexpected reference " }, \
	14 { " dset from prOpFindDset " id=$D1 dsflags=$D2 objflags=$D3 }, \
	15 { " Leaving rfs4_set_filehandle_dset " id=$D1 flags=$D2 gen=$D3 }, \
	16 { " rfs4_set_filehandle_dset " how=$D1 rc=$D2 error=$D3 }, \
	17 { " Entering process_dref_target " }, \
	18 { " Leaving process_dref_target " pfsp=$D1 }, \
	19 { " Entering rfs4_check_dset_referral " }, \
	20 { " Leaving rfs4_check_dset_referral " isref=$D1 vpp=$D2 rc=$D3 }, \
	21 { " Entering rfs4_find_path " }, \
	22 { " Leaving rfs4_find_path " where=$D1 rc=$D2 }, \
	23 { " Entering convert_locations " rootp=$D1 numentries=$D2 }, \
	24 { " Leaving convert_locations " rc=$D1 }, \
	25 { " Entering rfs4_dset_fslocations " }, \
	26 { " Leaving rfs4_dset_fslocations " where=$D1 rc=$D2 }, \
	27 { " fslocations - finddsetbyintid " id=$D1 rc=$D2 }, \
	28 { " fslocations after vp/cs eval " ref=$D1 id=$D2 dsnp=$D3 }, \
	29 { " fslocations - getlocationbyuuid " uuid=$D1 rc=$D2 locp=$D3 }, \
	30 { " Entering rfs4_compare_dsetid " }, \
	31 { " rfs4_compare_dsetid - invalid args " cs=$D1 cur=$D2 sav=$D3}, \
	32 { " rfs4_compare_dsetid - invalid args " cs=$D1 cur=$D2 sav=$D3}, \
	33 { " Exiting rfs4_compare_dsetid " cur=$D1 sav=$D2 }, \
	34 { " Entering rfs4_check_export_for_dsets " }, \
	35 { " Leaving rfs4_check_export_for_dsets " where=$D1 }, \
	36 { "check_export_for_dsets - find_provider " rc=$D1 }, \
	37 { " Entering rfs4_export_release_dset_provider" }, \
	38 { " Leaving rfs4_export_release_dset_provider "}, \
	39 { " Entering rfs4_check_dset_fh_stale " }, \
	40 { " check_dset_fh_stale - getdsetgenbyid " rc=$D1 }, \
	41 { " Leaving rfs4_check_dset_fh_stale " exp=$D1 rc=$D2 gen=$D3 dsgen=$D4 }, \
	42 { " Entering rfs4_set_fsid_dset " expi=$D1 id=$D2 cur=$D3}, \
	43 { " set_fsid_dset - dsets are not on " eip=$D1 flags=$D2 }, \
	44 { " set_fsid_dset - finddset " id=$D1}, \
	45 { " set_fsid_dset - id from cs " id=$D1 }, \
	46 { " Leaving rfs4_set_fsid_dset " status=$D1 major=$D2 }, \
	47 { " Entering rfs4_dset_init " }, \
	48 { " Leaving rfs4_dset_init " }, \
	\* { "unknown subhook " id=$HD%UW }
5D0 1.0 "@NFS WPAR CHECKPOINT" \
	$HD%D1, \
	1  { " nfs_wpar_event enter " flags=$D1 cid=$D2%D4 }, \
	2  { " nfs_wpar_event exit " flags=$D1 cid=$D2%D4 where=$D3 }, \
	3  { " nfs_dr_event enter " event=$D1 cid=$D2%D4 }, \
	4  { " nfs_dr_event exit " event=$D1 cid=$D2%D4 where=$D3 }, \
	5  { " nfs_vars_init enter " }, \
	6  { " nfs_vars_init exit " addr=$D1 error=$D2 where=$D3 }, \
	7  { " nfs_wpar_vars_create enter " cid=$D1%D4 }, \
	8  { " nfs_wpar_vars_create exit " addr=$D1 where=$D2 }, \
	9  { " nfs_wpar_vars_destroy enter " cid=$D1%D4 }, \
	10 { " nfs_wpar_vars_destroy exit " cid=$D1%D4 where=$D2 }, \
	11 { " intialize_variables enter " vars=$D1 table=$D2 }, \
	12 { " initialize_variables exit " vars=$D1 table=$D2 where=$D3 }, \
	13 { " deallocate_vars enter " vars=$D1 table=$D3 }, \
	14 { " deallocate_vars exit " vars=$D1 table=$D2 where=$D3 }, \
	15 { " nfs_get_wpar_vars enter " cid=$D1%D4 }, \
	16 { " nfs_get_wpar_vars exit " cid=$D1%D4 wparp=$D2 where=$D3 }, \
	17 { " write_checkpoint_data enter " type=$D1 addr=$D2 size=$D3 }, \
	18 { " write_checkpoint_data exit " type=$D1 left=$D2 written=$D3 error=$D4 where=$D5 }, \
	19 { " read_checkpoint_data enter " addr=$D1 size=$D2 }, \
	20 { " read_checkpoint_data exit " addr=$D1 left=$D2 READ=$D3 error=$D4 where=$D5 }, \
	21 { " nfs_checkpoint enter " cid=$D1%D4 }, \
	22 { " nfs_checkpoint exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	23 { " checkpoint_servers enter " cid=$D1%D4 }, \
	24 { " checkpoint_servers exit " cid=$D1%D4 count=$D2 error=$D3 where=$D4 }, \
	25 { " checkpoint_fsids enter " cid=$D1%D4 }, \
	26 { " checkpoint_fsids exit " cid=$D1%D4 fcount=$D2 lcount=$D3 error=$D4 where=$D5 }, \
	27 { " checkpoint_rnodes enter " cid=$D1%D4 }, \
	28 { " checkpoint_rnodes exit " cid=$D1%D4 rcount=$D2 locount=$D3 error=$D4 where=$D5 }, \
	29 { " checkpoint_tune enter " cid=$D1%D4 }, \
	30 { " checkpoint_tune exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	31 { " write_serv_obj_ckpt enter " servp=$D1 }, \
	32 { " write_serv_obj_ckpt exit " servp=$D1 error=$D2 where=$D3 }, \
	33 { " write_fsid_ckpt enter " fsidp=$D1 }, \
	34 { " write_fsid_ckpt exit " fsidp=$D1 error=$D2 where=$D3 }, \
	35 { " write_f_loc_ckpt enter " flp=$D1 }, \
	36 { " write_f_loc_ckpt exit " flp=$D1 error=$D2 where=$D3 }, \
	37 { " write_rnode_ckpt enter " rp=$D1 }, \
	38 { " write_rnode_ckpt exit " rp=$D1 error=$D2 where=$D3 }, \
	39 { " write_lock_owner_ckpt enter " clp=$D1 }, \
	40 { " write_lock_owner_ckpt exit " clp=$D1 error=$D2 where=$D3 }, \
	41 { " nfs_restart enter " cid=$D1%D4 }, \
	42 { "   restart record " cid=$D1%D4 type=$D2 }, \
	43 { " nfs_restart exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	44 { " restart_server enter " cid=$D1%D4 }, \
	45 { " restart_server exit " cid=$D1%D4 error=$D2 servp=$D3 where=$D4 }, \
	46 { " restart_fsid enter " cid=$D1%D4 }, \
	47 { " restart_fsid exit " cid=$D1%D4 error=$D2 fsid=$D3 where=$D4 }, \
	48 { "   fsid promote " cid=$D1%D4 fsidp=$D2 }, \
	49 { " restart_rnode enter " cid=$D1%D4 }, \
	50 { " restart_rnode exit " cid=$D1%D4 error=$D2 rp=$D3 where=$D4 }, \
	51 { " restart_tune enter " cid=$D1%D4 }, \
	52 { " restart_tune exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	53 { " update_server enter " servp=$D1 }, \
	54 { " update_server exit " servp=$D1 error=$D2 where=$D3 }, \
	55 { " update_fsid enter " cid=$D1%D4 }, \
	56 { " update_fsid exit " cid=$D1%D4 error=$D2 fsidp=$D3 where=$D4 }, \
	57 { " nfs_checkpoint_pre enter " cid=$D1%D4 }, \
	58 { " nfs_checkpoint_pre exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	59 { " nfs_checkpoint_post enter " cid=$D1%D4 }, \
	60 { " nfs_checkpoint_post exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	61 { " nfs_restart_pre enter " cid=$D1%D4 }, \
	62 { " nfs_restart_pre exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	63 { " nfs_restart_post enter " cid=$D1%D4 }, \
	64 { " nfs_restart_port exit " cid=$D1%D4 error=$D2 where=$D3 }, \
	65 { " nfs4_open_restart enter " cid=$D1%D4 rp=$D2 }, \
	66 { " nfs4_open_restart exit " cid=$D1%D4 rp=$D2 error=$D3 where=$D4 }, \
	67 { " nfs4_lock_restart enter "cid=$D1%D4 rp=$D2 }, \
	68 { " nfs4_lock_restart exit " cid=$D1%D4 rp=$D2 error=$D3 where=$D4 }, \
	\* { " unknown subhook " id=$HD%UW }
2DE 2.0 'IPSEC_FILTER' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      },  \
    0 { $HD%D1,										        \
	 1 {` Rule out of scope, outside of IF rule.`},						\
	 2 {` Rule out of scope, ELSE following an ELSE.`},					\
	 3 {` Rule out of scope, stray ENDIF.`},						\
	 4 {` ERROR parsing filter rules does not have a matching IF.`},			\
	 5 {` Unbalanced or incorrectly formed IF statements.`},				\
	 6 {` fltr_ioctl4: 1 memcpy_fltr_entry() xmalloc pinned_heap failed, rc = $D1.`},	\
	 7 {` fltr_ioctl4: 2 memcpy_fltr_entry xmalloc pinned_heap failed, rc = $D1.`},  	\
	 8 {` fltr_ioctl4: 3 memcpy_fltr_entry copyin failed rcode = $D1, for pattern_name.`},	\
	 9 {` fltr_ioctl4: 4 memcpy_fltr_entry xmalloc pinned_heap failed, rc = $D1.`},		\
	10 {` fltr_ioctl4: 5 memcpy_fltr_entry copyin failed rcode = $D1, for pattern_blk.`},	\
	11 {` fltr_ioctl4: 6 memcpy_fltr_entry pattern_to_GSALsig failed.`},   			\
	12 {` Cannot create shun rule, netmalloc failure.`},					\
	13 {` fltr_config() - CFG_TERM: open_cnt = $D1.`},					\
	14 {` fltro6: Bad encapsulation - rejecting.`},						\
	15 {` fltro6: Returning default value of (DENY = 0, PERMIT = 1): $D1`},			\
	16 {` fltro6: Error scanning packet, rejecting.`},					\
	17 {` W2 $HL%S1`},                                                                      \
        18 {` W2 $HL%S1`},                                                                      \
        19 {` W2 $HL%S1`},                                                                      \
        21 {` W2 $HL%S1`},                                                                      \
        22 {` W2 $HL%S1`},                                                                      \
        23 {` fltro6: Does not match filter rule $D1: bad direction checking.`},                \
        24 {` fltro6: Does not match filter rule $D1: rule is not not for fragment.`},          \
        25 {` fltro6: Does not match filter rule $D1: rule is for fragment header.`},           \
        26 {` fltro6: Does not match filter rule $D1: rule is for fragment.`},                  \
        27 {` fltro6: Does not match filter rule $D1: bad local packet.`},                     	\
        28 {` fltro6: Does not match filter rule $D1: bad routed packet.`},			\
        29 {` fltro6: Does not match filter rule $D1: bad adapter name.`},                      \
        30 {` fltro6: Does not match filter rule $D1: bad protocol.`},                          \
        31 {` fltro6: Does not match filter rule $D1: bad TCP ACK checking.`},                  \
        32 {` fltro6: Does not match filter rule $D1: bad TCP SYN checking.`},                  \
        33 {` fltro6: Does not match filter rule $D1: bad TCP FIN checking.`},                  \
        34 {` fltro6: Does not match filter rule $D1: bad TCP RST checking.`},                  \
        35 {` fltro6: Does not match filter rule $D1: bad TCP PUSH checking.`},                 \
        36 {` fltro6: Does not match filter rule $D1: bad TCP URG checking.`},                  \
        37 {` fltro6: Does not match filter rule $D1: bad TCP ECN_ECHO checking.`},             \
        38 {` fltro6: Does not match filter rule $D1: bad TCP CWR checking.`},                  \
        39 {` fltro6: Does not match filter rule $D1: bad protocol checking.`},                 \
        40 {` fltro6: Does not match filter rule $D1: bad source address.`},                    \
        41 {` fltro6: Does not match filter rule $D1: bad destination address.`},               \
        42 {` fltro6: Does not match filter rule $D1: no source port.`},                        \
        43 {` fltro6: Does not match filter rule $D1: bad source port.`},                       \
        44 {` fltro6: Does not match filter rule $D1: no destination port.`},                   \
        45 {` fltro6: Does not match filter rule $D1: bad destination port.`},                  \
        46 {` fltro6: Matched rule $D1, action is (DENY = 0, PERMIT = 1): $D2`},                \
        47 {` fltro6: No rule match, choosing default of (DENY = 0, PERMIT = 1): $D1.`},        \
        48 {` ipsec_get_hdr_size6: begin.`},                                                    \
        49 {` ipsec_get_hdr_size6: no interface in pcb, search ifnet list`},                    \
        50 {` ipsec_get_hdr_size4: found a matching adress.`},                                  \
        51 {` ipsec_get_hdr_size6: no interface found, return $D1.`},                           \
        52 {` W2 $HL%S1`},                                                                      \
        53 {` ipsec_get_hdr_size6: filter is not activated, return $D1.`},                      \
        54 {` ipsec_get_hdr_size6: tid = $D1.`},                                                \
        55 {` ipsec_get_hdr_size6: return $D1.`},                                               \
	56 {` fltri4: Rejecting malformed pkt could be an attack.`},				\
	57 {` fltri4: Returning default action of (DENY = 0, PERMIT = 1): $D1.`},               \
        58 {` fltri4: Rejecting pkt -- loopback violation.`},                                   \
	59 {` fltri4: Rejecting pkt because optlen is out of range: $D1.`},			\
	60 {` fltri4: Rejecting pkt because it has no associated adapter.`},			\
	61 {` fltri4: Rejecting pkt because it is a fragment attack.`},				\
        62 {` W2 $HL%S1`},                                                                      \
        66 {` fltri4: Got pkt that does not match tid of rule: rtid=$D1, ptid=$D2.`},           \
        67 {` W2 $HL%S1`},                                                                      \
	70 {` fltri4: No match for filter rules-choosing default of (DENY = 0,PERMIT = 1):$D1.`},\
        71 {` df_fltri4: begin.`},                                                              \
        72 {` df_fltri4: On demand tunnel does not exist.`},                                    \
        73 {` df_fltri4: Got pkt that does not match tid of rule: rtid=$D1, ptid=$D2.`},        \
        74 {` df_fltri4: found a matching rule.`},                                              \
        75 {` NAT_Traversal_auxiliay_process: enter.`},                                         \
        76 {` NAT_Traversal_auxiliay_process: ignore NAT keep alive packet.`},                  \
        77 {` NAT_Traversal_auxiliay_process: m_pullup.`},                                      \
        78 {` NAT_Traversal_auxiliay_process: drop too short UDP-encapsulated ESP packet.`},    \
        79 {` NAT_Traversal_auxiliay_process: remove UDP header.`},                             \
        80 {` NAT_Traversal_auxiliay_process: leave.`},                                         \
	81 {` fltr6_config() - CFG_TERM: open_cnt = $D1.`},					\
	82 {` ipsec_scan6_pkt: Ran out of mbufs in pkt in split. Dropping pkt.`},		\
	83 {` ipsec_scan6_pkt: Ran out of mbufs in pkt. Dropping pkt.`},			\
	84 {` ipsec_scan6_pkt: Ran out of mbufs in ADD_OFFSET.`},				\
	85 {` psec_scan6_pkt: current_hdr is $D1, cur_mbuf_offset is $D2.`},                    \
        86 {` ipsec_scan6_pkt: Found fragment header.`},                                        \
        87 {` ipsec_scan6_pkt: Fragment if6_off is $D1.`},                                      \
        88 {` ipsec_scan6_pkt: Found TCP header.`},                                             \
        89 {` ipsec_scan6_pkt: Source port is $D1.`},                                           \
        90 {` ipsec_scan6_pkt: Dest port is $D1.`},                                             \
        91 {` ipsec_scan6_pkt: tcp_flags is $D1.`},                                             \
        92 {` ipsec_scan6_pkt: Found UCP header.`},                                             \
        93 {` ipsec_scan6_pkt: Source port is $D1.`},                                           \
        94 {` ipsec_scan6_pkt: Dest port is $D1.`},                                             \
        95 {` ipsec_scan6_pkt: Found OSPF header.`},                                            \
        96 {` ipsec_scan6_pkt: OSPF type is $D1`},                                              \
        97 {` ipsec_scan6_pkt: Found ICMP header.`},                                            \
        98 {` ipsec_scan6_pkt: ICMP code is $D1.`},                                             \
        99 {` ipsec_scan6_pkt: ICMP type is $D1.`},                                             \
        100{` ipsec_scan6_pkt: Found routing header.`},                                         \
        101{` ipsec_scan6_pkt: Found DOPT header.`},                                            \
        102{` ipsec_scan6_pkt: Found MH header.`},                                              \
        103{` ipsec_scan6_pkt: Hit NHDR_NONH.`},                                                \
        104{` ipsec_scan6_pkt: Found protocol ($D1).`},                                         \
        105{` prepare_GSAL_sig: wrong input parameters.`},                                      \
        106{` prepare_GSAL_sig: xmalloc(GSALsigList) failed.`},                                 \
        107{` prepare_GSAL_sig: xmalloc(pattern_name) failed.`},                                \
        108{` prepare_GSAL_sig: plen <= 0.`},                                                   \
        109{` prepare_GSAL_sig: xmalloc(tmp_patt) failed.`},                                    \
        110{` prepare_GSAL_sig: xmalloc(GSLArec) failed.`},                                     \
        111{` prepare_GSAL_sig: xmalloc(jumprec) failed.`},                                     \
        112{` prepare_GSAL_sig: xmalloc(GSALsig) failed.`},                                     \
        113{` rm_GSALsig_list: input is NULL.`},                                                \
        114{` gc_GSALsig_list: input is NULL.`},                                                \
        115{` GSAL_search: net_malloc(buf) failed.`},                                           \
        116{` W2 $HL%S1`},                                                                      \
	117{` fltri6: Entrance.`},                                                              \
        118{` fltri6: Dropping packet - dest addr is ANYADDR.`},                                \
        119{` fltri6: Got tunnel ID in protect struct: $D1.`},                                  \
        120{` fltri6: Returning default action of (DENY = 0, PERMIT = 1): $D1.`},               \
        121{` fltri6: Rejecting pkt based on default action.`},                                 \
	122{` fltri6: Dropping pkt - dst addr is loopback, but src is not.`},			\
	123{` fltri6: ATTACK: V6 pkt received without an interface.`},				\
	124{` fltri6: Could not determine interface for pkt -- dropping pkt.`},			\
	125{` fltri6: Dropping pkt--cannot scan headers.`},					\
	126{` fltri6: Dropping pkt - fragment is too small.`},					\
        127{` W2 $HL%S1`},                                                                      \
        133{` fltri6: Does not match filter rule $D1: bad direction checking.`},                \
        134{` fltri6: Does not match filter rule $D1: bad fragment checking.`},                 \
        135{` fltri6: Does not match filter rule $D1: rule is for fragment header.`},           \
        136{` fltri6: Does not match filter rule $D1: rule is for fragment.`},                  \
        137{` fltri6: Does not match filter rule $D1: bad source routed.`},                     \
        138{` fltri6: Does not match filter rule $D1: bad adapter.`},                           \
        139{` fltri6: Does not match filter rule $D1: bad local packet.`},                      \
        140{` fltri6: Does not match filter rule $D1: bad routed packet.`},                     \
        141{` fltri6: Does not match filter rule bad source address.`},                         \
        142{` fltri6: Does not match filter rule bad dest address.`},                           \
        143{` fltri6: Does not match filter rule $D1: bad protocol.`},                          \
        144{` fltri6: Does not match filter rule $D1: bad TCP ACK checking.`},                  \
        145{` fltri6: Does not match filter rule $D1: bad TCP SYN checking.`},                  \
        146{` fltri6: Does not match filter rule $D1: bad TCP FIN checking.`},                  \
        147{` fltri6: Does not match filter rule $D1: bad TCP RST checking.`},                  \
        148{` fltri6: Does not match filter rule $D1: bad TCP PUSH checking.`},                 \
        149{` fltri6: Does not match filter rule $D1: bad TCP URG checking.`},                  \
        150{` fltri6: Does not match filter rule $D1: bad TCP ECN_ECHO checking.`},             \
        151{` fltri6: Does not match filter rule $D1: bad TCP CWR checking.`},                  \
        152{` fltri6: Does not match filter rule $D1: bad protocol checking.`},                 \
        153{` fltri6: Does not match filter rule $D1: no source port.`},                        \
        154{` fltri6: Does not match filter rule $D1: bad source port.`},                       \
        155{` fltri6: Does not match filter rule $D1: no dest port.`},                          \
        156{` fltri6: Does not match filter rule $D1: bad dest port.`},                         \
        157{` fltri6: Got pkt that does not match tid of rule: rtid=$D1, ptid=$D2.`},            \
        158{` fltri6: Does not match filter rule $D1: bad security protocol.`},                 \
	159{` fltri6: No match for filter rules-- default is (DENY = 0, PERMIT = 1): $D1.`},	\
        160{` df6_fltri6: begin.`},                                                             \
        161{` df6_fltri6: On demand tunnel does not exist.`},                                   \
        162{` df_fltri6: Got pkt that does not match tid of rule: rtid=$D1, ptid=$D2.`},        \
        163{` df6_fltri6: found a matching rule.`},                                             \
	164{` fltr_ioctl4: cmd=SIOCGFWLVL4: Get filter module level: $D1.`},                    \
        165{` fltr_ioctl4: cmd=SIOCSFWINA4: Set default action.`},                              \
	166{` fltr_ioctl4: cmd=SIOCSFWINA4 failed copyin(arg) $D1.`},                           \
        167{` fltr_ioctl4: Setting default action to $D1.`},                                    \
	168{` fltr_ioctl4: Bad action for SIOCSFWINA4.`},					\
        169{` fltr_ioctl4: cmd=SIOCSFWINI4: Activate filter.`},                                 \
	170{` fltr_ioctl4: cmd=SIOCSFWDBG4 failed copyin(arg) $D1.`},				\
        171{` fltr_ioctl4: cmd=SIOCSFWDBG4: Set logging to $D1.`},                              \
	172{` fltr_ioctl4: No fwl_ptr in SIOCSFWDBG4: No logging space.`},			\
        173{` fltr_ioctl4: cmd=SIOCSFWTBL4: Load filter rules.`},                               \
	174{` fltr_ioctl4: SIOCSFWTBL4: copyin(arg) == $D1.`},                                  \
        175{` fltr_ioctl4: No filter table in SIOCSFWTBL4.`},                                   \
        176{` fltr_ioctl4: Bad size of filter table for SIOCSFWTBL4.`},                         \
        177{` fltr_ioctl4:  SIOCSFWTBL4: Could not allocate memory for new filter table.(2).`}, \
        178{` fltr_ioctl4: SIOCSFWTBL4: Filter table copyin failed.`},                          \
        179{` fltr_ioctl4:  SIOCSFWTBL4: Could not allocate memory for new fltr_bld.(1).`},     \
        180{` fltr_ioctl4:  SIOCSFWTBL4: Could not allocate memory for new fltr_bld.(2).`},     \
        181{` fltr_ioctl4: SIOCSFWTBL4: Set logging to $D1.`},                                  \
        182{` fltr_ioctl4: SIOCSFWTBL4: Cannot enable logging.`},                               \
        183{` SIOCSFWTBL4: Freeing old filter table.`},                                         \
        184{` fltr_ioctl4: cmd=SIOCGFWTBL4: Retrieve filter rules.`},                           \
	185{` fltr_ioctl4: SIOCGFWTBL4: copyin(arg)=$D1.`},                                     \
        186{` fltr_ioctl4: SIOCGFWTBL4: fit_inout.fit_ptr=NULL.`},                              \
        187{` fltr_ioctl4: SIOCGFWTBL4: bad fit_len.`},                                         \
        188{` fltr_ioctl4: SIOCGFWTBL4: Copyout of segment table failed.`},                     \
        189{` fltr_ioctl4: SIOCGFWTBL4: failed to get shared lock.`},                           \
        190{` fltr_ioctl4: cmd=SIOCGFWETR4: Retrieve filter rules buffer.`},                    \
	191{` fltr_ioctl4: SIOCGFWETR4: copyin(arg) == $D1.`},                                  \
        192{` fltr_ioctl4: SIOCGFWETR4: fltr_elem_ptr == NULL.`},                               \
        193{` fltr_ioctl4: SIOCGFWETR4: invalid size for rules.`},                              \
        194{` fltr_ioctl4: SIOCGFWETR4: fltr_entry copyout fail, len=$D1.`},                    \
        195{` fltr_ioctl4: SIOCGFWETR4: copyout fltr_exp_time failed on len=$D1.`},             \
        196{` fltr_ioctl4: SIOCGFWETR4: fltr_timer copyout failed, len=$D1.`},                  \
        197{` fltr_ioctl4: SIOCGFWETR4: copyout failed, len=$D1.`},                             \
        198{` fltr_ioctl4: SIOCGFWETR4: failed to get shared lock.`},                           \
        199{` fltr_ioctl4: cmd=SIOCSFWCLR4: Deactivate filter.`},                               \
        200{` fltr_ioctl4: cmd=SIOCGFWLOG4: Retrieve log buffer.`},                             \
	201{` fltr_ioctl4: SIOCGFWLOG4: failed copyin(arg)=$D1.`},                              \
        202{` fltr_ioctl4: SIOCGFWLOG4: No buffer to obtain log.`},                             \
        203{` fltr_ioctl4: SIOCGFWLOG4: fltr_log_ptr = NULL.`},                                 \
        204{` fltr_ioctl4: SIOCGFWLOG4: Bad fltr_log_length.`},                                 \
        205{` fltr_ioctl4: SIOCGFWLOG4: Logging disabled and empty buffer.`},                   \
        206{` fltr_ioctl4: SIOCGFWLOG4: copyout failed.`},                                      \
        207{` fltr_ioctl4: Invalid ioctl cmd.`},                                                \
	208{` idMgrUCreateNewId: copyin failed.`},						\
	209{` idMgrUCreateNewId: out of memory.`},						\
	210{` idMgrUAddRules: failed copyin(args)=$D1.`},					\
	211{` ENOMEM in idMgrUAddRules() trying to xmalloc pinned for $D1 rules.`},		\
	212{` idMgrUAddRules: failed copyin(mdf_modf_rules)=$D1.`},				\
	213{` idMgrUAddRules: rules have different Ids.`},					\
	214{` idMgrUAddRules: out of memory.`},							\
	215{` idMgrUAddRules: invalid Id.`},							\
	216{` idMgrUAddRules: idAfter does not exist.`},					\
	217{` idMgrUMoveId: id and idAfter are the same.`},					\
	218{` idMgrUMoveId: invalid id.`},							\
	219{` idMgrUMoveId: invalid idAfter.`},							\
	220{` idMgrUMoveId: id_set(id) does not exist.`},					\
	221{` idMgrUDelIds: no ids specified.`},						\
	222{` idMgrUDelIds: not specified.`},							\
	223{` idMgrUDelIds: n=0, nothing done.`},						\
	224{` idMgrUDelIds: out of memory.`},							\
	225{` idMgrUDelType: out of memory.`},							\
	226{` idMgrUDelType: id_count=0, nothing to do.`},					\
	227{` idMgrUGetTblEtr: failed copyin(arg) = $D1.`},					\
	228{` ENOMEM in idMgrUGetTblEtr trying to xmalloc $D1 pinned.`},			\
	229{` DELIDS e_tmp=df_malloc($D1).`},							\
	230{` DELIDS c_tmp=df_malloc($D1).`},							\
	231{` DELIDS newTbl=df_malloc($D1).`},							\
	232{` idMgrUCreateNewId: table changed while growing, retry allocation.`},		\
	233{` idMgrUCreateNewId: Using preallocated mem to grow table.`},			\
	234{` idMgrUCreateNewId: preallocated memory not used.`},				\
	235{` idMgrUCreateNewId: preallocated memory not used.`},				\
	236{` idMgrUCreateNewId: table grow completed.`},					\
	237{` idMgrUCreateNewId: freeing preallocated mem.`},					\
	238{` filter_if_mpx in.`},                                                              \
	239{` filter_if_mpx out bad.`},                                                         \
	240{` filter_if_mpx out.`},                                                             \
	241{` filter_if_open.`},                                                                \
	242{` filter_if_open: Attempted kernel open.`},						\
	243{` filter_if_close.`},                                                               \
	244{` filter_if_read.`},                                                                \
	245{` filter_if_ioctl.`},                                                               \
	246{` fltr6_ioctl: cmd=SIOCGFWLVL6 Get filter6 level: $D1.`},                           \
	247{` fltr6_ioctl: cmd=SIOCSFWINA6: Set default action.`},                              \
	248{` fltr_ioctl6: cmd=SIOCSFWINA6 failed copyin(arg) $D1.`},				\
	249{` fltr6_ioctl: Setting default action to (DENY = 0, PERMIT = 1): $D1.`},            \
	250{` fltr6_ioctl: SIOCSFWINA6: Bad action.`},						\
        251{` fltr6_ioctl: cmd is SIOCSFWINI6: Activate filter6.`},                             \
	252{` fltr_ioctl6: cmd=SIOCSFWDBG6 failed copyin(arg) $D1.`},				\
        253{` fltr6_ioctl: cmd is SIOCSFWDBG6: Setting logging on/off.`},                       \
	254{` fltr6_ioctl: SIOCSFWDBG6: No logging space available.`},				\
        255{` fltr6_ioctl: cmd is SIOCSFWTBL6: Load filter table.`},                            \
	256{` fltr_ioctl4: SIOCSFWTBL6: copyin(arg) == $D1.`},					\
	257{` fltr6_ioctl: No filter table in SIOCSFWTBL6.`},					\
	258{` fltr6_ioctl: Bad size of filter table for SIOCSFWTBL6.`},				\
	259{` fltr6_ioctl: Could not allocate memory for filter table.(2).`},			\
	260{` fltr_ioctl6: SIOCSFWTBL6: copyin(set_filt_fltr_set_ptr.`},			\
	261{` fltr_ioctl6:  SIOCSFWTBL6: Could not allocate memory for new fltr_bld.(1).`},	\
	262{` fltr_ioctl6:  SIOCSFWTBL6: Could not allocate memory for new fltr_bld.(2).`},	\
        263{` W2 $HL%S1`},                                                                      \
	264{` `},										\
	265{` W2 $HL%S1`},                                                                      \
	266{` `},										\
        267{` W2 $HL%S1`},                                                                      \
	268{` `},										\
        269{` W2 $HL%S1`},                                                                      \
	270{` `},										\
        271{` W2 $HL%S1`},                                                                      \
	272{` W2 $HL%S1`},                                                                      \
	273{` W2 $HL%S1`},                                                                      \
	274{` fltr_ioctl6: SIOCSFWTBL6: Set logging to $D1.`},                                  \
	275{` fltr_ioctl6: SIOCSFWTBL6: Cannot enable logging.`},                               \
	276{` SIOCSFWTBL6: Freeing old filter table.`},                                         \
	277{` fltr6_ioctl: cmd is SIOCGFWTBL6: Retrieve filter table.`},                        \
	278{` fltr_ioctl6:  SIOCGFWTBL6: copyin(arg)=$D1.`},					\
	279{` fltr6_ioctl: SIOCGFWTBL6: fit_inout.fit_ptr == NULL.`},				\
	280{` fltr6_ioctl: SIOCGFWTBL6: Bad fit_len.`},						\
	281{` fltr6_ioctl: SIOCGFWTBL6: Copyout of segment table failed.`},			\
	282{` fltr6_ioctl: SIOCGFWTBL6: failed to get shared lock.`},				\
	283{` fltr_ioctl6: cmd=SIOCGFWETR6: Retrieve filter rules buffer.`},                    \
	284{` fltr_ioctl6: SIOCGFWETR6: copyin(arg) == $D1.`},					\
	285{` fltr_ioctl6: SIOCGFWETR6: fltr_elem_ptr == NULL.`},                               \
	286{` fltr_ioctl6: SIOCGFWETR6: invalid size for rules.`},				\
	287{` fltrioctl6: SIOCGFWETR4: fltr6_entry copyout fail, len=$D1.`},			\
	288{` fltr_ioctl4: SIOCGFWETR4: copyout fltr_exp_time failed on len=$D1.`},		\
	289{` fltr_ioctl4: SIOCGFWETR4: fltr_timer copyout failed, len=$D1.`},			\
	290{` fltr_ioctl6: SIOCGFWETR6: copyout failed, len=$D1.`},				\
	291{` fltr_ioctl6: SIOCGFWETR6: failed to get shared lock.`},				\
	292{` fltr6_ioctl: ioctl cmd is SIOCSFWCLR6: Deactivate filter.`},                      \
	293{` fltr6_ioctl: ioctl cmd is SIOCGFWLOG6: Retrieve filter log.`},                    \
	294{` fltr_ioctl6: SIOCGFWLOG6: failed copyin(arg)=$D1.`},				\
	295{` fltr6_ioctl: SIOCGFWLOG6: fltr_log_ptr == NULL.`},				\
	296{` fltr6_ioctl: SIOCGFWLOG6: Bad fltr_log_lgth.`},					\
	297{` fltr6_ioctl: SIOCGFWLOG6: Logging disabled/Empty buffer.`},                       \
	298{` fltr6_ioctl: SIOCGFWLOG6: Copyout failed.`},					\
	299{` fltr_ioctl6: Invalid ioctl cmd.`},                                                \
	300{` filter6_if_mpx in.`},                                                             \
        301{` filter6_if_mpx out bad.`},                                                        \
        302{` filter6_if_mpx out.`},                                                            \
        303{` filter6_if_open.`},                                                               \
	304{` filter6_if_open: Attempted kernel open.`},					\
	305{` filter6_if_close.`},                                                              \
        306{` filter6_if_read.`},                                                               \
        307{` filter6_if_ioctl: Received ioctl cmd.`},                                          \
	308{` fltro4: Received pkt without V4 addr struct in addr chain: rejecting pkt.`},	\
	309{` fltro4: Using default filter action of (DENY = 0, PERMIT = 1): $D1.`},		\
	310{` W2 $HL%S1`},									\
	311{` `},										\
        312{` W2 $HL%S1`},                                                                      \
	313{` `},										\
        314{` fltro4: fragment info ip_fragment=$D1, pkt_sport=$D2, pkt_dport=$D3.`},           \
        315{` fltro4: Matched rule $D1, action is (DENY = 0, PERMIT = 1): $D2.`},               \
        316{` fltro4: No rule match, will (DENY = 0, PERMIT = 1): $D1 packet.`},                \
        317{` df_fltro4 begin.`},                                                               \
        318{` df_filtro4, rule_cnt==0...`},                                                     \
        319{` df_fltro4: On demand tunnel does not exist.`},                                    \
        320{` df_fltro4: ACTIVE.`},                                                             \
        321{` df_fltro4: NEGOCIATING.`},                                                        \
        322{` df_fltro4: DORMANT.`},                                                            \
        323{` df_fltro4: Matched rule $D1, action is (DENY = 0, PERMIT = 1): $D2, tid=$D3.`},   \
        324{` ipsec_get_hdr_size4: begin.`},                                                    \
        325{` ipsec_get_hdr_size4: inpcb is NULL, returning 0.`},                               \
        326{` ipsec_get_hdr_size4: no interface in pcb, search ifnet list.`},                   \
        327{` ipsec_get_hdr_size4: found a matching address.`},                                 \
        328{` ipsec_get_hdr_size4: no interface found, return 0.`},                             \
        329{` ipsec_get_hdr_size4: loopback interface, return 0.`},                             \
        330{` W2 $HL%S1`},                                                                      \
        331{` ipsec_get_hdr_size4: _fltr_out_chk rejects - returning 0.`},                      \
        332{` ipsec_get_hdr_size4: tid = $D1.`},                                                \
        333{` ipsec_get_hdr_size4: return $D1.`},                                               \
	334{` fltrochk6: df6_fltro6 begin.`},							\
	335{` fltrochk6: fltro6: Does not match filter rule $D1: rule isn't not for fragment.`},\
	336{` fltrochk6: fltro6: Does not match filter rule $D1: rule is for fragment header.`},\
	337{` fltrochk6: fltro6: Does not match filter rule $D1: rule is for fragment.`},	\
	338{` fltrochk6: df6_fltro6: On demand tunnel does not exist.`},			\
	339{` fltrochk6: df6_fltro6: ACTIVE.`},							\
	340{` fltrochk6: df6_fltro6: NEGOCIATING.`},						\
	341{` fltrochk6: df6_fltro6: DORMANT.`},						\
	342{` crypto_if: ipsec_utils_config() - CFG_TERM: csys_head or mac_head not empty.`},	\
	343{` W2 $HL%S1`},									\
	344{` W2 $HL%S1`},									\
	\* { " unknown subhook " id=$HD%UW } \
        }
2DF 1.0 'IPSEC_FILTER_INFO' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      }
2E0 1.0 'IPSEC_CAPSUL' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      },  \
    0 { $HD%D1,										        \
	601{` ah_1826_cap4: ENT s_mac_alg $D1.`},						\
	602{` ah_1826_cap4: NO_HDR.`},								\
	603{` ah_1826_cap4: NO_TC.`},								\
	604{` ah_1826_cap4: smb->size = $D1.`},							\
	605{` ah_1826_cap4: NO_OMBUF.`},							\
	606{` ah_1826_cap4: NO_PAD.`},								\
	607{` ah_1826_cap4: NO_STPI.`},								\
	608{` ah_1826_cap4: BAD_ENC.`},								\
	609{` ah_1826_cap4: ENCAP_SYS_LAST.`},							\
	610{` ah_1826_cap4: NO_OHDR.`},								\
	611{` ah_1826_cap4: NO_STPI 2.`},							\
	612{` ah_1826_cap4: BAD_ENC 2.`},							\
	613{` ah_1826_cap4: BAD_ENC 3.`},							\
	614{` ah_1826_cap4: EXIT.`},								\
	615{` ah_1826_cap4: ENT s_mac_alg $D1.`},						\
	616{` ah_1826_cap4: NO_HDR.`},								\
	617{` ah_1826_cap4: No tunnel cache entry.`},						\
	618{` ah_1826_cap4: ah_len = $D1, rmb.sys->size = $D2.`},				\
	619{` ah_1826_cap4: bad ip_len $D1.`},							\
	620{` ah_1826_cap4: m_pullup() err, i_off = $D1.`},					\
	621{` ah_1826_cap4: W2 $HL%S1\.`},							\
	622{` ah_1826_cap4: ah_p->protocol = $D1, transport_mode = $D2, i_off = $D3, m_input_p->m_len = $D4.`}, \
	623{` ah_1826_cap4: BLD_HDR.`},								\
	624{` ah_1826_cap4: NO_NEW_HDR.`},							\
	625{` ah_1826_cap4: protocol $D1, auth_data_len $D2.`},					\
	626{` ah_1826_cap4: auth_data[0] = $D1.`},						\
	627{` ah_1826_cap4: DECAP_SYS_MODE.`},							\
	628{` ah_1826_cap4: NO_STPI.`},								\
	629{` ah_1826_cap4: BAD_ENC.`},								\
	630{` ah_1826_cap4: BAD_ENC 2.`},							\
	631{` ah_1826_cap4: BAD_MAC.`},								\
	632{` ah_1826_cap4: m_pullup() err.`},							\
	633{` ah_1826_cap4: EXIT.`},								\
	634{` ah_1826_cap4: Returning no-error code in error path.`},				\
	635{` ah_1826_cap4: NO_CS, crypto_alg_id $D1.`},					\
	636{` ah_1826_cap4: prepare_key() err.`},						\
	637{` ah_rply_cap4: ENT s_mac_alg $D1.`},						\
	638{` ah_rply_cap4: NO_HDR.`},								\
	639{` ah_rply_cap4: NO_TC.`},								\
	640{` ah_rply_cap4: NO_OMBUF.`},							\
	641{` ah_rply_cap4: NO_PAD.`},								\
	642{` ah_rply_cap4: NO_STPI.`},								\
	643{` ah_rply_cap4: BAD_ENC.`},								\
	644{` ah_rply_cap4: ENCAP_SYS_LAST.`},							\
	645{` ah_rply_cap4: NO_OHDR.`},								\
	646{` ah_rply_cap4: NO_STPI 2.`},							\
	647{` ah_rply_cap4: BAD_ENC 2.`},							\
	648{` ah_rply_cap4: BAD_ENC 3.`},							\
	649{` ah_rply_cap4: EXIT.`},								\
	650{` ah_rply_cap4: ENT s_mac_alg $D1.`},						\
	651{` ah_rply_cap4: NO_HDR.`},								\
	652{` ah_rply_cap4: no tunnel cache entry.`},						\
	653{` ah_rply_cap4: bad ip_len $D1.`},							\
	654{` ah_rply_cap4: m_pullup() err, i_off $D1.`},					\
	655{` ah_rply_cap4: replay check failed.`},						\
	656{` ah_rply_cap4: W2 $HL%S1`},							\
	657{` ah_rply_cap4: BLD_HDR.`},								\
	658{` ah_rply_cap4: NO_NEW_HDR.`},							\
	659{` ah_rply_cap4: protocol $D1, auth_data_len $D2.`},					\
	660{` ah_rply_cap4: auth_data[0] $D1.`},						\
	661{` ah_rply_cap4: DECAP_SYS_MODE.`},							\
	662{` ah_rply_cap4: NO_STPI.`},								\
	663{` ah_rply_cap4: BAD_ENC.`},								\
	664{` ah_rply_cap4: BAD_ENC 2.`},							\
	665{` ah_rply_cap4: BAD_MAC.`},								\
	666{` ah_rply_cap4: W2 $HL%S1`},							\
	667{` ah_rply_cap4: W2 $HL%S1`},							\
	668{` ah_rply_cap4: m_pullup() err.`},							\
	669{` ah_rply_cap4: EXIT.`},								\
	670{` ah_rply_cap4: Returning no-error code in error path.`},				\
        1840{` ah_rply_cap4: _encap4(): incorrect salt size ($D1).`},                           \
        1841{` ah_rply_cap4: _encap4(): failed to get random data.`},                           \
        1842{` ah_rply_cap4: _decap4(): incorrect salt size ($D1).`},                           \
	671{` ah_rply_cap6: ah_rply_encap.`},							\
	672{` ah_rply_cap6: transport_mode = $D1.`},						\
	673{` ah_rply_cap6: no header.`},							\
	674{` ah_rply_cap6: no tunnel cache.`},							\
	675{` ah_rply_cap6: tunnel mode not supported for mobility packet with Home Address option.`},	\
	676{` ah_rply_cap6: error in cap6_make_complete_ipv6_packet.`},				\
	677{` ah_rply_cap6: ah_nh = $D1, size_before_ah = $D2.`},				\
	678{` ah_rply_cap6: no mbuf.`},								\
	679{` ah_rply_cap6: ah_hdr = 0x$D1.`},							\
	680{` ah_rply_cap6: Transport mode.`},							\
	681{` ah_rply_cap6: No padding.`},							\
	682{` ah_rply_cap6: error in IP6_take_invariant.`},					\
	683{` ah_rply_cap6: bad encapsulation.`},						\
	684{` ah_rply_cap6: last encapsulation.`},						\
	685{` ah_rply_cap6: no header.`},							\
	686{` ah_rply_cap6: error in IP6_take_invariant.`},					\
	687{` ah_rply_cap6: bad encapsulation.`},						\
	688{` ah_rply_cap6: 1st and not last encapsulation.`},					\
	689{` ah_rply_cap6: bad encapsulation.`},						\
	690{` ah_rply_cap6: return OK.`},							\
	691{` ah_rply_cap6: ah_rply_decap.`},							\
	692{` ah_rply_cap6: error in cap6_make_complete_ipv6_packet.`},				\
	693{` ah_rply_cap6: ah_decap6 - no header.`},						\
	694{` ah_rply_cap6: ah_decap6: no tunnel cache entry.`},				\
	695{` ah_rply_cap6: ah_decap6: size_before_ah = $D1.`},					\
	696{` ah_rply_cap6: ah_decap6: ah_len = $D1.`},						\
	697{` ah_rply_cap6: ah_decap6: bad len.`},						\
	698{` ah_rply_cap6: ah_decap6: pullup error.`},						\
	699{` ah_rply_cap6: ah_rply_decap6(): replay check failed.`},				\
	700{` ah_rply_cap6: ah_decap6: mode = $D1.`},						\
	701{` ah_rply_cap6: W2 $HL%S1`},							\
	702{` ah_rply_cap6: ah_decap6: pullup error.`},						\
	703{` ah_rply_cap6: ah_decap6: pullup error.`},						\
	704{` ah_rply_cap6: ah_decap6: cannot allocate new hdr.`},				\
	705{` ah_rply_cap6: ah_decap6: cannot allocate new cluster.`},				\
	706{` ah_rply_cap6: ah_decap6: error in IP6_take_invariant.`},				\
	707{` ah_rply_cap6: ah_decap6: bad decapsulation 1.`},					\
	708{` ah_rply_cap6: ah_decap6: bad decapsulation 2.`},					\
	709{` ah_rply_cap6: ah_decap6: bad MAC.`},						\
	710{` ah_rply_cap6: ah_Decap6: bad pullup.`},						\
	711{` ah_rply_cap6: ah_decap6: return OK.`},						\
	712{` ah_rply_cap6: ah_decap6: Returning non-error code in error path.`},		\
	713{` ah_rply_cap6: ah_init6: no cs.`},							\
	714{` ah_rply_cap6: ah_init6: error prepare key.`},					\
        1845{` ah_rply_cap6: _encap6(): incorrect salt size ($D1).`},                           \
        1846{` ah_rply_cap6: _encap6(): failed to get random data.`},                           \
        1847{` ah_rply_cap6: _decap6(): incorrect salt size ($D1).`},                           \
	715{` crypto_cap4_if: Searching for id $D1, fmt $D2, Current ID $D3, fmt $D4.`},	\
	716{` crypto_cap4_if: ipsp_id_to_cap_sys(): Match Found.`},				\
	717{` crypto_cap6_if: cap6_add_cap_sys().`},						\
	718{` crypto_cap6_if: cap6_del_cap_sys().`},						\
	719{` crypto_cap6_if: cap6_id_to_cap_sys().`},						\
	720{` crypto_cap6_if: cap6_name_to_cap_sys().`},					\
	721{` crypto_cap6_if: cap6_release_cap_sys().`},					\
	722{` crypto_cap6_if: ipsec_cap6_config().`},						\
	723{` crypto_cap6_if: ipsec_cap6_config(): err = $D1.`},				\
	724{` esp_1829_cap4: esp_1829_encap4() ENT, s_enc_alg $D1.`},				\
	725{` esp_1829_cap4: esp_1829_encap4() NO_HDR.`},					\
	726{` esp_1829_cap4: esp_1829_encap4() NO_TC.`},					\
	727{` esp_1829_cap4: esp_1829_encap4() NO_OMBUF.`},					\
	728{` esp_1829_cap4: esp_1829_encap4() NO_PAD.`},					\
	729{` esp_1829_cap4: esp_1829_encap4() LONG_STPI.`},					\
	730{` esp_1829_cap4: esp_1829_encap4() BAD_ENC.`},					\
	731{` esp_1829_cap4: esp_1829_encap4() esp said $D1, iv 0x$D2 0x$D3.`},			\
	732{` esp_1829_cap4: esp_1829_encap4() NO_OHDR.`},					\
	733{` esp_1829_cap4: esp_1829_encap4() EXIT.`},						\
	734{` esp_1829_cap4: esp_1829_decap4() ENT, s_enc_alg $D1.`},				\
	735{` esp_1829_cap4: esp_1829_decap4() m_debug_p->m_len $D1.`},				\
	736{` esp_1829_cap4: esp_1829_decap4() no tunnel cache entry.`},			\
	737{` esp_1829_cap4: esp_1829_decap4() HDR_LEN $D1.`},					\
	738{` esp_1829_cap4: esp_1829_decap4: invalid output_len ($D1).`},			\
	739{` esp_1829_cap4: esp_1829_decap4() bad output_len $D1.`},				\
	740{` esp_1829_cap4: esp_1829_decap4() NO_OMBUF.`},					\
	741{` esp_1829_cap4: esp_1829_decap4() init_vector 0x$D1 0x$D2.`},			\
	742{` esp_1829_cap4: esp_1829_decap4() BAD_ENC.`},					\
	743{` esp_1829_cap4: esp_1829_decap4() BAD padding_len $D1.`},				\
	744{` esp_1829_cap4: W2 $HL%S1`},							\
	745{` esp_1829_cap4: esp_1829_decap4() PULLUP_ERR.`},					\
	746{` esp_1829_cap4: esp_1829_decap4() NO_HMBUF.`},					\
	747{` esp_1829_cap4: esp_1829_decap4() PULLUP_ERR.`},					\
	748{` esp_1829_cap4: esp_1829_decap4() EXIT.`},						\
	749{` esp_1829_cap4: esp_1829_decap4() exit bad.`},					\
	750{` esp_1829_cap4: esp_1829_decap4() exit bad1.`},					\
	751{` esp_1829_cap4: esp_1829_decap4: Returning non-error code in error path.`},	\
	752{` esp_init: esp_1829_init4(): ipsp_id_to_kernel_crypto_sys() err.`},		\
	753{` esp_init: esp_1829_init4(): crypto_alg_id $D1.`},					\
	754{` esp_init: esp_1829_init4(): prepare_key() err.`},					\
	755{` esp_init: esp_rply_init4() crypto_sys not found.`},				\
	756{` esp_init: esp_rply_init4() Prepare key for DES failed.`},				\
	757{` esp_init: esp_rply_init4() No encap_sys for mac.`},				\
	758{` esp_init: esp_rply_init4() No mac system found for $D1.`},			\
	759{` esp_init: esp_rply_init4() No encap_sys for mac.`},				\
	760{` esp_init: esp_rply_init4() Prepare key for receiver ESP_AH failed.`},		\
	761{` esp_init: esp_rply_init4() Prepare key for receiver ESP_AH failed.`},		\
	762{` esp_init6: esp_init6: ipsp_id_to_kernel_crypto_sys() err.`},			\
	763{` esp_init6: esp_init6: crypto_alg_id $D1.`},					\
	764{` esp_init6: esp_init6: prepare_key() err.`},					\
	765{` esp_init6: esp_rply_init6() crypto_sys not found.`},				\
	766{` esp_init6: esp_rply_init6() Prepare key for DES failed.`},			\
	767{` esp_init6: esp_rply_init6() Prepare key for DES failed.`},			\
	768{` esp_init6: esp_rply_init6() No encap_sys for mac.`},				\
	769{` esp_init6: esp_rply_init6() No mac system found for $D1.`},			\
	770{` esp_init6: esp_rply_init6() Prepare key for receiver ESP_AH failed.`},		\
	771{` esp_init6: esp_rply_init6() Prepare key for receiver ESP_AH failed.`},		\
	772{` esp_rply_cap4: esp_rply_encap4(): ENT tunnel_cache_p->s_enc_alg $D1.`},		\
	773{` esp_rply_cap4: esp_rply_encap4(): NO_HDR.`},					\
	774{` esp_rply_cap4: esp_rply_encap4(): NO_TC.`},					\
	775{` esp_rply_cap4: esp_rply_encap4(): NO_OMBUF.`},					\
	776{` esp_rply_cap4: esp_rply_encap4(): Could not allocate pad.`},			\
	777{` esp_rply_cap4: esp_rply_encap4(): no esp_hdr_p.`},				\
	778{` esp_rply_cap4: esp_rply_encap4(): no m_digest_p.`},				\
	779{` esp_rply_cap4: esp_rply_encap4(): Could not allocate udp_hdr.`},			\
	780{` esp_rply_cap4: esp_rply_encap4(): LONG_STPI.`},					\
	781{` esp_rply_cap4: esp_rply_encap4(): Pad length is $D1.`},				\
	782{` esp_rply_cap4: esp_rply_encap4(): m_copy on null encrypt failed.`},		\
	783{` esp_rply_cap4: esp_rply_encap4(): BAD_ENC.`},					\
	784{` esp_rply_cap4: esp_rply_encap4(): esp_p said $D1 iv 0x$D2 0x$D3.`},		\
	785{` esp_rply_cap4: esp_rply_encap4(): authentication failed.`},			\
	786{` esp_rply_cap4: esp_rply_encap4(): MD5 digest = $D1 $D2 $D3.`},			\
	787{` esp_rply_cap4: esp_rply_encap4(): NO_OHDR.`},					\
	788{` esp_rply_cap4: esp_rply_encap4(): Add NATT UDP header.`},				\
	789{` esp_rply_cap4: esp_rply_encap4(): EXIT.`},					\
	790{` esp_rply_cap4: esp_rply_decap4(): ENT tunnel_cache_p->r_enc_alg $D1.`},		\
	791{` esp_rply_cap4: esp_rply_decap4(): dm->m_len $D1.`},				\
	792{` esp_rply_cap4: esp_rply_encap4(): no tunnel cache entry.`},			\
	793{` esp_rply_cap4: esp_rply_decap4(): HDR_LEN $D1.`},					\
	794{` esp_rply_cap4: esp_rply_decap4(): Payload length is $D1.`},			\
	795{` esp_rply_cap4: esp_rply_decap4(): BAD_LEN for payload_len $D1.`},			\
	796{` esp_rply_cap4: esp_rply_decap4(): ip_hdr_len = $D1, m_input_p->m_len = $D2.`},	\
	797{` esp_rply_cap4: esp_rply_decap4(): authen func failed.`},				\
	798{` esp_rply_cap4: W2 $HL%S1`},							\
	799{` esp_rply_cap4: W2 $HL%S1`},							\
	800{` esp_rply_cap4: esp_rply_decap4(): NO_OMBUF.`},					\
	801{` esp_rply_cap4: esp_rply_decap4(): iv 0x$D1 0x$D2.`},				\
	802{` esp_rply_cap4: esp_rply_decap4(): BAD_ENC.`},					\
	803{` esp_rply_cap4: esp_rply_decap4(): m_copy on null decrypt failed.`},		\
	804{` esp_rply_cap4: esp_rply_decap4(): Bad Payload i = $D1.`},				\
	805{` esp_rply_cap4: W2 $HL%S1`},							\
	806{` esp_rply_cap4: esp_rply_decap4(): PULLUP_ERR.`},					\
	807{` esp_rply_cap4: esp_rply_decap4(): NO_HMBUF.`},					\
	808{` esp_rply_cap4: esp_rply_decap4(): HPULLUP_ERR.`},					\
	809{` esp_rply_cap4: esp_rply_decap4(): Returning non-error code in error path.`},	\
        1800{` esp_rply_cap4: _encap4(): incorrect salt size ($D1).`},                          \
        1801{` esp_rply_cap4: _encap4(): Could not allocate esp_esn_hdr.`},                     \
        1802{` esp_rply_cap4: _encap4(): combined mode (ESN) encryption failed.`},              \
        1803{` esp_rply_cap4: _encap4(): combined mode encryption failed.`},                    \
        1804{` esp_rply_cap4: _encap4(): m_copy (GMAC) failed.`},                               \
        1805{` esp_rply_cap4: _encap4(): combined mode GMAC (ESN) failed.`},                    \
        1806{` esp_rply_cap4: _encap4(): combined mode GMAC failed.`},                          \
        1807{` esp_rply_cap4: _encap4(): unsupported combined mode, alg_id = $D1.`},            \
        1810{` esp_rply_cap4: _decap4(): incorrect salt size ($D1).`},                          \
        1811{` esp_rply_cap4: _decap4(): Could not allocate esp_hdr.`},                         \
        1812{` esp_rply_cap4: _decap4(): Could not allocate output buffer n.`},                 \
        1813{` esp_rply_cap4: _decap4(): combined mode decryption failed.`},                    \
        1814{` esp_rply_cap4: _decap4(): m_copy (GMAC) failed.`},                               \
        1815{` esp_rply_cap4: _decap4(): combined mode GMAC (ESN) failed.`},                    \
        1816{` esp_rply_cap4: _decap4(): combined mode GMAC failed.`},                          \
        1817{` esp_rply_cap4: _decap4(): unsupported combined mode, alg_id = $D1.`},            \
	810{` esp_rply_cap6: _encap6(): Entrance: transport_mode = $D1.`},			\
	811{` esp_rply_cap6: _encap6(): no header.`},						\
	812{` esp_rply_cap6: _encap6(): tunnel mode not supported for mobility packet with Home Address option.`}, \
	813{` esp_rply_cap6: _encap6(): error in cap6_make_complete_ipv6_packet.`},		\
	814{` esp_rply_cap6: _encap6(): size_before_esP = $D1.`},				\
	815{` esp_rply_cap6: _encap6(): no tunnel cache supplied.`},				\
	816{` esp_rply_cap6: _encap6(): input_len = $D1, ip6_len = $D2, output_len = $D3.`}, 	\
	817{` esp_rply_cap6: _encap6(): no mbuf for tmp_n_p.`},					\
	818{` esp_rply_cap6: _encap6(): No mbuf for padding_p.`},				\
	819{` esp_rply_cap6: _encap6(): no esp_hdr_p allocated.`},				\
	820{` esp_rply_cap6: _encap6(): no m_digest_p allocated -- dropping pkt.`},		\
	821{` esp_rply_cap6: _encap6(): Long stpi.`},						\
	822{` esp_rply_cap6: _encap6(): padding_p->m_len = $D1, output_len = $D2.`},		\
	823{` esp_rply_cap6: _encap6(): m_copy on null encrypt failed.`},			\
	824{` esp_rply_cap6: _encap6(): encryption failed.`},					\
	825{` esp_rply_cap6: _encap6(): Added ESP hdr; output_len = $D1.`},			\
	826{` esp_rply_cap6: _encap6(): auth alg failed.`},					\
	827{` esp_rply_cap6: _encap6(): ESP Auth Digest (part) is 0x$D1, AUTH_LEN is $D2.`}, 	\
	828{` esp_rply_cap6: _encap6(): Added digest, output_len now $D1.`},			\
	829{` esp_rply_cap6: _encap6(): transport mode.`},					\
	830{` esp_rply_cap6: _encap6(): 2nd or last encapsulation, Set ip6_len to $D1.`}, 	\
	831{` esp_rply_cap6: _encap6(): output_len with V6 hdr is $D1.`},			\
	832{` esp_rply_cap6: _encap6(): 1st and not last encapsulation.`},			\
	833{` esp_rply_cap6: _encap6(): return 0 output_len = $D1.`},				\
	834{` esp_rply_cap6: _decap6(): no tunnel cache entry.`},				\
	835{` esp_rply_cap6: _decap6():  hdr_len is $D1, block_len = $D2.`},			\
	836{` esp_rply_cap6: _decap6(): output_len w/o iphdr or esphdr is $D1.`},		\
	837{` esp_rply_cap6: _decap6(): remb.sys->alg_id was SEC_TUNNEL_HMAC_MD5 -- subtracting $D1 from $D2.`}, \
	838{` esp_rply_cap6: _decap6(): bad len: $D1.`},					\
	839{` esp_rply_cap6: _decap6(): took digest at offset $D1, digest (part) is 0x$D2.`}, 	\
	840{` esp_rply_cap6: _decap6(): ESP auth func failed.`},				\
	841{` esp_rply_cap6: _decap6(): calculated digest (part) is 0x$D1.`},			\
	842{` esp_rply_cap6: _decap6(): auth digest compare error.`},				\
	843{` esp_rply_cap6: _decap6(): mbuf failure for decrypted_data_p.`},			\
	844{` esp_rply_cap6: _decap6(): decryption failed.`},					\
	845{` esp_rply_cap6: _decap6(): m_copy on null decrypt failed.`},			\
	846{` esp_rply_cap6: _decap6(): decryption succedded, but no data,mbuf len = 0.`}, 	\
	847{` esp_rply_cap6: _decap6(): invalid padding length.`},				\
	848{` esp_rply_cap6: _decap6(): invalid padding length.`},				\
	849{` esp_rply_cap6: _decap6(): non conform padding received in ESP.`},			\
	850{` esp_rply_cap6: W2 $HL%S1`},							\
	851{` esp_rply_cap6: _decap6(): After removing padding, output_len = $D1.`},		\
	852{` esp_rply_cap6: _decap6(): transport mode.`},					\
	853{` esp_rply_cap6: _decap6(): pullup error.`},					\
	854{` esp_rply_cap6: _decap6(): tunnel mode.`},						\
	855{` esp_rply_cap6: _decap6(): no mbuf.`},						\
	856{` esp_rply_cap6: _decap6(): error pullup.`},					\
	857{` esp_rply_cap6: _decap6(): return 0.`},						\
	858{` esp_rply_cap6: _decap6(): Returning non-error code in error path.`},		\
        1820{` esp_rply_cap6: _encap6(): incorrect salt size ($D1).`},                          \
        1821{` esp_rply_cap6: _encap6(): Could not allocate esp_esn_hdr.`},                     \
        1822{` esp_rply_cap6: _encap6(): combined mode (ESN) encryption failed.`},              \
        1823{` esp_rply_cap6: _encap6(): combined mode encryption failed.`},                    \
        1824{` esp_rply_cap6: _encap6(): m_copy (GMAC) failed.`},                               \
        1825{` esp_rply_cap6: _encap6(): combined mode GMAC (ESN) failed.`},                    \
        1826{` esp_rply_cap6: _encap6(): combined mode GMAC failed.`},                          \
        1827{` esp_rply_cap6: _encap6(): unsupported combined mode, alg_id = $D1.`},            \
        1830{` esp_rply_cap6: _decap6(): incorrect salt size ($D1).`},                          \
        1831{` esp_rply_cap6: _decap6(): Could not allocate esp_hdr.`},                         \
        1832{` esp_rply_cap6: _decap6(): Could not allocate output buffer.`},                   \
        1833{` esp_rply_cap6: _decap6(): combined mode decryption failed.`},                    \
        1834{` esp_rply_cap6: _decap6(): m_copy (GMAC) failed.`},                               \
        1835{` esp_rply_cap6: _decap6(): combined mode GMAC (ESN) failed.`},                    \
        1836{` esp_rply_cap6: _decap6(): combined mode GMAC failed.`},                          \
        1837{` esp_rply_cap6: _decap6(): unsupported combined mode, alg_id = $D1.`},            \
	859{` ip6_invariant: IP6_take_invariant().`},						\
	860{` ip6_invariant: IP6_take_invariant(): no input packet.`},				\
	861{` ip6_invariant: IP6_take_invariant(): cannot allocate mbuf.`},			\
	862{` ip6_invariant: IP6_take_invariant(): cannot allocate cluster.`},			\
	863{` ip6_invariant: IP6_take_invariant(): processing options.`},			\
	864{` ipsec_cap4: ipsp_encapsulate(): tunnel $D1 has no tunnel cache entry.`},		\
	865{` ipsec_cap4: ipsp_encapsulate(): ipsp_get_mbuf failed.`},				\
	866{` ipsec_cap4: ipsp_encapsulate(): addr mismatch.`},					\
	867{` ipsec_cap4: ipsp_encapsulate(): ESP lifesize reached.`},				\
	868{` ipsec_cap4: ipsp_encapsulate(): AH lifesize reached.`},				\
	869{` ipsec_cap4: ipsp_encapsulate(): MLEN $D1.`},					\
	870{` ipsec_cap4: ipsp_encapsulate(): OLEN $D1.`},					\
	871{` ipsec_cap4: ipsp_encapsulate(): failed to add SA for on-the-fly hardware encryption.`}, \
	872{` ipsec_cap4: ipsp_decapsulate(): found offload mbuf, but not adapter struct.`},	\
	873{` ipsec_cap4: ipsp_decapsulate(): illegal offload mbuf type: $D1.`},		\
	874{` ipsec_cap4: ipsp_decapsulate(): STRIPS_HEADERS not handled yet.`},		\
	875{` ipsec_cap4: ipsp_decapsulate(): offload mbuf but next proto = $D1.`},		\
	876{` ipsec_cap4: ipsp_decapsulate(): ip_len $D1 hlen $D2.`},				\
	877{` ipsec_cap4: ipsp_decapsulate(): ip_len $D1 hlen $D2.`},				\
	878{` ipsec_cap4: ipsp_decapsulate(): m_pullup returned 0.`},				\
	879{` ipsec_cap4: ipsp_decapsulate(): ip_len $D1 too short.`},				\
	880{` ipsec_cap4: ipsp_decapsulate(): ip_hdr_len = $D1 ip_hdr_addr = $D2.`},		\
	881{` ipsec_cap4: ipsp_decapsulate(): short pullup.`},					\
	882{` ipsec_cap4: ipsp_decapsulate(): SAID = $D1, tc_get_flag = $D2, esp = $D3.`},	\
	883{` ipsec_cap4: ipsp_decapsulate(): NO TC, said $D1.`},				\
	884{` ipsec_cap4: ipsp_decapsulate(): W2 $HL%S1`},					\
	885{` ipsec_cap4: ipsp_decapsulate(): Reloading SA due to rcv_missed_count: tid = 0x$D1, entry = $D2.`}, \
	886{` ipsec_cap4: ipsp_decapsulate(): NDD call to modify tid 0x$D1 in entry $D2 failed.`}, \
	887{` ipsec_cap4: ipsp_decapsulate(): ESP lifesize reached.`},				\
	888{` ipsec_cap4: ipsp_decapsulate(): AH lifesize reached.`},				\
	889{` ipsec_cap4: ipsp_decapsulate(): mismatch of nested tunnel ids.`},			\
	890{` ipsec_cap4: ipsp_decapsulate(): offload mbuf len = $D1.`},			\
	891{` ipsec_cap4: ipsp_decapsulate(): bad offload status = 0x$D1.`},			\
	892{` ipsec_cap4: ipsp_decapsulate(): offload entry $D1 does not match tunnel cache.`},	\
	893{` ipsec_cap4: ipsp_decapsulate(): offload esp err $D1.`},				\
	894{` ipsec_cap4: ipsp_decapsulate(): offload ah err $D1.`},				\
	895{` ipsec_cap4: ipsp_decapsulate(): decap err $D1.`},					\
	896{` ipsec_cap4: ipsp_decapsulate(): MLEN $D1.`},					\
	897{` ipsec_cap4: ipsp_decapsulate(): OLEN $D1.`},					\
	898{` ipsec_cap4: ipsp_decapsulate(): NOTME.`},						\
	899{` ipsec_cap4: ipsp_decapsulate(): decap\'d policy doesn\'t match stored policy.`},	\
	900{` ipsec_cap4: ipsp_decapsulate(): decap\'d policy mismatch with stored policy t:$D1 d:$D2.`}, \
	901{` ipsec_cap4: ipsp_decapsulate(): NO TC, said $D1.`},				\
	902{` ipsec_cap6: cap6_input().`},							\
	903{` ipsec_cap6: cap6_make_complete_ipv6_packet(): cannot invert mbuf chain.`},	\
	904{` ipsec_cap6: cap6_make_complete_ipv6_packet(): cannot allocate mbuf.`},		\
	905{` ipsec_cap6: cap6_make_complete_ipv6_packet(): cannot allocate cluster.`},		\
	906{` ipsec_cap6: cap6_make_complete_ipv6_packet(): cannot invert mbuf chain.`},	\
	907{` ipsec_cap6: cap6_encapulate().`},							\
	908{` ipsec_cap6: cap6_encapsulate(): no tunnel cache.`},				\
	909{` ipsec_cap6: cap6_encapsulate(): no hdr for 2nd IP hdr.`},				\
	910{` ipsec_cap6: cap6_encapsulate(): addr mismatch for transport mode.`},		\
	911{` ipsec_cap6: cap6_encapsulate(): ESP lifesize reached.`},				\
	912{` ipsec_cap6: cap6_encapsulate(): AH lifesize reached.`},				\
	913{` ipsec_cap6: cap6_encapsulate(): success.`},					\
	914{` ipsec_cap6: IP6_packet_for_me().`},						\
	915{` ipsec_cap6: cap6_decapsulate().`},						\
	916{` ipsec_cap6: cap6_decapsulate(): [1]: ip_header_p->ip6_len = $D1.`},		\
	917{` ipsec_cap6: cap6_decapsulate(): bad len.`},					\
	918{` ipsec_cap6: cap6_decapsulate(): pullup error.`},					\
	919{` ipsec_cap6: cap6_decapsulate(): decap begin.`},					\
	920{` ipsec_cap6: cap6_decapsulate(): said=0x$D1, tunnel_id spec=$D2, tc_get_flag=$D3.`}, \
	921{` ipsec_cap6: cap6_decapsulate(): no tunnel cache.`},				\
	922{` ipsec_cap6: cap6_decapsulate(): no tunnel cache.`},				\
	923{` ipsec_cap6: ipsp_decapsulate(): ESP lifesize reached.`},				\
	924{` ipsec_cap6: ipsp_decapsulate(): AH lifesize reached.`},				\
	925{` ipsec_cap6: cap6_decapsulate(): decapsulation error.`},				\
	926{` ipsec_cap6: cap6_decapsulate(): ip_header_p->ip6_nh=$D1.`},			\
	927{` ipsec_cap6: cap6_decapsulate(): decapsulation done.`},				\
	928{` ipsec_cap6: cap6_decapsulate(): doing second decapsulation.`},			\
	929{` ipsec_cap6: cap6_decapsulate(): decapsulated policy does not match stored policy.`}, \
	930{` ipsec_cap6: cap6_decapsulate(): decapsulated policy order mismatch.`},		\
	931{` ipsec_cap6: cap6_decapsulate(): return 0.`},					\
	932{` ipsec_cap6: cap6_decapsulate(): NO TC, said $D1.`},				\
	933{` ipsec_cap6: cap6_decapsulate(): bad decapsulation.`},				\
	934{` ipsec_offload4: psec_offload_callback: ndd = 0x$D1.`},				\
	935{` ipsec_offload4: ipsec_offload_callback: ndd offload not set in flags = 0x$D1.`},	\
	936{` ipsec_offload4: ipsec_offload_callback: adapter_head = 0x$D1.`},			\
	937{` ipsec_offload4: ipsec_offload_callback: no adapter struct.`},			\
	938{` ipsec_offload4: ipsec_offload_callback: Unknown command = $D1.`},			\
	939{` ipsec_offload4: ipsec_offload_adapter_p(): ndd_to_dev: Offload QUERY failed.`},	\
	940{` ipsec_offload4: ipsec_offload_adapter_p(): ndd_to_dev: net_malloc returned NULL.`}, \
	941{` ipsec_offload4: ndd_to_dev: init_dev_dep_functions returned error.`},		\
	942{` ipsec_offload4: ndd_to_dev: offload REGISTER callback failed.`},			\
	943{` ipsec_offload4: ipsec_SA_offloaded: failed to add SA for tid 0x$D1 in entry $D2.`}, \
	944{` ipsec_offload4: ipsec_offload_dev_dep_data_change: can't find old adapter.`},	\
	945{` ipsec_offload4: ipsec_offload_dev_dep_data_change: can't find new adapter.`},	\
	946{` ipsec_offload4: ipsec_offload_dev_dep_data_change: can't find tunnel cache entry for tid 0x$D1.`}, \
	947{` ipsec_offload4: ipsec_offload_dev_dep_data_change: undo failed.`},		\
	948{` ipsec_offload4: ipsec_offload_esp_decap: pdev = 0x$D1 tc_p=0x$D2.`},		\
	949{` ipsec_offload4: ipsec_offload_esp_decap: no ESP, status = 0x$D1.`},		\
	950{` ipsec_offload4: ipsec_offload_esp_decap: adapter didn't do ESP - alg = $D1, status = 0x$D2.`}, \
	951{` ipsec_offload4: ipsec_offload_esp_decap: invalid payload_len ($D1).`},		\
	952{` ipsec_offload4: ipsec_offload_esp_decap: encrypt len ($D1) not multiple of 8.`}, 	\
	953{` ipsec_offload4: ipsec_offload_esp_decap: chk_replay_window failed.`},		\
	954{` ipsec_offload4: ipsec_offload_esp_decap: auth alg = $D1, status = 0x$D2.`},	\
	955{` ipsec_offload4: ipsec_offload_esp_decap: m_copy failed.`},			\
	956{` ipsec_offload4: ipsec_offload_esp_decap: pad_len ($D1) >= enc len ($D2).`},	\
	957{` ipsec_offload4: ipsec_offload_esp_decap: header mismatch - transport = $D1, proto = $D2.`}, \
	958{` ipsec_offload4: ipsec_offload_esp_decap: m_pullup failed, len = $D1.`},		\
	959{` ipsec_offload4: ipsec_offload_esp_decap: ipsp_get_mbuf failed.`},			\
	960{` ipsec_offload4: ipsec_offload_esp_decap: m_pullup (2) failed, len = $D1.`},	\
	961{` ipsec_offload4: ipsec_offload_ah_decap: pdev = 0x$D1 tc_p=0x$D2.`},		\
	962{` ipsec_offload4: ipsec_offload_ah_decap: bad offload status = 0x$D1.`},		\
	963{` ipsec_offload4: ipsec_offload_ah_decap: No mbuf header.`},			\
	964{` ipsec_offload4: ipsec_offload_ah_decap: bad ip_len = $D1.`},			\
	965{` ipsec_offload4: ipsec_offload_ah_decap: m_pullup failed, len = $D1.`},		\
	966{` ipsec_offload4: ipsec_offload_ah_decap: chk_replay_window failed.`},		\
	967{` ipsec_offload4: ipsec_offload_ah_decap: header mismatch - transport = $D1, proto = $D2.`}, \
	968{` ipsec_offload4: ipsec_offload_ah_decap: m_gethdr failed.`},			\
	969{` ipsec_offload4: ipsec_offload_ah_decap: m_pullup (2) failed, size = $D1.`},	\
	970{` ipsec_offload4: esp_rply_add_headers4() ENT tunnel_cache_p->s_enc_alg $D1.`},	\
	971{` ipsec_offload4: esp_rply_add_headers4() NO_HDR.`},				\
	972{` ipsec_offload4: esp_rply_add_headers4() NO_TC.`},					\
	973{` ipsec_offload4: esp_rply_add_headers4() Could not allocate pad.`},		\
	974{` ipsec_offload4: esp_rply_add_headers4:no esp_hdr_p.`},				\
	975{` ipsec_offload4: esp_rply_add_headers4:no m_digest_p.`},				\
	976{` ipsec_offload4: esp_rply_add_headers4() LONG_STPI.`},				\
	977{` ipsec_offload4: esp_rply_add_headers4: Pad length is $D1.`},			\
	978{` ipsec_offload4: esp_rply_add_headers4() m_copy failed.`},				\
	979{` ipsec_offload4: esp_rply_add_headers4() esp_p said $D1.`},			\
	980{` ipsec_offload4: esp_rply_add_headers4(): unsupported xmt offload capability: AH transport inside ESP transport.`}, \
	981{` ipsec_offload4: esp_rply_add_headers4() NO_OHDR.`},				\
	982{` ipsec_offload4: esp_rply_add_headers4() EXIT.`},					\
	983{` ipsec_offload4: ah_rply_add_headers4() ENT s_mac_alg $D1.`},			\
	984{` ipsec_offload4: ah_rply_add_headers4() NO_HDR.`},					\
	985{` ipsec_offload4: ah_rply_add_headers4() NO_TC.`},					\
	986{` ipsec_offload4: ah_rply_add_headers4() NO_OMBUF.`},				\
	987{` ipsec_offload4: ah_rply_add_headers4() NO_PAD.`},					\
	988{` ipsec_offload4: ah_rply_add_headers4() ENCAP_SYS_LAST.`},				\
	989{` ipsec_offload4: ah_rply_add_headers4() NO_OHDR.`},				\
	990{` ipsec_offload4: ah_rply_add_headers4() EXIT.`},					\
	991{` replay: chk_replay_window: Got sequence number of 0.`},				\
	992{` replay: chk_replay_window: seq=$D1, replay_p->cnt=$D2, bitmap=0x$D3.`},		\
	993{` replay: update_replay_window: received seq == 0.`},				\
	994{` replay: update_replay_window: bitmap=0x$D1, replay_p->cnt=$D2, seq=$D3.`},	\
        995{` replay: chk_replay_window: replay_p is NULL. ` },                                 \
        996{` replay: update_replay_window: replay_p is NULL. ` },                              \
	\* { " unknown subhook " id=$HD%UW } \
        }
2E1 1.0 'IPSEC_CAPSUL_INFO' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      }
2E2 1.0 'IPSEC_CRYPTO' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      }, \
    0 { $HD%D1,								        	        \
        1201{` pkt_hmac_prepare_key() mb = NULL. `},                                            \
        1202{` pkt_hmac_prepare_key() invalid parameter vaule for key. klen = $D1. `},          \
        1203{` pkt_hmac_prepare_key() CLiC_hmac_new failed, err = $D1. `},                      \
        1204{` pkt_hmac_free_mem() CLiC_dispose failed, err = $D1. `},                          \
        1205{` pkt_hmac() mb = NULL. `},                                                        \
        1206{` pkt_hmac() min = NULL. `},                                                       \
        1207{` pkt_hmac() hmac = NULL. `},                                                      \
        1208{` pkt_hmac() ilen <= i_off. ilen = $D1, i_off = $D2. `},                           \
        1209{` pkt_hmac() mb->aux_data.content is NULL. `},                                     \
        1211{` pkt_hmac() CLiC_copy failed, err = $D1.`},                                       \
        1212{` pkt_hmac() next mbuf is NULL. `},                                                \
        1213{` pkt_hmac() CLiC_hmac_update failed, err = $D1. len = $D2.`},                     \
        1214{` pkt_hmac() m->m_next =NULL. `},                                                  \
        1215{` pkt_hmac() CLiC_hmac_update/final failed, err = $D1.`},                          \
        1216{` pkt_hmac() CLiC_dispose failed, err = $D1.`},                                    \
	1251{` hmac_md5: hmac_pkt_md5() pkt_hmac failed. `},		                        \
        1252{` hmac_md5: hmac_pkt_md5_prepare_key() pkt hmac_prepare_key failed. `},            \
	1253{` hmac_md5: hmac_pkt_md5_free_mem() pkt_hmac_free_mem failed.`},	                \
	1254{` hmac_md5: hmac_md5_config: ipsp_del_kernel_mac_sys() err $D1.`},			\
	1261{` hmac_sha: hmac_pkt_sha() pkt_hmac failed. `},		                        \
        1262{` hmac_sha: hmac_pkt_sha_prepare_key() pkt hmac_prepare_key failed. `},            \
	1263{` hmac_sha: hmac_pkt_sha_free_mem() pkt_hmac_free_mem failed.`},	                \
	1264{` hmac_sha: hmac_sha_config: ipsp_del_kernel_mac_sys() err $D1.`},			\
	1271{` pkt_md5: pkt_md5_prepare_key() net_malloc failed. len = $D1. `},                 \
        1272{` pkt_md5: pkt_md5() output md5 = NULL .` },                                       \
        1273{` pkt_md5: pkt_md5() ilen <=i_off, ilen = $D1, i_off = $D2 .` },                   \
        1274{` pkt_md5: pkt_md5_prepare_key() CLiC_digest_new failed, err = $D1, klen = $D2.`}, \
        1275{` pkt_md5: pkt_md5_prepare_key() CLiC_digest_update(key) failed, err = $D1, klen = $D2.`}, \
        1276{` pkt_md5: pkt_md5_prepare_key() CLiC_digest_update(keyfill) failed, err = $D1, padlen = $D2.`}, \
        1277{` pkt_md5: pkt_md5() invalid mbuf (is NULL). `},                                   \
        1278{` pkt_md5: pkt_md5() CLiC_digest_update(data) failed, err = $D1, len = $D2.`},     \
        1279{` pkt_md5: pkt_md5() next mbuf is NULL. `},                                        \
        1280{` pkt_md5: pkt_md5() CLiC_digest_update(key2) failed, err = $D1, klen = $D2.`},    \
        1281{` pkt_md5: pkt_md5() CLiC_dispose failed, err $D1.`},                              \
        1282{` pkt_md5: pkt_md5_free_mem() key.content = NULL key.len = $D1.`},			\
	1283{` pkt_md5: pkt_md5_config: ipsp_del_kernel_mac_sys() err $D1.`},			\
        1284{` pkt_md5: pkt_md5() CLiC_copy failed, err $D1.`},                                 \
        1285{` pkt_md5: pkt_md5_prepare_key() CLiC_dispose failed, err $D1.`},                  \
        1286{` pkt_md5: pkt_md5_free_mem() CLiC_dispose failed, err $D1. `},                    \
        1301{` pkt_initktab: crypto block (cb) is NULL. `},                                     \
        1302{` pkt_initktab: invalid key input. keylen = $D1. `},                               \
        1303{` pkt_initktab: CLiC_cipher_new failed, err = $D1. `},                             \
        1304{` pkt_free_mem: CLiC_dispose failed, err = $D1. `},                                \
        1305{` enc_pkt: crypto block (cb) is NULL. `},                                          \
        1306{` enc_pkt: in mbuf is NULL. `},                                                    \
        1307{` enc_pkt: out mbuf is NULL. `},                                                   \
        1308{` enc_pkt: wrong data lengths, ilen = $D1, i_off = $D2. `},                        \
        1310{` enc_pkt: cb->aux_data.content is NULL. `},                                       \
        1311{` enc_pkt: data len is not multiple of crypto block size, plen = $D1. `},          \
        1312{` enc_pkt: min_walk is NULL. `},                                                   \
        1313{` enc_pkt: CLiC_copy failed, err = $D1. `},                                        \
        1314{` enc_pkt: CLiC_cipher_reset failed, err = $D1. `},                                \
        1315{` enc_pkt: CLiC_cipher_update failed, err = $D1. `},                               \
        1316{` enc_pkt: wrong fract_len = $D1. `},                                              \
        1317{` enc_pkt: wrong plen = $D1. `},                                                   \
        1318{` enc_pkt: wrong olen = $D1. `},                                                   \
        1319{` enc_pkt: wrong len = $D1. `},                                                    \
        1320{` enc_pkt: no out buf (mout=NULL). `},                                             \
        1321{` enc_pkt: no in buf (min_wlk=NULL). `},                                           \
        1322{` enc_pkt: CLiC_dispose failed, err = $D1. `},                                     \
        1323{` pkt_enc_auth: crypto block (cb) is NULL. `},                                     \
        1324{` pkt_enc_auth: Both min and ADD are NULL. `},                                     \
        1325{` pkt_enc_auth: mac is NULL or it has wrong size (mac_len = $D1). `},              \
        1326{` pkt_enc_auth: IV len ($D1) is not 12. `},                                        \
        1327{` pkt_enc_auth: wrong ilen ($D1) or i_off ($D2).  `},                              \
        1328{` pkt_enc_auth: wrong add_len ($D1) or add_off ($D2). `},                          \
        1329{` pkt_enc_auth: No cipher object (aux_data.content is NULL). `},                   \
        1330{` pkt_enc_auth: CLiC_copy failed, err = $D1. `},                                   \
        1331{` pkt_enc_auth: CLiC_cipher_reset failed, err = $D1. `},                           \
        1332{` pkt_enc_auth: net_malloc failed. `},                                             \
        1333{` pkt_enc_auth: CLiC_cipher_message (GCM) failed, err = $D1. `},                   \
        1334{` pkt_enc_auth: mout is NULL. `},                                                  \
        1335{` pkt_enc_auth: ADD len ($D1) should be either 8 or 12. `},                        \
        1336{` pkt_enc_auth: CLiC_cipher_message (GMAC) failed, err = $D1. `},                  \
        1337{` pkt_enc_auth: Invalid inputs, don't know to do GCM or GMAC. `},                  \
        1338{` pkt_enc_auth: CLiC_dispose failed, err = $D1. `},                                \
        1340{` pkt_gmac: mac block (mb) is NULL. `},                                            \
        1341{` pkt_gmac: min is NULL. `},                                                       \
        1342{` pkt_gmac: gmac is NULL. `},                                                      \
        1343{` pkt_gmac: wrong ilen ($D1) or i_off ($D2).  `},                                  \
        1344{` pkt_gmac: No cipher object (aux_data.content is NULL). `},                       \
        1345{` pkt_gmac: CLiC_copy failed, err = $D1. `},                                       \
        1346{` pkt_gmac: CLiC_cipher_reset failed, err = $D1. `},                               \
        1347{` pkt_gmac: stpi is NULL. `},                                                      \
        1348{` pkt_gmac: CLiC_cipher_message (one mbuf, no ESN) failed, err = $D1. `},          \
        1349{` pkt_gmac: net_malloc failed. `},                                                 \
        1750{` pkt_gmac: CLiC_cipher_message failed, err = $D1. `},                             \
        1751{` pkt_gmac: CLiC_dispose failed, err = $D1. `},                                    \
        1752{` random: ipsec_random():CLiC_rng failed, err = $D1. `},                           \
        1351{` aes_pkt_if: aes_pkt_initktab() wrong key imput, key.len = $D1. `},               \
        1352{` aes_pkt_if: aes_pkt_initktab() pkt_initktab failed. `},                          \
        1353{` aes_pkt_if: aes_pkt_free_mem() pkt_free_mem failed. `},                          \
        1354{` aes_pkt_if: aes_enc_pkt() enc_pkt failed. ` },                                   \
        1355{` aes_pkt_if: aes_dec_pkt() enc_pkt failed. ` },                                   \
        1356{` aes_pkt_if: aes_config() ipsp_del_kernel_crypto_sys failed, err = $D1. ` },      \
        1361{` des_pkt_if: des_pkt_initktab() wrong key imput, key.len = $D1. `},               \
        1362{` des_pkt_if: des_pkt_initktab() pkt_initktab failed. `},                          \
        1363{` des_pkt_if: des_pkt_free_mem() pkt_free_mem failed. `},                          \
        1364{` des_pkt_if: des_enc_pkt() enc_pkt failed. ` },                                   \
        1365{` des_pkt_if: des_dec_pkt() enc_pkt failed. ` },                                   \
        1366{` des_pkt_if: des_cbc_config() ipsp_del_kernel_crypto_sys failed, err = $D1. ` },  \
        1371{` 3des_pkt_if: des3_pkt_initktab() wrong key imput, key.len = $D1. `},             \
        1372{` 3des_pkt_if: des3_pkt_initktab() pkt_initktab failed. `},                        \
        1373{` 3des_pkt_if: des3_pkt_free_mem() pkt_free_mem failed. `},                        \
        1374{` 3des_pkt_if: des3_enc_pkt() enc_pkt failed. ` },                                 \
        1375{` 3des_pkt_if: des3_dec_pkt() enc_pkt failed. ` },                                 \
        1376{` 3des_pkt_if: triple_des_cbc_config() ipsp_del_kernel_crypto_sys failed, err = $D1. ` },  \
        1401{` pkt_cmac_prepare_key() mb = NULL. `},                                            \
        1402{` pkt_cmac_prepare_key() invalid parameter vaule for key. klen = $D1. `},          \
        1403{` pkt_cmac_prepare_key() invalid cipher type. type = $D1. `},                      \
        1404{` pkt_cmac_prepare_key() invalid key length. keylen = $D1. `},                     \
        1405{` pkt_cmac_prepare_key() CLiC_cmac_new failed, err = $D1. `},                      \
        1406{` pkt_cmac_free_mem() CLiC_dispose failed, err = $D1. `},                          \
        1407{` pkt_cmac() mb = NULL. `},                                                        \
        1408{` pkt_cmac() min = NULL. `},                                                       \
        1409{` pkt_cmac() cmac = NULL. `},                                                      \
        1410{` pkt_cmac() ilen <= i_off. ilen = $D1, i_off = $D2. `},                           \
        1411{` pkt_cmac() mb->aux_data.content is NULL. `},                                     \
        1412{` pkt_cmac() CLiC_copy failed, err = $D1.`},                                       \
        1413{` pkt_cmac() next mbuf is NULL. `},                                                \
        1414{` pkt_cmac() CLiC_cmac_update failed, err = $D1. len = $D2.`},                     \
        1415{` pkt_cmac() m->m_next =NULL. `},                                                  \
        1416{` pkt_cmac() CLiC_cmac_update/final failed, err = $D1.`},                          \
        1417{` pkt_cmac() CLiC_dispose failed, err = $D1.`},                                    \
        1451{` cmac_aes: cmac_aes_xcbc: pkt_cmac() failed. `},		                        \
        1452{` cmac_aes: cmac_aes_xcbc_prepare_key: pkt_cmac_prepare_key() failed. `},          \
	1453{` cmac_aes: cmac_aes_xcbc_free_mem: pkt_cmac_free_mem() failed.`},	                \
	1454{` cmac_aes: cmac_aes_xcbc_config: ipsp_del_kernel_mac_sys() err $D1.`},            \
        1471{` aes_gcm_pkt_initktab: wrong key (keylen = $D1). `},		                \
        1472{` aes_gcm_pkt_initktab: pkt_initktab() failed. `},                                 \
	1473{` aes_gcm_pkt_free_mem: pkt_free_mem() failed.`},	                                \
        1474{` aes_gcm_enc_pkt: pkt_enc_auth() failed.`},	                                \
        1475{` aes_gcm_dec_pkt: pkt_enc_auth() failed.`},	                                \
        1486{` aes_gmac_prepare_key: mb is NULL. `},                                            \
        1487{` aes_gmac_prepare_key: key is NULL. `},                                           \
        1488{` aes_gmac_prepare_key: wrong key len ($D1). `},                                   \
        1489{` aes_gmac_prepare_key: CLiC_cipher_new failed, err = $D1. `},                     \
        1490{` aes_gmac_free_mem: pkt_cmac_free_mem() failed.`},	                        \
        1491{` aes_gmac: pkt_gmac() failed.`},	                                                \
	\* { " unknown subhook " id=$HD%UW } \
        }
2E3 1.0 'IPSEC_CRYPTO_INFO' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      }
2E4 1.0 'IPSEC_TUNNEL' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      }, \
    0 { $HD%D1,										\
	1501{` tunnel_cache4: tc$D1_config():pincode() failed.`},				\
	1502{` tunnel_cache4: del_offloaded_sa(): NDD call to delete tid 0x$D1 from entry $D2 failed.`}, \
	1503{` tunnel_cache4: del_offloaded_sa(): tid 0x$D1 deleted from offloaded entry $D2.`}, \
	1504{` tunnel_cache4: delete_tc_entry(): total_cache_cnt is $D1.`},			\
	1505{` tunnel_cache4: delete_tc_entry(): tunnel id 0x$D1.`},				\
	1506{` tunnel_cache4: delete_tc_entry(): found id cache entry to delete.`},		\
	1507{` tunnel_cache4: delete_tc_entry(): didn't found id cache entry to delete.`},	\
	1508{` tunnel_cache4: tc_spend_bytes: s_ah_nbytes=$D1, s_esp_nbytes=$D2, r_ah_nbytes=$D3, s_esp_nbytes=$D4.`}, \
	1509{` tunnel_cache4: tc$D1_clear: Clearing tunnel cache: total_cnt = $D2.`},		\
	1510{` tunnel_cache4: tc$D1_clear: Marked tunnel 0x$D2 for deletion.`},			\
	1511{` tunnel_cache4: tc$D1_clear: Removing entry for tunnel 0x$D2.`},			\
	1512{` tunnel_cache4: tc$D1_get: Bad parameters -- returning NULL.`},			\
	1513{` tunnel_cache4: tc$D1_get: Got tunnel-ID hash result of $D2 for tunnel ID=0x$D3.`}, \
	1514{` tunnel_cache4: tc$D1_get: No entries in tunnel ID cache bucket--return NULL.`},	\
	1515{` tunnel_cache4: tc$D1_get: Looking through tunnel ID hash list: current entry tid is 0x$D2.`}, \
	1516{` tunnel_cache4: tc$D1_get: Found entry for tid=0x$D2 in tunnel-ID hash list.`},	\
	1517{` tunnel_cache4: tc$D1_get: Didn't find a match in tunnel-ID cache bucket -- return NULL.`}, \
	1518{` tunnel_cache4: tc$D1_get: Rem addr param: 0x$D1.`},				\
	1519{` tunnel_cache4: W2 $HL%S1`},							\
	1520{` tunnel_cache4: tc$D1_get: tunnel hash result is $D2 (remote address hash).`},	\
	1521{` tunnel_cache4: tc$D1_get: tunnel hash bucket count=($D2) - return NULL.`},	\
	1522{` tunnel_cache4: tc$D1_get: .`},							\
	1523{` tunnel_cache4: Table entry: tid=0x$D1: re=$D2: ra=$D3: le=$D4: la=$D5.`},	\
	1524{` tunnel_cache4: tc$D1_get: Table entry: rem addr 0x$D2.`},			\
	1525{` tunnel_cache4: W2 $HL%S1`},							\
	1526{` tunnel_cache4: tc$D1_get: Table entry: local addr 0x$D1.`},			\
	1527{` tunnel_cache4: W2 $HL%S1`},							\
	1528{` tunnel_cache4: tc$D1_get: Skipping previously deleted tunnel entry.`},		\
	1529{` tunnel_cache4: tc$D1_get: Removing entry for tunnel 0x$D2.`},			\
	1530{` tunnel_cache4: tc$D1_get: tunnel 0x$D2 expired.`},				\
	1531{` tunnel_cache4: tc$D1_get(2): Removing entry for tunnel 0x$D2.`},			\
	1532{` tunnel_cache4: tc$D1_get: Addr mismatch.`},					\
	1533{` tunnel_cache4: tc$D1_get: Addr mismatch.`},					\
	1534{` tunnel_cache4: tc$D1_get: Mismatch in tids we want tid=0x$D2.`},			\
	1535{` tunnel_cache4: tc$D1_get: SAid mismatch, *tc_said=$D2 *said_p=$D3 mysaid=$D4.`},	\
	1536{` tunnel_cache4: tc$D1_get: Didn't find tunnel entry in tunnel hash list.`},	\
	1537{` tunnel_cache4: tc$D1_get: retrieved tunnel id 0x$D2, policy 0x$D3.`},		\
	1538{` tunnel_cache4: re=$D1: ra=$D2: le=$D3: la=$D4.`},				\
	1539{` tunnel_cache4: tc$D1_release: tunnel id: 0x$D2, policy 0x$D3.`},			\
	1540{` tunnel_cache4: re=$D1: ra=$D2: le=$D3: la=$D4.`},				\
	1541{` tunnel_cache4: tc$D1_release: tunnel 0x$D2 expired.`},				\
	1542{` tunnel_cache4: Threshold reached.`},						\
	1543{` tunnel_cache4: tc$D1_release: no mem.`},						\
	1544{` tunnel_cache4: Lifesize reached.`},						\
	1545{` tunnel_cache4: tc$D1_release: no mem.`},						\
	1546{` tunnel_cache4: Replay threshold reached.`},					\
	1547{` tunnel_cache4: tc$D1_release: no mem.`},						\
	1548{` tunnel_cache4: Replay rollover.`},						\
	1549{` tunnel_cache4: tc$D1_release: no mem.`},						\
	1550{` tunnel_cache4: tc$D1_insert: New entry: tid=0x$D2, policy 0x$D3.`},		\
	1551{` tunnel_cache4: re=$D1: ra=$D2: le=$D3: la=$D4: deleted=$D5.`},			\
	1552{` tunnel_cache4: tc$D1_insert: New entry: rem addr 0x$D2.`},			\
	1553{` tunnel_cache4: W2 $HL%S1`},							\
	1554{` tunnel_cache4: tc$D1_insert: New entry: local addr 0x$D2.`},			\
	1555{` tunnel_cache4: W2 $HL%S1`},							\
	1556{` tunnel_cache4: tc$D1_insert: Hash result for new entry is $D2.`},		\
	1557{` tunnel_cache4: W2 $HL%S1`},							\
	1558{` tunnel_cache4: tc$D1_insert: Table entry: rem addr 0x$D2.`},			\
	1559{` tunnel_cache4: W2 $HL%S1`},							\
	1560{` tunnel_cache4: tc$D1_insert: Table entry: local addr 0x$D2.`},			\
	1561{` tunnel_cache4: W2 $HL%S1`},							\
	1562{` tunnel_cache4: tc$D1_insert: Skipping deleted tc entry.`},			\
	1563{` tunnel_cache4: tc$D1_insert: Removing entry for tunnel 0x$D2.`},			\
	1564{` tunnel_cache4: tc$D1_insert: tunnel 0x$D2 expired.`},				\
	1565{` tunnel_cache4: tc$D1_insert(2): Removing entry for tunnel 0x$D2.`},		\
	1566{` tunnel_cache4: tc$D1_insert: Skipping- addr mismatch.`},				\
	1567{` tunnel_cache4: tc$D1_insert: Skipping- addr mismatch.`},				\
	1568{` tunnel_cache4: tc$D1_insert: Skipping- AH/ESP spi mismatch.`},			\
	1569{` tunnel_cache4: tc$D1_insert: Skipping- my AH spi mismatch.`},			\
	1570{` tunnel_cache4: tc$D1_insert: Skipping- my ESP spi mismatch.`},			\
	1571{` tunnel_cache4: tc$D1_insert: Found another entry matching in SPI/addr.`},	\
	1572{` tunnel_cache4: tc4_insert: NDD call to modify tid 0x$D1 in entry $D2 failed.`},	\
	1573{` tunnel_cache4: tc4_insert: refreshed SA of tid 0x$D1 in offloaded entry $D2.`},	\
	1574{` tunnel_cache4: tc4_insert: NDD call to modify tid 0x$D1 in entry $D2 failed.`},	\
	1575{` tunnel_cache4: tc4_insert: refreshed SA of tid 0x$D1 in offload entry $D2.`},	\
	1576{` tunnel_cache4: tc$D1_insert: tunnel-ID hash result is $D2 for tid=0x$D3.`},	\
	1577{` tunnel_cache4: tc$D1_insert: Currently checking tunnel id chain: tid=0x$D2.`},	\
	1578{` tunnel_cache4: tc$D1_insert: found existing tunnel ID hash entry, tid 0x$D2.`},	\
	1579{` tunnel_cache4: tc$D1_insert: ID hash entry pointed to old tc bucket.`},		\
	1580{` tunnel_cache4: tc$D1_insert: net_malloc failure during tunnel cache insert.`},	\
	1581{` tunnel_cache4: tc$D1_insert: Have $D2 in tunnel-ID bucket for tunnel 0x$D3.`},	\
	1582{` tunnel_cache4: tc$D1_insert: total_cache_cnt is $D2.`},				\
	1583{` tunnel_cache4: tc$D1_delete: Criteria tid=0x$D2: said=$D3: mysaid=$D4.`},	\
	1584{` tunnel_cache4: tc$D1_delete: rem addr is 0x$D2.`},				\
	1585{` tunnel_cache4: W2 $HL%S1`},							\
	1586{` tunnel_cache4: tc$D1_delete: tunnel hash result is $D2.`},			\
	1587{` tunnel_cache4: tc$D1_delete:.`},							\
	1588{` tunnel_cache4: Table entry: tid=0x$D1: re=$D2: ra=$D3: le=$D4: la=$D5.`},	\
	1589{` tunnel_cache4: tc$D1_delete: Table entry: rem addr 0x$D2.`},			\
	1590{` tunnel_cache4: W2 $HL%S1`},							\
	1591{` tunnel_cache4: tc$D1_delete: Table entry: local addr 0x$D2.`},			\
	1592{` tunnel_cache4: W2 $HL%S1`},							\
	1593{` tunnel_cache4: tc$D1_delete: Skipping deleted tc entry.`},			\
	1594{` tunnel_cache4: tc$D1_delete: Removing entry for tunnel 0x$D2.`},			\
	1595{` tunnel_cache4: tc$D1_delete: tunnel 0x$D2 expired.`},				\
	1596{` tunnel_cache4: tc$D1_delete: Removing entry for tunnel 0x$D2.`},			\
	1597{` tunnel_cache4: tc$D1_delete: skipping entry - mismatch with addr.`},		\
	1598{` tunnel_cache4: tc$D1_delete: skipping entry - mismatch in tid.`},		\
	1599{` tunnel_cache4: tc$D1_delete: skipping entry - mismatch in SPI.`},		\
	1600{` tunnel_cache4: tc$D1_delete: Marked tunnel 0x$D2 for deletion.`},		\
	1601{` tunnel_cache4: tc$D1_delete(2): Removing entry for tunnel 0x$D2.`},		\
	1602{` tunnel_cache4: get_tc_info(): tc_p->s_enc_key_len $D1.`},			\
	1603{` tunnel_cache4: get_tc_info(): tc_p->r_enc_key_len $D1.`},			\
	1604{` tunnel_cache4: get_tc_info(): tc_p->s_mac_key_len $D1.`},			\
	1605{` tunnel_cache4: get_tc_info(): tc_p->r_mac_key_len $D1.`},			\
	1606{` tunnel_cache4: get_tc_info(): tc_p->s_enc_mac_key_len $D1.`},			\
	1607{` tunnel_cache4: get_tc_info(): tc_p->r_enc_mac_key_len $D1.`},			\
	1608{` tunnel_cache4: tunnel_cache4_odt_activate: no mem.`},				\
	1609{` tunnel_cache4: tunnel_cache6_odt_activate: no mem.`},				\
        1701{` tunnel_cache4: get_tc_info(): tc_p->esp_salt_len $D1.`},	         		\
	1702{` tunnel_cache4: get_tc_info(): tc_p->ah_salt_len $D1.`},	        		\
	1610{` tunnel_if4: tuif_open: Attempted kernel open.`},					\
	1611{` tunnel_if4: tuif_write():net_malloc failed.`},					\
	1612{` tunnel_if4: tuif_write():copyin s_enc_key failed: $D1.`},			\
	1613{` tunnel_if4: tuif_write():copyin r_enc_key failed: $D1.`},			\
	1614{` tunnel_if4: tuif_write():copyin s_mac_key failed: $D1.`},			\
	1615{` tunnel_if4: tuif_write():copyin r_mac_key failed: $D1.`},			\
	1616{` tunnel_if4: tuif_write():copyin s_enc_mac_key failed: $D1.`},			\
	1617{` tunnel_if4: tuif_write():copyin r_enc_mac_key failed: $D1.`},			\
	1618{` tunnel_if4: tuif_write: Send ESP alg= $D1, fmt=$D2.`},				\
	1619{` tunnel_if4: tuif_write:no s crypto sys $D1 $D2.`},				\
	1620{` tunnel_if4: tuif_write:sesys pre key failed.`},					\
	1621{` tunnel_if4: tuif_write: No Send ESP Alg Defined.`},				\
	1622{` tunnel_if4: tuif_write: Recv ESP alg=$D1, fmt=$D2.`},				\
	1623{` tunnel_if4: tuif_write:no r crypto sys $D1 $D2.`},				\
	1624{` tunnel_if4: tuif_write:resys pre key failed.`},					\
	1625{` tunnel_if4: tuif_write: No Recv ESP Alg Defined.`},				\
	1626{` tunnel_if4: tuif_write: Send AH alg=$D1, fmt=$D2.`},				\
	1627{` tunnel_if4: tuif_write:no s mac sys $D1 $D2.`},					\
	1628{` tunnel_if4: tuif_write:smsys pre key failed.`},					\
	1629{` tunnel_if4: tuif_write: No Send AH Alg Defined.`},				\
	1630{` tunnel_if4: tuif_write: Recv AH alg=$D1, fmt= $D2.`},				\
	1631{` tunnel_if4: tuif_write:no r mac sys $D1, $D2.`},					\
	1632{` tunnel_if4: tuif_write:rmsys pre key failed.`},					\
	1633{` tunnel_if4: tuif_write: No Recv AH Alg Defined.`},				\
	1634{` tunnel_if4: tuif_write():tunnel_cache_insert() failed.`},			\
	1635{` tunnel_if4: tuif_write():tunnel_cache6_insert() failed.`},			\
	1636{` tunnel_if4: tuif_read: ERROR: not user space.`},					\
	1637{` tunnel_if4: tuif_read: no user data space.`},					\
	1638{` tunnel_if4: tuif_read:copyin ext failed.`},					\
	1639{` tunnel_if4: tuif_read:no ext.`},							\
	1640{` tunnel_if4: tuif_read():tunnel_cache_get() failed.`},				\
	1641{` tunnel_if4: tuif_read():copyout() failed.`},					\
	1642{` tunnel_if4: tunel_if_ioctl: cannot get tunnel cache, tid=$D1.`},			\
	1643{` tunnel_if4: tunnel_if_ioctl(): Error in copyout.`},				\
	1644{` tunnel_if4: tunnel_if_ioctl(): copyin() failed for IPSEC_GET_TC_INFO.`},		\
	1645{` tunnel_if4: tunnel_if_ioctl(): copyout() failed for IPSEC_GET_TC_INFO.`},	\
	1646{` tunnel_if4: tunnel_if_ioctl(): copyout() failed for IPSEC_GET_IC_BUCKETS.`},	\
	1647{` tunnel_if4: tunnel_if_ioctl(): copyout() failed for IPSEC_GET_TC_BUCKETS.`},	\
	1648{` tunnel_if4: tunnel_if_config: pincode() failed.`},				\
	1649{` tunnel_if4: tunnel_if_config() - CFG_TERM: open_cnt = $D1.`},			\
        1650{` tunnel_if4: tuif_write():copyin s_esp_salt failed: $D1.`},			\
	1651{` tunnel_if4: tuif_write():copyin r_esp_salt failed: $D1.`},			\
	1652{` tunnel_if4: tuif_write():copyin s_ah_salt failed: $D1.`},			\
	1653{` tunnel_if4: tuif_write():copyin r_ah_salt failed: $D1.`},			\
	\* { " unknown subhook " id=$HD%UW } \
        }
2E5 1.0 'IPSEC_TUNNEL_INFO' \
   $GENERIC, \
    1 { \
         " " W2 $HL%S1 \
      }
2E9 2.0 'IPSEC' 										\
    $GENERIC,											\
     1 { " STRING TRACE: " W2 $HL%S1},								\
     0 { $HD%D1,										\
	\* {` unknown subhook id=$HD%UW`}							\
    }
102F 1.0 "@CAA: Cluster Aware AIX routines" \
	$HD%D1, \
	1  { "XCLUSTER_PARM " \
	     $D1%D1, \
              0 {"xcluster_parm enter " cmd=$D2 }, \
              1 {"xcluster_parm Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"xcluster_parm exit " } }, \
       	2  { "XCLUSTER_CREATE " \
	     $D1%D1, \
              0 {"xcluster_create enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xcluster_create Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"xcluster_create successful." } }, \
       	3  { "_XCLUSTER_CREATE " \
	     $D1%D1, \
              0 {"_xcluster_create enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"_xcluster_create Error: Invalid cluster multicast address family" family=$D2 rc=$D3 at Line Number=$D4 }, \
              2 {"_xcluster_create Error: copyin u_nodelist failed " rc=$D2 at Line Number=$D3 }, \
              3 {"_xcluster_create Error: Invalid u_nodelist " cnt=$D2 rc=$D3 at Line Number=$D4 }, \
              4 {"_xcluster_create Error: Allocation failed " size=$D2 rc=$D3 at Line Number=$D4 }, \
              5 {"_xcluster_create Error: Invalid u_disklist " cnt=$D2 rc=$D3 at Line Number=$D4 }, \
              6 {"_xcluster_create enter: Valid multicast address " family=$D2 at Line Number=$D3 }, \
              7 {"_xcluster_create Error: node_index > NODE_LIMIT " node_index=$D2 rc=$D3 at Line Number=$D4 }, \
              8 {"_xcluster_create Error: node_index > NODE_LIMIT " node_index=$D2 rc=$D3 at Line Number=$D4 }, \
              9 {"_xcluster_create Error: Invalid nodelist " node_index=$D2 hostname=$D3 rc=$D4 at Line Number=$D5 }, \
              10 {"_xcluster_create Error: setdata != clusterp->kcl_num_nodes " setdata=$D2 num_nodes=$D3 }, \
              11 {"_xcluster_create Error: SFW_ADD_CLUSTER call failed" name=$D2 rc=$D3 rv=$D4 at Line Number=$D5 }, \
              12 {"_xcluster_create Error: SFW_ADD_NODE call failed" name=$D2 rc=$D3 rv=$D4 at Line Number=$D5 }, \
              13 {"_xcluster_create Error:  " rc=$D2 at Line Number=$D3 }, \
              14 {"_xcluster_create successful." family=$D2 } }, \
       	4  { "XCLUSTER_DELETE " \
	     $D1%D1, \
              0 {"xcluster_delete enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xcluster_delete Error:cluster has active links" num_links=$D2 rc=$D3 at Line Number=$D4 }, \
              2 {"xcluster_delete Error: SFW_DEL_LISTENER UP call failed " num_clusts=$D2 name=$D3 rc=$D4 rv=$D5 }, \
              3 {"xcluster_delete Error: SFW_DEL_LISTENER DOWN call failed " num_clusts=$D2 name=$D3 rc=$D4 rv=$D5 }, \
              4 {"xcluster_delete Error: SFW_DEL_CLUSTER call failed " name=$D2 rc=$D3 rv=$D4 }, \
              5 {"xcluster_delete Error: SFW_DEL_NODE call failed " name=$D2 rc=$D3 rv=$D4 }, \
              6 {"xcluster_delete Error: rc=$D2 at Line Number=$D3 }, \
              7 {"xcluster_delete successful." } }, \
       	5  { "XCLUSTER_QUERY " \
	     $D1%D1, \
              0 {"xcluster_query enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xcluster_query Error: Invalid cluster uuid" rc=$D2 at Line Number=$D3 }, \
              2 {"xcluster_query Error: copyin routine failed to copy cluster uuid" rc=$D2 at Line Number=$D3 }, \
              3 {"xcluster_query Error: a_num < nodelistremote->num_nodes " a_num=$D2 num_nodes=$D3 rc=$D4 at Line Number=$D5 }, \
              4 {"xcluster_query Error: a_num < disklistremote->num_disks " a_num=$D2 num_disks=$D3 rc=$D4 at Line Number=$D5 }, \
              5 {"xcluster_query Error: a_num < clusterp->kcl_num_nodes" a_num=$D2 kcl_num_nodes=$D3 rc=$D4 at Line Number=$D5 }, \
              6 {"xcluster_query Error: ick != clusterp->kcl_num_nodes" ick=$D2  kcl_num_nodes=$D3 size=$D4 sizeof(u_int32_t)=$D5 }, \
              7 {"xcluster_query Error: a_num < clusterp->kcl_num_disks" a_num=$D2 kcl_num_disks=$D3 rc=$D4 at Line Number=$D5 }, \
              8 {"xcluster_query Error: !a_disk, Bad disk count name " cluster_name=$D2 num_disks=$D3 rc=$D4 at Line Number=$D5 }, \
              9 {"xcluster_query Error: rc=$D2 at Line Number=$D3 }, \
              10 {"xcluster_query successful." } }, \
       	6  { "XCLUSTER_MODIFY " \
	     $D1%D1, \
              0 {"xcluster_modify enter " add_resource=$D2 cluster_name=$D3 cluster_type=$D4 }, \
              1 {"xcluster_modify Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"xcluster_modify Error: Invalid clustuuid_ur " add_resource=$D2 rc=$D3 at Line Number=$D4 }, \
              3 {"xcluster_modify Error: copyin clustuuid_usr failed " rc=$D2 at Line Number=$D3 }, \
              4 {"xcluster_modify Error: " rc=$D2 at Line Number=$D3 }, \
              5 {"xcluster_modify Error: read in nodelist " num_disks=$D2 rc=$D3 at Line Number=$D4 }, \
              6 {"xcluster_modify Error: read in disklist " num_disks=$D2 rc=$D3 at Line Number=$D4 }, \
              7 {"xcluster_modify Error: process disklist " disk_name=$D2 rc=$D3 at Line Number=$D4 }, \
              8 {"xcluster_modify Error: Attempt to add " host_name=$D2 kcl_name=$D3 num_nodes=$D4 at Line Number=$D5 }, \
              9 {"xcluster_modify Error: Attempt to delete " host_name=$D2 kcl_name=$D3 num_nodes=$D4 at Line Number=$D5 }, \
              10 {"xcluster_modify Error: node_index > NODE_LIMIT " shorthand_id=$D2 max_assigned=$D3 node_index=$D4 at Line Number=$D5 }, \
              11 {"xcluster_modify Error: node_index > NODE_LIMIT " shorthand_id=$D2 max_assigned=$D3 node_index=$D4 at Line Number=$D5 }, \
              12 {"xcluster_modify Error: SFW_ADD_NODE call failed " name=$D2 rc=$D3 rv=$D4 at Line Number=$D5 }, \
              13 {"xcluster_modify Error: SFW_DEL_NODE call failed " name=$D2 rc=$D3 rv=$D4 at Line Number=$D5 }, \
              14 {"xcluster_modify Error: " cnt=$D2 rc=$D3 at Line Number=$D4 }, \
              15 {"xcluster_modify successful." } }, \
       	7  { "XCLUSTER_NODE_QUERY " \
	     $D1%D1, \
              0 {"xcluster_node_query enter " size=$D2 }, \
              1 {"xcluster_node_query Error: copyin u_node_name failed " u_node_name=$D2 rc=$D3 at Line Number=$D4 }, \
              2 {"xcluster_node_query Error: copyout u_num_nodes failed " u_num_nodes=$D2 rc=$D3 at Line Number=$D4 }, \
              3 {"xcluster_node_query Error: ick != num_nodes_unique " ick=$D2 num_nodes_unique=$D3 }, \
              4 {"xcluster_node_query Error: size < req_size " size=$D2 req_size=$D3 rc=$D4 at Line Number=$D5 }, \
              5 {"xcluster_node_query Error: SFW_ADD_NODE call failed " name=$D2 rc=$D3 rv=$D4 at Line Number=$D5 }, \
              6 {"xcluster_node_query Error: cur_size > req_size " cur_size=$D2 req_size=$D3 at Line Number=$D4 }, \
              7 {"xcluster_node_query Error: Bad count " host_name=$D2 num_clusters=$D3 rc=$D4 at Line Number=$D5 }, \
              8 {"xcluster_node_query Error: cur_size > req_size " cur_size=$D2 req_size=$D3 at Line Number=$D4 }, \
              9 {"xcluster_node_query Error: cur_size > req_size " cur_size=$D2 req_size=$D3 at Line Number=$D4 }, \
              10 {"xcluster_node_query Error: cur_size > req_size " cur_size=$D2 req_size=$D3 at Line Number=$D4 }, \
              11 {"xcluster_node_query Error: " ick=$D2 rc=$D3 at Line Number=$D4 }, \
              12 {"xcluster_node_query successful." } }, \
       	8  { "XCLUSTER_STATS " \
	     $D1%D1, \
              0 {"xcluster_stats enter " num_clusts=$D2 }, \
              1 {"xcluster_stats Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"xcluster_stats successful." } }, \
       	9  { "XCLUSTER_FIND_NODE " \
	     $D1%D1, \
              0 {"xcluster_find_node enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xcluster_find_node Error: if alloc_size < req_size " alloc_size=$D2 req_size=$D3 rc=$D4 at Line Number=$D5 }, \
              2 {"xcluster_find_node Error: " rc=$D2 at Line Number=$D3 }, \
              3 {"xcluster_find_node successful." shorthand_id=$D2 } }, \
       	10 { "XCLUSTER_ZONES_QUERY " \
	     $D1%D1, \
              0 {"xcluster_zones_query enter " *zones_size_usrp=$D2 }, \
              1 {"xcluster_zones_query Error: " rc=$D2 }, \
              2 {"xcluster_zones_query Error: copyin failed" rc=$D2 }, \
              3 {"xcluster_zones_query Error: zone_size_usrp is invalid " rc=$D2 }, \
              4 {"xcluster_zones_query Error: zones_size_usr < zones_size " rc=$D2 }, \
              5 {"xcluster_zones_query Error: " rc=$D2 at Line Number=$D3 }, \
              6 {"xcluster_zones_query successful." } }, \
        11  { "SEC_ENCRYPTMSG " \
	     $D1%D1, \
              0 {"sec_encryptMsg enter " length=$D2 sequence_no=$D3 }, \
              1 {"sec_encryptMsg Error: enc_context not set. secinf_init should be invoked first " rc=$D2 }, \
              2 {"sec_encryptMsg Error: sec_encryptMsg parameters are invalid " rc=$D2 }, \
              3 {"sec_encryptMsg Error: CLiC_cipher_reset failed " rc=$D2 }, \
              4 {"sec_encryptMsg Error: CLiC_cipher_update failed " rc=$D2 }, \
              5 {"sec_encryptMsg successful." } }, \
       	12  { "SEC_DECRYPTMSG " \
	     $D1%D1, \
              0 {"sec_decryptMsg enter " length=$D2 sequence_no=$D3 }, \
              1 {"sec_decryptMsg Error: sec_decryptMsg parameters are invalid " rc=$D2  }, \
              2 {"sec_decryptMsg Error: packet is not encrypted " rc=$D2  }, \
              3 {"sec_decryptMsg Error: CLiC_cipher_reset failed " rc=$D2  }, \
              4 {"sec_decryptMsg Error: CLiC_cipher_update failed " rc=$D2  }, \
              5 {"sec_decryptMsg successful." } }, \
	13 { "XCLUSTER_ZONE_CREATE " \
	     $D1%D1, \
              0 {"xcluster_zone_create enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xcluster_zone_create " zone_name=$D2 zone_num_nodes=$D3 }, \
              2 {"xcluster_zone_create Error: " rc=$D2 at Line Number=$D3 }, \
              3 {"xcluster_zone_create Error: zone node does not exist in cluster " zone_node_name=$D2 rc=$D3 at Line Number=$D4  }, \
              4 {"xcluster_zone_create Error: " rc=$D2 at Line Number=$D3 }, \
              5 {"xcluster_zone_create successful."  kcl_num_zones=$D2 } }, \
       	14 { "XCLUSTER_ZONES_DELETE " \
	     $D1%D1, \
              0 {"xcluster_zone_delete enter " cluster_name=$D2 cluster_type=$D3 zone_name_usr=$D4 }, \
              1 {"xcluster_zone_delete " zone_name=$D2 zone_num_nodes=$D3 }, \
              2 {"xcluster_zone_create Error: " rc=$D2 at Line Number=$D3 }, \
              3 {"xcluster_zone_create successful."  zone_name=$D2 } }, \
       	15 { "XCLUSTER_ZONE_QUERY " \
	     $D1%D1, \
              0 {"xcluster_zone_query enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xcluster_zone_query " zone_name=$D2 zone_num_nodes=$D3 }, \
              2 {"xcluster_zone_query Error: " rc=$D2 at Line Number=$D3 }, \
              3 {"xcluster_zone_query Error: " rc=$D2 at Line Number=$D3 }, \
              4 {"xcluster_zone_query successful." } }, \
       	16 { "XCLUSTER_ZONE_MODIFY " \
	     $D1%D1, \
              0 {"xcluster_zone_modify enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xcluster_zone_modify " zone_name=$D2 zone_num_nodes=$D3 }, \
              2 {"xcluster_zone_modify Error: " rc=$D2 at Line Number=$D3 }, \
              3 {"xcluster_zone_modify Error: " rc=$D2 at Line Number=$D3 }, \
              4 {"xcluster_zone_modify successful." } }, \
       	17 { "XCLUSTER_LOCK " \
	     $D1%D1, \
              0 {"xcluster_lock enter " cmd=$D2 lockid=$D3 state=$D4 tid=$D5}, \
              1 {"xcluster_lock Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"xcluster_lock successful." state=$D2} }, \
       	18 { "LOCK_THREAD " \
	     $D1%D1, \
              0 {"lock_thread enter " threadid=$D2 }, \
              1 {"lock_thread Error: " lock_id=$D2 at Line Number=$D3 }, \
              2 {"lock_thread Error: kcluster_sendmsg failed " lock_id=$D2 msg.seq_no=$D3 send_rc=$D4 at Line Number=$D5 }, \
              3 {msg.dst=$D2 msg.src=$D3 }, \
              4 {"lock_thread Error: kcluster_sendmsg failed " lock_id=$D2 msg.seq_no=$D3 send_rc=$D4 at Line Number=$D5 }, \
              5 {msg.dst=$D2 msg.src=$D3 }, \
              6 {"lock_thread Error: dst == kcl_myid " dst=$D2 kcl_myid=$D3 at Line Number=$D4 }, \
              7 {"lock_thread Error: kcluster_sendmsg failed " lock_id=$D2 msg.seq_no=$D3 send_rc=$D4 at Line Number=$D5 }, \
              8 {msg.dst=$D2 msg.src=$D3 }, \
              9 {"lock_thread Error: kcluster_sendmsg failed " lock_id=$D2 msg.seq_no=$D3 send_rc=$D4 at Line Number=$D5 }, \
              10 {msg.dst=$D2 msg.src=$D3 }, \
              11 {"lock_thread Error: kcluster_sendmsg failed " lock_id=$D2 msg.seq_no=$D3 send_rc=$D4 at Line Number=$D5 }, \
              12 {msg.dst=$D2 msg.src=$D3 }, \
              13 {"lock_thread Error: " at Line Number=$D5 }, \
              14 {"lock_thread Error: " at Line Number=$D5 }, \
              15 {"lock_thread Error: " at Line Number=$D5 }, \
              16 {"lock_thread Error: response_count >= num_nodes_active" response_count=$D2 num_nodes_active=$D3 at Line Number=$D4 }, \
              17 {"lock_thread Error: " at Line Number=$D5 }, \
              18 {"lock_thread Error: kcluster_sendmsg failed " lock_id=$D2 msg.seq_no=$D3 send_rc=$D4 at Line Number=$D5 }, \
              19 {msg.dst=$D2 msg.src=$D3 }, \
              20 {"lock_thread Error: " at Line Number=$D5 }, \
              21 {"xcluster_zone_create successful." } }, \
       	19 { "COUNT_ACTIVE_NODES " \
	     $D1%D1, \
              0 {"count_active_nodes enter " }, \
              1 {"count_active_nodes exit  " num_nodes_active=$D2 } }, \
       	20 { "CLUSTER_PROD_UNLOCK " \
	     $D1%D1, \
              0 {"cluster_prod_unlock enter " len=$D2 }, \
              0 {"cluster_prod_unlock Error:  " rc=$D2 at Line Number=$D3 }, \
              1 {"count_active_nodes successful.  " } }, \
       	21 { "XDISK_QUERY " \
	     $D1%D1, \
              0 {"xdisk_query enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xdisk_query Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"xdisk_query successful." } }, \
       	22 { "XINTERFACE_QUERY " \
	     $D1%D1, \
              0 {"xinterface_query enter " cluster_name=$D2 cluster_type=$D3 }, \
              1 {"xinterface_query Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"xinterface_query successful." } }, \
       	23 { "CLUSTER_HANDLE_OURS " \
	     $D1%D1, \
              0 {"cluster_handle ours enter " pinfo->m=$D2 m_len=$D3 hlen=$D4 type=$D5 }, \
              1 {"cluster_handle_ours " cmd:$D2 cmd_src=$D3 cmd_dst=$D4 true_size=$D5 }, \
              2 {"cluster_handle_ours " sec_seq=$D2 }, \
              3 {"cluster_handle_ours Error: " rc=$D2 at Line Number=$D3 }, \
              4 {"cluster_handle_ours successful." } }, \
       	24 { "FRAGMENT_PROCESSING " \
	     $D1%D1, \
              0 {"fragment_processing enter " ip_off=$D2 ip_v=$D3 ip_id=$D4 }, \
              1 {"fragment_processing Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"fragment_processing successful." } }, \
       	25 { "CLUSTER_HANDLED " \
	     $D1%D1, \
              0 {"cluster_handled enter " m=$D2 nddp=$D3 ndd_type=$D4 slot=$D5 }, \
              1 {"cluster_handled Error: Invalid mbuf pointer "  }, \
              2 {"cluster_handled Error: " rc=$D2 at Line Number=$D3 }, \
              3 {"cluster_handled Error: " rc=$D2 at Line Number=$D3 }, \
              4 {"cluster_handled Error: " rc=$D2 at Line Number=$D3 }, \
              5 {"cluster_handled Error: Invalid pkt_info.m pointer " rc=$D2 }, \
              6 {"cluster_handled Error: " rc=$D2 at Line Number=$D3 }, \
              7 {"cluster_handled Error: " rc=$D2 at Line Number=$D3 }, \
              8 {"cluster_handled successful." } }, \
       	26 { "CLUSTER_HANDLE_ETH " \
	     $D1%D1, \
              0 {"cluster_handle_eth enter " eh->ether_type=$D2 pinfo->m=$D3 }, \
              1 {"cluster_handle_eth Error: " etype= $D2 rc=$D3 at Line Number=$D4 }, \
              2 {"cluster_handle_eth successful." etype=$D2 } }, \
       	27 { "KCLUSTER_CLUSTERWIDE " \
	     $D1%D1, \
              0 {"kcluster_clusterwide enter " cmd_real=$D2 cmd_clusterwide=$D3 }, \
              1 {"kcluster_clusterwide Error: _kcluster_sendmsg failed " rc= $D2 rc=$D3 at Line Number=$D4 }, \
              2 {"kcluster_clusterwide Error: " rc= $D2 rc=$D3 at Line Number=$D4 }, \
              3 {"kcluster_clusterwide successful." } }, \
       	28 { "CLUSTERWIDE_RECV_OFFLVL " \
	     $D1%D1, \
              0 {"clusterwide_recv_offlvl enter " tid=$D2 }, \
              1 {"clusterwide_recv_offlvl Error: findcluster failed " }, \
              2 {"clusterwide_recv_offlvl : " cmd_direction=$D2 cmd_clusterwide=$D3 }, \
              3 {"clusterwide_recv_offlvl Error: net_malloc failed " }, \
              4 {"clusterwide_recv_offlvl Error: get_netinfo failed " }, \
              5 {"clusterwide_recv_offlvl Error: get_diskinfo failed " }, \
              6 {"clusterwide_recv_offlvl Error: _kcluster_sendmsg failed " rc=$D2 }, \
              7 {"clusterwide_recv_offlvl Error: Input with No interface output " }, \
              8 {"clusterwide_recv_offlvl Error: Input with No disk output " }, \
              9 {"cluster_handle_eth successful." } }, \
       	29 { "CLUST_INPUT " \
	     $D1%D1, \
              0 {"clust_input enter " hsize=$D2 }, \
              1 {"clust_input Error: Invalid clustp->true_size " return_value= $D2 }, \
              2 {"clust_input Error: sock_clust_port_array failed " return_value= $D2 }, \
              3 {"clust_input : " socket pid=$D2 tid=$D3 cmd_src=$D4 cmd_port_src=$D5 }, \
              4 {"clust_input Error: m_pkthdr.len > sbspace(&so->so_rcv) " len=$D2 sbspace(&so->so_rcv)=$D3 return_value=$D4 }, \
              5 {"clust_input Error: sbappendaddr failed " return_value= $D2 }, \
              6 {"clust_input successful." } }, \
       	30 { "CLUST_OUTPUT " \
	     $D1%D1, \
              0 {"clust_output enter " mbuf=$D2, socket pid=$D3 tid=$D4 }, \
              1 {"clust_output Error: m_pkthdr.len < CLUST_MINMT" m_pkthdr.len= $D2 error=$D3 at Line Number=$D4 }, \
              2 {"clust_output Error: " error=$D2 at Line Number=$D3 }, \
              3 {"clust_output successful." } }, \
       	31 { "CLSOCK_RECV " \
	     $D1%D1, \
              0 {"clsock_recv enter " socket state=$D2 pid=$D3 tid=$D4 }, \
              1 {"clsock_recv Error: flag & MSG_OOB  " flags=$D2 error=$D3  }, \
              2 {"clsock_recv Error: if sum " sum=$D2 }, \
              3 {"clsock_recv Error: " error=$D2 at Line Number=$D3 }, \
              4 {"clsock_recv successful." } }, \
       	32 { "_IF_SET " \
	     $D1%D1, \
              0 {"_if_set enter " args->cmd=$D2 if_name=$D3 if_unit=$D4 if_type=$D5 }, \
              1 {"_if_set Error: " at Line Number=$D2 }, \
              2 {"_if_set Error: " num_clusts=$D2 at Line Number=$D3 }, \
              3 {"_if_set Error: ifset returning for interface " namebuf=$D2 at Line Number=$D3 }, \
              4 {"_if_set Error: " icnt=$D2 error=$D3 at Line Number=$D4 }, \
              5 {"_if_set Error: ns_alloc failed " error=$D2 at Line Number=$D4 }, \
              6 {"_if_set Error: " error=$D2 at Line Number=$D3 }, \
              7 {"_if_set successful." }, \
              8 {"_if_set Error: " error=$D2 at Line Number=$D3 } }, \
       	33 { "IF_RESET " \
	     $D1%D1, \
              0 {"if_reset enter " cmd=$D2 icnt=$D3 num_ifs=$D4 }, \
              1 {"if_reset: " if_name=$D2 if_unit=$D3 sa_family=$D4}, \
              2 {"if_reset: " sa->sa_family=$D4}, \
              3 {"if_reset Error: " error=$D2 at Line Number=$D3 }, \
              4 {"if_reset successful." } }, \
       	34 { "KCLUSTER_SENDMSG_EXT " \
	     $D1%D1, \
              0 {"kcluster_sendmsg_ext enter " send_ext_cmd=$D2 flags=$D3 kcl_num_nodes=$D4}, \
              1 {"kcluster_sendmsg_ext Error: len > ksendp->send_ext_rclen " len=$D2 send_ext_rclen=$D3 rc=$D4 at Line Number=$D5 }, \
              3 {"kcluster_sendmsg_ext Error: len > ksendp->send_ext_rclen " len=$D2 send_ext_rclen=$D3 rc=$D4 at Line Number=$D5 }, \
              4 {"kcluster_sendmsg_ext Error: " rc=$D2 at Line Number=$D3 }, \
              2 {"kcluster_sendmsg_ext successful." } }, \
       	35 { "_KCLUSTER_SENDMSG " \
	     $D1%D1, \
              0 {"_kcluster_sendmsg enter " payload_hdr.cmd=$D2 num_ifs=$D3 }, \
              1 {"_kcluster_sendmsg Error: Invalid p_mbufout " rc=$D2 }, \
              2 {"_kcluster_sendmsg Error: m_flags & M_EXT == 0 " m_flags=$D2 rc=$D3 }, \
              3 {"_kcluster_sendmsg Error: mbuf_fixup failed" if_type=$D2 rc=$D3 }, \
              4 {"_kcluster_sendmsg Error: Invalid isend " rc=$D2 }, \
              5 {"_kcluster_sendmsg successful." } }, \
       	36 { "MBUF_FIXUP " \
	     $D1%D1, \
              0 {"mbuf_fixup enter " type=$D2 true_size=$D3 queue=D4 noheader=$D5}, \
              1 {"mbuf_fixup Error: find cluster failed " rc=$D2 at Line Number=$D3 }, \
              2 {"mbuf_fixup Error: Invalid find " cmd_dst=$D2 rc=$D3 at Line Number=$D4 }, \
              3 {"mbuf_fixup Error: net_malloc failed " rc=$D2 at Line Number=$D3 }, \
              4 {"mbuf_fixup Error: net_malloc failed " len=$D2 rc=$D3 at Line Number=$D4 }, \
              5 {"mbuf_fixup successful." } }, \
        37 { "AHAFS_DISK_EVENT " \
	     $D1%D1, \
              0 {"ahafs_storage_event enter " }, \
              1 {"ahafs_storage_event SFW" event=$D2 disk=$D3 }, \
              2 {"ahafs_storage_event exit " } }, \
        38 { "GENERATE_EVENT " \
	     $D1%D1, \
	      0 {"generate_event enter " }, \
	      1 {"generate_event CBFN_ALLOC fail" rc =$D2 }, \
	      2 {"generate_event MSG_ALLOC fail " rc =$D2 }, \
              3 {"generate_event BUF_ALLOC fail " rc =$D2 }, \
              4 {"generate_event SEND_ALLOC fail" rc =$D2 }, \
	      5 {"generate_event" event=$D2 msg=$D3  }, \
	      6 {"generate_event kcluster_wraper_send fail" rc =$D2 }, \
	      7 {"generate_event kcluster_wraper_send link fail " rc =$D2 }, \
	      8 {"generate_event exit " }, \
 	      9 {"generate_event " EVENT_TYPE=$D2 NODE_NUMBER=$D3 NODE_ID=$D4 } }, \
        39 { "SET_CLUSTER " \
	     $D1%D1, \
	      0 {"set_cluster enter" }, \
	      1 {"set_cluster exit" nodeid=$D2 clustid=$D3 } }, \
	40 { "UNSET_CLUSTER " \
	      $D1%D1, \
	       0 {"unset_cluster enter" nodeid=$D2 clustid=$D3 }, \
	       1 {"unset_cluster exit" } }, \
	41 { "GET_CLUSTERID " \
	      $D1%D1, \
	       0 {"get_clusterid enter" clustid=$D2 }, \
	       1 {"get_clusterid exit " } }, \
	43 { "PROCESS_MSG_LOCK " \
	      $D1%D1, \
	       0 {"process_msg_lock" lock_global_index=$D2 } \
	       }
525 1.0 "SMBFS" \
        $HD%D1, \
       1  { `cn_link  vnode=$D1` }, \
       2  { `return from cn_link  vnode=$D1` }, \
       3  { `cn_mkdir  vnode=$D1` }, \
       4  { `return from cn_mkdir  vnode=$D1 error=$D2` }, \
       5  { `cn_remove  vnode=$D1 parent vnode=$D2` }, \
       6  { `return from cn_remove  vnode=$D1 error=$D2` }, \
       7  { `cn_rename  vnode=$D1 parent vnode=$D2 new parent=$D3` }, \
       8  { `return from cn_rename  vnode=$D1 error=$D2` }, \
       9  { `cn_rmdir  vnode=$D1 parent vnode=$D2` }, \
       10 { `return from cn_rmdir parent vnode=$D1 error=$D2` }, \
       11 { `cn_lookup  vnode=$D1 parent vnode=$D2` }, \
       12 { `return from cn_lookup  vnode=$D1 error=$D2` }, \
       13 { `cn_fid  vnode=$D1` }, \
       14 { `return from cn_fid  vnode=$D1` }, \
       15 { `cn_open  vnode=$D1 mode=$D2` }, \
       16 { `return from cn_open  vnode=$D1 error=$D2` }, \
       17 { `cn_create  parent vnode=$D1` }, \
       18 { `return from cn_create  vnode=$D1 error=$D2` }, \
       19 { `cn_hold  vnode=$D1` }, \
       20 { `return from cn_hold  vnode=$D1 error=$D2` }, \
       21 { `cn_rele  vnode=$D1 vfs=$D2` }, \
       22 { `return from cn_rele  vnode=$D1 error=$D2` }, \
       23 { `cn_close  vnode=$D1` }, \
       24 { `return from cn_close  vnode=$D1 error=$D2` }, \
       25 { `cn_map  vnode=$D1` }, \
       26 { `return from cn_map  vnode=$D1` }, \
       27 { `cn_unmap  vnode=$D1` }, \
       28 { `return from cn_unmap  vnode=$D1` }, \
       29 { `cn_access  vnode=$D1 mode=$D2` }, \
       30 { `return from cn_access  vnode=$D1 error=$D2` }, \
       31 { `cn_getattr  vnode=$D1` }, \
       32 { `return from cn_getattr  vnode=$D1 error=$D2` }, \
       33 { `cn_setattr  vnode=$D1` }, \
       34 { `return from cn_setattr  vnode=$D1 error=$D2` }, \
       35 { `cn_ftrunc  vnode=$D1 length=$D2` }, \
       36 { `return from cn_ftrunc  vnode=$D1 error=$D2` }, \
       37 { `cn_rdwr  vnode=$D1 op=$D2` }, \
       38 { `return from cn_rdwr  vnode=$D1 op=$D2 error=$D3` }, \
       39 { `cn_readdir  vnode=$D1` }, \
       40 { `return from cn_readdir  vnode=$D1 error=$D2` }, \
       41 { `cn_getacl  vnode=$D1` }, \
       42 { `return from cn_getacl vnode=$D1 error=$D2` }, \
       43 { `cn_setacl  vnode=$D1` }, \
       44 { `return from cn_setacl vnode=$D1` }, \
       45 { `cifs_mount  vfs=$D1` }, \
       46 { `return from cifs_mount vfs=$D1 error=$D2` }, \
       47 { `cifs_unmount  vfs=$D1` }, \
       48 { `return from cifs_unmount vfs=$D1 error=$D2` }, \
       49 { `cifs_root  vfs=$D1` }, \
       50 { `return from cifs_root vfs=$D1 vnode=$D2 error=$D3` }, \
       51 { `cifs_statfs  vfs=$D1` }, \
       52 { `return from cifs_statfs vfs=$D1 error=$D2` }, \
       53 { `cifs_vget vfs=$D1` }, \
       54 { `return from cifs_vget vfs=$D1` }, \
       55 { `nsmb_dev_ioctl data=$D1 op=$D2` }, \
       56 { `return from nsmb_dev_ioctl op=$D1 error=$D2` }, \
       \* { unknown subhook $HD%D1 }
620 1.1 "VxIO driver" \
	$HD, \
	0x01 { `enter open: dev=$D1, flags=$D2, chan=$D3, ext=$D4` }, \
	0x02 { `exit open: dev=$D1, flags=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x03 { `enter close: dev=$D1, chan=$D2, ext=$D3` }, \
	0x04 { `exit close: dev=$D1, chan=$D2, ext=$D3, ret=$D4` }, \
	0x05 { `enter read: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4` }, \
	0x06 { `exit read: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x07 { `enter write: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4` }, \
	0x08 { `exit write: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x09 { `enter ioctl: dev=$D1, cmd=$D2, arg=$D3, mode=$D4, ext=$D5` }, \
	0x0A { `exit ioctl: dev=$D1, cmd=$D2, arg=$D3, ret=$D4, rval_p=$D5` }, \
	0x0D { `enter config: devno=$D1, op=$D2, uiop=$D3` }, \
	0x0E { `exit config: devno=$D1, op=$D2, uiop=$D3, err=$D4` }, \
	0x0F { `enter strategy: bp=$D1` }, \
	0x10 { `exit strategy: bp=$D1, ret=$D2` }, \
	0x11 { `TRC hd_dev_ioevnt: event=$D1 dgname=$D2 obj=$D3 count=$D4` }, \
	0x12 { `TRC hd_dev_errevnt: event=$D1 dgname=$D2 obj=$D3 etime=$D4%XW` }, \
	0x13 { `TRC hd_dev_cmpevnt: event=$D1 dgname=$D2 obj=$D3 etime=$D4%XW` }, \
	0x14 { `TRC hd_obj_ioevnt: sio_flags=$D1 obj=$D2 offset=$D3 sio_len=$D4` }, \
	0x15 { `TRC hd_obj_errevnt: sio_flags=$D1 obj=$D2 offset=$D3 sio_len=$D4` }, \
	0x16 { `TRC hd_obj_cmpevnt: event=$D1 sio_eno=$D2 obj=$D3 etime=$D4%XW` }, \
	0x17 { `TRC hd_dsk_evnt: event=$D1 sio_eno=$D2 offset=$D3 len=$D4` }, \
	0x18 { `TRC hd_dsk_errevnt: event=$D1 sio_eno=$D2 offset=$D3 len=$D4` }, \
	0x19 { `TRC hd_dsk_cmpevnt:  event=$D1 sio_eno=$D2 offset=$D3 len=$D4` }, \
	0x1A { `TRC hd_dsk_cfg: flags=$D1 nio=$D2 type=$D3 count=$D4` }, \
	0x1B { `TRC hd_obj_cfg: flags=$D1 nio=$D2 obj=$D3 type=$D4` }, \
	0x1C { `TRC hd_dev_cfg: flags=$D1 size=$D2 type=$D3 dev=$D4` }, \
	0x1D { `TRC hd_errt_in: read=$D1` }, \
	0x1E { `TRC hd_read_buf: dev=$D1` }, \
	0x1F { `TRC hd_read_buf: dev=$D1 uio_p=$D2 cred_p=$D3 readp=$D4` }, \
	0x20 { `TRC hd_read_buf: dev=$D1 uio_p=$D2 readp=$D3 len=$D4` }, \
	0x21 { `TRC hd_errt_in: recp=$D1` }, \
	0x22 { `TRC hd_errt_in: type=$D1` }, \
	0x23 { `TRC hd_read_buf: len=$D1` }, \
	0x24 { `TRC hd_read_buf: recp=$D1 len=$D2 size=$D3 buf=$D4` }, \
	0x25 { `TRC hd_comm_trc: type=$D1` }, \
	\*   { `VxIO mode=$HD` }
621 1.1 "VxSPEC driver" \
	$HD, \
	0x01 { `enter open: dev=$D1, flags=$D2, chan=$D3, ext=$D4` }, \
	0x02 { `exit open: dev=$D1, flags=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x03 { `enter close: dev=$D1, chan=$D2, ext=$D3` }, \
	0x04 { `exit close: dev=$D1, chan=$D2, ext=$D3, ret=$D4` }, \
	0x05 { `enter read: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4` }, \
	0x06 { `exit read: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x07 { `enter write: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4` }, \
	0x08 { `exit write: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x09 { `enter ioctl: dev=$D1, cmd=$D2, arg=$D3, mode=$D4, ext=$D5` }, \
	0x0A { `exit ioctl: dev=$D1, cmd=$D2, arg=$D3, ret=$D4, rval_p=$D5` }, \
	0x0B { `enter select: dev=$D1, events=$D2, reventsp=$D3, chan=$D4` }, \
	0x0C { `exit select: dev=$D1, events=$D2, reventsp=$D3, chan=$D4, ret=$D5` }, \
	0x0D { `enter config: devno=$D1, op=$D2, uiop=$D3` }, \
	0x0E { `exit config: devno=$D1, op=$D2, uiop=$D3, err=$D4` }, \
	\*   { `VxSPEC mode=$HD` }
622 1.1 "VxDMP driver" \
	$HD, \
	0x01 { `enter open: dev=$D1, flags=$D2, chan=$D3, ext=$D4` }, \
	0x02 { `exit open: dev=$D1, flags=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x03 { `enter close: dev=$D1, chan=$D2, ext=$D3` }, \
	0x04 { `exit close: dev=$D1, chan=$D2, ext=$D3, ret=$D4` }, \
	0x05 { `enter read: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4` }, \
	0x06 { `exit read: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x07 { `enter write: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4` }, \
	0x08 { `exit write: dev=$D1, uio_p=$D2, chan=$D3, ext=$D4, ret=$D5` }, \
	0x09 { `enter ioctl: dev=$D1, cmd=$D2, arg_in=$D3, mode=$D4, ext=$D5` }, \
	0x0A { `exit ioctl: dev=$D1, cmd=$D2, arg_in=$D3, ret=$D4, rval_p=$D5` }, \
	0x0D { `enter config: devno=$D1, op=$D2, uiop=$D3` }, \
	0x0E { `exit config: devno=$D1, op=$D2, uiop=$D3, err=$D4` }, \
	0x0F { `enter strategy: bp=$D1` }, \
	0x10 { `exit strategy: bp=$D1, ret=$D2` }, \
	\*   { `VxDMP mode=$HD` }
0E1 1.0 'VxFS' \
	$HD, \
	0x01  { `VxFS rdwr (vp,ip)=($D1,$D2)` $BREAK }, \
	2  { {{ $h = "read " }} }, \
	3  { {{ $h = "write" }} }, \
	\* { `VxFS mode=$HD` } \
	`VxFS $h VA.S=$D3$D4.$D2 bcount=$D5 ip=$D1`

