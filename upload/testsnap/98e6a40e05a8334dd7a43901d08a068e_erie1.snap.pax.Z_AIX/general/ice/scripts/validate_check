#!/usr/bin/ksh
# IBM_PROLOG_BEGIN_TAG         
# This is an automatically generated prolog.  
#                            
# $Source: aix710 bos/usr/lib/security/ice/scripts/validate_check.sh 1$                         
#                                                           
# COPYRIGHT International Business Machines Corp. 2010,2010              
#                                                                      
# Pvalue: p2 
#Licensed Materials - Property of IBM
#
#Restricted Materials of IBM
#
#US Government Users Restricted Rights - Use, duplication or
#disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
# Origin: 27
#
# sccsid: $Header: @(#) AIX710_area/1 bos/usr/lib/security/ice/scripts/validate_check.sh, libice, aix710, 1010A_710 2010-03-02T17:20:36-06:00$
#
# IBM_PROLOG_END_TAG
#	COMPONENT_NAME: (ICE) validate_check.sh
#	FUNCTIONS:	None
#	ORIGINS: 	27
#
#	Syntax: 
#		validate_check -{c|e|p}[v] rulename toggle 
#	Parameters:
#		-c	- Check mode
#		-e	- Enforce mode
#		-p	- Preview mode
#		-v	- verbose mode
#		toggle		- Boolean
#				  false => Disable 
#				  true  => Enable
#
#	OUTPUT:
#		0	- success
#		1	- check/enforce failure
#
#	Description:
#		This script checks/verifies and enforces the correctness of
#		the user/group/passwd definitions in the user/group/passwd 
#		database files, by checking the definitions for ALL users. 
#		If the input is to check the TCB database then it audits the
#		security state of the system by checking the installation
#		of the files defined in the sysck database.


export PATH=/usr/bin:/usr/sbin:$PATH
exec 2>&1

###
#Print Usage
###
Usage() {
	ice_status=1
	print "usage: \n
   validate_check -{c|e|p}[v] rulename toggle\n" >> log_msg 2>&1
}

###
#Output from Script to the Native Library
###
Script_Output() {
	print -n "$cur_val%$ice_status%"
	cat log_msg
	print
}


###
#Process arguments
###

#Check mode
cflag=0
#Enforce mode
eflag=0
#Preview mode
pflag=0
#Verbose mode
vflag=0

###
#Initialize the Script Output variables
###
cur_val=0
ice_status=0
print -n > log_msg 2>&1

while getopts :cevp OPT
do
        case $OPT in
                c)      cflag=1;;
                e)      eflag=1;;
                v)      vflag=1;;
		p)	pflag=1;;
                ?|:)    Usage
			Script_Output
                        exit 1;;
        esac
done
shift $(($OPTIND -1))

#Enable Verbose
if [[ vflag -eq 1 ]];
then
        set -x
fi


#Need atleast arguments
if [[ $# -lt 2 ]];
then
	Usage
	Script_Output
	exit 1
fi


# -c, -e and -p mutually exclusive
((chkflg=cflag+eflag+pflag))
if [[ chkflg -ne 1 ]];
then
	Usage
	Script_Output
	exit 1
fi


RULE_NAME=$1
STATUS_ARG=$2
#Toggle argument must be true or false
if ( [ "$STATUS_ARG" != "true" ] && [ "$STATUS_ARG" != "false" ] )
then
        print "Toggle must be true or false" >> log_msg 2>&1
        Usage
        Script_Output
        exit 1
fi

#
# When the toggle is False do nothing and return
# This check was moved up because it did not matter whether
# system was installed with TCB or not for case when the 
# value was false.
#
if ( [ "$STATUS_ARG" == "false" ] && [ "$RULE_NAME" != "pwdck" ] )
then
	Script_Output
	exit 0
fi

oslvl=""

if [ "$RULE_NAME" == "usrck" ]
then
	CMD=/usr/bin/usrck
elif [ "$RULE_NAME" == "pwdck" ]
then
	CMD=/usr/bin/pwdck 
elif [ "$RULE_NAME" == "grpck" ]
then
	CMD=/usr/sbin/grpck
elif ( [ "$RULE_NAME" == "tcbck" ] || [ "$RULE_NAME" == "sysck" ] )
then
	oslvl=`oslevel | /usr/bin/awk -F '.' '{print $1}'`

	if [ "$oslvl" == "5" ]
	then
		# Check whether TCB is enabled or not
		tcb_state=`export ODMDIR=/usr/lib/objrepos; /usr/bin/odmget\
 -qattribute=TCB_STATE PdAt|/usr/bin/awk -F '"' '/deflt/ {print $2}'`

		if [ "$tcb_state" != "tcb_enabled" ]
		then
			print "TCB is not enabled on the system" >> log_msg 2>&1
			ice_status=1
			Script_Output
			exit 0
		fi
		CMD=/usr/bin/tcbck
	# It is a 6.1 and above system so use Trusted Execution database
	else
		CMD=/usr/sbin/trustchk
	fi
else
	print "rulename should be either usrck,pwdck,grpck,tcbk or sysck" >> log_msg 2>&1
	Usage
	Script_Output
	exit 1
fi


# Preview mode set-up
if [[ pflag -eq 1 ]];
then
	ECHOPREFIX="echo"
else
	ECHOPREFIX=""
fi

PREREQ=/etc/security/ice/scripts/chkprereq
PREREQ_LIST="bos.rte.security,bos.rte.shell,bos.rte.ILS,bos.rte.date"

$ECHOPREFIX $PREREQ $PREREQ_LIST

if [ $? -ne 0  ]
then
        print "Prereqs are missing..." >> log_msg 2>&1
	print "Prereqs needed: " $PREREQ_LIST >> log_msg 2>&1
        ice_status=1
        Script_Output
	exit 0
fi


#checking
if [[ cflag -eq 1 ]];
then
	if [ "$STATUS_ARG" == "true" ]
	then
		$CMD -n ALL >> log_msg 2>&1

		if [ $? -ne 0  ]
		then
               		print "$CMD Check has returned Errors" >> log_msg 2>&1 
			ice_status=2
			Script_Output
		# For Trusted Execution check the log msg for errors.
		elif [ $oslvl == "6" ] 
		then
			grep failed log_msg > /dev/null 2>&1
			if [ $? -ne 0 ]
			then
				ice_status=0
				Script_Output
			else
				print "$CMD Check has returned Errors" >> log_msg 2>&1
				ice_status=2
				Script_Output
			fi
		else
			ice_status=0
			Script_Output
		fi
	else
		ice_status=0
		Script_Output
	fi
		

        exit 0
fi

###
#Preview/Enforcing
###

#Check and update the user definitions
$CMD -y ALL >> log_msg 2>&1

if [ "$STATUS_ARG" == "true" ]
then
	$CMD -n ALL >> log_msg 2>&1

	if [ $? -ne 0  ]
	then
		print "$CMD Check has returned Errors" >> log_msg 2>&1
		ice_status=1
		Script_Output
	else
		print "$CMD Check has fixed any possible errors"  >> log_msg 2>&1
		ice_status=0
		Script_Output
	fi
else
	ice_status=0
	Script_Output
fi

if [ "$RULE_NAME" == "pwdck" ]
then 
  #Set the lastupdate to NULL for users having blank passwords
  PASSWDFILE=/etc/security/passwd
  USERFILE=/etc/security/user


  for user in `dispuid`
  do
          if [ "$user" != "root" ]
          then
                  # Get the lastupdate from the file /etc/security/passwd.
                  # This will be NULL if the user has no password set.

                  lastupdate=`lssec -f $PASSWDFILE -s $user -a lastupdate|\
                              awk -F "=" '{print $2}'`

                  if [ "$lastupdate" = "" ]
                  then
                          if [ "$STATUS_ARG" == "true" ]
                          then
                            # Lock users
                            $ECHOPREFIX chsec -f $USERFILE -s $user -a account_locked=true
                          else
                            # Unlock the users
                            $ECHOPREFIX chsec -f $USERFILE -s $user -a account_locked=false
                          fi
                  fi
          fi

  done
fi


exit 0
