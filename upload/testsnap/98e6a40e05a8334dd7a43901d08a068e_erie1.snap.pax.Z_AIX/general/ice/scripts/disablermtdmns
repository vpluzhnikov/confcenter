#!/usr/bin/ksh
# IBM_PROLOG_BEGIN_TAG         
# This is an automatically generated prolog.  
#                            
# $Source: aix710 bos/usr/lib/security/ice/scripts/disablermtdmns.sh 1$                         
#                                                           
# COPYRIGHT International Business Machines Corp. 2010,2010              
#                                                                      
# Pvalue: p2 
#Licensed Materials - Property of IBM
#
#Restricted Materials of IBM
#
#US Government Users Restricted Rights - Use, duplication or
#disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
# Origin: 27
#
# sccsid: $Header: @(#) AIX710_area/1 bos/usr/lib/security/ice/scripts/disablermtdmns.sh, libice, aix710, 1010A_710 2010-03-02T17:22:07-06:00$
#
# IBM_PROLOG_END_TAG
#	COMPONENT_NAME: (ICE) disablermtdmns.sh
#	FUNCTIONS:	None
#	ORIGINS: 	27
#
#	Syntax: 
#		disablermtdmns.sh -{c|e|p}[v] rulename toggle
#	Parameters:
#		-c	- Check mode
#		-e	- Enforce mode
#		-p	- Preview mode
#		-v	- verbose mode
#		rulename	- Defines the remote daemons to be disabled 
#		toggle		- 1 disables the daemons & 1 enables the commands
#
#	OUTPUT:
#		0	- success
#		1	- check/enforce failure
#		2	- usage error
#
#	Description:
#		This script disables or enables the daemons. The current list of 
#		remote daemons:  tftpd, rlogind, rshd.

export PATH=/usr/bin:/usr/sbin:$PATH
exec 2>&1

###
#Print Usage
###
Usage() {
	ice_status=1
	print "usage: \n
   disablermtdmns.sh -{c|e|p}[v] rulename toggle\n"
}

###
#Output from Script to the Native Library
###
Script_Output() {
	print -n "$cur_val%$ice_status%"
	cat log_msg
	print
}

###
#Process arguments
###

#Check mode
cflag=0
#Enforce mode
eflag=0
#Preview mode
pflag=0
#Verbose mode
vflag=0

###
#Initialize the Script Output variables
###
cur_val=0
ice_status=0
print -n > log_msg 2>&1

while getopts :cevp OPT
do
        case $OPT in
                c)      cflag=1;;
                e)      eflag=1;;
                v)      vflag=1;;
		p)	pflag=1;;
                ?|:)    Usage
			Script_Output
                        exit 1;;
        esac
done
shift $(($OPTIND -1))

#Enable Verbose
if [[ vflag -eq 1 ]];
then
	set -x
fi

#Need atleast arguments
if [[ $# -ne 2 ]];
then
	Usage
	Script_Output
	exit 1 
fi

RULE_NAME=$1
STATUS_ARG=$2

# -c, -e and -p mutually exclusive
((chkflg=cflag+eflag+pflag))
if [[ chkflg -ne 1 ]];
then
	Usage
	Script_Output
	exit 1 
fi

if ( [ "$STATUS_ARG" != "false" ] && [ "$STATUS_ARG" != "true" ] )
then
	Usage
	Script_Output
	exit 1
fi

# Preview mode set-up
if [[ pflag -eq 1 ]];
then
	ECHOPREFIX="echo"
else
	ECHOPREFIX=""
fi

PREREQ=/etc/security/ice/scripts/chkprereq

$ECHOPREFIX $PREREQ \
"bos.rte.commands,bos.rte.shell,bos.rte.ILS,bos.rte.security,bos.rte.odm,bos.rte.install,bos.rte.control"

# Function to determine the mode of a file in octal format
detmode ()
{
        #Convert the mode string from ls command into octal format
        perm=`ls -l $1 | awk '{str=$1;ind=0;
                tb[2,"r"]=400;
                tb[3,"w"]=200;
                tb[4,"x"]=100;
                tb[4,"s"]=4100;
                tb[4,"S"]=4000;
                tb[5,"r"]=40;
                tb[6,"w"]=20;
                tb[7,"x"]=10;
                tb[7,"s"]=2010;
                tb[7,"S"]=2000;
                tb[8,"r"]=4;
                tb[9,"w"]=2;
                tb[10,"x"]=1;
                tb[10,"t"]=1001;
                tb[10,"T"]=1000;
                perm=0
                while(x=match(str,"r|w|x|s|S|t|T"))
                {
                        ind+=x;
                        ch=substr(str,x,1);
                        perm+=tb[ind,ch];
                        str=substr(str, x+1);
                }
		if ( perm == "0" ) {
			print "0000"
		} else {
                	print perm
		}
        }'`
}


# Function to construct the mode string to be set in the TCB
con_mode_str ()
{
        # Separate the SUID, SGID, SVTX and rwx attributes from
        # the given file mode in octal
        mode=
        res=$1
        if [ $res -ge 4000 ]
        then
                mode=SUID
                res=` expr $res - 4000 `
        elif [ $res -ge 2000 ]
        then
                if [ "$mode" = "" ]
                then
                        mode=SGID
                else
                        mode="$mode,SGID"
                fi
                res=` expr $res - 2000 `
        elif [ $res -ge 1000 ]
        then
                if [ "$mode" = ""]
                then
                        mode=SVTX
                else
                        mode="$mode,SVTX"
                fi
                res=` expr $res - 1000 `
        fi

        if [ $res -gt 0 ]
        then
                if [ "$mode" = "" ]
                then
                        mode=$res
                else
                        mode="$mode,$res"
                fi
        fi

        res=`chtcb query $2 | grep -v "not"`
        if [ "$res" != "" ]
        then
                if [ "$mode" = "" ]
                then
                        mode=TCB
                else
                        mode="TCB,$mode"
                fi
        fi

}

CONFIG_FILE=/etc/security/config
TFTPD=/usr/sbin/tftpd
RLOGIND=/usr/sbin/rlogind
RSHD=/usr/sbin/rshd

if [ "$STATUS_ARG" == "false" ]
then
        setperm=0000
        setmode=0000
        setmodestr="TCB"
else
        setperm=4555
        setmode=4555
        setmodestr="TCB,SUID,555"
fi


###
#Preview/Enforcing/Checking
###


# Determine whether TCB is installed
ODMDIR=/etc/objrepos odmget -q 'deflt= tcb_enabled' PdAt | if read rec
then
        # Chmod these files so that they are not executable, and have
        # sysck make the appropriate changes to /etc/security/sysck.cfg
        for i in $TFTPD $RLOGIND $RSHD 
        do
                if [ -f $i ]
                then
                        # First determine the mode(octal number) of the file $i
                        detmode $i

			if [ "$perm" != "0000" ] && [[ cflag -eq 1 ]];
			then
				cur_val=1
			fi

                        # Construct the mode string to be put in sysck.cfg
                        con_mode_str $perm $i

                        if [ "$mode" != "$setmodestr" ]
                        then
                                if [[ cflag -eq 1 ]] && [ $perm -ne $setperm ]; 
                                then
					if [ "$res" = "" ]
					then
                                       		print "Error: File $i has permission $perm , however it should be $setmode \n" >> log_msg 2>&1
					else
                                       		print "Error: File $i has mode $mode , however it should be $setmodestr \n" >> log_msg 2>&1
					fi
					ice_status=2
                                else
					if [ "$res" = "" ]
					then
						$ECHOPREFIX chmod $setmode $i
					else
                                        	$ECHOPREFIX chmod $setmode $i
                                        	$ECHOPREFIX /bin/sysck -a $i mode=$setmodestr
                                        	$ECHOPREFIX /bin/sysck -y $i
					fi
				fi
                        fi
                fi
        done
else
        # TCB is disabled
        # Chmod these files so that they are not executable
        for i in $TFTPD $RLOGIND $RSHD

        do
                if [ -f $i ]
                then
                        # First determine the mode(octal number) of the file $i
                        detmode $i

			if [ "$perm" != "0000" ] && [[ cflag -eq 1 ]];
			then
				cur_val=1
			fi

                        if [ $perm  -ne $setperm ]
                        then
				if [[ cflag -eq 1 ]];
                                then
                                        print "Error: File $i has permission $perm , however it should be $setmode \n" >> log_msg 2>&1
					ice_status=2
                                else
                                        $ECHOPREFIX chmod $setmode $i
				fi
                        fi
                fi

        done
fi

if [ "$STATUS_ARG" == "false" ]
then
        for i in $TFTPD $RLOGIND $RSHD
        do
                # Kill the processes running these commands
                cmdname=`echo $i | awk -F "/" '{print $NF}'`

                ps -eo pid,comm | egrep -w "$i|$cmdname" | awk '{print $1}' |\
 while read pid
                do
                        # Check whether the current script is a descendant of $pid
                        rmtexe=`ps -o pid -T $pid | grep $PID`

                        if [ -z "$rmtexe" ]
                        then
				if [[ cflag -eq 1 ]];
                                then
                                        print "Error: Process $i is still running. \n" >> log_msg 2>&1
					ice_status=2
					cur_val=1
                                else
                                        $ECHOPREFIX kill -9 $pid
				fi
                        fi
                done
        done
fi
Script_Output

exit 0
