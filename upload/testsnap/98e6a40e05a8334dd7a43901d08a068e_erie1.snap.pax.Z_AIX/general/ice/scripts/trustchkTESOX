# IBM_PROLOG_BEGIN_TAG         
# This is an automatically generated prolog.  
#                            
# $Source: aix71B bos/usr/lib/security/ice/scripts/trustchkTESOX.sh 1$                         
#                                                           
# COPYRIGHT International Business Machines Corp. 2010,2010              
#                                                                      
# Pvalue: p2 
#Licensed Materials - Property of IBM
#
#Restricted Materials of IBM
#
#US Government Users Restricted Rights - Use, duplication or
#disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
# Origin: 27
#
# sccsid: $Header: @(#) AIX71B_area/1 bos/usr/lib/security/ice/scripts/trustchkTESOX.sh, libice, aix71B, 1035A_71B 2010-07-27T10:06:23-05:00$
#
# IBM_PROLOG_END_TAG
#!/usr/bin/ksh
#       COMPONENT_NAME: (ICE) trustchkTESOX.sh
#       FUNCTIONS:      None
#       ORIGINS:        27
#
#       Syntax:
#               trustchkTE -{c|e|p}[v] rulename toggle
#       Parameters:
#               -c      - Check mode
#               -e      - Enforce mode
#               -p      - Preview mode
#               -v      - verbose mode
#		lname	- rule_name
#		toggle	- Boolean
#			  false => Disable
#			  true  => Enable
#
#       OUTPUT:
#               0       - success
#               1       - check/enforce failure
#
#       Description             : This script checks turns on the below TE policies
#                                       CHKEXEC=ON
#                                       CHKSHLIB=ON
#                                       CHKSCRIPT=ON
#                                       CHKKERNEXT=ON
#                                       STOP_ON_CHKFAIL=ON
					TSD_LOCK_FILES=ON
#                                       TE=ON



export PATH=/usr/bin:/usr/sbin:$PATH
exec 2>&1
###
#Print Usage
###
Usage() {
	ice_status=1
        print "usage: \n
   trustchkTE -{c|e|p}[v] rulename toggle\n" >> log_msg 2>&1
}

###
#Output from Script to the Native Library
###
Script_Output() {
        print -n "$cur_val%$ice_status%"
        cat log_msg
        print
}

###
#Process arguments
###

#Check mode
cflag=0
#Enforce mode
eflag=0
#Preview mode
pflag=0
#Verbose mode
vflag=0

###
#Initialize the Script Output variables
###
cur_val=0
ice_status=0
print -n > log_msg 2>&1

while getopts :cevp OPT
do
        case $OPT in
                c)      cflag=1;;
                e)      eflag=1;;
                v)      vflag=1;;
                p)      pflag=1;;
                ?|:)    Usage
			Script_Output
                        exit 1;;
        esac
done
shift $(($OPTIND -1))

#Enable Verbose
if [[ vflag -eq 1 ]];
then
        set -x
fi

#Need 2 arguments
if [[ $# -lt 2 ]];
then
        Usage
	Script_Output
        exit 1
fi

# -c, -e and -p mutually exclusive
((chkflg=cflag+eflag+pflag))
if [[ chkflg -ne 1 ]];
then
        Usage
	Script_Output
        exit 1
fi

RULE_NAME=$1
STATUS_ARG=$2
#Toggle argument must be true or false
if ( [ "$STATUS_ARG" != "true" ] && [ "$STATUS_ARG" != "false" ] )
then
        print "Toggle must be true or false" >> log_msg 2>&1
        Usage
        Script_Output
        exit 1
fi

AIXvers=`oslevel | cut -d. -f1`
        if [ $AIXvers -lt 6 ]
        then
		print "This is a 53 system and this rule is not supported on a 53 system" >> log_msg 2 >&1
		Script_Output
		exit 1
        fi


# Preview mode set-up
if [[ pflag -eq 1 ]];
then
        ECHOPREFIX="echo"
else
        ECHOPREFIX=""
fi

# check the status of current TE policies
stexec=`trustchk -p CHKEXEC 2>&1 | awk -F '=' '{print $2}'`
stshlib=`trustchk -p CHKSHLIB 2>&1 | awk -F '=' '{print $2}'`
stscrpt=`trustchk -p  CHKSCRIPT 2>&1 | awk -F '=' '{print $2}'`
stkerex=`trustchk -p CHKKERNEXT 2>&1 | awk -F '=' '{print $2}'`
stckfail=`trustchk -p STOP_ON_CHKFAIL 2>&1 | awk -F '=' '{print $2}'`
stTSDfl=`trustchk -p TSD_FILES_LOCK 2>&1 | awk -F '=' '{print $2}'`
TEstatus=`trustchk -p TE 2>&1 | awk -F '=' '{print $2}'`

cur_val=true
ice_status=0

#checking
if [[ cflag -eq 1 ]];
then
	# Default case
	if [ "$STATUS_ARG" = "true" ] 	
	then
        if ( [ "$stexec" = "OFF" ] || [ "$stshlib" = "OFF" ] ||
                [ "$stscrpt" = "OFF" ] || [ "$stkerex" = "OFF" ] || [ "$stTSDfl" = "OFF" ] )
        then
                print "One or more of the CHKEXEC, CHKSHLIB, CHKSCRIPT or CHKKERNEXT"\
                        "polcies is turned OFF, however they should be turned ON\n" >> log_msg 2>&1
			ice_status=2
			cur_val=false
        fi
        if [ "$stckfail" = "OFF" ]
        then
                print " STOP_ON_CHKFAIL policy is OFF,"\
                        "however it should be ON\n" >> log_msg 2>&1
                        ice_status=2
                        cur_val=false
        fi
        if [ "$TEstatus" = "OFF" ]
        then
                print " TE policy is turned OFF,"\
                        "however it should be ON\n" >> log_msg 2>&1
			ice_status=2
                        cur_val=false
        fi
        else
	cur_val=false
	ice_status=0
		
        if ( [ "$stexec" = "ON" ] || [ "$stshlib" = "ON" ] ||
                [ "$stscrpt" = "ON" ] || [ "$stkerex" = "ON" ] || [ "$stTSDfl" = "OFF" ] )
        then
                print "One or more of the CHKEXEC, CHKSHLIB, CHKSCRIPT or CHKKERNEXT"\
                        "polcies is turned ON, however they should be turned OFF\n" >> log_msg 2>&1
			ice_status=2
			cur_val=true
        fi
        if [ "$stckfail" = "ON" ]
        then
                print " STOP_ON_CHKFAIL policy is ON,"\
                        "however it should be OFF\n" >> log_msg 2>&1
		ice_status=2
                cur_val=true
	
        fi
        if [ "$TEstatus" = "ON" ]
        then
                print " TE policy is turned ON,"\
                        "however it should be OFF\n" >> log_msg 2>&1
		ice_status=2
                cur_val=true
        fi

	fi 

	Script_Output
	exit 0
fi

###
#Preview/Enforcing
###

if [ "$STATUS_ARG" = "true" ]
then
# turn on CHK* policies first
        $ECHOPREFIX trustchk -p CHKEXEC=ON >> log_msg 2>&1
        rc1=$?

        $ECHOPREFIX trustchk -p CHKSHLIB=ON
        rc2=$?

        $ECHOPREFIX trustchk -p CHKSCRIPT=ON
        rc3=$?

        $ECHOPREFIX trustchk -p CHKKERNEXT=ON
        rc4=$?

	$ECHOPREFIX trustchk -p STOP_ON_CHKFAIL=ON
	rc5=$?

	$ECHOPREFIX trustchk -p TSD_FILES_LOCK=ON
	rc6=$?

	$ECHOPREFIX trustchk -p TE=ON
	rc7=$?

	if ( [ $rc1  -ne 0 ] || [ $rc2 -ne 0 ] || [ $rc3 -ne 0 ] || [ $rc4 -ne 0 ] || [ $rc5 -ne 0 ] || [ $rc6 -ne 0 ]  || [ $rc7 -ne 0 ] )
	then
		ice_status=1
		cur_val=false
		Script_Output
	else
		ice_status=0
		cur_val=true
		Script_Output
	fi


else
# turn off CHK* policies first
        $ECHOPREFIX trustchk -p CHKEXEC=OFF >> log_msg 2>&1
        rc1=$?

        $ECHOPREFIX trustchk -p CHKSHLIB=OFF >> log_msg 2>&1
        rc2=$?

        $ECHOPREFIX trustchk -p CHKSCRIPT=OFF >> log_msg 2>&1
        rc3=$?

        $ECHOPREFIX trustchk -p CHKKERNEXT=OFF >> log_msg 2>&1
        rc4=$?

	$ECHOPREFIX trustchk -p STOP_ON_CHKFAIL=OFF
	rc5=$?

	$ECHOPREFIX trustchk -p TSD_FILES_LOCK=OFF
	rc6=$?

	$ECHOPREFIX trustchk -p TE=OFF
	rc7=$?

	if ( [ $rc1  -ne 0 ] || [ $rc2 -ne 0 ] || [ $rc3 -ne 0 ] || [ $rc4 -ne 0 ] || [ $rc5 -ne 0 ] || [ $rc6 -ne 0 ]  || [ $rc7 -ne 0 ] )
	then
		ice_status=1
		cur_val=true
		Script_Output
	else
		ice_status=0
		cur_val=false
		Script_Output
	fi


fi

exit 0
