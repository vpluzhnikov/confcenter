# IBM_PROLOG_BEGIN_TAG         
# This is an automatically generated prolog.  
#                            
# $Source: aix71B bos/usr/lib/security/ice/scripts/disable_user.sh 1$                         
#                                                           
# COPYRIGHT International Business Machines Corp. 2010,2010              
#                                                                      
# Pvalue: p2 
#Licensed Materials - Property of IBM
#
#Restricted Materials of IBM
#
#US Government Users Restricted Rights - Use, duplication or
#disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
# Origin: 27
#
# sccsid: $Header: @(#) AIX71B_area/1 bos/usr/lib/security/ice/scripts/disable_user.sh, libice, aix71B, 1035A_71B 2010-07-27T10:06:10-05:00$
#
# IBM_PROLOG_END_TAG
#!/usr/bin/ksh
#       COMPONENT_NAME: (ICE) disable_user.sh
#       FUNCTIONS:      None
#       ORIGINS:        27
#
#       Syntax:
#               disable_user -{c|e|p}[v] rulename toggle
#       Parameters:
#               -c      - Check mode
#               -e      - Enforce mode
#               -p      - Preview mode
#               -v      - verbose mode (unimplemented)
#               rulename (ignore)
#               toggle  - Boolean
#                       false => Disable
#                       true  => Enable
#
#       OUTPUT:
#               0       - success
#               1       - check/enforce failure
#
#       Description:
#       Check /etc/passwd file for a list of valid users (users that have valid shell path)
#       Then check those users against the last log (/etc/security/lastlog). If the user is not
#       in the last log, or in the last log but not active for a certain time (number of days
#       indicated by the second argument), then disable the user by modifying /etc/passwd to 
#       replace the password field with * and the shell-path field with /bin/noshell.
#
#
#       When set to 0: Do nothing
#       When set to <number>: This script disable accounts that are inactive after <number> days
#
#       Look in the /var/adm/sulog
#       Look in the /etc/syslog.conf
#       Look in the /etc/passwd file
#       Use the last command
#
#       GEN items requirements are as following:
#
# ------------------
# GEN000760 - Inactive Accounts are not locked
# Indications of inactive accounts are those that have no entries in the last log. Check the date in
# the last log to verify it is within the last 35 days. If an inactive account is not disabled via an
# entry in the password field in the /etc/passwd or /etc/shadow (or TCB equivalent),
# check the /etc/passwd file to check if the account has a valid shell. If not, this is a finding.
# Non-interactive application accounts may be documented. The following command should help
# in determining if the account is locked.
# # passwd -status (-s) <username>
# ------------------
#       
#       cur_val     reflects current value of current state of system. (0-false-disable, 1-true-enable)
#       ice_status  reflects compliance status (0 - Compliant, 1 - Error, 2 - Non-compliant)
#
######################################################################################################


export PATH=/usr/bin:/usr/sbin:$PATH

###
#Print Usage
###
Usage() {
    ice_status=1
    print "usage: \n
            disableUser -{c|e|p}[v] rulename number\n" >> log_msg 2>&1
}

###
#Output from Script to the Native Library
###
Script_Output() {
    print -n "$cur_val%$ice_status%"
    cat log_msg
    print
}

###
#Process arguments
###

#Check mode
cflag=0
#Enforce mode
eflag=0
#Preview mode
pflag=0
#Verbose mode
vflag=0

###
#Initialize the Script Output variables
###
cur_val=0
ice_status=0
print -n > log_msg 2>&1

while getopts :cevp OPT
do
    case $OPT in
        c)      cflag=1;;
        e)      eflag=1;;
        v)      vflag=1;;
        p)      pflag=1;;
        ?|:)    Usage
                Script_Output
                exit 1;;
    esac
done
shift $(($OPTIND -1))

#Enable Verbose
if [[ vflag -eq 1 ]];
then
    set -x
fi

#Need 1 argument(s)
if [[ $# -ne 2 ]];
then
    Usage
    Script_Output
    exit 1 
fi


# -c, -e and -p mutually exclusive
((chkflg=cflag+eflag+pflag))
if [[ chkflg -ne 1 ]];
then
    Usage
    Script_Output
    exit 1 
fi

RULE_NAME="$1"
STATUS_ARG="$2"
PID=$$
PASSWDFILE=/etc/passwd

# Toggle argument must be zero or positive integer
case $STATUS_ARG in
    [0-9]* )    ;;
    * )     print "Second argument must be zero or positive integer" >> log_msg 2>&1 
            Usage
            Script_Output
            exit 1
            ;;
esac

# Check for perl
if [[ ! -e /usr/bin/perl && ! -e /usr/opt/perl5/bin/perl5.8.8 ]] ; then
    print "perl is not found at /usr/bin/perl" >> log_msg 2>&1
    Script_Output
    exit 1
fi

# Preview mode set-up
if [[ pflag -eq 1 ]] ;
then
        ECHOPREFIX="echo"
else
        ECHOPREFIX=""
fi

# Enable the rule
if [[ $STATUS_ARG -gt 0 ]] ; then

    # Get the list of valid shells
    shelllist=`awk '{ if ( $1 ~ /^[\t ]+shells$/ ) { gsub(/,/," ",$2) ; print " "$2" " } }' FS=" = " /etc/security/login.cfg`
    
    # Look in /etc/passwd file to find valid users
    # Invalid users have password field set to *, or shell field set to invalid shell path
    validUsers=`awk '{ if ($2 != "*" && ($7 == "" || shelllist ~ " "$7" ")) print $1 }' FS=":" ORS=" " shelllist="$shelllist" $PASSWDFILE`    

    # Find inactive user in the lastlog
    inactiveUsers=""
    for user in $validUsers ; do
        grep "^$user:" /etc/security/lastlog > /dev/null 2>&1
        rc=$?
        if [[ $rc -eq 0 ]] ; then
            # get epoch of last activity
            lastact=`/usr/sbin/lsuser -a time_last_login $user | awk '{print $2}' FS="="`
            # add the number of seconds into epoch ($days * 24 hours * 60 minutes * 60 seconds)
            timelimit=$(( $lastact + $STATUS_ARG * 24 * 60 * 60 ))
            # convert the current time to epoch
            currenttime=`perl -e 'print scalar time();'`
            # compare timelimit with currenttime
            # if time limit is less than current time, add user to the invalidUsers list
            if [[ $timelimit -le $currenttime ]] ; then inactiveUsers="$inactiveUsers $user" ; fi
        # user is not in the lastlog. add user to invalidUsers list
        else
            inactiveUsers="$inactiveUsers $user"
        fi
    done

    # no invalid users -> true/enabled rule
    if [[ -z $inactiveUsers ]] ; then cur_val=1 ;
    # has inactive users
    else
        # check flag
        if [[ cflag -eq 1 ]] ; then
            print "Inactive users after $STATUS_ARG days are: $inactiveUsers" >> log_msg 2>&1
            cur_val=0       # false/disable
            ice_status=2    # non-compliant
        # enforce flag - disable inactive users
        else
            # make copy of /etc/passwd
            $ECHOPREFIX cp $PASSWDFILE /tmp/passwd.$PID
            inactiveUsers=:$(echo $inactiveUsers | sed 's/ /:/g'):
            if [[ eflag -eq 1 ]] ; then
                # modify /etc/passwd to disable inactive users by
                # replacing password field with * and shellpath with /bin/noshell
                > /tmp/temppasswd.$PID
                awk '{ if (users ~ ":"$1":") {$2="*";$7="/bin/noshell"} print $0 }' users="$inactiveUsers" FS=":" OFS=":" $PASSWDFILE >> /tmp/temppasswd.$PID
            elif [[ pflag -eq 1 ]] ; then
                echo "awk '{ if (users ~ \":\"\$1\":\") {\$2=\"*\";\$7=\"/bin/noshell\"} print \$0 }' users=\"$inactiveUsers\" FS=\":\" OFS=\":\" $PASSWDFILE >> /tmp/temppasswd.$PID"
            fi
            $ECHOPREFIX mv /tmp/temppasswd.$PID $PASSWDFILE
            cur_val=1
            ice_status=0
        fi
    fi
fi

Script_Output
exit 0
