#!/usr/bin/ksh
# IBM_PROLOG_BEGIN_TAG         
# This is an automatically generated prolog.  
#                            
# $Source: aix710 bos/usr/lib/security/ice/scripts/disablermtcmds.sh 1$                         
#                                                           
# COPYRIGHT International Business Machines Corp. 2010,2010              
#                                                                      
# Pvalue: p2 
#Licensed Materials - Property of IBM
#
#Restricted Materials of IBM
#
#US Government Users Restricted Rights - Use, duplication or
#disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
# Origin: 27
#
# sccsid: $Header: @(#) AIX710_area/1 bos/usr/lib/security/ice/scripts/disablermtcmds.sh, libice, aix710, 1010A_710 2010-03-02T17:22:10-06:00$
#
# IBM_PROLOG_END_TAG
#	COMPONENT_NAME: (ICE) disablermtcmds.sh
#	FUNCTIONS:	None
#	ORIGINS: 	27
#
#	Syntax: 
#		disablermtcmds.sh -{c|e|p}[v] rulename toggle
#	Parameters:
#		-c	- Check mode
#		-e	- Enforce mode
#		-p	- Preview mode
#		-v	- verbose mode
#		rulename	- Defines the remote commands to be disabled
#		toggle		- false disables the commands & true enables the commands
#
#	OUTPUT:
#		0	- success
#		1	- check/enforce failure
#		2	- non-compliant
#
#	Description:
#		This script disbles remote commands based on the rulename.
#		When the rulename is rmtcmd it disables tftp,uftp,rcp,rlogin & rsh.
#		When the rulename is rmsuid it removes SUID for rsh,rdist,rexec,remsh
#		rlogin & rcp.

export PATH=/usr/bin:/usr/sbin:$PATH
exec 2>&1

###
#Print Usage
###
Usage() {
	ice_status=1
	print "usage: \n
   disablermtcmds.sh -{c|e|p}[v] rulename(rmtcmd or rmsuid) toggle(true or false)" >> log_msg 2>&1
}

###
#Output from Script to the Native Library
###
Script_Output() {
	print -n "$cur_val%$ice_status%"
	cat log_msg
	print
}

###
#Process arguments
###

#Check mode
cflag=0
#Enforce mode
eflag=0
#Preview mode
pflag=0
#Verbose mode
vflag=0

###
#Initialize the Script Output variables
###
cur_val=0
ice_status=0
print -n > log_msg 2>&1

while getopts :cevp OPT
do
        case $OPT in
                c)      cflag=1;;
                e)      eflag=1;;
                v)      vflag=1;;
		p)	pflag=1;;
                ?|:)    Usage
			Script_Output
                        exit 1;;
        esac
done
shift $(($OPTIND -1))

#Enable Verbose
if [[ vflag -eq 1 ]];
then
	set -x
fi

#Need two arguments
if [[ $# -ne 2 ]];
then
	Usage
	Script_Output
	exit 1 
fi


# -c, -e and -p mutually exclusive
((chkflg=cflag+eflag+pflag))
if [[ chkflg -ne 1 ]];
then
	Usage
	Script_Output
	exit 1 
fi

RULE_NAME=$1
STATUS_ARG=$2

if ( [ "$RULE_NAME" != "rmtcmd" ] && [ "$RULE_NAME" != "rmsuid" ] )
then
	Usage
	Script_Output
	exit 1 
fi

if ( [ "$STATUS_ARG" != "false" ] && [ "$STATUS_ARG" != "true" ] )
then
	Usage
	Script_Output
	exit 1 
fi


# Preview mode set-up
if [[ pflag -eq 1 ]];
then
	ECHOPREFIX="echo"
else
	ECHOPREFIX=""
fi

PREREQ=/etc/security/ice/scripts/chkprereq

$ECHOPREFIX $PREREQ \
"bos.rte.commands,bos.rte.shell,bos.rte.ILS,bos.rte.security,bos.rte.odm,bos.rte.install,bos.rte.control"


# Function to determine the mode of a file in octal format
detmode ()
{
        #Convert the mode string from ls command into octal format
        perm=`ls -l $1 | awk '{str=$1;ind=0;
                tb[2,"r"]=400;
                tb[3,"w"]=200;
                tb[4,"x"]=100;
                tb[4,"s"]=4100;
                tb[4,"S"]=4000;
                tb[5,"r"]=40;
                tb[6,"w"]=20;
                tb[7,"x"]=10;
                tb[7,"s"]=2010;
                tb[7,"S"]=2000;
                tb[8,"r"]=4;
                tb[9,"w"]=2;
                tb[10,"x"]=1;
                tb[10,"t"]=1001;
                tb[10,"T"]=1000;
                perm=0
                while(x=match(str,"r|w|x|s|S|t|T"))
                {
                        ind+=x;
                        ch=substr(str,x,1);
                        perm+=tb[ind,ch];
                        str=substr(str, x+1);
                }
		if ( perm == "0" ) {
			print "0000"
		} else {
                	print perm
		}
        }'`

}


# Function to construct the mode string to be set in the TCB
con_mode_str ()
{
        # Separate the SUID, SGID, SVTX and rwx attributes from
        # the given file mode in octal
        mode=
        res=$1
        if [ $res -ge 4000 ]
        then
                mode=SUID
                res=` expr $res - 4000 `
        elif [ $res -ge 2000 ]
        then
                if [ "$mode" = "" ]
                then
                        mode=SGID
                else
                        mode="$mode,SGID"
                fi
                res=` expr $res - 2000 `
        elif [ $res -ge 1000 ]
        then
                if [ "$mode" = ""]
                then
                        mode=SVTX
                else
                        mode="$mode,SVTX"
                fi
                res=` expr $res - 1000 `
        fi

        if [ $res -gt 0 ]
        then
                if [ "$mode" = "" ]
                then
                        mode=$res
                else
                        mode="$mode,$res"
                fi
        fi

        res=`chtcb query $2 | grep -v "not"`
        if [ "$res" != "" ]
        then
                if [ "$mode" = "" ]
                then
                        mode=TCB
                else
                        mode="TCB,$mode"
                fi
        fi

}

CONFIG_FILE=/etc/security/config

#list of remote commands

if [ "$RULE_NAME" = "rmtcmd" ]
then
	list="/usr/bin/tftp /usr/bin/uftp /usr/bin/rcp /usr/bin/rlogin \
/usr/bin/rsh"
else
	list="/usr/bin/rsh /usr/bin/rdist /usr/bin/rexec /usr/bin/remsh \
/usr/bin/rlogin /usr/bin/rcp"
fi

if [ "$STATUS_ARG" == "false" ]
then
	if [ "$RULE_NAME" = "rmtcmd" ] 
	then
	        setperm=0
		setmode=0000
		setmodestr="TCB"
	else
		setperm=0555
		setmode=0555
		setmodestr="TCB,555"
	fi
else
        setperm=4555
        setmode=4555
        setmodestr="TCB,SUID,555"
fi



###
#Preview/Enforcing
###


# Determine whether TCB is installed
ODMDIR=/etc/objrepos odmget -q 'deflt= tcb_enabled' PdAt | if read rec
then
        # Chmod these files so that they are not executable or remove
        # SUID based on rule name, and have sysck make the appropriate 
	# changes to /etc/security/sysck.cfg
        for i in $list
        do
                if [ -f $i ]
                then
                        # First determine the mode(octal number) of the file $i
                        detmode $i

			if [ "$perm" != "0000" ] && [[ cflag -eq 1 ]];
			then
				cur_val=1
			fi

                        # Construct the mode string to be put in sysck.cfg
                        con_mode_str $perm $i
                        if [ "$mode" != "$setmodestr" ]
                        then
				if [[ cflag -eq 1 ]];
				then
					print "Error: File $i has mode $mode , however it should be $setmodestr \n" >> log_msg 2>&1
					ice_status=2
				else
                                        $ECHOPREFIX chmod $setmode $i
                                        $ECHOPREFIX /bin/sysck -a $i mode=$setmodestr >> log_msg 2>&1
                                        $ECHOPREFIX /bin/sysck -y $i >> log_msg 2>&1
				fi
                        fi
                fi
        done
else
        # TCB is disabled
        # Chmod these files so that they are not executable or remove SUID 
	# depending on the rulename.
        for i in $list
        do
                if [ -f $i ]
                then
                        # First determine the mode(octal number) of the file $i
                        detmode $i

			if [ "$perm" != "0000" ] && [[ cflag -eq 1 ]];
			then
				cur_val=1
			fi

                        if [ $perm  -ne $setperm ]
                        then
				if [[ cflag -eq 1 ]];
                                then
                                        print "Error: File $i has permission $perm , however it should be $setmode \n" >> log_msg 2>&1
					ice_status=2
				else
                                        $ECHOPREFIX chmod $setmode $i
				fi
                        fi
                fi

        done
fi

if ( [ "$STATUS_ARG" = "false" ] && [ "$RULE_NAME" = "rmtcmd" ] )
then
        for i in $list
        do
                # Kill the processes running these commands
                cmdname=`echo $i | awk -F "/" '{print $NF}'`

                ps -eo pid,comm | egrep -w "$i|$cmdname" | awk '{print $1}' |\
 while read pid
                do
                        # Check whether the current script is a descendant of $pid
                        rmtexe=`ps -o pid -T $pid | grep $PID`

                        if [ -z "$rmtexe" ]
                        then
				if [[ cflag -eq 1 ]];
                                then
                                        print "Error: Process $i is still running. \n" >> log_msg 2>&1
					ice_status=2
					cur_val=1
				else
                                        $ECHOPREFIX kill -9 $pid
				fi
                        fi
                done
        done
fi


if [ "$RULE_NAME" = "rmtcmd" ]
then
   if [ "$STATUS_ARG" = "false" ]
   then
        # Add stanza to /etc/security/config to restrict .netrc
        # usage in ftp, and rexec.
        /bin/grep "^tcpip:" $CONFIG_FILE > /dev/null 2>&1
        rc=$?

        if [ $rc -ne 0 ]
        then
		if [[ cflag -eq 1 ]];
                then
                	print "Error: $CONFIG_FILE file doesn't have tcpip entry or the file does not exist. \n" >> log_msg 2>&1
			ice_status=2
			cur_val=1
		else
                        $ECHOPREFIX echo "\ntcpip:" >> $CONFIG_FILE
                        $ECHOPREFIX echo "\tnetrc = ftp,rexec\n" >> $CONFIG_FILE
		fi
        fi
   else
        if [ -f $CONFIG_FILE ]
        then
		if [[ cflag -eq 1 ]];
		then
			print "Error: $CONFIG_FILE file exists. \n" >> log_msg 2>&1
			ice_status=2
		else
                        $ECHOPREFIX rm $CONFIG_FILE
		fi
	fi
   fi
fi


Script_Output

exit 0
