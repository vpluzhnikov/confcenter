#!/usr/bin/ksh
# IBM_PROLOG_BEGIN_TAG 
# This is an automatically generated prolog. 
#  
# bos610 src/bos/usr/lib/security/aixpert/scripts/disrmtcmds.sh 1.5 
#  
# Licensed Materials - Property of IBM 
#  
# Restricted Materials of IBM 
#  
# COPYRIGHT International Business Machines Corp. 2006,2007 
# All Rights Reserved 
#  
# US Government Users Restricted Rights - Use, duplication or 
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp. 
#  
# @(#)86	1.5  src/bos/usr/lib/security/aixpert/scripts/disrmtcmds.sh, aixpert, bos610 3/15/07 06:08:13
# IBM_PROLOG_END_TAG 
#	COMPONENT_NAME		: (AIXPERT) disrmtcmds.sh
#	FUNCTIONS		: None
#	ORIGINS			: 27
#
#	Command Line Arguments	: The script expects 2 command line arguments.
#				The first argument must be either 'd' or 'e' i.e.,
#				"disable" or "enable".
#				The second argument must be the rulename.
#				Syntax - disrmtcmds {e|d} rulename 
#
#	OUTPUT			: None
#
#	Description		: This script disables insecure commands rlogin,
#				rcp, rsh and tftp, when the first argument is 'd'.
#				Otherwise, it enables them. The script creates
#				an Undo rule and script dynamicaly.
#				This script should be run with superuser privileges.

export PATH=/usr/bin:/usr/sbin:$PATH

# Function to determine the mode of a file in octal format
detmode ()
{
	#Convert the mode string from ls command into octal format
	perm=`ls -l $1 | awk '{str=$1;ind=0;
		tb[2,"r"]=400;
		tb[3,"w"]=200;	
		tb[4,"x"]=100;
		tb[4,"s"]=4100;
		tb[4,"S"]=4000;
		tb[5,"r"]=40;
		tb[6,"w"]=20;
		tb[7,"x"]=10;
		tb[7,"s"]=2010;
		tb[7,"S"]=2000;
		tb[8,"r"]=4;
		tb[9,"w"]=2;
		tb[10,"x"]=1;
		tb[10,"t"]=1001;
		tb[10,"T"]=1000;
		perm=0
		while(x=match(str,"r|w|x|s|S|t|T"))
		{ 
			ind+=x; 
			ch=substr(str,x,1);
			perm+=tb[ind,ch];
			str=substr(str, x+1);
		}
		print perm
	}'`
			
}

# Function to construct the mode string to be set in the TCB
con_mode_str ()
{
	# Separate the SUID, SGID, SVTX and rwx attributes from
	# the given file mode in octal
	mode=
	res=$1
	if [ $res -ge 4000 ]
	then
		mode=SUID
		res=` expr $res - 4000 `
	elif [ $res -ge 2000 ]
	then
		if [ "$mode" = "" ]
		then
			mode=SGID
		else
			mode="$mode,SGID"
		fi
		res=` expr $res - 2000 `
	elif [ $res -ge 1000 ]
	then
		if [ "$mode" = ""]
		then
			mode=SVTX
		else
			mode="$mode,SVTX"
		fi
		res=` expr $res - 1000 `
	fi
	
	if [ $res -gt 0 ]
	then
		if [ "$mode" = "" ]
		then
			mode=$res
		else
			mode="$mode,$res"
		fi
	fi
	
	res=`chtcb query $2 | grep -v "not"`
	if [ "$res" != "" ]
	then
		if [ "$mode" = "" ]
		then
			mode=TCB
		else
			mode="TCB,$mode"
		fi	
	fi

}

# Initialize variables AIXPERT_FIFO, LOG, REPORT, SAVE, SCPTDIR and UNDOXML
. /etc/security/aixpert/bin/initialize_variables

CONFIG_FILE=/etc/security/config
PID=$$
TMP=/etc/security/aixpert/tmp/disrmtcmds
TFTP=/usr/bin/tftp
UTFTP=/usr/bin/utftp
RCP=/usr/bin/rcp 
RLOGIN=/usr/bin/rlogin
RSH=/usr/bin/rsh

# Log output and errors to /etc/security/aixpert/log/aixpert.log
exec 1>>$LOG
exec 2>&1

if  [ $# -ne 2 ] || ( [ "$1" != "e" ] && [ "$1" != "d" ] )
then
        dspmsg -s 8 aixpert.cat 1 "Usage : disrmtcmds {e|d} rulename\n"
        exit 1
fi

# echo all the commands and the current time and date to the AIXpert log
set -x
date
echo $0

# A value of 0 indicates that Undo rule need not be created. This variable
# will be set later in the script if there is anything to be undone
undo=0

if [ "$1" = "d" ]
then
	setperm=0
	setmode=0000
	setmodestr="TCB"
else
	setperm=4555
	setmode=4555
	setmodestr="TCB,SUID,555"
fi

# Check whether AIXPERT_CHECK_REPORT environment variable is set or not.
report=`echo $AIXPERT_CHECK_REPORT`

# Counter to determine the number of failures in Dynamic Security Check
counter=0

# Determine whether TCB is installed
ODMDIR=/etc/objrepos odmget -q 'deflt= tcb_enabled' PdAt | if read rec
then
	# Chmod these files so that they are not executable, and have
	# sysck make the appropriate changes to /etc/security/sysck.cfg
	for i in $RCP $RLOGIN $RSH $TFTP
	do
		if [ -f $i ]
		then
			# First determine the mode(octal number) of the file $i
			detmode $i
			# Construct the mode string to be put in sysck.cfg
			con_mode_str $perm $i
			
			if [ "$mode" != "$setmodestr" ]
			then
				# Dynamic Security Check
				if [ "$report" = "1" ]
				then
					counter=`expr $counter + 1`
					dspmsg -s 8 aixpert.cat 2 \
 "disrmtcmds.sh: File %s has mode %s, however it should be %s\n"\
 $i $mode $setmodestr >>$REPORT
					dspmsg -s 8 aixpert.cat 2 \
 "disrmtcmds.sh: File %s has mode %s, however it should be %s\n"\
 $i $mode $setmodestr >>$AIXPERT_FIFO
				else
					# Create Undo rule
					undo=1
					chmod $setmode $i
					/bin/sysck -a $i mode=$setmodestr
					/bin/sysck -y $i
					echo "chmod $perm $i" >>$TMP$PID
					echo "/bin/sysck -a $i mode=\"$mode\"" >>$TMP$PID
					echo "/bin/sysck -y $i" >>$TMP$PID
				fi
			else
				# for undo consistency
				if [ "$report" != "1" ]
				then
					undo=1
					echo "chmod $perm $i" >>$TMP$PID
					echo "/bin/sysck -a $i mode=\"$mode\"" >>$TMP$PID
					echo "/bin/sysck -y $i" >>$TMP$PID
				fi
			fi
		fi
	done
else
	# TCB is disabled
	# Chmod these files so that they are not executable
	for i in $RCP $RLOGIN $RSH $TFTP
	do
		if [ -f $i ]
		then
			# First determine the mode(octal number) of the file $i
			detmode $i

			if [ $perm  -ne $setperm ]
			then
				# Dynamic Security Check
				if [ "$report" = "1" ]
				then
					counter=`expr $counter + 1`
					dspmsg -s 8 aixpert.cat 3\
 "disrmtcmds.sh: File %s has permission %s, however it should be %s\n"\
 $i $perm $setmode >>$REPORT
					dspmsg -s 8 aixpert.cat 3\
 "disrmtcmds.sh: File %s has permission %s, however it should be %s\n"\
 $i $perm $setmode >>$AIXPERT_FIFO
				else
					# Create Undo rule
					undo=1
					chmod $setmode $i
					echo "chmod $perm $i" >>$TMP$PID
				fi
			else
				# for undo consistency
				if [ "$report" != "1" ]
				then
					undo=1
					echo "chmod $perm $i" >>$TMP$PID
				fi
			fi
		fi
		
	done
fi

if [ "$1" = "d" ]
then
	for i in $RCP $RLOGIN $RSH $TFTP $UTFTP
	do
		# Kill the processes running these commands
		cmdname=`echo $i | awk -F "/" '{print $NF}'`

		ps -eo pid,comm | egrep -w "$i|$cmdname" | awk '{print $1}' |\
 while read pid
		do
			# Check whether the current script is a descendant of $pid
			rmtexe=`ps -o pid -T $pid | grep $PID`

			if [ -z "$rmtexe" ]
			then
				# Dynamic Security Check
				if [ "$report" = "1" ]
				then
					counter=`expr $counter + 1`
					dspmsg -s 8 aixpert.cat 4\
 "disrmtcmds.sh: Process %s is still running\n" $i >>$REPORT
					dspmsg -s 8 aixpert.cat 4\
 "disrmtcmds.sh: Process %s is still running\n" $i >>$AIXPERT_FIFO
				else
					kill -9 $pid
				fi
			fi
		done
	done
fi

if [ "$1" = "d" ]
then
	# Add stanza to /etc/security/config to restrict .netrc
	# usage in ftp, and rexec.
	/bin/grep "^tcpip:" $CONFIG_FILE > /dev/null 2>&1
	rc=$?

	if [ $rc -ne 0 ]
	then
		# Dynamic Security Check
		if [ "$report" = "1" ]
		then
			counter=`expr $counter + 1`
			dspmsg -s 8 aixpert.cat 5 "disrmtcmds.sh:\
 %s file doesnt have tcpip entry or the file does not exist\n"\
 $CONFIG_FILE >>$REPORT
			dspmsg -s 8 aixpert.cat 5 "disrmtcmds.sh:\
 %s file doesnt have tcpip entry or the file does not exist\n"\
 $CONFIG_FILE >>$AIXPERT_FIFO
		else
			undo=1
			if [ -f $CONFIG_FILE ]
			then
				time=`date +%s`
				cp $CONFIG_FILE $SAVE/disrmtcmds_config.$time
				echo "mv $SAVE/disrmtcmds_config.$time\
 $CONFIG_FILE" >>$TMP$PID
			else
				echo "rm $CONFIG_FILE" >>$TMP$PID
			fi
		
			echo "\ntcpip:" >> $CONFIG_FILE
			echo "\tnetrc = ftp,rexec\n" >> $CONFIG_FILE
		fi
	else
		# for undo consistency
		if [ "$report" != "1" ]
		then
			undo=1
			time=`date +%s`
			cp $CONFIG_FILE $SAVE/disrmtcmds_config.$time
			echo "mv $SAVE/disrmtcmds_config.$time $CONFIG_FILE" >>$TMP$PID
		fi
	fi

else
	if [ -f $CONFIG_FILE ]
	then
		# Dynamic Security Check
		if [ "$report" = "1" ]
		then
			dspmsg -s 8 aixpert.cat 6 "disrmtcmds.sh:\
 %s file exists\n" $CONFIG_FILE >>$REPORT
			dspmsg -s 8 aixpert.cat 6 "disrmtcmds.sh:\
 %s file exists\n" $CONFIG_FILE >>$AIXPERT_FIFO
		else
			undo=1
			time=`date +%s`
			mv $CONFIG_FILE $SAVE/disrmtcmds_config.$time
			echo "mv $SAVE/disrmtcmds_config.$time\
 $CONFIG_FILE" >>$TMP$PID
		fi
	fi
fi

# Exit for Dynamic Security Check
if [ "$report" = "1" ]
then
	if [ $counter -ne 0 ]
	then
		exit 1
	else
		exit 0
	fi
fi

if [ $undo -eq 1 ]
then
	time=`date +%s`

	#Create Undo script $SCPTDIR/Undo$2$time
	echo "#!/usr/bin/ksh\nexport PATH=/usr/bin:/usr/sbin:\$PATH\n" >$SCPTDIR/Undo$2$time
	echo "exec 1>>$LOG\nexec 2>&1\nset -x\ndate\necho" '$0' >>$SCPTDIR/Undo$2$time
	cat $TMP$PID >>$SCPTDIR/Undo$2$time
	rm $TMP$PID
	chmod ug+x $SCPTDIR/Undo$2$time
	
	#Check whether the $UNDOXML file is empty
	empty=`grep "^<AIXPertUndo>" $UNDOXML`
	
	#If empty, add the start and end tags to $UNDOXML
	if [ "$empty" = "" ]
	then
		echo "\n<AIXPertUndo>\n</AIXPertUndo>" >> $UNDOXML
	fi

	# Get the rulename and put it in undo rule
	name=`echo $AIXPERT_NAME`
	# Get the rule description & pass it to undo rule
	desc=`echo $AIXPERT_DESC`

	#Add an undo XML rule to the file $UNDOXML
	awk -v rulehalf1="\t<AIXPertEntry name=\"$name\">\n\
\t\t<AIXPertRuleType type=\"Undo\"/>\n\
\t\t<AIXPertDescription>Undo action for \"$desc\"</AIXPertDescription>\n\
\t\t<AIXPertPrereqList/>\n"\
 -v rulehalf2="\t\t<AIXPertCommand>$SCPTDIR/Undo$2$time</AIXPertCommand>\n\
\t\t<AIXPertArgs/>\n\t\t<AIXPertGroup>Miscellaneous Rules</AIXPertGroup>\n\
\t</AIXPertEntry>" '{if(match($0,"^[\t ]*</AIXPertUndo>")==0) print $0;\
 else print rulehalf1 rulehalf2 "\n" $0}' $UNDOXML >$TMP$PID
	mv $TMP$PID $UNDOXML
fi

exit 0
